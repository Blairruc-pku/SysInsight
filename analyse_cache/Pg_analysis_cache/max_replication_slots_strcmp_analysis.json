{
  "param_name": "max_replication_slots",
  "function_name": "strcmp",
  "analysis": "<需要提供函数>\n不需要提供其他函数，现有的函数片段已经足够进行分析。\n\n<思考过程>\n1. 参数通过控制关键函数对数据库性能的影响：\n    - max_replication_slots通过[插槽数量管理机制]影响strcmp，进而产生[数据库性能影响]\n    - 机制：max_replication_slots决定了可以创建的最大复制插槽数量。当复制插槽达到最大值时，函数ReplicationSlotCreate中会对每个插槽使用strcmp进行名称比较，以检测名称冲突。在代码片段SearchNamedReplicationSlot中，调用strcmp判断给定的插槽是否存在。较大的max_replication_slots会导致更多的名称比较，从而使strcmp执行频率提高。\n    - 数据库性能影响：如果max_replication_slots设置得过高，可能导致创建和搜索复制插槽时的性能下降，因为需要进行更多的名称比较（strcmp执行增加），这可能使系统大规模处理插槽时引起延迟。\n\n<火焰图采样分析与调优方向>\n2. 基于strcmp执行状态和相关函数片段给出max_replication_slots优化建议：\n    - 如果涉及到[其他函数]，请指出除了监控strcmp之外，是否还需要监控其他函数。不需要监控其他函数，主要是通过strcmp的活跃度来进行调整。\n    - 如何根据strcmp和[其他函数]的火焰图采样率，推荐max_replication_slots调整的方向（升高或降低）和依据：\n        - 如果火焰图中strcmp的采样率过高，说明由于大量插槽名称对比导致的计算量过大，应考虑降低max_replication_slots，以减少插槽分配导致的性能开销。\n        - 如果strcmp的采样率较低且系统中插槽需求未得到满足，可以考虑适度升高max_replication_slots，以提高系统插槽分配应对能力。",
  "code_snippets": "CreateRestartPoint(int flags)\n{\n\tXLogRecPtr\tlastCheckPointRecPtr;\n\tXLogRecPtr\tlastCheckPointEndPtr;\n\tCheckPoint\tlastCheckPoint;\n\tXLogRecPtr\tPriorRedoPtr;\n\tXLogRecPtr\treceivePtr;\n\tXLogRecPtr\treplayPtr;\n\tTimeLineID\treplayTLI;\n\tXLogRecPtr\tendptr;\n\tXLogSegNo\t_logSegNo;\n\tTimestampTz xtime;\n\n\t/* Concurrent checkpoint/restartpoint cannot happen */\n\tAssert(!IsUnderPostmaster || MyBackendType == B_CHECKPOINTER);\n\n\t/* Get a local copy of the last safe checkpoint record. */\n\tSpinLockAcquire(&XLogCtl->info_lck);\n\tlastCheckPointRecPtr = XLogCtl->lastCheckPointRecPtr;\n\tlastCheckPointEndPtr = XLogCtl->lastCheckPointEndPtr;\n\tlastCheckPoint = XLogCtl->lastCheckPoint;\n\tSpinLockRelease(&XLogCtl->info_lck);\n\n\t/*\n\t * Check that we're still in recovery mode. It's ok if we exit recovery\n\t * mode after this check, the restart point is valid anyway.\n\t */\n\tif (!RecoveryInProgress())\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"skipping restartpoint, recovery has already ended\")));\n\t\treturn false;\n\t}\n\n\t/*\n\t * If the last checkpoint record we've replayed is already our last\n\t * restartpoint, we can't perform a new restart point. We still update\n\t * minRecoveryPoint in that case, so that if this is a shutdown restart\n\t * point, we won't start up earlier than before. That's not strictly\n\t * necessary, but when hot standby is enabled, it would be rather weird if\n\t * the database opened up for read-only connections at a point-in-time\n\t * before the last shutdown. Such time travel is still possible in case of\n\t * immediate shutdown, though.\n\t *\n\t * We don't explicitly advance minRecoveryPoint when we do create a\n\t * restartpoint. It's assumed that flushing the buffers will do that as a\n\t * side-effect.\n\t */\n\tif (XLogRecPtrIsInvalid(lastCheckPointRecPtr) ||\n\t\tlastCheckPoint.redo <= ControlFile->checkPointCopy.redo)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"skipping restartpoint, already performed at %X/%X\",\n\t\t\t\t\t\t\t\t LSN_FORMAT_ARGS(lastCheckPoint.redo))));\n\n\t\tUpdateMinRecoveryPoint(InvalidXLogRecPtr, true);\n\t\tif (flags & CHECKPOINT_IS_SHUTDOWN)\n\t\t{\n\t\t\tLWLockAcquire(ControlFileLock, LW_EXCLUSIVE);\n\t\t\tControlFile->state = DB_SHUTDOWNED_IN_RECOVERY;\n\t\t\tUpdateControlFile();\n\t\t\tLWLockRelease(ControlFileLock);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * Update the shared RedoRecPtr so that the startup process can calculate\n\t * the number of segments replayed since last restartpoint, and request a\n\t * restartpoint if it exceeds CheckPointSegments.\n\t *\n\t * Like in CreateCheckPoint(), hold off insertions to update it, although\n\t * during recovery this is just pro forma, because no WAL insertions are\n\t * happening.\n\t */\n\tWALInsertLockAcquireExclusive();\n\tRedoRecPtr = XLogCtl->Insert.RedoRecPtr = lastCheckPoint.redo;\n\tWALInsertLockRelease();\n\n\t/* Also update the info_lck-protected copy */\n\tSpinLockAcquire(&XLogCtl->info_lck);\n\tXLogCtl->RedoRecPtr = lastCheckPoint.redo;\n\tSpinLockRelease(&XLogCtl->info_lck);\n\n\t/*\n\t * Prepare to accumulate statistics.\n\t *\n\t * Note: because it is possible for log_checkpoints to change while a\n\t * checkpoint proceeds, we always accumulate stats, even if\n\t * log_checkpoints is currently off.\n\t */\n\tMemSet(&CheckpointStats, 0, sizeof(CheckpointStats));\n\tCheckpointStats.ckpt_start_t = GetCurrentTimestamp();\n\n\tif (log_checkpoints)\n\t\tLogCheckpointStart(flags, true);\n\n\t/* Update the process title */\n\tupdate_checkpoint_display(flags, true, false);\n\n\tCheckPointGuts(lastCheckPoint.redo, flags);\n\n\t/*\n\t * Remember the prior checkpoint's redo ptr for\n\t * UpdateCheckPointDistanceEstimate()\n\t */\n\tPriorRedoPtr = ControlFile->checkPointCopy.redo;\n\n\t/*\n\t * Update pg_control, using current time.  Check that it still shows an\n\t * older checkpoint, else do nothing; this is a quick hack to make sure\n\t * nothing really bad happens if somehow we get here after the\n\t * end-of-recovery checkpoint.\n\t */\n\tLWLockAcquire(ControlFileLock, LW_EXCLUSIVE);\n\tif (ControlFile->checkPointCopy.redo < lastCheckPoint.redo)\n\t{\n\t\t/*\n\t\t * Update the checkpoint information.  We do this even if the cluster\n\t\t * does not show DB_IN_ARCHIVE_RECOVERY to match with the set of WAL\n\t\t * segments recycled below.\n\t\t */\n\t\tControlFile->checkPoint = lastCheckPointRecPtr;\n\t\tControlFile->checkPointCopy = lastCheckPoint;\n\n\t\t/*\n\t\t * Ensure minRecoveryPoint is past the checkpoint record and update it\n\t\t * if the control file still shows DB_IN_ARCHIVE_RECOVERY.  Normally,\n\t\t * this will have happened already while writing out dirty buffers,\n\t\t * but not necessarily - e.g. because no buffers were dirtied.  We do\n\t\t * this because a backup performed in recovery uses minRecoveryPoint\n\t\t * to determine which WAL files must be included in the backup, and\n\t\t * the file (or files) containing the checkpoint record must be\n\t\t * included, at a minimum.  Note that for an ordinary restart of\n\t\t * recovery there's no value in having the minimum recovery point any\n\t\t * earlier than this anyway, because redo will begin just after the\n\t\t * checkpoint record.\n\t\t */\n\t\tif (ControlFile->state == DB_IN_ARCHIVE_RECOVERY)\n\t\t{\n\t\t\tif (ControlFile->minRecoveryPoint < lastCheckPointEndPtr)\n\t\t\t{\n\t\t\t\tControlFile->minRecoveryPoint = lastCheckPointEndPtr;\n\t\t\t\tControlFile->minRecoveryPointTLI = lastCheckPoint.ThisTimeLineID;\n\n\t\t\t\t/* update local copy */\n\t\t\t\tLocalMinRecoveryPoint = ControlFile->minRecoveryPoint;\n\t\t\t\tLocalMinRecoveryPointTLI = ControlFile->minRecoveryPointTLI;\n\t\t\t}\n\t\t\tif (flags & CHECKPOINT_IS_SHUTDOWN)\n\t\t\t\tControlFile->state = DB_SHUTDOWNED_IN_RECOVERY;\n\t\t}\n\t\tUpdateControlFile();\n\t}\n\tLWLockRelease(ControlFileLock);\n\n\t/*\n\t * Update the average distance between checkpoints/restartpoints if the\n\t * prior checkpoint exists.\n\t */\n\tif (PriorRedoPtr != InvalidXLogRecPtr)\n\t\tUpdateCheckPointDistanceEstimate(RedoRecPtr - PriorRedoPtr);\n\n\t/*\n\t * Delete old log files, those no longer needed for last restartpoint to\n\t * prevent the disk holding the xlog from growing full.\n\t */\n\tXLByteToSeg(RedoRecPtr, _logSegNo, wal_segment_size);\n\n\t/*\n\t * Retreat _logSegNo using the current end of xlog replayed or received,\n\t * whichever is later.\n\t */\n\treceivePtr = GetWalRcvFlushRecPtr(NULL, NULL);\n\treplayPtr = GetXLogReplayRecPtr(&replayTLI);\n\tendptr = (receivePtr < replayPtr) ? replayPtr : receivePtr;\n\tKeepLogSeg(endptr, &_logSegNo);\n\tif (InvalidateObsoleteReplicationSlots(RS_INVAL_WAL_REMOVED,\n\t\t\t\t\t\t\t\t\t\t   _logSegNo, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t   InvalidTransactionId))\n\t{\n\t\t/*\n\t\t * Some slots have been invalidated; recalculate the old-segment\n\t\t * horizon, starting again from RedoRecPtr.\n\t\t */\n\t\tXLByteToSeg(RedoRecPtr, _logSegNo, wal_segment_size);\n\t\tKeepLogSeg(endptr, &_logSegNo);\n\t}\n\t_logSegNo--;\n\n\t/*\n\t * Try to recycle segments on a useful timeline. If we've been promoted\n\t * since the beginning of this restartpoint, use the new timeline chosen\n\t * at end of recovery.  If we're still in recovery, use the timeline we're\n\t * currently replaying.\n\t *\n\t * There is no guarantee that the WAL segments will be useful on the\n\t * current timeline; if recovery proceeds to a new timeline right after\n\t * this, the pre-allocated WAL segments on this timeline will not be used,\n\t * and will go wasted until recycled on the next restartpoint. We'll live\n\t * with that.\n\t */\n\tif (!RecoveryInProgress())\n\t\treplayTLI = XLogCtl->InsertTimeLineID;\n\n\tRemoveOldXlogFiles(_logSegNo, RedoRecPtr, endptr, replayTLI);\n\n\t/*\n\t * Make more log segments if needed.  (Do this after recycling old log\n\t * segments, since that may supply some of the needed files.)\n\t */\n\tPreallocXlogFiles(endptr, replayTLI);\n\n\t/*\n\t * Truncate pg_subtrans if possible.  We can throw away all data before\n\t * the oldest XMIN of any running transaction.  No future transaction will\n\t * attempt to reference any pg_subtrans entry older than that (see Asserts\n\t * in subtrans.c).  When hot standby is disabled, though, we mustn't do\n\t * this because StartupSUBTRANS hasn't been called yet.\n\t */\n\tif (EnableHotStandby)\n\t\tTruncateSUBTRANS(GetOldestTransactionIdConsideredRunning());\n\n\t/* Real work is done; log and update stats. */\n\tLogCheckpointEnd(true);\n\n\t/* Reset the process title */\n\tupdate_checkpoint_display(flags, true, true);\n\n\txtime = GetLatestXTime();\n\tereport((log_checkpoints ? LOG : DEBUG2),\n\t\t\t(errmsg(\"recovery restart point at %X/%X\",\n\t\t\t\t\tLSN_FORMAT_ARGS(lastCheckPoint.redo)),\n\t\t\t xtime ? errdetail(\"Last completed transaction was at log time %s.\",\n\t\t\t\t\t\t\t   timestamptz_to_str(xtime)) : 0));\n\n\t/*\n\t * Finally, execute archive_cleanup_command, if any.\n\t */\n\tif (archiveCleanupCommand && strcmp(archiveCleanupCommand, \"\") != 0)\n\t\tExecuteRecoveryCommand(archiveCleanupCommand,\n\t\t\t\t\t\t\t   \"archive_cleanup_command\",\n\t\t\t\t\t\t\t   false,\n\t\t\t\t\t\t\t   WAIT_EVENT_ARCHIVE_CLEANUP_COMMAND);\n\n\treturn true;\n}ReplicationSlotCreate(const char *name, bool db_specific,\n\t\t\t\t\t  ReplicationSlotPersistency persistency, bool two_phase)\n{\n\tReplicationSlot *slot = NULL;\n\tint\t\t\ti;\n\n\tAssert(MyReplicationSlot == NULL);\n\n\tReplicationSlotValidateName(name, ERROR);\n\n\t/*\n\t * If some other backend ran this code concurrently with us, we'd likely\n\t * both allocate the same slot, and that would be bad.  We'd also be at\n\t * risk of missing a name collision.  Also, we don't want to try to create\n\t * a new slot while somebody's busy cleaning up an old one, because we\n\t * might both be monkeying with the same directory.\n\t */\n\tLWLockAcquire(ReplicationSlotAllocationLock, LW_EXCLUSIVE);\n\n\t/*\n\t * Check for name collision, and identify an allocatable slot.  We need to\n\t * hold ReplicationSlotControlLock in shared mode for this, so that nobody\n\t * else can change the in_use flags while we're looking at them.\n\t */\n\tLWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\n\tfor (i = 0; i < max_replication_slots; i++)\n\t{\n\t\tReplicationSlot *s = &ReplicationSlotCtl->replication_slots[i];\n\n\t\tif (s->in_use && strcmp(name, NameStr(s->data.name)) == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_OBJECT),\n\t\t\t\t\t errmsg(\"replication slot \\\"%s\\\" already exists\", name)));\n\t\tif (!s->in_use && slot == NULL)\n\t\t\tslot = s;\n\t}\n\tLWLockRelease(ReplicationSlotControlLock);\n\n\t/* If all slots are in use, we're out of luck. */\n\tif (slot == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"all replication slots are in use\"),\n\t\t\t\t errhint(\"Free one or increase max_replication_slots.\")));\n\n\t/*\n\t * Since this slot is not in use, nobody should be looking at any part of\n\t * it other than the in_use field unless they're trying to allocate it.\n\t * And since we hold ReplicationSlotAllocationLock, nobody except us can\n\t * be doing that.  So it's safe to initialize the slot.\n\t */\n\tAssert(!slot->in_use);\n\tAssert(slot->active_pid == 0);\n\n\t/* first initialize persistent data */\n\tmemset(&slot->data, 0, sizeof(ReplicationSlotPersistentData));\n\tnamestrcpy(&slot->data.name, name);\n\tslot->data.database = db_specific ? MyDatabaseId : InvalidOid;\n\tslot->data.persistency = persistency;\n\tslot->data.two_phase = two_phase;\n\tslot->data.two_phase_at = InvalidXLogRecPtr;\n\n\t/* and then data only present in shared memory */\n\tslot->just_dirtied = false;\n\tslot->dirty = false;\n\tslot->effective_xmin = InvalidTransactionId;\n\tslot->effective_catalog_xmin = InvalidTransactionId;\n\tslot->candidate_catalog_xmin = InvalidTransactionId;\n\tslot->candidate_xmin_lsn = InvalidXLogRecPtr;\n\tslot->candidate_restart_valid = InvalidXLogRecPtr;\n\tslot->candidate_restart_lsn = InvalidXLogRecPtr;\n\n\t/*\n\t * Create the slot on disk.  We haven't actually marked the slot allocated\n\t * yet, so no special cleanup is required if this errors out.\n\t */\n\tCreateSlotOnDisk(slot);\n\n\t/*\n\t * We need to briefly prevent any other backend from iterating over the\n\t * slots while we flip the in_use flag. We also need to set the active\n\t * flag while holding the ControlLock as otherwise a concurrent\n\t * ReplicationSlotAcquire() could acquire the slot as well.\n\t */\n\tLWLockAcquire(ReplicationSlotControlLock, LW_EXCLUSIVE);\n\n\tslot->in_use = true;\n\n\t/* We can now mark the slot active, and that makes it our slot. */\n\tSpinLockAcquire(&slot->mutex);\n\tAssert(slot->active_pid == 0);\n\tslot->active_pid = MyProcPid;\n\tSpinLockRelease(&slot->mutex);\n\tMyReplicationSlot = slot;\n\n\tLWLockRelease(ReplicationSlotControlLock);\n\n\t/*\n\t * Create statistics entry for the new logical slot. We don't collect any\n\t * stats for physical slots, so no need to create an entry for the same.\n\t * See ReplicationSlotDropPtr for why we need to do this before releasing\n\t * ReplicationSlotAllocationLock.\n\t */\n\tif (SlotIsLogical(slot))\n\t\tpgstat_create_replslot(slot);\n\n\t/*\n\t * Now that the slot has been marked as in_use and active, it's safe to\n\t * let somebody else try to allocate a slot.\n\t */\n\tLWLockRelease(ReplicationSlotAllocationLock);\n\n\t/* Let everybody know we've modified this slot */\n\tConditionVariableBroadcast(&slot->active_cv);\n}SearchNamedReplicationSlot(const char *name, bool need_lock)\n{\n\tint\t\t\ti;\n\tReplicationSlot *slot = NULL;\n\n\tif (need_lock)\n\t\tLWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\n\n\tfor (i = 0; i < max_replication_slots; i++)\n\t{\n\t\tReplicationSlot *s = &ReplicationSlotCtl->replication_slots[i];\n\n\t\tif (s->in_use && strcmp(name, NameStr(s->data.name)) == 0)\n\t\t{\n\t\t\tslot = s;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (need_lock)\n\t\tLWLockRelease(ReplicationSlotControlLock);\n\n\treturn slot;\n}copy_replication_slot(FunctionCallInfo fcinfo, bool logical_slot)\n{\n\tName\t\tsrc_name = PG_GETARG_NAME(0);\n\tName\t\tdst_name = PG_GETARG_NAME(1);\n\tReplicationSlot *src = NULL;\n\tReplicationSlot first_slot_contents;\n\tReplicationSlot second_slot_contents;\n\tXLogRecPtr\tsrc_restart_lsn;\n\tbool\t\tsrc_islogical;\n\tbool\t\ttemporary;\n\tchar\t   *plugin;\n\tDatum\t\tvalues[2];\n\tbool\t\tnulls[2];\n\tDatum\t\tresult;\n\tTupleDesc\ttupdesc;\n\tHeapTuple\ttuple;\n\n\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\telog(ERROR, \"return type must be a row type\");\n\n\tCheckSlotPermissions();\n\n\tif (logical_slot)\n\t\tCheckLogicalDecodingRequirements();\n\telse\n\t\tCheckSlotRequirements();\n\n\tLWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\n\n\t/*\n\t * We need to prevent the source slot's reserved WAL from being removed,\n\t * but we don't want to lock that slot for very long, and it can advance\n\t * in the meantime.  So obtain the source slot's data, and create a new\n\t * slot using its restart_lsn.  Afterwards we lock the source slot again\n\t * and verify that the data we copied (name, type) has not changed\n\t * incompatibly.  No inconvenient WAL removal can occur once the new slot\n\t * is created -- but since WAL removal could have occurred before we\n\t * managed to create the new slot, we advance the new slot's restart_lsn\n\t * to the source slot's updated restart_lsn the second time we lock it.\n\t */\n\tfor (int i = 0; i < max_replication_slots; i++)\n\t{\n\t\tReplicationSlot *s = &ReplicationSlotCtl->replication_slots[i];\n\n\t\tif (s->in_use && strcmp(NameStr(s->data.name), NameStr(*src_name)) == 0)\n\t\t{\n\t\t\t/* Copy the slot contents while holding spinlock */\n\t\t\tSpinLockAcquire(&s->mutex);\n\t\t\tfirst_slot_contents = *s;\n\t\t\tSpinLockRelease(&s->mutex);\n\t\t\tsrc = s;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tLWLockRelease(ReplicationSlotControlLock);\n\n\tif (src == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"replication slot \\\"%s\\\" does not exist\", NameStr(*src_name))));\n\n\tsrc_islogical = SlotIsLogical(&first_slot_contents);\n\tsrc_restart_lsn = first_slot_contents.data.restart_lsn;\n\ttemporary = (first_slot_contents.data.persistency == RS_TEMPORARY);\n\tplugin = logical_slot ? NameStr(first_slot_contents.data.plugin) : NULL;\n\n\t/* Check type of replication slot */\n\tif (src_islogical != logical_slot)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t src_islogical ?\n\t\t\t\t errmsg(\"cannot copy physical replication slot \\\"%s\\\" as a logical replication slot\",\n\t\t\t\t\t\tNameStr(*src_name)) :\n\t\t\t\t errmsg(\"cannot copy logical replication slot \\\"%s\\\" as a physical replication slot\",\n\t\t\t\t\t\tNameStr(*src_name))));\n\n\t/* Copying non-reserved slot doesn't make sense */\n\tif (XLogRecPtrIsInvalid(src_restart_lsn))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"cannot copy a replication slot that doesn't reserve WAL\")));\n\n\t/* Overwrite params from optional arguments */\n\tif (PG_NARGS() >= 3)\n\t\ttemporary = PG_GETARG_BOOL(2);\n\tif (PG_NARGS() >= 4)\n\t{\n\t\tAssert(logical_slot);\n\t\tplugin = NameStr(*(PG_GETARG_NAME(3)));\n\t}\n\n\t/* Create new slot and acquire it */\n\tif (logical_slot)\n\t{\n\t\t/*\n\t\t * We must not try to read WAL, since we haven't reserved it yet --\n\t\t * hence pass find_startpoint false.  confirmed_flush will be set\n\t\t * below, by copying from the source slot.\n\t\t */\n\t\tcreate_logical_replication_slot(NameStr(*dst_name),\n\t\t\t\t\t\t\t\t\t\tplugin,\n\t\t\t\t\t\t\t\t\t\ttemporary,\n\t\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t\tsrc_restart_lsn,\n\t\t\t\t\t\t\t\t\t\tfalse);\n\t}\n\telse\n\t\tcreate_physical_replication_slot(NameStr(*dst_name),\n\t\t\t\t\t\t\t\t\t\t true,\n\t\t\t\t\t\t\t\t\t\t temporary,\n\t\t\t\t\t\t\t\t\t\t src_restart_lsn);\n\n\t/*\n\t * Update the destination slot to current values of the source slot;\n\t * recheck that the source slot is still the one we saw previously.\n\t */\n\t{\n\t\tTransactionId copy_effective_xmin;\n\t\tTransactionId copy_effective_catalog_xmin;\n\t\tTransactionId copy_xmin;\n\t\tTransactionId copy_catalog_xmin;\n\t\tXLogRecPtr\tcopy_restart_lsn;\n\t\tXLogRecPtr\tcopy_confirmed_flush;\n\t\tbool\t\tcopy_islogical;\n\t\tchar\t   *copy_name;\n\n\t\t/* Copy data of source slot again */\n\t\tSpinLockAcquire(&src->mutex);\n\t\tsecond_slot_contents = *src;\n\t\tSpinLockRelease(&src->mutex);\n\n\t\tcopy_effective_xmin = second_slot_contents.effective_xmin;\n\t\tcopy_effective_catalog_xmin = second_slot_contents.effective_catalog_xmin;\n\n\t\tcopy_xmin = second_slot_contents.data.xmin;\n\t\tcopy_catalog_xmin = second_slot_contents.data.catalog_xmin;\n\t\tcopy_restart_lsn = second_slot_contents.data.restart_lsn;\n\t\tcopy_confirmed_flush = second_slot_contents.data.confirmed_flush;\n\n\t\t/* for existence check */\n\t\tcopy_name = NameStr(second_slot_contents.data.name);\n\t\tcopy_islogical = SlotIsLogical(&second_slot_contents);\n\n\t\t/*\n\t\t * Check if the source slot still exists and is valid. We regard it as\n\t\t * invalid if the type of replication slot or name has been changed,\n\t\t * or the restart_lsn either is invalid or has gone backward. (The\n\t\t * restart_lsn could go backwards if the source slot is dropped and\n\t\t * copied from an older slot during installation.)\n\t\t *\n\t\t * Since erroring out will release and drop the destination slot we\n\t\t * don't need to release it here.\n\t\t */\n\t\tif (copy_restart_lsn < src_restart_lsn ||\n\t\t\tsrc_islogical != copy_islogical ||\n\t\t\tstrcmp(copy_name, NameStr(*src_name)) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not copy replication slot \\\"%s\\\"\",\n\t\t\t\t\t\t\tNameStr(*src_name)),\n\t\t\t\t\t errdetail(\"The source replication slot was modified incompatibly during the copy operation.\")));\n\n\t\t/* The source slot must have a consistent snapshot */\n\t\tif (src_islogical && XLogRecPtrIsInvalid(copy_confirmed_flush))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot copy unfinished logical replication slot \\\"%s\\\"\",\n\t\t\t\t\t\t\tNameStr(*src_name)),\n\t\t\t\t\t errhint(\"Retry when the source replication slot's confirmed_flush_lsn is valid.\")));\n\n\t\t/* Install copied values again */\n\t\tSpinLockAcquire(&MyReplicationSlot->mutex);\n\t\tMyReplicationSlot->effective_xmin = copy_effective_xmin;\n\t\tMyReplicationSlot->effective_catalog_xmin = copy_effective_catalog_xmin;\n\n\t\tMyReplicationSlot->data.xmin = copy_xmin;\n\t\tMyReplicationSlot->data.catalog_xmin = copy_catalog_xmin;\n\t\tMyReplicationSlot->data.restart_lsn = copy_restart_lsn;\n\t\tMyReplicationSlot->data.confirmed_flush = copy_confirmed_flush;\n\t\tSpinLockRelease(&MyReplicationSlot->mutex);\n\n\t\tReplicationSlotMarkDirty();\n\t\tReplicationSlotsComputeRequiredXmin(false);\n\t\tReplicationSlotsComputeRequiredLSN();\n\t\tReplicationSlotSave();\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Check that the restart_lsn is available */\n\t\t{\n\t\t\tXLogSegNo\tsegno;\n\n\t\t\tXLByteToSeg(copy_restart_lsn, segno, wal_segment_size);\n\t\t\tAssert(XLogGetLastRemovedSegno() < segno);\n\t\t}\n#endif\n\t}\n\n\t/* target slot fully created, mark as persistent if needed */\n\tif (logical_slot && !temporary)\n\t\tReplicationSlotPersist();\n\n\t/* All done.  Set up the return values */\n\tvalues[0] = NameGetDatum(dst_name);\n\tnulls[0] = false;\n\tif (!XLogRecPtrIsInvalid(MyReplicationSlot->data.confirmed_flush))\n\t{\n\t\tvalues[1] = LSNGetDatum(MyReplicationSlot->data.confirmed_flush);\n\t\tnulls[1] = false;\n\t}\n\telse\n\t\tnulls[1] = true;\n\n\ttuple = heap_form_tuple(tupdesc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tReplicationSlotRelease();\n\n\tPG_RETURN_DATUM(result);\n}PostmasterMain(int argc, char *argv[])\n{\n\tint\t\t\topt;\n\tint\t\t\tstatus;\n\tchar\t   *userDoption = NULL;\n\tbool\t\tlisten_addr_saved = false;\n\tint\t\t\ti;\n\tchar\t   *output_config_variable = NULL;\n\n\tInitProcessGlobals();\n\n\tPostmasterPid = MyProcPid;\n\n\tIsPostmasterEnvironment = true;\n\n\t/*\n\t * Start our win32 signal implementation\n\t */\n#ifdef WIN32\n\tpgwin32_signal_initialize();\n#endif\n\n\t/*\n\t * We should not be creating any files or directories before we check the\n\t * data directory (see checkDataDir()), but just in case set the umask to\n\t * the most restrictive (owner-only) permissions.\n\t *\n\t * checkDataDir() will reset the umask based on the data directory\n\t * permissions.\n\t */\n\tumask(PG_MODE_MASK_OWNER);\n\n\t/*\n\t * By default, palloc() requests in the postmaster will be allocated in\n\t * the PostmasterContext, which is space that can be recycled by backends.\n\t * Allocated data that needs to be available to backends should be\n\t * allocated in TopMemoryContext.\n\t */\n\tPostmasterContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"Postmaster\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\tMemoryContextSwitchTo(PostmasterContext);\n\n\t/* Initialize paths to installation files */\n\tgetInstallationPaths(argv[0]);\n\n\t/*\n\t * Set up signal handlers for the postmaster process.\n\t *\n\t * CAUTION: when changing this list, check for side-effects on the signal\n\t * handling setup of child processes.  See tcop/postgres.c,\n\t * bootstrap/bootstrap.c, postmaster/bgwriter.c, postmaster/walwriter.c,\n\t * postmaster/autovacuum.c, postmaster/pgarch.c, postmaster/syslogger.c,\n\t * postmaster/bgworker.c and postmaster/checkpointer.c.\n\t */\n\tpqinitmask();\n\tsigprocmask(SIG_SETMASK, &BlockSig, NULL);\n\n\tpqsignal(SIGHUP, handle_pm_reload_request_signal);\n\tpqsignal(SIGINT, handle_pm_shutdown_request_signal);\n\tpqsignal(SIGQUIT, handle_pm_shutdown_request_signal);\n\tpqsignal(SIGTERM, handle_pm_shutdown_request_signal);\n\tpqsignal(SIGALRM, SIG_IGN); /* ignored */\n\tpqsignal(SIGPIPE, SIG_IGN); /* ignored */\n\tpqsignal(SIGUSR1, handle_pm_pmsignal_signal);\n\tpqsignal(SIGUSR2, dummy_handler);\t/* unused, reserve for children */\n\tpqsignal(SIGCHLD, handle_pm_child_exit_signal);\n\n\t/* This may configure SIGURG, depending on platform. */\n\tInitializeLatchSupport();\n\tInitProcessLocalLatch();\n\n\t/*\n\t * No other place in Postgres should touch SIGTTIN/SIGTTOU handling.  We\n\t * ignore those signals in a postmaster environment, so that there is no\n\t * risk of a child process freezing up due to writing to stderr.  But for\n\t * a standalone backend, their default handling is reasonable.  Hence, all\n\t * child processes should just allow the inherited settings to stand.\n\t */\n#ifdef SIGTTIN\n\tpqsignal(SIGTTIN, SIG_IGN); /* ignored */\n#endif\n#ifdef SIGTTOU\n\tpqsignal(SIGTTOU, SIG_IGN); /* ignored */\n#endif\n\n\t/* ignore SIGXFSZ, so that ulimit violations work like disk full */\n#ifdef SIGXFSZ\n\tpqsignal(SIGXFSZ, SIG_IGN); /* ignored */\n#endif\n\n\t/* Begin accepting signals. */\n\tsigprocmask(SIG_SETMASK, &UnBlockSig, NULL);\n\n\t/*\n\t * Options setup\n\t */\n\tInitializeGUCOptions();\n\n\topterr = 1;\n\n\t/*\n\t * Parse command-line options.  CAUTION: keep this in sync with\n\t * tcop/postgres.c (the option sets should not conflict) and with the\n\t * common help() function in main/main.c.\n\t */\n\twhile ((opt = getopt(argc, argv, \"B:bC:c:D:d:EeFf:h:ijk:lN:OPp:r:S:sTt:W:-:\")) != -1)\n\t{\n\t\tswitch (opt)\n\t\t{\n\t\t\tcase 'B':\n\t\t\t\tSetConfigOption(\"shared_buffers\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'b':\n\t\t\t\t/* Undocumented flag used for binary upgrades */\n\t\t\t\tIsBinaryUpgrade = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'C':\n\t\t\t\toutput_config_variable = strdup(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':\n\t\t\tcase '-':\n\t\t\t\t{\n\t\t\t\t\tchar\t   *name,\n\t\t\t\t\t\t\t   *value;\n\n\t\t\t\t\tParseLongOption(optarg, &name, &value);\n\t\t\t\t\tif (!value)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (opt == '-')\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t\t errmsg(\"--%s requires a value\",\n\t\t\t\t\t\t\t\t\t\t\toptarg)));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t\t errmsg(\"-c %s requires a value\",\n\t\t\t\t\t\t\t\t\t\t\toptarg)));\n\t\t\t\t\t}\n\n\t\t\t\t\tSetConfigOption(name, value, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\t\tpfree(name);\n\t\t\t\t\tpfree(value);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 'D':\n\t\t\t\tuserDoption = strdup(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'd':\n\t\t\t\tset_debug_options(atoi(optarg), PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\tSetConfigOption(\"log_statement\", \"all\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'e':\n\t\t\t\tSetConfigOption(\"datestyle\", \"euro\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'F':\n\t\t\t\tSetConfigOption(\"fsync\", \"false\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\tif (!set_plan_disabling_options(optarg, PGC_POSTMASTER, PGC_S_ARGV))\n\t\t\t\t{\n\t\t\t\t\twrite_stderr(\"%s: invalid argument for option -f: \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\t progname, optarg);\n\t\t\t\t\tExitPostmaster(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\t\tSetConfigOption(\"listen_addresses\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'i':\n\t\t\t\tSetConfigOption(\"listen_addresses\", \"*\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'j':\n\t\t\t\t/* only used by interactive backend */\n\t\t\t\tbreak;\n\n\t\t\tcase 'k':\n\t\t\t\tSetConfigOption(\"unix_socket_directories\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\t\tSetConfigOption(\"ssl\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'N':\n\t\t\t\tSetConfigOption(\"max_connections\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'O':\n\t\t\t\tSetConfigOption(\"allow_system_table_mods\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':\n\t\t\t\tSetConfigOption(\"ignore_system_indexes\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\tSetConfigOption(\"port\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\n\t\t\t\t/* only used by single-user backend */\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\tSetConfigOption(\"work_mem\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tSetConfigOption(\"log_statement_stats\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'T':\n\n\t\t\t\t/*\n\t\t\t\t * This option used to be defined as sending SIGSTOP after a\n\t\t\t\t * backend crash, but sending SIGABRT seems more useful.\n\t\t\t\t */\n\t\t\t\tSetConfigOption(\"send_abort_for_crash\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\t{\n\t\t\t\t\tconst char *tmp = get_stats_option_name(optarg);\n\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tSetConfigOption(tmp, \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twrite_stderr(\"%s: invalid argument for option -t: \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\t\t progname, optarg);\n\t\t\t\t\t\tExitPostmaster(1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 'W':\n\t\t\t\tSetConfigOption(\"post_auth_delay\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\twrite_stderr(\"Try \\\"%s --help\\\" for more information.\\n\",\n\t\t\t\t\t\t\t progname);\n\t\t\t\tExitPostmaster(1);\n\t\t}\n\t}\n\n\t/*\n\t * Postmaster accepts no non-option switch arguments.\n\t */\n\tif (optind < argc)\n\t{\n\t\twrite_stderr(\"%s: invalid argument: \\\"%s\\\"\\n\",\n\t\t\t\t\t progname, argv[optind]);\n\t\twrite_stderr(\"Try \\\"%s --help\\\" for more information.\\n\",\n\t\t\t\t\t progname);\n\t\tExitPostmaster(1);\n\t}\n\n\t/*\n\t * Locate the proper configuration files and data directory, and read\n\t * postgresql.conf for the first time.\n\t */\n\tif (!SelectConfigFiles(userDoption, progname))\n\t\tExitPostmaster(2);\n\n\tif (output_config_variable != NULL)\n\t{\n\t\t/*\n\t\t * If this is a runtime-computed GUC, it hasn't yet been initialized,\n\t\t * and the present value is not useful.  However, this is a convenient\n\t\t * place to print the value for most GUCs because it is safe to run\n\t\t * postmaster startup to this point even if the server is already\n\t\t * running.  For the handful of runtime-computed GUCs that we cannot\n\t\t * provide meaningful values for yet, we wait until later in\n\t\t * postmaster startup to print the value.  We won't be able to use -C\n\t\t * on running servers for those GUCs, but using this option now would\n\t\t * lead to incorrect results for them.\n\t\t */\n\t\tint\t\t\tflags = GetConfigOptionFlags(output_config_variable, true);\n\n\t\tif ((flags & GUC_RUNTIME_COMPUTED) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * \"-C guc\" was specified, so print GUC's value and exit.  No\n\t\t\t * extra permission check is needed because the user is reading\n\t\t\t * inside the data dir.\n\t\t\t */\n\t\t\tconst char *config_val = GetConfigOption(output_config_variable,\n\t\t\t\t\t\t\t\t\t\t\t\t\t false, false);\n\n\t\t\tputs(config_val ? config_val : \"\");\n\t\t\tExitPostmaster(0);\n\t\t}\n\n\t\t/*\n\t\t * A runtime-computed GUC will be printed later on.  As we initialize\n\t\t * a server startup sequence, silence any log messages that may show\n\t\t * up in the output generated.  FATAL and more severe messages are\n\t\t * useful to show, even if one would only expect at least PANIC.  LOG\n\t\t * entries are hidden.\n\t\t */\n\t\tSetConfigOption(\"log_min_messages\", \"FATAL\", PGC_SUSET,\n\t\t\t\t\t\tPGC_S_OVERRIDE);\n\t}\n\n\t/* Verify that DataDir looks reasonable */\n\tcheckDataDir();\n\n\t/* Check that pg_control exists */\n\tcheckControlFile();\n\n\t/* And switch working directory into it */\n\tChangeToDataDir();\n\n\t/*\n\t * Check for invalid combinations of GUC settings.\n\t */\n\tif (SuperuserReservedConnections + ReservedConnections >= MaxConnections)\n\t{\n\t\twrite_stderr(\"%s: superuser_reserved_connections (%d) plus reserved_connections (%d) must be less than max_connections (%d)\\n\",\n\t\t\t\t\t progname,\n\t\t\t\t\t SuperuserReservedConnections, ReservedConnections,\n\t\t\t\t\t MaxConnections);\n\t\tExitPostmaster(1);\n\t}\n\tif (XLogArchiveMode > ARCHIVE_MODE_OFF && wal_level == WAL_LEVEL_MINIMAL)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"WAL archival cannot be enabled when wal_level is \\\"minimal\\\"\")));\n\tif (max_wal_senders > 0 && wal_level == WAL_LEVEL_MINIMAL)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"WAL streaming (max_wal_senders > 0) requires wal_level \\\"replica\\\" or \\\"logical\\\"\")));\n\n\t/*\n\t * Other one-time internal sanity checks can go here, if they are fast.\n\t * (Put any slow processing further down, after postmaster.pid creation.)\n\t */\n\tif (!CheckDateTokenTables())\n\t{\n\t\twrite_stderr(\"%s: invalid datetoken tables, please fix\\n\", progname);\n\t\tExitPostmaster(1);\n\t}\n\n\t/*\n\t * Now that we are done processing the postmaster arguments, reset\n\t * getopt(3) library so that it will work correctly in subprocesses.\n\t */\n\toptind = 1;\n#ifdef HAVE_INT_OPTRESET\n\toptreset = 1;\t\t\t\t/* some systems need this too */\n#endif\n\n\t/* For debugging: display postmaster environment */\n\t{\n\t\textern char **environ;\n\t\tchar\t  **p;\n\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"%s: PostmasterMain: initial environment dump:\",\n\t\t\t\t\t\t\t\t progname)));\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"-----------------------------------------\")));\n\t\tfor (p = environ; *p; ++p)\n\t\t\tereport(DEBUG3,\n\t\t\t\t\t(errmsg_internal(\"\\t%s\", *p)));\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"-----------------------------------------\")));\n\t}\n\n\t/*\n\t * Create lockfile for data directory.\n\t *\n\t * We want to do this before we try to grab the input sockets, because the\n\t * data directory interlock is more reliable than the socket-file\n\t * interlock (thanks to whoever decided to put socket files in /tmp :-().\n\t * For the same reason, it's best to grab the TCP socket(s) before the\n\t * Unix socket(s).\n\t *\n\t * Also note that this internally sets up the on_proc_exit function that\n\t * is responsible for removing both data directory and socket lockfiles;\n\t * so it must happen before opening sockets so that at exit, the socket\n\t * lockfiles go away after CloseServerPorts runs.\n\t */\n\tCreateDataDirLockFile(true);\n\n\t/*\n\t * Read the control file (for error checking and config info).\n\t *\n\t * Since we verify the control file's CRC, this has a useful side effect\n\t * on machines where we need a run-time test for CRC support instructions.\n\t * The postmaster will do the test once at startup, and then its child\n\t * processes will inherit the correct function pointer and not need to\n\t * repeat the test.\n\t */\n\tLocalProcessControlFile(false);\n\n\t/*\n\t * Register the apply launcher.  It's probably a good idea to call this\n\t * before any modules had a chance to take the background worker slots.\n\t */\n\tApplyLauncherRegister();\n\n\t/*\n\t * process any libraries that should be preloaded at postmaster start\n\t */\n\tprocess_shared_preload_libraries();\n\n\t/*\n\t * Initialize SSL library, if specified.\n\t */\n#ifdef USE_SSL\n\tif (EnableSSL)\n\t{\n\t\t(void) secure_initialize(true);\n\t\tLoadedSSL = true;\n\t}\n#endif\n\n\t/*\n\t * Now that loadable modules have had their chance to alter any GUCs,\n\t * calculate MaxBackends.\n\t */\n\tInitializeMaxBackends();\n\n\t/*\n\t * Give preloaded libraries a chance to request additional shared memory.\n\t */\n\tprocess_shmem_requests();\n\n\t/*\n\t * Now that loadable modules have had their chance to request additional\n\t * shared memory, determine the value of any runtime-computed GUCs that\n\t * depend on the amount of shared memory required.\n\t */\n\tInitializeShmemGUCs();\n\n\t/*\n\t * Now that modules have been loaded, we can process any custom resource\n\t * managers specified in the wal_consistency_checking GUC.\n\t */\n\tInitializeWalConsistencyChecking();\n\n\t/*\n\t * If -C was specified with a runtime-computed GUC, we held off printing\n\t * the value earlier, as the GUC was not yet initialized.  We handle -C\n\t * for most GUCs before we lock the data directory so that the option may\n\t * be used on a running server.  However, a handful of GUCs are runtime-\n\t * computed and do not have meaningful values until after locking the data\n\t * directory, and we cannot safely calculate their values earlier on a\n\t * running server.  At this point, such GUCs should be properly\n\t * initialized, and we haven't yet set up shared memory, so this is a good\n\t * time to handle the -C option for these special GUCs.\n\t */\n\tif (output_config_variable != NULL)\n\t{\n\t\tconst char *config_val = GetConfigOption(output_config_variable,\n\t\t\t\t\t\t\t\t\t\t\t\t false, false);\n\n\t\tputs(config_val ? config_val : \"\");\n\t\tExitPostmaster(0);\n\t}\n\n\t/*\n\t * Set up shared memory and semaphores.\n\t *\n\t * Note: if using SysV shmem and/or semas, each postmaster startup will\n\t * normally choose the same IPC keys.  This helps ensure that we will\n\t * clean up dead IPC objects if the postmaster crashes and is restarted.\n\t */\n\tCreateSharedMemoryAndSemaphores();\n\n\t/*\n\t * Estimate number of openable files.  This must happen after setting up\n\t * semaphores, because on some platforms semaphores count as open files.\n\t */\n\tset_max_safe_fds();\n\n\t/*\n\t * Set reference point for stack-depth checking.\n\t */\n\t(void) set_stack_base();\n\n\t/*\n\t * Initialize pipe (or process handle on Windows) that allows children to\n\t * wake up from sleep on postmaster death.\n\t */\n\tInitPostmasterDeathWatchHandle();\n\n#ifdef WIN32\n\n\t/*\n\t * Initialize I/O completion port used to deliver list of dead children.\n\t */\n\twin32ChildQueue = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);\n\tif (win32ChildQueue == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"could not create I/O completion port for child queue\")));\n#endif\n\n#ifdef EXEC_BACKEND\n\t/* Write out nondefault GUC settings for child processes to use */\n\twrite_nondefault_variables(PGC_POSTMASTER);\n\n\t/*\n\t * Clean out the temp directory used to transmit parameters to child\n\t * processes (see internal_forkexec, below).  We must do this before\n\t * launching any child processes, else we have a race condition: we could\n\t * remove a parameter file before the child can read it.  It should be\n\t * safe to do so now, because we verified earlier that there are no\n\t * conflicting Postgres processes in this data directory.\n\t */\n\tRemovePgTempFilesInDir(PG_TEMP_FILES_DIR, true, false);\n#endif\n\n\t/*\n\t * Forcibly remove the files signaling a standby promotion request.\n\t * Otherwise, the existence of those files triggers a promotion too early,\n\t * whether a user wants that or not.\n\t *\n\t * This removal of files is usually unnecessary because they can exist\n\t * only during a few moments during a standby promotion. However there is\n\t * a race condition: if pg_ctl promote is executed and creates the files\n\t * during a promotion, the files can stay around even after the server is\n\t * brought up to be the primary.  Then, if a new standby starts by using\n\t * the backup taken from the new primary, the files can exist at server\n\t * startup and must be removed in order to avoid an unexpected promotion.\n\t *\n\t * Note that promotion signal files need to be removed before the startup\n\t * process is invoked. Because, after that, they can be used by\n\t * postmaster's SIGUSR1 signal handler.\n\t */\n\tRemovePromoteSignalFiles();\n\n\t/* Do the same for logrotate signal file */\n\tRemoveLogrotateSignalFiles();\n\n\t/* Remove any outdated file holding the current log filenames. */\n\tif (unlink(LOG_METAINFO_DATAFILE) < 0 && errno != ENOENT)\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\",\n\t\t\t\t\t\tLOG_METAINFO_DATAFILE)));\n\n\t/*\n\t * Initialize input sockets.\n\t *\n\t * Mark them all closed, and set up an on_proc_exit function that's\n\t * charged with closing the sockets again at postmaster shutdown.\n\t */\n\tfor (i = 0; i < MAXLISTEN; i++)\n\t\tListenSocket[i] = PGINVALID_SOCKET;\n\n\ton_proc_exit(CloseServerPorts, 0);\n\n\t/*\n\t * If enabled, start up syslogger collection subprocess\n\t */\n\tSysLoggerPID = SysLogger_Start();\n\n\t/*\n\t * Reset whereToSendOutput from DestDebug (its starting state) to\n\t * DestNone. This stops ereport from sending log messages to stderr unless\n\t * Log_destination permits.  We don't do this until the postmaster is\n\t * fully launched, since startup failures may as well be reported to\n\t * stderr.\n\t *\n\t * If we are in fact disabling logging to stderr, first emit a log message\n\t * saying so, to provide a breadcrumb trail for users who may not remember\n\t * that their logging is configured to go somewhere else.\n\t */\n\tif (!(Log_destination & LOG_DESTINATION_STDERR))\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"ending log output to stderr\"),\n\t\t\t\t errhint(\"Future log output will go to log destination \\\"%s\\\".\",\n\t\t\t\t\t\t Log_destination_string)));\n\n\twhereToSendOutput = DestNone;\n\n\t/*\n\t * Report server startup in log.  While we could emit this much earlier,\n\t * it seems best to do so after starting the log collector, if we intend\n\t * to use one.\n\t */\n\tereport(LOG,\n\t\t\t(errmsg(\"starting %s\", PG_VERSION_STR)));\n\n\t/*\n\t * Establish input sockets.\n\t */\n\tif (ListenAddresses)\n\t{\n\t\tchar\t   *rawstring;\n\t\tList\t   *elemlist;\n\t\tListCell   *l;\n\t\tint\t\t\tsuccess = 0;\n\n\t\t/* Need a modifiable copy of ListenAddresses */\n\t\trawstring = pstrdup(ListenAddresses);\n\n\t\t/* Parse string into list of hostnames */\n\t\tif (!SplitGUCList(rawstring, ',', &elemlist))\n\t\t{\n\t\t\t/* syntax error in list */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"listen_addresses\")));\n\t\t}\n\n\t\tforeach(l, elemlist)\n\t\t{\n\t\t\tchar\t   *curhost = (char *) lfirst(l);\n\n\t\t\tif (strcmp(curhost, \"*\") == 0)\n\t\t\t\tstatus = StreamServerPort(AF_UNSPEC, NULL,\n\t\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\t\t\telse\n\t\t\t\tstatus = StreamServerPort(AF_UNSPEC, curhost,\n\t\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\n\t\t\tif (status == STATUS_OK)\n\t\t\t{\n\t\t\t\tsuccess++;\n\t\t\t\t/* record the first successful host addr in lockfile */\n\t\t\t\tif (!listen_addr_saved)\n\t\t\t\t{\n\t\t\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_LISTEN_ADDR, curhost);\n\t\t\t\t\tlisten_addr_saved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"could not create listen socket for \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tcurhost)));\n\t\t}\n\n\t\tif (!success && elemlist != NIL)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errmsg(\"could not create any TCP/IP sockets\")));\n\n\t\tlist_free(elemlist);\n\t\tpfree(rawstring);\n\t}\n\n#ifdef USE_BONJOUR\n\t/* Register for Bonjour only if we opened TCP socket(s) */\n\tif (enable_bonjour && ListenSocket[0] != PGINVALID_SOCKET)\n\t{\n\t\tDNSServiceErrorType err;\n\n\t\t/*\n\t\t * We pass 0 for interface_index, which will result in registering on\n\t\t * all \"applicable\" interfaces.  It's not entirely clear from the\n\t\t * DNS-SD docs whether this would be appropriate if we have bound to\n\t\t * just a subset of the available network interfaces.\n\t\t */\n\t\terr = DNSServiceRegister(&bonjour_sdref,\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t bonjour_name,\n\t\t\t\t\t\t\t\t \"_postgresql._tcp.\",\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t pg_hton16(PostPortNumber),\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL);\n\t\tif (err != kDNSServiceErr_NoError)\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"DNSServiceRegister() failed: error code %ld\",\n\t\t\t\t\t\t\t(long) err)));\n\n\t\t/*\n\t\t * We don't bother to read the mDNS daemon's reply, and we expect that\n\t\t * it will automatically terminate our registration when the socket is\n\t\t * closed at postmaster termination.  So there's nothing more to be\n\t\t * done here.  However, the bonjour_sdref is kept around so that\n\t\t * forked children can close their copies of the socket.\n\t\t */\n\t}\n#endif\n\n\tif (Unix_socket_directories)\n\t{\n\t\tchar\t   *rawstring;\n\t\tList\t   *elemlist;\n\t\tListCell   *l;\n\t\tint\t\t\tsuccess = 0;\n\n\t\t/* Need a modifiable copy of Unix_socket_directories */\n\t\trawstring = pstrdup(Unix_socket_directories);\n\n\t\t/* Parse string into list of directories */\n\t\tif (!SplitDirectoriesString(rawstring, ',', &elemlist))\n\t\t{\n\t\t\t/* syntax error in list */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"unix_socket_directories\")));\n\t\t}\n\n\t\tforeach(l, elemlist)\n\t\t{\n\t\t\tchar\t   *socketdir = (char *) lfirst(l);\n\n\t\t\tstatus = StreamServerPort(AF_UNIX, NULL,\n\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t  socketdir,\n\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\n\t\t\tif (status == STATUS_OK)\n\t\t\t{\n\t\t\t\tsuccess++;\n\t\t\t\t/* record the first successful Unix socket in lockfile */\n\t\t\t\tif (success == 1)\n\t\t\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_SOCKET_DIR, socketdir);\n\t\t\t}\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"could not create Unix-domain socket in directory \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tsocketdir)));\n\t\t}\n\n\t\tif (!success && elemlist != NIL)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errmsg(\"could not create any Unix-domain sockets\")));\n\n\t\tlist_free_deep(elemlist);\n\t\tpfree(rawstring);\n\t}\n\n\t/*\n\t * check that we have some socket to listen on\n\t */\n\tif (ListenSocket[0] == PGINVALID_SOCKET)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"no socket created for listening\")));\n\n\t/*\n\t * If no valid TCP ports, write an empty line for listen address,\n\t * indicating the Unix socket must be used.  Note that this line is not\n\t * added to the lock file until there is a socket backing it.\n\t */\n\tif (!listen_addr_saved)\n\t\tAddToDataDirLockFile(LOCK_FILE_LINE_LISTEN_ADDR, \"\");\n\n\t/*\n\t * Record postmaster options.  We delay this till now to avoid recording\n\t * bogus options (eg, unusable port number).\n\t */\n\tif (!CreateOptsFile(argc, argv, my_exec_path))\n\t\tExitPostmaster(1);\n\n\t/*\n\t * Write the external PID file if requested\n\t */\n\tif (external_pid_file)\n\t{\n\t\tFILE\t   *fpidfile = fopen(external_pid_file, \"w\");\n\n\t\tif (fpidfile)\n\t\t{\n\t\t\tfprintf(fpidfile, \"%d\\n\", MyProcPid);\n\t\t\tfclose(fpidfile);\n\n\t\t\t/* Make PID file world readable */\n\t\t\tif (chmod(external_pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) != 0)\n\t\t\t\twrite_stderr(\"%s: could not change permissions of external PID file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t\t\t progname, external_pid_file, strerror(errno));\n\t\t}\n\t\telse\n\t\t\twrite_stderr(\"%s: could not write external PID file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t\t progname, external_pid_file, strerror(errno));\n\n\t\ton_proc_exit(unlink_external_pid_file, 0);\n\t}\n\n\t/*\n\t * Remove old temporary files.  At this point there can be no other\n\t * Postgres processes running in this directory, so this should be safe.\n\t */\n\tRemovePgTempFiles();\n\n\t/*\n\t * Initialize the autovacuum subsystem (again, no process start yet)\n\t */\n\tautovac_init();\n\n\t/*\n\t * Load configuration files for client authentication.\n\t */\n\tif (!load_hba())\n\t{\n\t\t/*\n\t\t * It makes no sense to continue if we fail to load the HBA file,\n\t\t * since there is no way to connect to the database in this case.\n\t\t */\n\t\tereport(FATAL,\n\t\t/* translator: %s is a configuration file */\n\t\t\t\t(errmsg(\"could not load %s\", HbaFileName)));\n\t}\n\tif (!load_ident())\n\t{\n\t\t/*\n\t\t * We can start up without the IDENT file, although it means that you\n\t\t * cannot log in using any of the authentication methods that need a\n\t\t * user name mapping. load_ident() already logged the details of error\n\t\t * to the log.\n\t\t */\n\t}\n\n#ifdef HAVE_PTHREAD_IS_THREADED_NP\n\n\t/*\n\t * On macOS, libintl replaces setlocale() with a version that calls\n\t * CFLocaleCopyCurrent() when its second argument is \"\" and every relevant\n\t * environment variable is unset or empty.  CFLocaleCopyCurrent() makes\n\t * the process multithreaded.  The postmaster calls sigprocmask() and\n\t * calls fork() without an immediate exec(), both of which have undefined\n\t * behavior in a multithreaded program.  A multithreaded postmaster is the\n\t * normal case on Windows, which offers neither fork() nor sigprocmask().\n\t */\n\tif (pthread_is_threaded_np() != 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"postmaster became multithreaded during startup\"),\n\t\t\t\t errhint(\"Set the LC_ALL environment variable to a valid locale.\")));\n#endif\n\n\t/*\n\t * Remember postmaster startup time\n\t */\n\tPgStartTime = GetCurrentTimestamp();\n\n\t/*\n\t * Report postmaster status in the postmaster.pid file, to allow pg_ctl to\n\t * see what's happening.\n\t */\n\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STARTING);\n\n\t/* Start bgwriter and checkpointer so they can help with recovery */\n\tif (CheckpointerPID == 0)\n\t\tCheckpointerPID = StartCheckpointer();\n\tif (BgWriterPID == 0)\n\t\tBgWriterPID = StartBackgroundWriter();\n\n\t/*\n\t * We're ready to rock and roll...\n\t */\n\tStartupPID = StartupDataBase();\n\tAssert(StartupPID != 0);\n\tStartupStatus = STARTUP_RUNNING;\n\tpmState = PM_STARTUP;\n\n\t/* Some workers may be scheduled to start now */\n\tmaybe_start_bgworkers();\n\n\tstatus = ServerLoop();\n\n\t/*\n\t * ServerLoop probably shouldn't ever return, but if it does, close down.\n\t */\n\tExitPostmaster(status != STATUS_OK);\n\n\tabort();\t\t\t\t\t/* not reached */\n}WalReceiverMain(void)\n{\n\tchar\t\tconninfo[MAXCONNINFO];\n\tchar\t   *tmp_conninfo;\n\tchar\t\tslotname[NAMEDATALEN];\n\tbool\t\tis_temp_slot;\n\tXLogRecPtr\tstartpoint;\n\tTimeLineID\tstartpointTLI;\n\tTimeLineID\tprimaryTLI;\n\tbool\t\tfirst_stream;\n\tWalRcvData *walrcv = WalRcv;\n\tTimestampTz now;\n\tchar\t   *err;\n\tchar\t   *sender_host = NULL;\n\tint\t\t\tsender_port = 0;\n\n\t/*\n\t * WalRcv should be set up already (if we are a backend, we inherit this\n\t * by fork() or EXEC_BACKEND mechanism from the postmaster).\n\t */\n\tAssert(walrcv != NULL);\n\n\t/*\n\t * Mark walreceiver as running in shared memory.\n\t *\n\t * Do this as early as possible, so that if we fail later on, we'll set\n\t * state to STOPPED. If we die before this, the startup process will keep\n\t * waiting for us to start up, until it times out.\n\t */\n\tSpinLockAcquire(&walrcv->mutex);\n\tAssert(walrcv->pid == 0);\n\tswitch (walrcv->walRcvState)\n\t{\n\t\tcase WALRCV_STOPPING:\n\t\t\t/* If we've already been requested to stop, don't start up. */\n\t\t\twalrcv->walRcvState = WALRCV_STOPPED;\n\t\t\t/* fall through */\n\n\t\tcase WALRCV_STOPPED:\n\t\t\tSpinLockRelease(&walrcv->mutex);\n\t\t\tConditionVariableBroadcast(&walrcv->walRcvStoppedCV);\n\t\t\tproc_exit(1);\n\t\t\tbreak;\n\n\t\tcase WALRCV_STARTING:\n\t\t\t/* The usual case */\n\t\t\tbreak;\n\n\t\tcase WALRCV_WAITING:\n\t\tcase WALRCV_STREAMING:\n\t\tcase WALRCV_RESTARTING:\n\t\tdefault:\n\t\t\t/* Shouldn't happen */\n\t\t\tSpinLockRelease(&walrcv->mutex);\n\t\t\telog(PANIC, \"walreceiver still running according to shared memory state\");\n\t}\n\t/* Advertise our PID so that the startup process can kill us */\n\twalrcv->pid = MyProcPid;\n\twalrcv->walRcvState = WALRCV_STREAMING;\n\n\t/* Fetch information required to start streaming */\n\twalrcv->ready_to_display = false;\n\tstrlcpy(conninfo, (char *) walrcv->conninfo, MAXCONNINFO);\n\tstrlcpy(slotname, (char *) walrcv->slotname, NAMEDATALEN);\n\tis_temp_slot = walrcv->is_temp_slot;\n\tstartpoint = walrcv->receiveStart;\n\tstartpointTLI = walrcv->receiveStartTLI;\n\n\t/*\n\t * At most one of is_temp_slot and slotname can be set; otherwise,\n\t * RequestXLogStreaming messed up.\n\t */\n\tAssert(!is_temp_slot || (slotname[0] == '\\0'));\n\n\t/* Initialise to a sanish value */\n\tnow = GetCurrentTimestamp();\n\twalrcv->lastMsgSendTime =\n\t\twalrcv->lastMsgReceiptTime = walrcv->latestWalEndTime = now;\n\n\t/* Report the latch to use to awaken this process */\n\twalrcv->latch = &MyProc->procLatch;\n\n\tSpinLockRelease(&walrcv->mutex);\n\n\tpg_atomic_write_u64(&WalRcv->writtenUpto, 0);\n\n\t/* Arrange to clean up at walreceiver exit */\n\ton_shmem_exit(WalRcvDie, PointerGetDatum(&startpointTLI));\n\n\t/* Properly accept or ignore signals the postmaster might send us */\n\tpqsignal(SIGHUP, SignalHandlerForConfigReload); /* set flag to read config\n\t\t\t\t\t\t\t\t\t\t\t\t\t * file */\n\tpqsignal(SIGINT, SIG_IGN);\n\tpqsignal(SIGTERM, SignalHandlerForShutdownRequest); /* request shutdown */\n\t/* SIGQUIT handler was already set up by InitPostmasterChild */\n\tpqsignal(SIGALRM, SIG_IGN);\n\tpqsignal(SIGPIPE, SIG_IGN);\n\tpqsignal(SIGUSR1, procsignal_sigusr1_handler);\n\tpqsignal(SIGUSR2, SIG_IGN);\n\n\t/* Reset some signals that are accepted by postmaster but not here */\n\tpqsignal(SIGCHLD, SIG_DFL);\n\n\t/* Load the libpq-specific functions */\n\tload_file(\"libpqwalreceiver\", false);\n\tif (WalReceiverFunctions == NULL)\n\t\telog(ERROR, \"libpqwalreceiver didn't initialize correctly\");\n\n\t/* Unblock signals (they were blocked when the postmaster forked us) */\n\tsigprocmask(SIG_SETMASK, &UnBlockSig, NULL);\n\n\t/* Establish the connection to the primary for XLOG streaming */\n\twrconn = walrcv_connect(conninfo, false, false,\n\t\t\t\t\t\t\tcluster_name[0] ? cluster_name : \"walreceiver\",\n\t\t\t\t\t\t\t&err);\n\tif (!wrconn)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CONNECTION_FAILURE),\n\t\t\t\t errmsg(\"could not connect to the primary server: %s\", err)));\n\n\t/*\n\t * Save user-visible connection string.  This clobbers the original\n\t * conninfo, for security. Also save host and port of the sender server\n\t * this walreceiver is connected to.\n\t */\n\ttmp_conninfo = walrcv_get_conninfo(wrconn);\n\twalrcv_get_senderinfo(wrconn, &sender_host, &sender_port);\n\tSpinLockAcquire(&walrcv->mutex);\n\tmemset(walrcv->conninfo, 0, MAXCONNINFO);\n\tif (tmp_conninfo)\n\t\tstrlcpy((char *) walrcv->conninfo, tmp_conninfo, MAXCONNINFO);\n\n\tmemset(walrcv->sender_host, 0, NI_MAXHOST);\n\tif (sender_host)\n\t\tstrlcpy((char *) walrcv->sender_host, sender_host, NI_MAXHOST);\n\n\twalrcv->sender_port = sender_port;\n\twalrcv->ready_to_display = true;\n\tSpinLockRelease(&walrcv->mutex);\n\n\tif (tmp_conninfo)\n\t\tpfree(tmp_conninfo);\n\n\tif (sender_host)\n\t\tpfree(sender_host);\n\n\tfirst_stream = true;\n\tfor (;;)\n\t{\n\t\tchar\t   *primary_sysid;\n\t\tchar\t\tstandby_sysid[32];\n\t\tWalRcvStreamOptions options;\n\n\t\t/*\n\t\t * Check that we're connected to a valid server using the\n\t\t * IDENTIFY_SYSTEM replication command.\n\t\t */\n\t\tprimary_sysid = walrcv_identify_system(wrconn, &primaryTLI);\n\n\t\tsnprintf(standby_sysid, sizeof(standby_sysid), UINT64_FORMAT,\n\t\t\t\t GetSystemIdentifier());\n\t\tif (strcmp(primary_sysid, standby_sysid) != 0)\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"database system identifier differs between the primary and standby\"),\n\t\t\t\t\t errdetail(\"The primary's identifier is %s, the standby's identifier is %s.\",\n\t\t\t\t\t\t\t   primary_sysid, standby_sysid)));\n\t\t}\n\n\t\t/*\n\t\t * Confirm that the current timeline of the primary is the same or\n\t\t * ahead of ours.\n\t\t */\n\t\tif (primaryTLI < startpointTLI)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"highest timeline %u of the primary is behind recovery timeline %u\",\n\t\t\t\t\t\t\tprimaryTLI, startpointTLI)));\n\n\t\t/*\n\t\t * Get any missing history files. We do this always, even when we're\n\t\t * not interested in that timeline, so that if we're promoted to\n\t\t * become the primary later on, we don't select the same timeline that\n\t\t * was already used in the current primary. This isn't bullet-proof -\n\t\t * you'll need some external software to manage your cluster if you\n\t\t * need to ensure that a unique timeline id is chosen in every case,\n\t\t * but let's avoid the confusion of timeline id collisions where we\n\t\t * can.\n\t\t */\n\t\tWalRcvFetchTimeLineHistoryFiles(startpointTLI, primaryTLI);\n\n\t\t/*\n\t\t * Create temporary replication slot if requested, and update slot\n\t\t * name in shared memory.  (Note the slot name cannot already be set\n\t\t * in this case.)\n\t\t */\n\t\tif (is_temp_slot)\n\t\t{\n\t\t\tsnprintf(slotname, sizeof(slotname),\n\t\t\t\t\t \"pg_walreceiver_%lld\",\n\t\t\t\t\t (long long int) walrcv_get_backend_pid(wrconn));\n\n\t\t\twalrcv_create_slot(wrconn, slotname, true, false, 0, NULL);\n\n\t\t\tSpinLockAcquire(&walrcv->mutex);\n\t\t\tstrlcpy(walrcv->slotname, slotname, NAMEDATALEN);\n\t\t\tSpinLockRelease(&walrcv->mutex);\n\t\t}\n\n\t\t/*\n\t\t * Start streaming.\n\t\t *\n\t\t * We'll try to start at the requested starting point and timeline,\n\t\t * even if it's different from the server's latest timeline. In case\n\t\t * we've already reached the end of the old timeline, the server will\n\t\t * finish the streaming immediately, and we will go back to await\n\t\t * orders from the startup process. If recovery_target_timeline is\n\t\t * 'latest', the startup process will scan pg_wal and find the new\n\t\t * history file, bump recovery target timeline, and ask us to restart\n\t\t * on the new timeline.\n\t\t */\n\t\toptions.logical = false;\n\t\toptions.startpoint = startpoint;\n\t\toptions.slotname = slotname[0] != '\\0' ? slotname : NULL;\n\t\toptions.proto.physical.startpointTLI = startpointTLI;\n\t\tif (walrcv_startstreaming(wrconn, &options))\n\t\t{\n\t\t\tif (first_stream)\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"started streaming WAL from primary at %X/%X on timeline %u\",\n\t\t\t\t\t\t\t\tLSN_FORMAT_ARGS(startpoint), startpointTLI)));\n\t\t\telse\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"restarted WAL streaming at %X/%X on timeline %u\",\n\t\t\t\t\t\t\t\tLSN_FORMAT_ARGS(startpoint), startpointTLI)));\n\t\t\tfirst_stream = false;\n\n\t\t\t/* Initialize LogstreamResult and buffers for processing messages */\n\t\t\tLogstreamResult.Write = LogstreamResult.Flush = GetXLogReplayRecPtr(NULL);\n\t\t\tinitStringInfo(&reply_message);\n\t\t\tinitStringInfo(&incoming_message);\n\n\t\t\t/* Initialize nap wakeup times. */\n\t\t\tnow = GetCurrentTimestamp();\n\t\t\tfor (int i = 0; i < NUM_WALRCV_WAKEUPS; ++i)\n\t\t\t\tWalRcvComputeNextWakeup(i, now);\n\n\t\t\t/* Send initial reply/feedback messages. */\n\t\t\tXLogWalRcvSendReply(true, false);\n\t\t\tXLogWalRcvSendHSFeedback(true);\n\n\t\t\t/* Loop until end-of-streaming or error */\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tchar\t   *buf;\n\t\t\t\tint\t\t\tlen;\n\t\t\t\tbool\t\tendofwal = false;\n\t\t\t\tpgsocket\twait_fd = PGINVALID_SOCKET;\n\t\t\t\tint\t\t\trc;\n\t\t\t\tTimestampTz nextWakeup;\n\t\t\t\tlong\t\tnap;\n\n\t\t\t\t/*\n\t\t\t\t * Exit walreceiver if we're not in recovery. This should not\n\t\t\t\t * happen, but cross-check the status here.\n\t\t\t\t */\n\t\t\t\tif (!RecoveryInProgress())\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t\t\t errmsg(\"cannot continue WAL streaming, recovery has already ended\")));\n\n\t\t\t\t/* Process any requests or signals received recently */\n\t\t\t\tProcessWalRcvInterrupts();\n\n\t\t\t\tif (ConfigReloadPending)\n\t\t\t\t{\n\t\t\t\t\tConfigReloadPending = false;\n\t\t\t\t\tProcessConfigFile(PGC_SIGHUP);\n\t\t\t\t\t/* recompute wakeup times */\n\t\t\t\t\tnow = GetCurrentTimestamp();\n\t\t\t\t\tfor (int i = 0; i < NUM_WALRCV_WAKEUPS; ++i)\n\t\t\t\t\t\tWalRcvComputeNextWakeup(i, now);\n\t\t\t\t\tXLogWalRcvSendHSFeedback(true);\n\t\t\t\t}\n\n\t\t\t\t/* See if we can read data immediately */\n\t\t\t\tlen = walrcv_receive(wrconn, &buf, &wait_fd);\n\t\t\t\tif (len != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Process the received data, and any subsequent data we\n\t\t\t\t\t * can read without blocking.\n\t\t\t\t\t */\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (len > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Something was received from primary, so adjust\n\t\t\t\t\t\t\t * the ping and terminate wakeup times.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tnow = GetCurrentTimestamp();\n\t\t\t\t\t\t\tWalRcvComputeNextWakeup(WALRCV_WAKEUP_TERMINATE,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnow);\n\t\t\t\t\t\t\tWalRcvComputeNextWakeup(WALRCV_WAKEUP_PING, now);\n\t\t\t\t\t\t\tXLogWalRcvProcessMsg(buf[0], &buf[1], len - 1,\n\t\t\t\t\t\t\t\t\t\t\t\t startpointTLI);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (len == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if (len < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tereport(LOG,\n\t\t\t\t\t\t\t\t\t(errmsg(\"replication terminated by primary server\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"End of WAL reached on timeline %u at %X/%X.\",\n\t\t\t\t\t\t\t\t\t\t\t   startpointTLI,\n\t\t\t\t\t\t\t\t\t\t\t   LSN_FORMAT_ARGS(LogstreamResult.Write))));\n\t\t\t\t\t\t\tendofwal = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = walrcv_receive(wrconn, &buf, &wait_fd);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Let the primary know that we received some data. */\n\t\t\t\t\tXLogWalRcvSendReply(false, false);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If we've written some records, flush them to disk and\n\t\t\t\t\t * let the startup process and primary server know about\n\t\t\t\t\t * them.\n\t\t\t\t\t */\n\t\t\t\t\tXLogWalRcvFlush(false, startpointTLI);\n\t\t\t\t}\n\n\t\t\t\t/* Check if we need to exit the streaming loop. */\n\t\t\t\tif (endofwal)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* Find the soonest wakeup time, to limit our nap. */\n\t\t\t\tnextWakeup = TIMESTAMP_INFINITY;\n\t\t\t\tfor (int i = 0; i < NUM_WALRCV_WAKEUPS; ++i)\n\t\t\t\t\tnextWakeup = Min(wakeup[i], nextWakeup);\n\n\t\t\t\t/* Calculate the nap time, clamping as necessary. */\n\t\t\t\tnow = GetCurrentTimestamp();\n\t\t\t\tnap = TimestampDifferenceMilliseconds(now, nextWakeup);\n\n\t\t\t\t/*\n\t\t\t\t * Ideally we would reuse a WaitEventSet object repeatedly\n\t\t\t\t * here to avoid the overheads of WaitLatchOrSocket on epoll\n\t\t\t\t * systems, but we can't be sure that libpq (or any other\n\t\t\t\t * walreceiver implementation) has the same socket (even if\n\t\t\t\t * the fd is the same number, it may have been closed and\n\t\t\t\t * reopened since the last time).  In future, if there is a\n\t\t\t\t * function for removing sockets from WaitEventSet, then we\n\t\t\t\t * could add and remove just the socket each time, potentially\n\t\t\t\t * avoiding some system calls.\n\t\t\t\t */\n\t\t\t\tAssert(wait_fd != PGINVALID_SOCKET);\n\t\t\t\trc = WaitLatchOrSocket(MyLatch,\n\t\t\t\t\t\t\t\t\t   WL_EXIT_ON_PM_DEATH | WL_SOCKET_READABLE |\n\t\t\t\t\t\t\t\t\t   WL_TIMEOUT | WL_LATCH_SET,\n\t\t\t\t\t\t\t\t\t   wait_fd,\n\t\t\t\t\t\t\t\t\t   nap,\n\t\t\t\t\t\t\t\t\t   WAIT_EVENT_WAL_RECEIVER_MAIN);\n\t\t\t\tif (rc & WL_LATCH_SET)\n\t\t\t\t{\n\t\t\t\t\tResetLatch(MyLatch);\n\t\t\t\t\tProcessWalRcvInterrupts();\n\n\t\t\t\t\tif (walrcv->force_reply)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The recovery process has asked us to send apply\n\t\t\t\t\t\t * feedback now.  Make sure the flag is really set to\n\t\t\t\t\t\t * false in shared memory before sending the reply, so\n\t\t\t\t\t\t * we don't miss a new request for a reply.\n\t\t\t\t\t\t */\n\t\t\t\t\t\twalrcv->force_reply = false;\n\t\t\t\t\t\tpg_memory_barrier();\n\t\t\t\t\t\tXLogWalRcvSendReply(true, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rc & WL_TIMEOUT)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We didn't receive anything new. If we haven't heard\n\t\t\t\t\t * anything from the server for more than\n\t\t\t\t\t * wal_receiver_timeout / 2, ping the server. Also, if\n\t\t\t\t\t * it's been longer than wal_receiver_status_interval\n\t\t\t\t\t * since the last update we sent, send a status update to\n\t\t\t\t\t * the primary anyway, to report any progress in applying\n\t\t\t\t\t * WAL.\n\t\t\t\t\t */\n\t\t\t\t\tbool\t\trequestReply = false;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Check if time since last receive from primary has\n\t\t\t\t\t * reached the configured limit.\n\t\t\t\t\t */\n\t\t\t\t\tnow = GetCurrentTimestamp();\n\t\t\t\t\tif (now >= wakeup[WALRCV_WAKEUP_TERMINATE])\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CONNECTION_FAILURE),\n\t\t\t\t\t\t\t\t errmsg(\"terminating walreceiver due to timeout\")));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If we didn't receive anything new for half of receiver\n\t\t\t\t\t * replication timeout, then ping the server.\n\t\t\t\t\t */\n\t\t\t\t\tif (now >= wakeup[WALRCV_WAKEUP_PING])\n\t\t\t\t\t{\n\t\t\t\t\t\trequestReply = true;\n\t\t\t\t\t\twakeup[WALRCV_WAKEUP_PING] = TIMESTAMP_INFINITY;\n\t\t\t\t\t}\n\n\t\t\t\t\tXLogWalRcvSendReply(requestReply, requestReply);\n\t\t\t\t\tXLogWalRcvSendHSFeedback(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The backend finished streaming. Exit streaming COPY-mode from\n\t\t\t * our side, too.\n\t\t\t */\n\t\t\twalrcv_endstreaming(wrconn, &primaryTLI);\n\n\t\t\t/*\n\t\t\t * If the server had switched to a new timeline that we didn't\n\t\t\t * know about when we began streaming, fetch its timeline history\n\t\t\t * file now.\n\t\t\t */\n\t\t\tWalRcvFetchTimeLineHistoryFiles(startpointTLI, primaryTLI);\n\t\t}\n\t\telse\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"primary server contains no more WAL on requested timeline %u\",\n\t\t\t\t\t\t\tstartpointTLI)));\n\n\t\t/*\n\t\t * End of WAL reached on the requested timeline. Close the last\n\t\t * segment, and await for new orders from the startup process.\n\t\t */\n\t\tif (recvFile >= 0)\n\t\t{\n\t\t\tchar\t\txlogfname[MAXFNAMELEN];\n\n\t\t\tXLogWalRcvFlush(false, startpointTLI);\n\t\t\tXLogFileName(xlogfname, recvFileTLI, recvSegNo, wal_segment_size);\n\t\t\tif (close(recvFile) != 0)\n\t\t\t\tereport(PANIC,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not close WAL segment %s: %m\",\n\t\t\t\t\t\t\t\txlogfname)));\n\n\t\t\t/*\n\t\t\t * Create .done file forcibly to prevent the streamed segment from\n\t\t\t * being archived later.\n\t\t\t */\n\t\t\tif (XLogArchiveMode != ARCHIVE_MODE_ALWAYS)\n\t\t\t\tXLogArchiveForceDone(xlogfname);\n\t\t\telse\n\t\t\t\tXLogArchiveNotify(xlogfname);\n\t\t}\n\t\trecvFile = -1;\n\n\t\telog(DEBUG1, \"walreceiver ended streaming and awaits new instructions\");\n\t\tWalRcvWaitForStartPosition(&startpoint, &startpointTLI);\n\t}\n\t/* not reached */\n}",
  "timestamp": "2025-06-04T20:03:25.241857"
}