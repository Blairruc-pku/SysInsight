{
  "param_name": "work_mem",
  "function_name": "get_relation_info",
  "analysis": "<需要提供函数>\n无需提供其他函数的实现\n\n<思考过程>\n1. 参数通过控制关键函数对数据库性能的影响：\n    - work_mem 通过内存使用机制影响 get_relation_info，进而产生内存溢出或者内存不足的问题从而影响数据库性能\n    - 机制：work_mem参数决定了单个查询操作可用的内存量。当get_relation_info在处理大量索引信息或统计数据时，可能会使用大量的内存。如果work_mem设置过低，可能导致过程中更多使用磁盘上的临时文件，从而降低性能。\n    - 数据库性能影响：设置不当的work_mem可能导致CPU与I/O资源使用不均衡，内存不足导致对磁盘的过度依赖，从而降低查询性能。反之，过高的设置可能会导致内存的浪费或争抢，影响其他进程的运行。\n\n<火焰图采样分析与调优方向>\n2. 基于 get_relation_info执行状态和相关函数片段给出work_mem 优化建议：\n    - 如果涉及到RelationGetIndexList、index_open等大量操作函数，则需要监控这些函数与get_relation_info的关系，以评估它们的内存消耗。\n    - 如果get_relation_info在火焰图采样中占用的比例较高，并且呈现出内存使用不足的问题（频繁的磁盘I/O），建议适度升高work_mem值，以减少外部内存使用；反之，如果发现内存使用过量但达不到所需性能提升，建议降低work_mem值，确保内存资源的合理分配。依据是基于低内存利用率或高I/O waited time的火焰图特征。",
  "code_snippets": "get_relation_info(PlannerInfo *root, Oid relationObjectId, bool inhparent,\n\t\t\t\t  RelOptInfo *rel)\n{\n\tIndex\t\tvarno = rel->relid;\n\tRelation\trelation;\n\tbool\t\thasindex;\n\tList\t   *indexinfos = NIL;\n\n\t/*\n\t * We need not lock the relation since it was already locked, either by\n\t * the rewriter or when expand_inherited_rtentry() added it to the query's\n\t * rangetable.\n\t */\n\trelation = table_open(relationObjectId, NoLock);\n\n\t/*\n\t * Relations without a table AM can be used in a query only if they are of\n\t * special-cased relkinds.  This check prevents us from crashing later if,\n\t * for example, a view's ON SELECT rule has gone missing.  Note that\n\t * table_open() already rejected indexes and composite types; spell the\n\t * error the same way it does.\n\t */\n\tif (!relation->rd_tableam)\n\t{\n\t\tif (!(relation->rd_rel->relkind == RELKIND_FOREIGN_TABLE ||\n\t\t\t  relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"cannot open relation \\\"%s\\\"\",\n\t\t\t\t\t\t\tRelationGetRelationName(relation)),\n\t\t\t\t\t errdetail_relkind_not_supported(relation->rd_rel->relkind)));\n\t}\n\n\t/* Temporary and unlogged relations are inaccessible during recovery. */\n\tif (!RelationIsPermanent(relation) && RecoveryInProgress())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot access temporary or unlogged relations during recovery\")));\n\n\trel->min_attr = FirstLowInvalidHeapAttributeNumber + 1;\n\trel->max_attr = RelationGetNumberOfAttributes(relation);\n\trel->reltablespace = RelationGetForm(relation)->reltablespace;\n\n\tAssert(rel->max_attr >= rel->min_attr);\n\trel->attr_needed = (Relids *)\n\t\tpalloc0((rel->max_attr - rel->min_attr + 1) * sizeof(Relids));\n\trel->attr_widths = (int32 *)\n\t\tpalloc0((rel->max_attr - rel->min_attr + 1) * sizeof(int32));\n\n\t/*\n\t * Estimate relation size --- unless it's an inheritance parent, in which\n\t * case the size we want is not the rel's own size but the size of its\n\t * inheritance tree.  That will be computed in set_append_rel_size().\n\t */\n\tif (!inhparent)\n\t\testimate_rel_size(relation, rel->attr_widths - rel->min_attr,\n\t\t\t\t\t\t  &rel->pages, &rel->tuples, &rel->allvisfrac);\n\n\t/* Retrieve the parallel_workers reloption, or -1 if not set. */\n\trel->rel_parallel_workers = RelationGetParallelWorkers(relation, -1);\n\n\t/*\n\t * Make list of indexes.  Ignore indexes on system catalogs if told to.\n\t * Don't bother with indexes from traditional inheritance parents.  For\n\t * partitioned tables, we need a list of at least unique indexes as these\n\t * serve as unique proofs for certain planner optimizations.  However,\n\t * let's not discriminate here and just record all partitioned indexes\n\t * whether they're unique indexes or not.\n\t */\n\tif ((inhparent && relation->rd_rel->relkind != RELKIND_PARTITIONED_TABLE)\n\t\t|| (IgnoreSystemIndexes && IsSystemRelation(relation)))\n\t\thasindex = false;\n\telse\n\t\thasindex = relation->rd_rel->relhasindex;\n\n\tif (hasindex)\n\t{\n\t\tList\t   *indexoidlist;\n\t\tLOCKMODE\tlmode;\n\t\tListCell   *l;\n\n\t\tindexoidlist = RelationGetIndexList(relation);\n\n\t\t/*\n\t\t * For each index, we get the same type of lock that the executor will\n\t\t * need, and do not release it.  This saves a couple of trips to the\n\t\t * shared lock manager while not creating any real loss of\n\t\t * concurrency, because no schema changes could be happening on the\n\t\t * index while we hold lock on the parent rel, and no lock type used\n\t\t * for queries blocks any other kind of index operation.\n\t\t */\n\t\tlmode = root->simple_rte_array[varno]->rellockmode;\n\n\t\tforeach(l, indexoidlist)\n\t\t{\n\t\t\tOid\t\t\tindexoid = lfirst_oid(l);\n\t\t\tRelation\tindexRelation;\n\t\t\tForm_pg_index index;\n\t\t\tIndexAmRoutine *amroutine;\n\t\t\tIndexOptInfo *info;\n\t\t\tint\t\t\tncolumns,\n\t\t\t\t\t\tnkeycolumns;\n\t\t\tint\t\t\ti;\n\n\t\t\t/*\n\t\t\t * Extract info from the relation descriptor for the index.\n\t\t\t */\n\t\t\tindexRelation = index_open(indexoid, lmode);\n\t\t\tindex = indexRelation->rd_index;\n\n\t\t\t/*\n\t\t\t * Ignore invalid indexes, since they can't safely be used for\n\t\t\t * queries.  Note that this is OK because the data structure we\n\t\t\t * are constructing is only used by the planner --- the executor\n\t\t\t * still needs to insert into \"invalid\" indexes, if they're marked\n\t\t\t * indisready.\n\t\t\t */\n\t\t\tif (!index->indisvalid)\n\t\t\t{\n\t\t\t\tindex_close(indexRelation, NoLock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the index is valid, but cannot yet be used, ignore it; but\n\t\t\t * mark the plan we are generating as transient. See\n\t\t\t * src/backend/access/heap/README.HOT for discussion.\n\t\t\t */\n\t\t\tif (index->indcheckxmin &&\n\t\t\t\t!TransactionIdPrecedes(HeapTupleHeaderGetXmin(indexRelation->rd_indextuple->t_data),\n\t\t\t\t\t\t\t\t\t   TransactionXmin))\n\t\t\t{\n\t\t\t\troot->glob->transientPlan = true;\n\t\t\t\tindex_close(indexRelation, NoLock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinfo = makeNode(IndexOptInfo);\n\n\t\t\tinfo->indexoid = index->indexrelid;\n\t\t\tinfo->reltablespace =\n\t\t\t\tRelationGetForm(indexRelation)->reltablespace;\n\t\t\tinfo->rel = rel;\n\t\t\tinfo->ncolumns = ncolumns = index->indnatts;\n\t\t\tinfo->nkeycolumns = nkeycolumns = index->indnkeyatts;\n\n\t\t\tinfo->indexkeys = (int *) palloc(sizeof(int) * ncolumns);\n\t\t\tinfo->indexcollations = (Oid *) palloc(sizeof(Oid) * nkeycolumns);\n\t\t\tinfo->opfamily = (Oid *) palloc(sizeof(Oid) * nkeycolumns);\n\t\t\tinfo->opcintype = (Oid *) palloc(sizeof(Oid) * nkeycolumns);\n\t\t\tinfo->canreturn = (bool *) palloc(sizeof(bool) * ncolumns);\n\n\t\t\tfor (i = 0; i < ncolumns; i++)\n\t\t\t{\n\t\t\t\tinfo->indexkeys[i] = index->indkey.values[i];\n\t\t\t\tinfo->canreturn[i] = index_can_return(indexRelation, i + 1);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < nkeycolumns; i++)\n\t\t\t{\n\t\t\t\tinfo->opfamily[i] = indexRelation->rd_opfamily[i];\n\t\t\t\tinfo->opcintype[i] = indexRelation->rd_opcintype[i];\n\t\t\t\tinfo->indexcollations[i] = indexRelation->rd_indcollation[i];\n\t\t\t}\n\n\t\t\tinfo->relam = indexRelation->rd_rel->relam;\n\n\t\t\t/*\n\t\t\t * We don't have an AM for partitioned indexes, so we'll just\n\t\t\t * NULLify the AM related fields for those.\n\t\t\t */\n\t\t\tif (indexRelation->rd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t\t{\n\t\t\t\t/* We copy just the fields we need, not all of rd_indam */\n\t\t\t\tamroutine = indexRelation->rd_indam;\n\t\t\t\tinfo->amcanorderbyop = amroutine->amcanorderbyop;\n\t\t\t\tinfo->amoptionalkey = amroutine->amoptionalkey;\n\t\t\t\tinfo->amsearcharray = amroutine->amsearcharray;\n\t\t\t\tinfo->amsearchnulls = amroutine->amsearchnulls;\n\t\t\t\tinfo->amcanparallel = amroutine->amcanparallel;\n\t\t\t\tinfo->amhasgettuple = (amroutine->amgettuple != NULL);\n\t\t\t\tinfo->amhasgetbitmap = amroutine->amgetbitmap != NULL &&\n\t\t\t\t\trelation->rd_tableam->scan_bitmap_next_block != NULL;\n\t\t\t\tinfo->amcanmarkpos = (amroutine->ammarkpos != NULL &&\n\t\t\t\t\t\t\t\t\t  amroutine->amrestrpos != NULL);\n\t\t\t\tinfo->amcostestimate = amroutine->amcostestimate;\n\t\t\t\tAssert(info->amcostestimate != NULL);\n\n\t\t\t\t/* Fetch index opclass options */\n\t\t\t\tinfo->opclassoptions = RelationGetIndexAttOptions(indexRelation, true);\n\n\t\t\t\t/*\n\t\t\t\t * Fetch the ordering information for the index, if any.\n\t\t\t\t */\n\t\t\t\tif (info->relam == BTREE_AM_OID)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If it's a btree index, we can use its opfamily OIDs\n\t\t\t\t\t * directly as the sort ordering opfamily OIDs.\n\t\t\t\t\t */\n\t\t\t\t\tAssert(amroutine->amcanorder);\n\n\t\t\t\t\tinfo->sortopfamily = info->opfamily;\n\t\t\t\t\tinfo->reverse_sort = (bool *) palloc(sizeof(bool) * nkeycolumns);\n\t\t\t\t\tinfo->nulls_first = (bool *) palloc(sizeof(bool) * nkeycolumns);\n\n\t\t\t\t\tfor (i = 0; i < nkeycolumns; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint16\t\topt = indexRelation->rd_indoption[i];\n\n\t\t\t\t\t\tinfo->reverse_sort[i] = (opt & INDOPTION_DESC) != 0;\n\t\t\t\t\t\tinfo->nulls_first[i] = (opt & INDOPTION_NULLS_FIRST) != 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (amroutine->amcanorder)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Otherwise, identify the corresponding btree opfamilies\n\t\t\t\t\t * by trying to map this index's \"<\" operators into btree.\n\t\t\t\t\t * Since \"<\" uniquely defines the behavior of a sort\n\t\t\t\t\t * order, this is a sufficient test.\n\t\t\t\t\t *\n\t\t\t\t\t * XXX This method is rather slow and also requires the\n\t\t\t\t\t * undesirable assumption that the other index AM numbers\n\t\t\t\t\t * its strategies the same as btree.  It'd be better to\n\t\t\t\t\t * have a way to explicitly declare the corresponding\n\t\t\t\t\t * btree opfamily for each opfamily of the other index\n\t\t\t\t\t * type.  But given the lack of current or foreseeable\n\t\t\t\t\t * amcanorder index types, it's not worth expending more\n\t\t\t\t\t * effort on now.\n\t\t\t\t\t */\n\t\t\t\t\tinfo->sortopfamily = (Oid *) palloc(sizeof(Oid) * nkeycolumns);\n\t\t\t\t\tinfo->reverse_sort = (bool *) palloc(sizeof(bool) * nkeycolumns);\n\t\t\t\t\tinfo->nulls_first = (bool *) palloc(sizeof(bool) * nkeycolumns);\n\n\t\t\t\t\tfor (i = 0; i < nkeycolumns; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint16\t\topt = indexRelation->rd_indoption[i];\n\t\t\t\t\t\tOid\t\t\tltopr;\n\t\t\t\t\t\tOid\t\t\tbtopfamily;\n\t\t\t\t\t\tOid\t\t\tbtopcintype;\n\t\t\t\t\t\tint16\t\tbtstrategy;\n\n\t\t\t\t\t\tinfo->reverse_sort[i] = (opt & INDOPTION_DESC) != 0;\n\t\t\t\t\t\tinfo->nulls_first[i] = (opt & INDOPTION_NULLS_FIRST) != 0;\n\n\t\t\t\t\t\tltopr = get_opfamily_member(info->opfamily[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\tinfo->opcintype[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\tinfo->opcintype[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\tBTLessStrategyNumber);\n\t\t\t\t\t\tif (OidIsValid(ltopr) &&\n\t\t\t\t\t\t\tget_ordering_op_properties(ltopr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &btopfamily,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &btopcintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &btstrategy) &&\n\t\t\t\t\t\t\tbtopcintype == info->opcintype[i] &&\n\t\t\t\t\t\t\tbtstrategy == BTLessStrategyNumber)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Successful mapping */\n\t\t\t\t\t\t\tinfo->sortopfamily[i] = btopfamily;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Fail ... quietly treat index as unordered */\n\t\t\t\t\t\t\tinfo->sortopfamily = NULL;\n\t\t\t\t\t\t\tinfo->reverse_sort = NULL;\n\t\t\t\t\t\t\tinfo->nulls_first = NULL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinfo->sortopfamily = NULL;\n\t\t\t\t\tinfo->reverse_sort = NULL;\n\t\t\t\t\tinfo->nulls_first = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinfo->amcanorderbyop = false;\n\t\t\t\tinfo->amoptionalkey = false;\n\t\t\t\tinfo->amsearcharray = false;\n\t\t\t\tinfo->amsearchnulls = false;\n\t\t\t\tinfo->amcanparallel = false;\n\t\t\t\tinfo->amhasgettuple = false;\n\t\t\t\tinfo->amhasgetbitmap = false;\n\t\t\t\tinfo->amcanmarkpos = false;\n\t\t\t\tinfo->amcostestimate = NULL;\n\n\t\t\t\tinfo->sortopfamily = NULL;\n\t\t\t\tinfo->reverse_sort = NULL;\n\t\t\t\tinfo->nulls_first = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Fetch the index expressions and predicate, if any.  We must\n\t\t\t * modify the copies we obtain from the relcache to have the\n\t\t\t * correct varno for the parent relation, so that they match up\n\t\t\t * correctly against qual clauses.\n\t\t\t */\n\t\t\tinfo->indexprs = RelationGetIndexExpressions(indexRelation);\n\t\t\tinfo->indpred = RelationGetIndexPredicate(indexRelation);\n\t\t\tif (info->indexprs && varno != 1)\n\t\t\t\tChangeVarNodes((Node *) info->indexprs, 1, varno, 0);\n\t\t\tif (info->indpred && varno != 1)\n\t\t\t\tChangeVarNodes((Node *) info->indpred, 1, varno, 0);\n\n\t\t\t/* Build targetlist using the completed indexprs data */\n\t\t\tinfo->indextlist = build_index_tlist(root, info, relation);\n\n\t\t\tinfo->indrestrictinfo = NIL;\t/* set later, in indxpath.c */\n\t\t\tinfo->predOK = false;\t/* set later, in indxpath.c */\n\t\t\tinfo->unique = index->indisunique;\n\t\t\tinfo->immediate = index->indimmediate;\n\t\t\tinfo->hypothetical = false;\n\n\t\t\t/*\n\t\t\t * Estimate the index size.  If it's not a partial index, we lock\n\t\t\t * the number-of-tuples estimate to equal the parent table; if it\n\t\t\t * is partial then we have to use the same methods as we would for\n\t\t\t * a table, except we can be sure that the index is not larger\n\t\t\t * than the table.  We must ignore partitioned indexes here as\n\t\t\t * there are not physical indexes.\n\t\t\t */\n\t\t\tif (indexRelation->rd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t\t{\n\t\t\t\tif (info->indpred == NIL)\n\t\t\t\t{\n\t\t\t\t\tinfo->pages = RelationGetNumberOfBlocks(indexRelation);\n\t\t\t\t\tinfo->tuples = rel->tuples;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdouble\t\tallvisfrac; /* dummy */\n\n\t\t\t\t\testimate_rel_size(indexRelation, NULL,\n\t\t\t\t\t\t\t\t\t  &info->pages, &info->tuples, &allvisfrac);\n\t\t\t\t\tif (info->tuples > rel->tuples)\n\t\t\t\t\t\tinfo->tuples = rel->tuples;\n\t\t\t\t}\n\n\t\t\t\tif (info->relam == BTREE_AM_OID)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * For btrees, get tree height while we have the index\n\t\t\t\t\t * open\n\t\t\t\t\t */\n\t\t\t\t\tinfo->tree_height = _bt_getrootheight(indexRelation);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* For other index types, just set it to \"unknown\" for now */\n\t\t\t\t\tinfo->tree_height = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Zero these out for partitioned indexes */\n\t\t\t\tinfo->pages = 0;\n\t\t\t\tinfo->tuples = 0.0;\n\t\t\t\tinfo->tree_height = -1;\n\t\t\t}\n\n\t\t\tindex_close(indexRelation, NoLock);\n\n\t\t\t/*\n\t\t\t * We've historically used lcons() here.  It'd make more sense to\n\t\t\t * use lappend(), but that causes the planner to change behavior\n\t\t\t * in cases where two indexes seem equally attractive.  For now,\n\t\t\t * stick with lcons() --- few tables should have so many indexes\n\t\t\t * that the O(N^2) behavior of lcons() is really a problem.\n\t\t\t */\n\t\t\tindexinfos = lcons(info, indexinfos);\n\t\t}\n\n\t\tlist_free(indexoidlist);\n\t}\n\n\trel->indexlist = indexinfos;\n\n\trel->statlist = get_relation_statistics(rel, relation);\n\n\t/* Grab foreign-table info using the relcache, while we have it */\n\tif (relation->rd_rel->relkind == RELKIND_FOREIGN_TABLE)\n\t{\n\t\trel->serverid = GetForeignServerIdByRelId(RelationGetRelid(relation));\n\t\trel->fdwroutine = GetFdwRoutineForRelation(relation, true);\n\t}\n\telse\n\t{\n\t\trel->serverid = InvalidOid;\n\t\trel->fdwroutine = NULL;\n\t}\n\n\t/* Collect info about relation's foreign keys, if relevant */\n\tget_relation_foreign_keys(root, rel, relation, inhparent);\n\n\t/* Collect info about functions implemented by the rel's table AM. */\n\tif (relation->rd_tableam &&\n\t\trelation->rd_tableam->scan_set_tidrange != NULL &&\n\t\trelation->rd_tableam->scan_getnextslot_tidrange != NULL)\n\t\trel->amflags |= AMFLAG_HAS_TID_RANGE;\n\n\t/*\n\t * Collect info about relation's partitioning scheme, if any. Only\n\t * inheritance parents may be partitioned.\n\t */\n\tif (inhparent && relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)\n\t\tset_relation_partition_info(root, rel, relation);\n\n\ttable_close(relation, NoLock);\n\n\t/*\n\t * Allow a plugin to editorialize on the info we obtained from the\n\t * catalogs.  Actions might include altering the assumed relation size,\n\t * removing an index, or adding a hypothetical index to the indexlist.\n\t */\n\tif (get_relation_info_hook)\n\t\t(*get_relation_info_hook) (root, relationObjectId, inhparent, rel);\n}",
  "timestamp": "2025-06-09T15:51:04.488912"
}