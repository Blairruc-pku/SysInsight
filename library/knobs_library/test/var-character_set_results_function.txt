-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/set_var.cc
Function: set_var_collation_client::update
bool sys_var::update(THD *thd, set_var *var) {
  /*
    Invoke preparatory step for updating a system variable. Doing this action
    before we have acquired any locks allows to invoke code which acquires other
    locks without introducing deadlocks.
  */
  if (pre_update && pre_update(this, thd, var)) return true;

  enum_var_type type = var->type;
  if (type == OPT_GLOBAL || type == OPT_PERSIST || scope() == GLOBAL) {
    /*
      Yes, both locks need to be taken before an update, just as
      both are taken to get a value. If we'll take only 'guard' here,
      then value_ptr() for strings won't be safe in SHOW VARIABLES anymore,
      to make it safe we'll need value_ptr_unlock().
    */
    AutoWLock lock1(&PLock_global_system_variables);
    AutoWLock lock2(guard);
    return global_update(thd, var) ||
           (on_update && on_update(this, thd, OPT_GLOBAL));
  } else {
    /* Block reads from other threads. */
    mysql_mutex_lock(&thd->LOCK_thd_sysvar);

    bool ret = session_update(thd, var) ||
               (on_update && on_update(this, thd, OPT_SESSION));

    mysql_mutex_unlock(&thd->LOCK_thd_sysvar);

    /*
      Make sure we don't session-track variables that are not actually
      part of the session. tx_isolation and and tx_read_only for example
      exist as GLOBAL, SESSION, and one-shot ("for next transaction only").
    */
    if ((var->type == OPT_SESSION) || !is_trilevel()) {
      if ((!ret) && thd->session_tracker.get_tracker(SESSION_SYSVARS_TRACKER)
                        ->is_enabled())
        thd->session_tracker.get_tracker(SESSION_SYSVARS_TRACKER)
            ->mark_as_changed(thd, name);

      if ((!ret) &&
          thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
              ->is_enabled())
        thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
            ->mark_as_changed(thd, name);
    }

    return ret;
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: ndb_create_thd
THD *ndb_create_thd(char *stackptr) {
  DBUG_TRACE;
  THD *thd = new THD; /* note that constructor of THD uses DBUG_ */
  if (thd == nullptr) {
    return nullptr;
  }
  THD_CHECK_SENTRY(thd);

  thd->thread_stack = stackptr; /* remember where our stack is */
  thd->store_globals();

  thd->init_query_mem_roots();
  thd->set_command(COM_DAEMON);
  thd->system_thread = SYSTEM_THREAD_NDBCLUSTER_BINLOG;
  thd->get_protocol_classic()->set_client_capabilities(0);
  thd->lex->start_transaction_opt = 0;
  thd->security_context()->skip_grants();

  CHARSET_INFO *charset_connection =
      get_charset_by_csname("utf8mb3", MY_CS_PRIMARY, MYF(MY_WME));
  thd->variables.character_set_client = charset_connection;
  thd->variables.character_set_results = charset_connection;
  thd->variables.collation_connection = charset_connection;
  thd->update_charset();
  return thd;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/protocol_classic.cc
Function: net_send_error_packet
  return net_send_error_packet(thd->get_protocol_classic()->get_net(),
                               sql_errno, err, sqlstate,
                               thd->is_bootstrap_system_thread(),
                               thd->get_protocol()->get_client_capabilities(),
                               thd->variables.character_set_results);
}

/**
  @param net                    Low-level NET struct
  @param sql_errno              The error code to send
  @param err                    A pointer to the error message
  @param sqlstate               SQL state
  @param bootstrap              Server is started in bootstrap mode
  @param client_capabilities    Client capabilities flag
  @param character_set_results  Char set info

  @retval false The message was successfully sent
  @retval true  An error occurred and the messages wasn't sent properly

  See also @ref page_protocol_basic_err_packet
*/

static bool net_send_error_packet(NET *net, uint sql_errno, const char *err,
                                  const char *sqlstate, bool bootstrap,
                                  ulong client_capabilities,
                                  const CHARSET_INFO *character_set_results) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/protocol_classic.cc
Function: Protocol_classic::send_field_metadata
bool Protocol_classic::send_field_metadata(Send_field *field,
                                           const CHARSET_INFO *item_charset) {
  DBUG_TRACE;
  char *pos;
  const CHARSET_INFO *cs = system_charset_info;
  const CHARSET_INFO *thd_charset = m_thd->variables.character_set_results;

  assert(field->type != MYSQL_TYPE_BOOL);

  /* Keep things compatible for old clients */
  if (field->type == MYSQL_TYPE_VARCHAR) field->type = MYSQL_TYPE_VAR_STRING;

  send_metadata = true;
  if (has_client_capability(CLIENT_PROTOCOL_41)) {
    if (store_string(STRING_WITH_LEN("def"), cs) ||
        store_string(field->db_name, strlen(field->db_name), cs) ||
        store_string(field->table_name, strlen(field->table_name), cs) ||
        store_string(field->org_table_name, strlen(field->org_table_name),
                     cs) ||
        store_string(field->col_name, strlen(field->col_name), cs) ||
        store_string(field->org_col_name, strlen(field->org_col_name), cs) ||
        packet->mem_realloc(packet->length() + 12)) {
      send_metadata = false;
      return true;
    }
    /* Store fixed length fields */
    pos = packet->ptr() + packet->length();
    *pos++ = 12;  // Length of packed fields
    /* inject a NULL to test the client */
    DBUG_EXECUTE_IF("poison_rs_fields", pos[-1] = (char)0xfb;);
    if (item_charset == &my_charset_bin || thd_charset == nullptr) {
      /* No conversion */
      int2store(pos, item_charset->number);
      int4store(pos + 2, field->length);
    } else {
      /* With conversion */
      uint32 field_length, max_length;
      int2store(pos, thd_charset->number);
      /*
        For TEXT/BLOB columns, field_length describes the maximum data
        length in bytes. There is no limit to the number of characters
        that a TEXT column can store, as long as the data fits into
        the designated space.
        For the rest of textual columns, field_length is evaluated as
        char_count * mbmaxlen, where character count is taken from the
        definition of the column. In other words, the maximum number
        of characters here is limited by the column definition.

        When one has a LONG TEXT column with a single-byte
        character set, and the connection character set is multi-byte, the
        client may get fields longer than UINT_MAX32, due to
        <character set column> -> <character set connection> conversion.
        In that case column max length does not fit into the 4 bytes
        reserved for it in the protocol.
      */
      max_length = (field->type >= MYSQL_TYPE_TINY_BLOB &&
                    field->type <= MYSQL_TYPE_BLOB)
                       ? field->length / item_charset->mbminlen
                       : field->length / item_charset->mbmaxlen;
      field_length =
          char_to_byte_length_safe(max_length, thd_charset->mbmaxlen);
      int4store(pos + 2, field_length);
    }
    pos[6] = field->type;
    int2store(pos + 7, field->flags);
    pos[9] = (char)field->decimals;
    pos[10] = 0;  // For the future
    pos[11] = 0;  // For the future
    pos += 12;
  } else {
    if (store_string(field->table_name, strlen(field->table_name), cs) ||
        store_string(field->col_name, strlen(field->col_name), cs) ||
        packet->mem_realloc(packet->length() + 10)) {
      send_metadata = false;
      return true;
    }
    pos = packet->ptr() + packet->length();
    pos[0] = 3;
    int3store(pos + 1, field->length);
    pos[4] = 1;
    pos[5] = field->type;
    pos[6] = 3;
    int2store(pos + 7, field->flags);
    pos[9] = (char)field->decimals;
    pos += 10;
  }
  packet->length((uint)(pos - packet->ptr()));

#ifndef NDEBUG
  field_types[count++] = field->type;
#endif
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::send_result_metadata
bool THD::send_result_metadata(const mem_root_deque<Item *> &list, uint flags) {
  DBUG_TRACE;
  uchar buff[MAX_FIELD_WIDTH];
  String tmp((char *)buff, sizeof(buff), &my_charset_bin);

  if (m_protocol->start_result_metadata(CountVisibleFields(list), flags,
                                        variables.character_set_results))
    goto err;
  switch (variables.resultset_metadata) {
    case RESULTSET_METADATA_FULL:
      /* Send metadata. */
      for (Item *item : VisibleFields(list)) {
        Send_field field;
        item->make_field(&field);
        m_protocol->start_row();
        if (m_protocol->send_field_metadata(&field,
                                            item->charset_for_protocol()))
          goto err;
        if (flags & Protocol::SEND_DEFAULTS) item->send(m_protocol, &tmp);
        if (m_protocol->end_row()) return true;
      }
      break;

    case RESULTSET_METADATA_NONE:
      /* Skip metadata. */
      break;

    default:
      /* Unknown @@resultset_metadata value. */
      return true;
  }

  return m_protocol->end_result_metadata();

err:
  my_error(ER_OUT_OF_RESOURCES, MYF(0)); /* purecov: inspected */
  return true;                           /* purecov: inspected */
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_connect.cc
Function: thd_init_client_charset
bool thd_init_client_charset(THD *thd, uint cs_number) {
  CHARSET_INFO *cs;
  /*
   Use server character set and collation if
   - opt_character_set_client_handshake is not set
   - client has not specified a character set
   - client character set is the same as the servers
   - client character set doesn't exists in server
  */
  if (!opt_character_set_client_handshake ||
      !(cs = get_charset(cs_number, MYF(0))) ||
      !my_strcasecmp(&my_charset_latin1,
                     global_system_variables.character_set_client->m_coll_name,
                     cs->m_coll_name)) {
    if (!is_supported_parser_charset(
            global_system_variables.character_set_client)) {
      /* Disallow non-supported parser character sets: UCS2, UTF16, UTF32 */
      my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), "character_set_client",
               global_system_variables.character_set_client->csname);
      return true;
    }
    thd->variables.character_set_client =
        global_system_variables.character_set_client;
    thd->variables.collation_connection =
        global_system_variables.collation_connection;
    thd->variables.character_set_results =
        global_system_variables.character_set_results;
  } else {
    if (!is_supported_parser_charset(cs)) {
      /* Disallow non-supported parser character sets: UCS2, UTF16, UTF32 */
      my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), "character_set_client",
               cs->csname);
      return true;
    }
    thd->variables.character_set_results = thd->variables.collation_connection =
        thd->variables.character_set_client = cs;
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_prepare.cc
Function: Protocol_local::store_string
  bool store_string(const char *from, size_t length,
                    const CHARSET_INFO *cs) override;
  bool store_datetime(const MYSQL_TIME &time, uint precision) override;
  bool store_date(const MYSQL_TIME &time) override;
  bool store_time(const MYSQL_TIME &time, uint precision) override;
  bool store_float(float value, uint32 decimals, uint32 zerofill) override;
  bool store_double(double value, uint32 decimals, uint32 zerofill) override;
  bool store_field(const Field *field) override;

  enum enum_protocol_type type() const override { return PROTOCOL_LOCAL; }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/srv_session.cc
Function: Srv_session::execute_command
int Srv_session::execute_command(enum enum_server_command command,
                                 const union COM_DATA *data,
                                 const CHARSET_INFO *client_cs,
                                 const struct st_command_service_cbs *callbacks,
                                 enum cs_text_or_binary text_or_binary,
                                 void *callbacks_context) {
  DBUG_TRACE;

  if (!srv_session_server_is_available()) {
    if (m_err_protocol_ctx.handler)
      m_err_protocol_ctx.handler(m_err_protocol_ctx.handler_context,
                                 ER_SESSION_WAS_KILLED,
                                 ER_DEFAULT(ER_SESSION_WAS_KILLED));
    return 1;
  }

  if (m_thd->killed) {
    if (m_err_protocol_ctx.handler)
      m_err_protocol_ctx.handler(m_err_protocol_ctx.handler_context,
                                 ER_SESSION_WAS_KILLED,
                                 ER_DEFAULT(ER_SESSION_WAS_KILLED));
    return 1;
  }

  assert(m_thd->get_protocol() == &m_protocol_error);

  // RAII:the destructor restores the state
  Srv_session::Session_backup_and_attach backup(this, false);

  if (backup.attach_error) return 1;

  if (client_cs && m_thd->variables.character_set_results != client_cs &&
      thd_init_client_charset(m_thd, client_cs->number))
    return 1;

  /* Switch to different callbacks */
  Protocol_callback client_proto(callbacks, text_or_binary, callbacks_context);

  m_thd->push_protocol(&client_proto);

  mysql_audit_release(m_thd);

  /*
    The server does it for COM_QUERY in dispatch_sql_command() but not for
    COM_INIT_DB, for example
  */
  if (command != COM_QUERY) m_thd->reset_for_next_command();

  /* For per-query performance counters with log_slow_statement */
  struct System_status_var query_start_status;
  m_thd->clear_copy_status_var();
  if (opt_log_slow_extra) {
    m_thd->copy_status_var(&query_start_status);
  }

  mysql_thread_set_secondary_engine(false);

  if (m_state != SRV_SESSION_ASSOCIATED) {
    assert(m_thd->m_statement_psi == nullptr);
    m_thd->m_statement_psi = MYSQL_START_STATEMENT(
        &m_thd->m_statement_state, stmt_info_new_packet.m_key, m_thd->db().str,
        m_thd->db().length, m_thd->charset(), nullptr);
  }
  int ret = dispatch_command(m_thd, data, command);

  m_thd->pop_protocol();
  assert(m_thd->get_protocol() == &m_protocol_error);
  return ret;
}


