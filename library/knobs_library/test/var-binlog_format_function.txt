-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: read_lock_type_for_table
thr_lock_type read_lock_type_for_table(THD *thd,
                                       Query_tables_list *prelocking_ctx,
                                       Table_ref *table_list,
                                       bool routine_modifies_data) {
  /*
    In cases when this function is called for a sub-statement executed in
    prelocked mode we can't rely on OPTION_BIN_LOG flag in THD::options
    bitmap to determine that binary logging is turned on as this bit can
    be cleared before executing sub-statement. So instead we have to look
    at THD::variables::sql_log_bin member.
  */
  bool log_on = mysql_bin_log.is_open() && thd->variables.sql_log_bin;

  /*
    When we do not write to binlog or when we use row based replication,
    it is safe to use a weaker lock.
  */
  if (log_on == false || thd->variables.binlog_format == BINLOG_FORMAT_ROW)
    return TL_READ;

  if ((table_list->table->s->table_category == TABLE_CATEGORY_LOG) ||
      (table_list->table->s->table_category == TABLE_CATEGORY_RPL_INFO) ||
      (table_list->table->s->table_category == TABLE_CATEGORY_GTID) ||
      (table_list->table->s->table_category == TABLE_CATEGORY_PERFORMANCE))
    return TL_READ;

  // SQL queries which updates data need a stronger lock.
  if (is_update_query(prelocking_ctx->sql_command)) return TL_READ_NO_INSERT;

  /*
    table_list is placeholder for prelocking.
    Ignore prelocking_placeholder status for non "LOCK TABLE" statement's
    table_list objects when routine_modifies_data is false.
  */
  if (table_list->prelocking_placeholder &&
      (routine_modifies_data || thd->in_lock_tables))
    return TL_READ_NO_INSERT;

  if (thd->locked_tables_mode > LTM_LOCK_TABLES) return TL_READ_NO_INSERT;

  return TL_READ;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: THD::reset_current_stmt_binlog_format_row
  inline void reset_current_stmt_binlog_format_row() {
    DBUG_TRACE;
    DBUG_PRINT("debug", ("in_sub_stmt: %d, system_thread: %s", in_sub_stmt != 0,
                         show_system_thread(system_thread)));
    if (in_sub_stmt == 0) {
      if (variables.binlog_format == BINLOG_FORMAT_ROW)
        set_current_stmt_binlog_format_row();
      else
        clear_current_stmt_binlog_format_row();
    }
    return;
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: THD::set_current_stmt_binlog_format_row_if_mixed
  inline void set_current_stmt_binlog_format_row_if_mixed() {
    DBUG_TRACE;
    /*
      This should only be called from decide_logging_format.

      @todo Once we have ensured this, uncomment the following
      statement, remove the big comment below that, and remove the
      in_sub_stmt==0 condition from the following 'if'.
    */
    /* assert(in_sub_stmt == 0); */
    /*
      If in a stored/function trigger, the caller should already have done the
      change. We test in_sub_stmt to prevent introducing bugs where people
      wouldn't ensure that, and would switch to row-based mode in the middle
      of executing a stored function/trigger (which is too late, see also
      reset_current_stmt_binlog_format_row()); this condition will make their
      tests fail and so force them to propagate the
      lex->binlog_row_based_if_mixed upwards to the caller.
    */
    if ((variables.binlog_format == BINLOG_FORMAT_MIXED) && (in_sub_stmt == 0))
      set_current_stmt_binlog_format_row();

    return;
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::is_secondary_storage_engine_eligible
bool THD::is_secondary_storage_engine_eligible() const {
  // STATEMENT based replication is enabled and the statement is CTAS or
  // INSERT INTO SELECT
  if (variables.binlog_format == BINLOG_FORMAT_STMT &&
      (lex->sql_command == SQLCOM_CREATE_TABLE ||
       lex->sql_command == SQLCOM_INSERT_SELECT))
    return false;
  // Secondary engines had been disabled in the session
  if (secondary_engine_optimization() ==
      Secondary_engine_optimization::PRIMARY_ONLY)
    return false;
  // The user has explicitly disabled secondary engines
  if (variables.use_secondary_engine == SECONDARY_ENGINE_OFF) return false;
  // LOCK TABLES mode is active
  if (locked_tables_mode != LTM_NONE) return false;
  // Multi-statement transaction mode is active and the statement is not a
  // CREATE TABLE AS SELECT (these are safe due to COMMIT being run before
  // and after the statement is executed)
  if ((in_multi_stmt_transaction_mode() &&
       lex->sql_command != SQLCOM_CREATE_TABLE))
    return false;
  //  It is a sub-statement of a stored procedure
  if (sp_runtime_ctx != nullptr) return false;
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_rm_table
   mysql_rm_table()
   thd      Thread handle
   tables   List of tables to delete
   if_exists    If 1, don't give error if one table doesn't exists

  NOTES
    Will delete all tables that can be deleted and give a compact error
    messages for tables that could not be deleted.
    If a table is in use, we will wait for all users to free the table
    before dropping it

    Wait if global_read_lock (FLUSH TABLES WITH READ LOCK) is set, but
    not if under LOCK TABLES.

  RETURN
    false OK.  In this case ok packet is sent to user
    true  Error

*/

bool mysql_rm_table(THD *thd, Table_ref *tables, bool if_exists,
                    bool drop_temporary) {
  bool error;
  Drop_table_error_handler err_handler;
  Table_ref *table;
  uint have_non_tmp_table = 0;

  DBUG_TRACE;

  // DROP table is not allowed in the XA_IDLE or XA_PREPARED transaction states.
  if (thd->get_transaction()->xid_state()->check_xa_idle_or_prepared(true)) {
    return true;
  }

  /*
    DROP tables need to have their logging format determined if
    in MIXED mode and dropping a TEMP table.
  */
  if (thd->decide_logging_format(tables)) {
    return true;
  }

  /* Disable drop of enabled log tables, must be done before name locking */
  for (table = tables; table; table = table->next_local) {
    if (query_logger.check_if_log_table(table, true)) {
      my_error(ER_BAD_LOG_STATEMENT, MYF(0), "DROP");
      return true;
    }
  }

  if (!drop_temporary) {
    if (!thd->locked_tables_mode) {
      if (lock_table_names(thd, tables, nullptr,
                           thd->variables.lock_wait_timeout, 0) ||
          lock_trigger_names(thd, tables))
        return true;

      DEBUG_SYNC(thd, "mysql_rm_table_after_lock_table_names");

      for (table = tables; table; table = table->next_local) {
        if (is_temporary_table(table)) continue;

        /* Here we are sure that a non-tmp table exists */
        have_non_tmp_table = 1;
      }
    } else {
      bool acquire_backup_lock = false;

      for (table = tables; table; table = table->next_local)
        if (is_temporary_table(table)) {
          /*
            A temporary table.

            Don't try to find a corresponding MDL lock or assign it
            to table->mdl_request.ticket. There can't be metadata
            locks for temporary tables: they are local to the session.

            Later in this function we release the MDL lock only if
            table->mdl_requeset.ticket is not NULL. Thus here we
            ensure that we won't release the metadata lock on the base
            table locked with LOCK TABLES as a side effect of temporary
            table drop.
          */
          assert(table->mdl_request.ticket == nullptr);
        } else {
          /*
            Not a temporary table.

            Since 'tables' list can't contain duplicates (this is ensured
            by parser) it is safe to cache pointer to the TABLE instances
            in its elements.
          */
          table->table = find_table_for_mdl_upgrade(thd, table->db,
                                                    table->table_name, false);
          if (!table->table) return true;
          table->mdl_request.ticket = table->table->mdl_ticket;

          if (wait_while_table_is_used(thd, table->table,
                                       HA_EXTRA_FORCE_REOPEN))
            return true;

          /* Here we are sure that a non-tmp table exists */
          have_non_tmp_table = 1;

          if (!acquire_backup_lock) acquire_backup_lock = true;
        }

      if (acquire_backup_lock &&
          acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
        return true;
    }

    if (rm_table_do_discovery_and_lock_fk_tables(thd, tables)) return true;

    if (lock_check_constraint_names(thd, tables)) return true;
  }

  std::vector<MDL_ticket *> safe_to_release_mdl;

  {
    // This Auto_releaser needs to go out of scope before we start releasing
    // metadata locks below. Otherwise we end up having acquired objects for
    // which we no longer have any locks held.
    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    std::set<handlerton *> post_ddl_htons;
    Foreign_key_parents_invalidator fk_invalidator;
    bool not_used;

    /* mark for close and remove all cached entries */
    thd->push_internal_handler(&err_handler);
    error = mysql_rm_table_no_locks(thd, tables, if_exists, drop_temporary,
                                    false, &not_used, &post_ddl_htons,
                                    &fk_invalidator, &safe_to_release_mdl);
    thd->pop_internal_handler();
  }

  if (!drop_temporary) {
    /*
      Under LOCK TABLES we should release meta-data locks on the tables
      which were dropped.

      Leave LOCK TABLES mode if we managed to drop all tables which were
      locked. Additional check for 'non_temp_tables_count' is to avoid
      leaving LOCK TABLES mode if we have dropped only temporary tables.
    */
    if (thd->locked_tables_mode) {
      /*
        First we need to reopen tables which data-dictionary entries were
        updated/invalidated (and thus they were closed) due to fact that
        they participate in the same FKs as tables which were dropped.
      */
      if (thd->locked_tables_list.reopen_tables(thd)) error = true;

      if (thd->lock && thd->lock->table_count == 0 && have_non_tmp_table > 0) {
        thd->mdl_context.release_statement_locks();
        thd->locked_tables_list.unlock_locked_tables(thd);
      } else {
        for (MDL_ticket *mdl_ticket : safe_to_release_mdl) {
          /*
            Under LOCK TABLES we may have several instances of table open
            and locked and therefore have to remove several metadata lock
            requests associated with them.
          */
          thd->mdl_context.release_all_locks_for_name(mdl_ticket);
        }
      }
    }
  }

  if (error) return true;

  if (thd->lex->drop_temporary && thd->in_multi_stmt_transaction_mode()) {
    /*
      When autocommit is disabled, dropping temporary table sets this flag
      to start transaction in any case (regardless of binlog=on/off,
      binlog format and transactional/non-transactional engine) to make
      behavior consistent.
    */
    thd->server_status |= SERVER_STATUS_IN_TRANS;
  }

  if (thd->variables.binlog_format == BINLOG_FORMAT_STMT &&
      thd->lex->drop_temporary && (thd->in_sub_stmt & SUB_STMT_FUNCTION) &&
      thd->binlog_evt_union.do_union) {
    /*
      This does not write the query into binary log, it just sets
      thd->binlog_evt_union.unioned_events to true for writing
      its top function call to the binary log on function exit
      in mixed mode and statement mode. So this does not cause
      any error.
    */
    write_bin_log(thd, true, thd->query().str, thd->query().length, true);
  }

  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_alter_table
bool mysql_alter_table(THD *thd, const char *new_db, const char *new_name,
                       HA_CREATE_INFO *create_info, Table_ref *table_list,
                       Alter_info *alter_info) {
  DBUG_TRACE;

  /*
    Check if we attempt to alter mysql.slow_log or
    mysql.general_log table and return an error if
    it is the case.
    TODO: this design is obsolete and will be removed.
  */
  enum_log_table_type table_kind =
      query_logger.check_if_log_table(table_list, false);

  if (table_kind != QUERY_LOG_NONE) {
    /* Disable alter of enabled query log tables */
    if (query_logger.is_log_table_enabled(table_kind)) {
      my_error(ER_BAD_LOG_STATEMENT, MYF(0), "ALTER");
      return true;
    }

    /* Disable alter of log tables to unsupported engine */
    if ((create_info->used_fields & HA_CREATE_USED_ENGINE) &&
        (!create_info->db_type || /* unknown engine */
         !(create_info->db_type->flags & HTON_SUPPORT_LOG_TABLES))) {
      my_error(ER_UNSUPORTED_LOG_ENGINE, MYF(0));
      return true;
    }

    if (alter_info->flags & Alter_info::ALTER_PARTITION) {
      my_error(ER_WRONG_USAGE, MYF(0), "PARTITION", "log table");
      return true;
    }
  }

  // Reject request to ALTER TABLE with START TRANSACTION.
  if (create_info->m_transactional_ddl) {
    my_error(ER_NOT_ALLOWED_WITH_START_TRANSACTION, MYF(0),
             "with ALTER TABLE command.");
    return true;
  }

  if (alter_info->with_validation != Alter_info::ALTER_VALIDATION_DEFAULT &&
      !(alter_info->flags &
        (Alter_info::ALTER_ADD_COLUMN | Alter_info::ALTER_CHANGE_COLUMN))) {
    my_error(ER_WRONG_USAGE, MYF(0), "ALTER", "WITH VALIDATION");
    return true;
  }

  if ((alter_info->flags & Alter_info::ALTER_ADD_COLUMN) ==
      Alter_info::ALTER_ADD_COLUMN) {
    for (auto create_field : alter_info->create_list) {
      if (create_field.m_default_val_expr) {
        // ALTER TABLE .. DEFAULT (NDF function) should be rejected for mixed or
        // row binlog_format. For statement binlog_format it should be allowed
        // to continue and warning should be logged and/or pushed to the client
        if ((thd->variables.option_bits & OPTION_BIN_LOG) &&
            thd->lex->is_stmt_unsafe(
                Query_tables_list::BINLOG_STMT_UNSAFE_SYSTEM_FUNCTION)) {
          if (thd->variables.binlog_format == BINLOG_FORMAT_STMT) {
            LogErr(WARNING_LEVEL, ER_SERVER_BINLOG_UNSAFE_SYSTEM_FUNCTION,
                   "ALTER TABLE .. DEFAULT (NDF function)");
            push_warning(thd, Sql_condition::SL_WARNING,
                         ER_BINLOG_UNSAFE_SYSTEM_FUNCTION,
                         ER_THD(thd, ER_BINLOG_UNSAFE_SYSTEM_FUNCTION));
            break;
          } else {
            my_error(ER_BINLOG_UNSAFE_SYSTEM_FUNCTION, MYF(0));
            return true;
          }
        }
      }
    }
  }

  // LOCK clause doesn't make any sense for ALGORITHM=INSTANT.
  if (alter_info->requested_algorithm ==
          Alter_info::ALTER_TABLE_ALGORITHM_INSTANT &&
      alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_DEFAULT) {
    my_error(ER_WRONG_USAGE, MYF(0), "ALGORITHM=INSTANT",
             "LOCK=NONE/SHARED/EXCLUSIVE");
    return true;
  }

  THD_STAGE_INFO(thd, stage_init);

  // Reject invalid usage of the 'mysql' tablespace.
  if (dd::invalid_tablespace_usage(thd, table_list->db, table_list->table_name,
                                   create_info))
    return true;

  /*
    Assign target tablespace name to enable locking in lock_table_names().
    Reject invalid name lengths. Names will be validated after the table is
    opened and the SE (needed for SE specific validation) is identified.
  */
  if (create_info->tablespace) {
    if (validate_tablespace_name_length(create_info->tablespace)) return true;

    if (lex_string_strmake(thd->mem_root, &table_list->target_tablespace_name,
                           create_info->tablespace,
                           strlen(create_info->tablespace))) {
      my_error(ER_OUT_OF_RESOURCES, MYF(ME_FATALERROR));
      return true;
    }
  }

  /* Validate that AUTOEXTEND_SIZE option is not specified for
  temporary tables */
  if (is_temporary_table(table_list)) {
    if (create_info->m_implicit_tablespace_autoextend_size > 0) {
      my_error(ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE, MYF(0), "temporary");
      return true;
    }
  }

  /*
    Reject invalid tablespace name lengths specified for partitions.
    Names will be validated after the table has been opened.
  */
  if (validate_partition_tablespace_name_lengths(thd->lex->part_info))
    return true;

  /*
    Assign the partition info, so that the locks on tablespaces
    assigned for any new partitions added would be acquired during
    open_table.
  */
  thd->work_part_info = thd->lex->part_info;

  /*
    Code below can handle only base tables so ensure that we won't open a view.
    Note that RENAME TABLE the only ALTER clause which is supported for views
    has been already processed.
  */
  table_list->required_type = dd::enum_table_type::BASE_TABLE;

  /*
    If we are about to ALTER non-temporary table we need to get permission
    from/notify interested storage engines.
  */
  Table_ddl_hton_notification_guard notification_guard{
      thd, &table_list->mdl_request.key, HA_ALTER_DDL};

  if (!is_temporary_table(table_list) && notification_guard.notify())
    return true;

  Alter_table_prelocking_strategy alter_prelocking_strategy;

  DEBUG_SYNC(thd, "alter_table_before_open_tables");
  uint tables_opened;
  bool error = open_tables(thd, &table_list, &tables_opened, 0,
                           &alter_prelocking_strategy);

  DEBUG_SYNC(thd, "alter_opened_table");

  if (error) return true;

  // If we are removing a functional index, add any related hidden generated
  // columns to the drop list as well.
  if (handle_drop_functional_index(thd, alter_info, table_list)) {
    return true;
  }

  // If we are renaming a functional index, rename any related hidden generated
  // columns as well.
  if (alter_info->flags & Alter_info::ALTER_RENAME_INDEX) {
    if (handle_rename_functional_index(thd, alter_info, table_list)) {
      return true; /* purecov: deadcode */
    }
  }

  // Check tablespace name validity for the relevant engine.
  {
    // If there is no target handlerton, use the current.
    const handlerton *target_handlerton = create_info->db_type;
    if (target_handlerton == nullptr)
      target_handlerton = table_list->table->file->ht;

    /*
      Reject invalid tablespace names for the relevant engine, if the ALTER
      statement changes either tablespace or engine. We do this after the table
      has been opened because we need the handlerton and tablespace information.
      No need to validate if neither engine nor tablespace is changed, then the
      validation was done when the table was created.
    */
    if (create_info->tablespace || create_info->db_type) {
      // If there is no target table level tablespace, use the current.
      const char *target_tablespace = create_info->tablespace;
      if (target_tablespace == nullptr)
        target_tablespace = table_list->table->s->tablespace;

      // Check the tablespace/engine combination.
      assert(target_handlerton);
      if (target_tablespace != nullptr &&
          validate_tablespace_name(TS_CMD_NOT_DEFINED, target_tablespace,
                                   target_handlerton))
        return true;
    }

    // Reject invalid tablespace names specified for partitions.
    if (validate_partition_tablespace_names(thd->lex->part_info,
                                            target_handlerton))
      return true;
  }

  if (validate_secondary_engine_option(thd, *alter_info, *create_info,
                                       *table_list->table))
    return true;

  if (lock_trigger_names(thd, table_list)) return true;

  /*
    If we're in LOCK TABLE mode, we must lock the target tablespace name
    as well as the currently used tablesapces (since these may have been
    introduced by a previous ALTER while already in LOCK TABLE mode).
  */
  if (thd->locked_tables_mode &&
      get_and_lock_tablespace_names(thd, table_list, nullptr,
                                    thd->variables.lock_wait_timeout, MYF(0))) {
    return true;
  }

  if (table_list->table->s->db_type() != create_info->db_type &&
      (alter_info->flags & Alter_info::ALTER_OPTIONS) &&
      (create_info->used_fields & HA_CREATE_USED_ENGINE)) {
    handlerton *actual_hton = get_viable_handlerton_for_alter(
        thd, *create_info, table_list->table->s->db_type());
    if (actual_hton == nullptr) return true;

    create_info->db_type = actual_hton;
  }

  const handlerton *hton = create_info->db_type;
  if (hton == nullptr) {
    hton = table_list->table->s->db_type();
  }
  assert(hton != nullptr);
  if ((alter_info->flags & Alter_info::ANY_ENGINE_ATTRIBUTE) != 0 &&
      ((hton->flags & HTON_SUPPORTS_ENGINE_ATTRIBUTE) == 0 &&
       DBUG_EVALUATE_IF("simulate_engine_attribute_support", false, true))) {
    my_error(ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED, MYF(0),
             ha_resolve_storage_engine_name(hton));
    return true;
  }

  TABLE *table = table_list->table;
  table->use_all_columns();
  MDL_ticket *mdl_ticket = table->mdl_ticket;

  /*
    Prohibit changing of the UNION list of a non-temporary MERGE table
    under LOCK tables. It would be quite difficult to reuse a shrunk
    set of tables from the old table or to open a new TABLE object for
    an extended list and verify that they belong to locked tables.
  */
  if ((thd->locked_tables_mode == LTM_LOCK_TABLES ||
       thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) &&
      (create_info->used_fields & HA_CREATE_USED_UNION) &&
      (table->s->tmp_table == NO_TMP_TABLE)) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  Alter_table_ctx alter_ctx(thd, table_list, tables_opened, new_db, new_name);

  /*
    Acquire and keep schema locks until commit time, so the DD layer can
    safely assert that we have proper MDL on objects stored in the DD.
  */
  dd::Schema_MDL_locker mdl_locker_1(thd), mdl_locker_2(thd);
  const dd::Schema *schema = nullptr;
  const dd::Schema *new_schema = nullptr;
  const dd::Table *old_table_def = nullptr;
  /*
    This releaser allows us to keep uncommitted DD objects cached
    in the Dictionary_client until commit time.
  */
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  if (mdl_locker_1.ensure_locked(alter_ctx.db) ||
      mdl_locker_2.ensure_locked(alter_ctx.new_db) ||
      thd->dd_client()->acquire(alter_ctx.db, &schema) ||
      thd->dd_client()->acquire(alter_ctx.new_db, &new_schema))
    return true;

  if ((table->s->tmp_table == NO_TMP_TABLE) &&
      thd->dd_client()->acquire(alter_ctx.db, alter_ctx.table_name,
                                &old_table_def))
    return true;

  // If this is a temporary table, the schema might not exist even
  // if we have successfully opened the table
  if (schema == nullptr) {
    assert(table->s->tmp_table);
    my_error(ER_BAD_DB_ERROR, MYF(0), alter_ctx.db);
    return true;
  }

  assert((table->s->tmp_table != NO_TMP_TABLE) || old_table_def != nullptr);

  if (new_schema == nullptr) {
    my_error(ER_BAD_DB_ERROR, MYF(0), alter_ctx.new_db);
    return true;
  }

  /*
    Add old and new (if any) databases to the list of accessed databases
    for this statement. Needed for MTS.
  */
  thd->add_to_binlog_accessed_dbs(alter_ctx.db);
  if (alter_ctx.is_database_changed())
    thd->add_to_binlog_accessed_dbs(alter_ctx.new_db);

  // Ensure that triggers are in the same schema as their subject table.
  if (alter_ctx.is_database_changed() && old_table_def != nullptr &&
      old_table_def->has_trigger()) {
    my_error(ER_TRG_IN_WRONG_SCHEMA, MYF(0));
    return true;
  }

  /* Check that we are not trying to rename to an existing table */
  if (alter_ctx.is_table_renamed()) {
    if (table->s->tmp_table != NO_TMP_TABLE) {
      if (find_temporary_table(thd, alter_ctx.new_db, alter_ctx.new_name)) {
        my_error(ER_TABLE_EXISTS_ERROR, MYF(0), alter_ctx.new_alias);
        return true;
      }
    } else {
      MDL_request_list mdl_requests;

      mdl_requests.push_front(&alter_ctx.target_mdl_request);
      /*
        If we are moving the table to a different database, we also
        need IX lock on the database name so that the target database
        is protected by MDL while the table is moved.
      */
      if (alter_ctx.is_database_changed())
        mdl_requests.push_front(&alter_ctx.target_db_mdl_request);

      /*
        Global intention exclusive lock must have been already acquired when
        table to be altered was open, so there is no need to do it here.
      */
      assert(thd->mdl_context.owns_equal_or_stronger_lock(
          MDL_key::GLOBAL, "", "", MDL_INTENTION_EXCLUSIVE));

      if (thd->mdl_context.acquire_locks(&mdl_requests,
                                         thd->variables.lock_wait_timeout))
        return true;

      DEBUG_SYNC(thd, "locked_table_name");
      /*
        Table maybe does not exist, but we got an exclusive lock
        on the name, now we can safely try to find out for sure.
      */
      const dd::Abstract_table *at = nullptr;
      if (thd->dd_client()->acquire(alter_ctx.new_db, alter_ctx.new_name, &at))
        return true;

      if (at != nullptr) {
        /* Table will be closed in do_command() */
        my_error(ER_TABLE_EXISTS_ERROR, MYF(0), alter_ctx.new_alias);
        return true;
      }
    }
  }

  if (!create_info->db_type) {
    if (table->part_info && create_info->used_fields & HA_CREATE_USED_ENGINE) {
      /*
        This case happens when the user specified
        ENGINE = x where x is a non-existing storage engine
        We set create_info->db_type to default_engine_type
        to ensure we don't change underlying engine type
        due to a erroneously given engine name.
      */
      create_info->db_type = table->part_info->default_engine_type;
    } else
      create_info->db_type = table->s->db_type();
  }

  if (check_engine(alter_ctx.new_db, alter_ctx.new_name, create_info))
    return true;

  /*
    Do not allow change of storage engine if table participates in a foreign
    key. Even in cases when both source and target storage engines support
    foreign keys the fine details of what is supported might differ.
  */
  if (create_info->db_type != table->s->db_type() && old_table_def != nullptr &&
      (old_table_def->foreign_keys().size() ||
       old_table_def->foreign_key_parents().size())) {
    my_error(ER_FK_CANNOT_CHANGE_ENGINE, MYF(0));
    return true;
  }

  /*
   If foreign key is added then check permission to access parent table.

   In function "check_fk_parent_table_access", create_info->db_type is used
   to identify whether engine supports FK constraint or not. Since
   create_info->db_type is set here, check to parent table access is delayed
   till this point for the alter operation.
  */
  if ((alter_info->flags & Alter_info::ADD_FOREIGN_KEY) &&
      check_fk_parent_table_access(thd, create_info, alter_info))
    return true;

  Foreign_key_parents_invalidator fk_invalidator;

  if (table->s->tmp_table == NO_TMP_TABLE) {
    MDL_request_list mdl_requests;

    if (collect_fk_parents_for_new_fks(
            thd, table_list->db, table_list->table_name, alter_info,
            MDL_SHARED_UPGRADABLE, nullptr, &mdl_requests, nullptr))
      return true;

    /*
      Acquire SU locks on parent and child tables so we can access
      their definition while checking if this ALTER TABLE will break
      any FKs involving them.

      TODO: Refine set of ALTER TABLE commands for which we do this.
            This is obviously necessary for ADD/DROP KEY and COLUMN
            modifications. But are there any other operations which
            might affect indexes somehow?
    */
    if (!is_simple_rename_or_index_change(alter_info)) {
      if (collect_fk_parents_for_all_fks(thd, old_table_def, nullptr,
                                         MDL_SHARED_UPGRADABLE, &mdl_requests,
                                         nullptr))
        return true;

      if (create_info->db_type != table->s->db_type()) {
        /*
          By changing table's storage engine we might be introducing parent
          table for previously orphan foreign keys in the new SE. We need
          to lock child tables of such orphan foreign keys. OTOH it is safe
          to assume that if SE is changed table can't be parent in any
          foreign keys in old SE.

          Note that here and in other similar places we assume that ALTER
          TABLE which combines change of SE and renaming of table is executed
          by changing SE first and then performing rename (this is closer to
          ALTER TABLE real implementation). Because of this such ALTER TABLEs
          need to pick up orphan foreign keys associated with old table names
          as well. Thus we use old table name to get list of orphans.
        */
        assert(old_table_def->foreign_key_parents().size() == 0);

        if (collect_fk_children(thd, table_list->db, table_list->table_name,
                                create_info->db_type, MDL_SHARED_UPGRADABLE,
                                &mdl_requests))
          return true;
      } else {
        if (collect_fk_children(thd, old_table_def, MDL_SHARED_UPGRADABLE,
                                &mdl_requests))
          return true;
      }

      if (alter_ctx.is_table_renamed() &&
          collect_fk_children(thd, alter_ctx.new_db, alter_ctx.new_alias,
                              create_info->db_type, MDL_SHARED_UPGRADABLE,
                              &mdl_requests))
        return true;
    }

    /*
      Lock names of foreign keys to be dropped.

      Note that we can't lock names of foreign keys to be added yet
      because database in which they will be created depends on ALTER
      TABLE algorithm we are going to choose later.
    */
    if (collect_fk_names_for_dropped_fks(thd, table_list->db, alter_info,
                                         old_table_def, &mdl_requests))
      return true;

    /*
      Under LOCK TABLES all parent tables must be locked at least in READ
      mode. Otherwise, our ALTER TABLE will leave after itself child table
      locked for WRITE, without corresponding parent tables locked and thus
      without ability to perform FK checks when child table is modified.
    */
    if (thd->locked_tables_mode == LTM_LOCK_TABLES ||
        thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) {
      MDL_request_list::Iterator it(mdl_requests);
      MDL_request *mdl_request;

      while ((mdl_request = it++) != nullptr) {
        if (mdl_request->key.mdl_namespace() != MDL_key::TABLE) continue;

        if (!thd->mdl_context.owns_equal_or_stronger_lock(
                MDL_key::TABLE, mdl_request->key.db_name(),
                mdl_request->key.name(), MDL_SHARED_READ_ONLY)) {
          my_error(ER_TABLE_NOT_LOCKED, MYF(0), mdl_request->key.name());
          return true;
        }
      }
    }

    if (!mdl_requests.is_empty() &&
        thd->mdl_context.acquire_locks(&mdl_requests,
                                       thd->variables.lock_wait_timeout))
      return true;

    DEBUG_SYNC(thd, "alter_table_after_mdl_lock_fk");

    /*
      If we are executing ALTER TABLE RENAME under LOCK TABLES we also need
      to check that all previously orphan tables which reference new table
      name through foreign keys are locked for write. Otherwise this ALTER
      will leave after itself parent table locked for WRITE without child
      tables locked for WRITE. This will break FK LOCK TABLES invariants if
      some of previously orphan FKs have referential actions which update
      child table.

      The same should be done when we are going to add parent table to
      previously orphan foreign keys by changing table storage engine.

      In theory, we can reduce chance of MDL deadlocks by also checking at
      this stage that all child and parent tables for FKs in which this
      table participates are locked for WRITE (as we will have to acquire
      to exclusive MDLs on these tables later). But this is, probably, too
      severe restriction since many 3rd-party online ALTER tools use ALTER
      TABLE RENAME under LOCK TABLES and are unaware of it.
    */
    if (thd->locked_tables_mode == LTM_LOCK_TABLES ||
        thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) {
      MDL_request_list orphans_mdl_requests;

      if (create_info->db_type != table->s->db_type()) {
        assert(old_table_def->foreign_key_parents().size() == 0);
        if (collect_fk_children(thd, table_list->db, table_list->table_name,
                                create_info->db_type, MDL_EXCLUSIVE,
                                &orphans_mdl_requests))
          return true;
      }
      if (alter_ctx.is_table_renamed() &&
          collect_fk_children(thd, alter_ctx.new_db, alter_ctx.new_alias,
                              create_info->db_type, MDL_EXCLUSIVE,
                              &orphans_mdl_requests))
        return true;

      if (!orphans_mdl_requests.is_empty()) {
        MDL_request_list::Iterator it(orphans_mdl_requests);
        MDL_request *mdl_request;

        while ((mdl_request = it++) != nullptr) {
          if (mdl_request->key.mdl_namespace() != MDL_key::TABLE) continue;

          if (!thd->mdl_context.owns_equal_or_stronger_lock(
                  MDL_key::TABLE, mdl_request->key.db_name(),
                  mdl_request->key.name(), MDL_SHARED_NO_READ_WRITE)) {
            my_error(ER_TABLE_NOT_LOCKED_FOR_WRITE, MYF(0),
                     mdl_request->key.name());
            return true;
          }
        }
      }
    }
  }

  /*
   If this is an ALTER TABLE and no explicit row type specified reuse
   the table's row type.
   Note : this is the same as if the row type was specified explicitly.
  */
  if (create_info->row_type == ROW_TYPE_NOT_USED) {
    /* ALTER TABLE without explicit row type */
    create_info->row_type = table->s->row_type;
  } else {
    /* ALTER TABLE with specific row type */
    create_info->used_fields |= HA_CREATE_USED_ROW_FORMAT;
  }

  DBUG_PRINT("info", ("old type: %s  new type: %s",
                      ha_resolve_storage_engine_name(table->s->db_type()),
                      ha_resolve_storage_engine_name(create_info->db_type)));
  if (ha_check_storage_engine_flag(table->s->db_type(),
                                   HTON_ALTER_NOT_SUPPORTED) ||
      ha_check_storage_engine_flag(create_info->db_type,
                                   HTON_ALTER_NOT_SUPPORTED)) {
    DBUG_PRINT("info", ("doesn't support alter"));
    my_error(ER_ILLEGAL_HA, MYF(0), table_list->table_name);
    return true;
  }

  THD_STAGE_INFO(thd, stage_setup);

  if (is_simple_rename_or_index_change(alter_info) && !table->s->tmp_table) {
    // This requires X-lock, no other lock levels supported.
    if (alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_DEFAULT &&
        alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "LOCK=NONE/SHARED",
               "LOCK=EXCLUSIVE");
      return true;
    }
    return simple_rename_or_index_change(thd, *new_schema, table_list,
                                         alter_info->keys_onoff, &alter_ctx);
  }

  /* We have to do full alter table. */
  bool partition_changed = false;
  partition_info *new_part_info = nullptr;
  {
    if (prep_alter_part_table(thd, table, alter_info, create_info, &alter_ctx,
                              &partition_changed, &new_part_info)) {
      return true;
    }
  }

  /*
    Store all columns that are going to be dropped, since we need this list
    when removing column statistics later. The reason we need to store it here,
    is that 'mysql_prepare_alter_table' may remove some of the columns from
    the drop_list.
  */
  histograms::columns_set columns;
  for (const auto column : alter_info->drop_list) {
    if (column->type == Alter_drop::COLUMN) columns.emplace(column->name);
  }
  const Alter_column *alter = nullptr;
  uint i = 0;
  while (i < alter_info->alter_list.size()) {
    alter = alter_info->alter_list[i];
    if (alter->change_type() == Alter_column::Type::RENAME_COLUMN)
      columns.emplace(alter->name);
    i++;
  }

  Create_field *create_field;
  List_iterator<Create_field> list_it(alter_info->create_list);
  while ((create_field = list_it++)) {
    if (create_field->change != nullptr) columns.emplace(create_field->change);
  }

  /*
    Type of a constraint marked for DROP with DROP CONSTRAINT clause is unknown.
    Resolve type of a constraint by name.
  */
  Drop_constraint_type_resolver drop_constraint_type_resolver(alter_info);
  if (drop_constraint_type_resolver.is_type_resolution_needed() &&
      (drop_constraint_type_resolver.resolve_constraints_type(thd, table,
                                                              old_table_def)))
    return true;

  /*
    Type of a constraint marked for ALTER with ALTER CONSTRAINT clause is
    unknown. Resolve type of a constraint by name.
  */
  Enforce_constraint_type_resolver enforce_constraint_type_resolver(alter_info);
  if (enforce_constraint_type_resolver.is_type_resolution_needed() &&
      (enforce_constraint_type_resolver.resolve_constraints_type(
          thd, table, old_table_def)))
    return true;

  // Prepare check constraints for alter table operation.
  if (prepare_check_constraints_for_alter(thd, table, alter_info, &alter_ctx))
    return true;

  if (mysql_prepare_alter_table(thd, old_table_def, table, create_info,
                                alter_info, &alter_ctx)) {
    return true;
  }

  // Check restrictions on ALTER TABLE operations that affects GIPK and PK.
  if (check_primary_key_alter_restrictions(thd, create_info->db_type,
                                           alter_info, table))
    return true;

  /*
    Check if we are changing the SRID specification on a geometry column that
    has a spatial index. If that is the case, reject the change since allowing
    geometries with different SRIDs in a spatial index will make the index
    useless.
  */
  if (!is_alter_geometry_column_valid(alter_info)) return true;

  if (set_table_default_charset(thd, create_info, *schema)) return true;

  /*
    Use copy algorithm if:
    - old_alter_table system variable is set without in-place requested using
      the ALGORITHM clause.
    - Or if in-place is impossible for given operation.
    - Changes to partitioning needs to be handled using table copying
      algorithm unless the engine supports partitioning changes using
      in-place API (because it supports auto-partitioning or simply
      can do partitioning changes using in-place using mark-up in
      partition_info object).
  */
  if ((thd->variables.old_alter_table &&
       alter_info->requested_algorithm !=
           Alter_info::ALTER_TABLE_ALGORITHM_INPLACE &&
       alter_info->requested_algorithm !=
           Alter_info::ALTER_TABLE_ALGORITHM_INSTANT) ||
      is_inplace_alter_impossible(table, create_info, alter_info) ||
      (partition_changed &&
       !(table->s->db_type()->partition_flags() & HA_USE_AUTO_PARTITION) &&
       !new_part_info)) {
    if (alter_info->requested_algorithm ==
        Alter_info::ALTER_TABLE_ALGORITHM_INPLACE) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "ALGORITHM=INPLACE",
               "ALGORITHM=COPY");
      return true;
    }
    if (alter_info->requested_algorithm ==
        Alter_info::ALTER_TABLE_ALGORITHM_INSTANT) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "ALGORITHM=INSTANT",
               "ALGORITHM=COPY");
      return true;
    }
    alter_info->requested_algorithm = Alter_info::ALTER_TABLE_ALGORITHM_COPY;
  }

  /*
    If 'avoid_temporal_upgrade' mode is not enabled, then the
    pre MySQL 5.6.4 old temporal types if present is upgraded to the
    current format.
  */

  mysql_mutex_lock(&LOCK_global_system_variables);
  bool check_temporal_upgrade = !avoid_temporal_upgrade;
  mysql_mutex_unlock(&LOCK_global_system_variables);

  if (check_temporal_upgrade) {
    if (upgrade_old_temporal_types(thd, alter_info)) return true;
  }

  /*
    ALTER TABLE ... ENGINE to the same engine is a common way to
    request table rebuild. Set ALTER_RECREATE flag to force table
    rebuild.
  */
  if (create_info->db_type == table->s->db_type() &&
      create_info->used_fields & HA_CREATE_USED_ENGINE)
    alter_info->flags |= Alter_info::ALTER_RECREATE;

  /*
    If the old table had partitions and we are doing ALTER TABLE ...
    engine= <new_engine>, the new table must preserve the original
    partitioning. This means that the new engine is still the
    partitioning engine, not the engine specified in the parser.
    This is discovered in prep_alter_part_table, which in such case
    updates create_info->db_type.
    It's therefore important that the assignment below is done
    after prep_alter_part_table.
  */
  handlerton *new_db_type = create_info->db_type;
  handlerton *old_db_type = table->s->db_type();
  TABLE *new_table = nullptr;
  ha_rows copied = 0, deleted = 0;

  /*
    Handling of symlinked tables:
    If no rename:
      Create new data file and index file on the same disk as the
      old data and index files.
      Copy data.
      Rename new data file over old data file and new index file over
      old index file.
      Symlinks are not changed.

   If rename:
      Create new data file and index file on the same disk as the
      old data and index files.  Create also symlinks to point at
      the new tables.
      Copy data.
      At end, rename intermediate tables, and symlinks to intermediate
      table, to final table name.
      Remove old table and old symlinks

    If rename is made to another database:
      Create new tables in new database.
      Copy data.
      Remove old table and symlinks.
  */
  char index_file[FN_REFLEN], data_file[FN_REFLEN];

  if (!alter_ctx.is_database_changed()) {
    if (create_info->index_file_name) {
      /* Fix index_file_name to have 'tmp_name' as basename */
      my_stpcpy(index_file, alter_ctx.tmp_name);
      create_info->index_file_name =
          fn_same(index_file, create_info->index_file_name, 1);
    }
    if (create_info->data_file_name) {
      /* Fix data_file_name to have 'tmp_name' as basename */
      my_stpcpy(data_file, alter_ctx.tmp_name);
      create_info->data_file_name =
          fn_same(data_file, create_info->data_file_name, 1);
    }
  } else {
    /* Ignore symlink if db is changed. */
    create_info->data_file_name = create_info->index_file_name = nullptr;
  }

  DEBUG_SYNC(thd, "alter_table_before_create_table_no_lock");
  DBUG_EXECUTE_IF("sleep_before_create_table_no_lock", my_sleep(100000););
  /*
    Promote first timestamp column, when explicit_defaults_for_timestamp
    is not set
  */
  if (!thd->variables.explicit_defaults_for_timestamp)
    promote_first_timestamp_column(&alter_info->create_list);

  /*
    Create .FRM for new version of table with a temporary name.
    We don't log the statement, it will be logged later.

    Keep information about keys in newly created table as it
    will be used later to construct Alter_inplace_info object
    and by fill_alter_inplace_info() call.
  */
  KEY *key_info;
  uint key_count;
  FOREIGN_KEY *fk_key_info = nullptr;
  uint fk_key_count = 0;

  Alter_info::enum_enable_or_disable keys_onoff =
      ((alter_info->keys_onoff == Alter_info::LEAVE_AS_IS &&
        table->file->indexes_are_disabled())
           ? Alter_info::DISABLE
           : alter_info->keys_onoff);

  /*
    Take the X metadata lock on temporary name used for new version of
    the table. This ensures that concurrent I_S queries won't try to open it.
  */

  MDL_request tmp_name_mdl_request;
  bool is_tmp_table = (table->s->tmp_table != NO_TMP_TABLE);

  // Avoid these tables to be visible by I_S/SHOW queries.
  create_info->m_hidden = !is_tmp_table;

  if (!is_tmp_table) {
    MDL_REQUEST_INIT(&tmp_name_mdl_request, MDL_key::TABLE, alter_ctx.new_db,
                     alter_ctx.tmp_name, MDL_EXCLUSIVE, MDL_STATEMENT);
    if (thd->mdl_context.acquire_lock(&tmp_name_mdl_request,
                                      thd->variables.lock_wait_timeout))
      return true;
  }

  // Stop if we have invalid encryption clause.
  if (!is_tmp_table && validate_table_encryption(thd, create_info)) return true;

  /*
    For temporary tables or tables in SEs supporting atomic DDL dd::Table
    object describing new version of table. This object will be created in
    memory in create_table_impl() and will not be put into the on-disk DD
    and DD Object Cache.

    We become responsible for destroying this dd::Table object (for
    temporary tables until we pass its ownership to the TABLE_SHARE).
  */
  std::unique_ptr<dd::Table> non_dd_table_def;

  {
    Disable_binlog_guard binlog_guard(thd);
    /* Prevent intermediate commits to invoke commit order */
    Implicit_substatement_state_guard substatement_guard(
        thd, enum_implicit_substatement_guard_mode ::
                 DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);
    error = create_table_impl(
        thd, *new_schema, alter_ctx.new_db, alter_ctx.tmp_name,
        alter_ctx.table_name, alter_ctx.get_tmp_path(), create_info, alter_info,
        true, 0, true, true,
        /*
          If target SE supports atomic DDL do not store
          new table version in on-disk DD.
          It is not required to rollback statement in
          case of error and allows to keep correct names
          for pre-existing foreign keys in the dd::Table
          object for new table version.
         */
        (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL), nullptr, &key_info,
        &key_count, keys_onoff, &fk_key_info, &fk_key_count, alter_ctx.fk_info,
        alter_ctx.fk_count, old_table_def,
        alter_ctx.fk_max_generated_name_number, &non_dd_table_def, nullptr);
  }

  if (error) {
    /*
      Play it safe, rollback possible changes to the data-dictionary,
      so failed mysql_alter_table()/mysql_recreate_table() do not
      require rollback in the caller. Also do full rollback in unlikely
      case we have THD::transaction_rollback_request.
    */
    trans_rollback_stmt(thd);
    trans_rollback(thd);
    return true;
  }

  /*
    Atomic replacement of the table is possible only if both old and new
    storage engines support DDL atomicity.
  */
  bool atomic_replace = (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
                        (old_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL);

  /* Remember that we have not created table in storage engine yet. */
  bool no_ha_table = true;

  /* Indicates special case when we do ALTER TABLE which is really no-op. */
  bool is_noop = false;

  /*
    Indicates special case involving non-atomic ALTER TABLE which adds
    foreign keys and then fails at the late stage. Such ALTER TABLE still
    requires FK parent invalidation even despite of error.
  */
  bool invalidate_fk_parents_on_error = false;

  dd::Encrypt_result old_er{false, false};
  dd::Encrypt_result new_er{false, false};

  /*
    If we are ALTERing non-temporary table in SE not supporting atomic DDL
    we don't have dd::Table object describing new version of table yet.
    Retrieve it now.
  */
  dd::Table *table_def = non_dd_table_def.get();
  if (!table_def) {
    if (thd->dd_client()->acquire_for_modification(
            alter_ctx.new_db, alter_ctx.tmp_name, &table_def))
      goto err_new_table_cleanup;

    set_check_constraints_alter_mode(table_def, alter_info);

    assert(table_def);
  }

  if (!is_tmp_table) {
    // Check for usage of prefix key index in PARTITION BY KEY() function.
    dd::warn_on_deprecated_prefix_key_partition(
        thd, alter_ctx.db, alter_ctx.table_name, table_def, false);
  }

  if (remove_secondary_engine(thd, *table_list, *create_info, old_table_def))
    goto err_new_table_cleanup;

  // If we are changing the tablespace or the table encryption type.
  if (old_table_def &&
      (create_info->used_fields & HA_CREATE_USED_TABLESPACE ||
       create_info->used_fields & HA_CREATE_USED_ENCRYPT ||
       create_info->used_fields & HA_CREATE_USED_AUTOEXTEND_SIZE ||
       alter_ctx.is_database_changed())) {
    bool source_is_general_tablespace{false};
    bool source_encrytion_type{false};
    bool destination_is_general_tablespace{false};
    bool destination_encrytion_type{false};

    // Determine source tablespace type and encryption type.
    old_er = dd::is_tablespace_encrypted(thd, *old_table_def,
                                         &source_is_general_tablespace);
    if (old_er.error) {
      goto err_new_table_cleanup;
    }
    source_encrytion_type = old_er.value;
    if (!source_is_general_tablespace &&
        old_table_def->options().exists("encrypt_type")) {
      dd::String_type et;
      (void)old_table_def->options().get("encrypt_type", &et);
      assert(et.empty() == false);
      source_encrytion_type = is_encrypted(et);
    }

    // Determine destination tablespace type and encryption type.
    new_er = dd::is_tablespace_encrypted(thd, *table_def,
                                         &destination_is_general_tablespace);
    if (new_er.error) {
      goto err_new_table_cleanup;
    }
    destination_encrytion_type = new_er.value;
    if (!destination_is_general_tablespace &&
        table_def->options().exists("encrypt_type")) {
      dd::String_type et;
      (void)table_def->options().get("encrypt_type", &et);
      assert(et.empty() == false);
      destination_encrytion_type = is_encrypted(et);
    }

    /*
      Disallow converting a general tablespace to a file-per-table
      tablespace without a explicit ENCRYPTION clause.
    */
    if (source_is_general_tablespace && source_encrytion_type == true &&
        !destination_is_general_tablespace &&
        !(create_info->used_fields & HA_CREATE_USED_ENCRYPT)) {
      my_error(ER_TARGET_TABLESPACE_UNENCRYPTED, MYF(0));
      goto err_new_table_cleanup;
    }

    /*
      Disallow moving encrypted table (using general or file-per-table
      tablespace) to a unencrypted general tablespace.
    */
    if (source_encrytion_type && destination_is_general_tablespace &&
        !destination_encrytion_type) {
      my_error(ER_TARGET_TABLESPACE_UNENCRYPTED, MYF(0));
      goto err_new_table_cleanup;
    }

    /*
      Check table encryption privilege, if table encryption type differ
      from schema encryption type.
    */
    if (new_schema->default_encryption() != destination_encrytion_type) {
      // Ignore privilege check and show warning if database is same and
      // table encryption type is not changed.
      bool show_warning = !alter_ctx.is_database_changed() &&
                          source_encrytion_type == destination_encrytion_type;

      if (!show_warning && opt_table_encryption_privilege_check) {
        if (check_table_encryption_admin_access(thd)) {
          my_error(ER_CANNOT_SET_TABLE_ENCRYPTION, MYF(0));
          return true;
        }
      } else if (new_schema->default_encryption() &&
                 !destination_encrytion_type) {
        push_warning(thd, Sql_condition::SL_WARNING,
                     WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB,
                     ER_THD(thd, WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB));
      }
    }
  }

  if (old_table_def) {
    if (is_checked_for_upgrade(*old_table_def)) {
      DBUG_PRINT("admin", ("Transfering upgrade mark "
                           "from Table %s (%llu) to Table %s (%llu)",
                           old_table_def->name().c_str(), old_table_def->id(),
                           table_def->name().c_str(), table_def->id()));
      table_def->mark_as_checked_for_upgrade();
    }
  }

  /*
    Check if new table definition is compatible with foreign keys
    on other tales which reference this one. We want to do this
    before starting potentially expensive main phases of COPYing
    or INPLACE ALTER TABLE.
  */
  if (!is_tmp_table) {
    if (new_db_type != old_db_type) {
      /*
        By changing table's storage engine we might be introducing parent
        table for previously orphan foreign keys in the new SE. We need
        to lock child tables of such orphan foreign keys. OTOH it is safe
        to assume that if SE is changed table can't be parent in any
        foreign keys in old SE.

        We assume that ALTER TABLE which combines change of SE and renaming
        of table is executed by changing SE first and then performing rename
        (this is closer to ALTER TABLE real implementation). So such ALTER
        TABLEs  need to pick up orphan foreign keys associated with old table
        names as well. Thus we use old table name in the below check.
      */
      assert(old_table_def->foreign_key_parents().size() == 0);

      if (check_fk_children_after_parent_def_change(
              thd, table_list->db, table_list->table_name, nullptr, nullptr,
              new_db_type, table_def))
        goto err_new_table_cleanup;
    } else {
      if (check_fk_children_after_parent_def_change(
              thd, table_list->db, table_list->table_name, new_db_type,
              old_table_def, table_def, alter_info))
        goto err_new_table_cleanup;
    }

    if (alter_ctx.is_table_renamed() &&
        check_fk_children_after_parent_def_change(
            thd, alter_ctx.new_db, alter_ctx.new_alias, table_list->db,
            table_list->table_name, new_db_type, table_def))
      goto err_new_table_cleanup;
  }

  if (alter_info->requested_algorithm !=
      Alter_info::ALTER_TABLE_ALGORITHM_COPY) {
    Alter_inplace_info ha_alter_info(create_info, alter_info,
                                     alter_ctx.error_if_not_empty, key_info,
                                     key_count, thd->work_part_info);
    TABLE *altered_table = nullptr;
    bool use_inplace = true;

    /* Fill the Alter_inplace_info structure. */
    if (fill_alter_inplace_info(thd, table, &ha_alter_info))
      goto err_new_table_cleanup;

    DBUG_EXECUTE_IF("innodb_index_drop_count_zero", {
      if (ha_alter_info.index_drop_count) {
        my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "Index rebuild",
                 "Without rebuild");
        return true;
      }
    };);

    DBUG_EXECUTE_IF("innodb_index_drop_count_one", {
      if (ha_alter_info.index_drop_count != 1) {
        my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "Index change",
                 "Index rebuild");
        return true;
      }
    };);

    // We assume that the table is non-temporary.
    assert(!table->s->tmp_table);

    if (!(altered_table = open_table_uncached(
              thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
              alter_ctx.tmp_name, true, false, *table_def)))
      goto err_new_table_cleanup;

    /* Set markers for fields in TABLE object for altered table. */
    update_altered_table(ha_alter_info, altered_table);

    /*
      Mark all columns in 'altered_table' as used to allow usage
      of its record[0] buffer and Field objects during in-place
      ALTER TABLE.
    */
    altered_table->column_bitmaps_set_no_signal(&altered_table->s->all_set,
                                                &altered_table->s->all_set);

    set_column_static_defaults(altered_table, alter_info->create_list);

    if (ha_alter_info.handler_flags == 0) {
      /*
        No-op ALTER, no need to call handler API functions.

        If this code path is entered for an ALTER statement that
        should not be a real no-op, new handler flags should be added
        and fill_alter_inplace_info() adjusted.

        Note that we can end up here if an ALTER statement has clauses
        that cancel each other out (e.g. ADD/DROP identically index).

        Also note that we ignore the LOCK clause here.
      */
      close_temporary_table(thd, altered_table, true, false);

      if (!(create_info->db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
        // Delete temporary table object from data dictionary.
        bool result = dd::drop_table(thd, alter_ctx.new_db, alter_ctx.tmp_name,
                                     *table_def);
        (void)trans_intermediate_ddl_commit(thd, result);
      }

      is_noop = true;
      goto end_inplace_noop;
    }

    // Ask storage engine whether to use copy or in-place
    enum_alter_inplace_result inplace_supported =
        table->file->check_if_supported_inplace_alter(altered_table,
                                                      &ha_alter_info);

    // If INSTANT was requested but it is not supported, report error.
    if (alter_info->requested_algorithm ==
            Alter_info::ALTER_TABLE_ALGORITHM_INSTANT &&
        inplace_supported != HA_ALTER_INPLACE_INSTANT &&
        inplace_supported != HA_ALTER_ERROR) {
      ha_alter_info.report_unsupported_error("ALGORITHM=INSTANT",
                                             "ALGORITHM=COPY/INPLACE");
      close_temporary_table(thd, altered_table, true, false);
      goto err_new_table_cleanup;
    }

    switch (inplace_supported) {
      case HA_ALTER_INPLACE_EXCLUSIVE_LOCK:
        // If SHARED lock and no particular algorithm was requested, use COPY.
        if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_SHARED &&
            alter_info->requested_algorithm ==
                Alter_info::ALTER_TABLE_ALGORITHM_DEFAULT) {
          use_inplace = false;
        }
        // Otherwise, if weaker lock was requested, report error.
        else if (alter_info->requested_lock ==
                     Alter_info::ALTER_TABLE_LOCK_NONE ||
                 alter_info->requested_lock ==
                     Alter_info::ALTER_TABLE_LOCK_SHARED) {
          ha_alter_info.report_unsupported_error("LOCK=NONE/SHARED",
                                                 "LOCK=EXCLUSIVE");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        break;
      case HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE:
      case HA_ALTER_INPLACE_SHARED_LOCK:
        // If weaker lock was requested, report error.
        if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_NONE) {
          ha_alter_info.report_unsupported_error("LOCK=NONE", "LOCK=SHARED");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        break;
      case HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE:
      case HA_ALTER_INPLACE_NO_LOCK:
      case HA_ALTER_INPLACE_INSTANT:
        /*
          Note that any instant operation is also in fact in-place operation.

          It is totally safe to execute operation using instant algorithm if it
          has no drawbacks as compared to in-place algorithm even if user
          explicitly asked for ALGORITHM=INPLACE. Doing so, also allows to
          keep code in engines which support only limited subset of in-place
          ALTER TABLE operations as instant metadata only changes simple.

          If instant algorithm has some downsides to in-place algorithm and user
          explicitly asks for ALGORITHM=INPLACE it is responsibility of storage
          engine to fallback to in-place algorithm execution by returning
          HA_ALTER_INPLACE_NO_LOCK or HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE.
        */
        break;
      case HA_ALTER_INPLACE_NOT_SUPPORTED:
        // If INPLACE was requested, report error.
        if (alter_info->requested_algorithm ==
            Alter_info::ALTER_TABLE_ALGORITHM_INPLACE) {
          ha_alter_info.report_unsupported_error("ALGORITHM=INPLACE",
                                                 "ALGORITHM=COPY");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        // COPY with LOCK=NONE is not supported, no point in trying.
        if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_NONE) {
          ha_alter_info.report_unsupported_error("LOCK=NONE", "LOCK=SHARED");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        // Otherwise use COPY
        use_inplace = false;
        break;
      case HA_ALTER_ERROR:
      default:
        close_temporary_table(thd, altered_table, true, false);
        goto err_new_table_cleanup;
    }

    if (use_inplace) {
      if (mysql_inplace_alter_table(thd, *schema, *new_schema, old_table_def,
                                    table_def, table_list, table, altered_table,
                                    &ha_alter_info, inplace_supported,
                                    &alter_ctx, columns, fk_key_info,
                                    fk_key_count, &fk_invalidator)) {
        return true;
      }

      goto end_inplace;
    } else {
      close_temporary_table(thd, altered_table, true, false);
    }
  }

  /* ALTER TABLE using copy algorithm. */

  /* Check if ALTER TABLE is compatible with foreign key definitions. */
  if (fk_check_copy_alter_table(thd, table_list, old_table_def, alter_info))
    goto err_new_table_cleanup;

  if (!table->s->tmp_table) {
    MDL_request_list mdl_requests;

    // COPY algorithm doesn't work with concurrent writes.
    if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_NONE) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED_REASON, MYF(0), "LOCK=NONE",
               ER_THD(thd, ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY),
               "LOCK=SHARED");
      goto err_new_table_cleanup;
    }

    // If EXCLUSIVE lock is requested, upgrade already.
    if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE &&
        wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN))
      goto err_new_table_cleanup;

    /*
      Otherwise upgrade to SHARED_NO_WRITE.
      Note that under LOCK TABLES, we will already have SHARED_NO_READ_WRITE.
    */
    if (alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE &&
        thd->mdl_context.upgrade_shared_lock(mdl_ticket, MDL_SHARED_NO_WRITE,
                                             thd->variables.lock_wait_timeout))
      goto err_new_table_cleanup;

    DEBUG_SYNC(thd, "alter_table_copy_after_lock_upgrade");

    /*
      COPY algorithm creates new table version in the new database.
      So if new database differs from old one we need to lock all
      foreign key names in new table version. If it is the same as
      the old one we need to lock only names of foreign keys added.

      Also if table is renamed we need to acquire locks on all foreign
      key names involved (taking into account adjustment of auto-generated
      names).
    */
    if (alter_ctx.is_database_changed()) {
      if (collect_fk_names(thd, alter_ctx.new_db, table_def, &mdl_requests))
        goto err_new_table_cleanup;
    } else {
      if (collect_fk_names_for_new_fks(
              thd, alter_ctx.new_db, table_list->table_name, alter_info,
              new_db_type,
              get_fk_max_generated_name_number(table_list->table_name,
                                               old_table_def, new_db_type),
              &mdl_requests))
        goto err_new_table_cleanup;
    }

    if (alter_ctx.is_table_renamed() &&
        collect_fk_names_for_rename_table(
            thd, table_list->db, table_list->table_name, table_def, new_db_type,
            alter_ctx.new_db, alter_ctx.new_name, &mdl_requests))
      goto err_new_table_cleanup;

    /*
      Acquire SRO locks on parent tables for newly added foreign keys
      in order to prevent concurrent DML on them.

      This is temporary workaround to the problem caused by the fact that
      InnoDB makes such foreign keys visible in its internal dictionary
      cache before ALTER TABLE commit. So such DML can result in access
      to our temporary table without prior acquisition of metadata lock
      on it (which would have blocked such access normally). As result
      our ALTER TABLE can fail due to locks acquired by these accesses.

      Long-term the problem should be solved by adjusting InnoDB code
      to avoid making such uncommitted changes visible to other
      connections.
    */
    if (collect_fk_parents_for_new_fks(
            thd, table_list->db, table_list->table_name, alter_info,
            MDL_SHARED_READ_ONLY, nullptr, &mdl_requests, nullptr))
      goto err_new_table_cleanup;

    if (!mdl_requests.is_empty() &&
        thd->mdl_context.acquire_locks(&mdl_requests,
                                       thd->variables.lock_wait_timeout))
      goto err_new_table_cleanup;

    /*
      Check if ALTER TABLE results in any foreign key name conflicts
      before starting potentially expensive copying operation.
    */
    if (!dd::get_dictionary()->is_dd_table_name(table_list->db,
                                                table_list->table_name) &&
        (new_db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
      if (alter_ctx.is_database_changed()) {
        /*
          If new table version was created schema different from the old one
          we need to check names for both pre-existing and newly added foreign
          keys.
        */
        for (FOREIGN_KEY *fk = fk_key_info; fk < fk_key_info + fk_key_count;
             ++fk) {
          bool exists;
          if (thd->dd_client()->check_foreign_key_exists(*new_schema, fk->name,
                                                         &exists))
            goto err_new_table_cleanup;

          if (exists) {
            my_error(ER_FK_DUP_NAME, MYF(0), fk->name);
            goto err_new_table_cleanup;
          }
        }
      } else {
        /* Otherwise we can limit our check to newly added foreign keys only. */
        for (FOREIGN_KEY *fk = fk_key_info + alter_ctx.fk_count;
             fk < fk_key_info + fk_key_count; ++fk) {
          bool exists;
          if (thd->dd_client()->check_foreign_key_exists(*new_schema, fk->name,
                                                         &exists))
            goto err_new_table_cleanup;

          if (exists) {
            my_error(ER_FK_DUP_NAME, MYF(0), fk->name);
            goto err_new_table_cleanup;
          }
        }
      }

      if (alter_ctx.is_table_renamed() &&
          check_fk_names_before_rename(thd, table_list, *table_def, new_db_type,
                                       *new_schema, alter_ctx))
        goto err_new_table_cleanup;
    }
  }

  {
    if (ha_create_table(thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
                        alter_ctx.tmp_name, create_info, false, true,
                        table_def))
      goto err_new_table_cleanup;

    /* Mark that we have created table in storage engine. */
    no_ha_table = false;

    if (create_info->options & HA_LEX_CREATE_TMP_TABLE) {
      if (thd->decide_logging_format(table_list) ||
          !open_table_uncached(thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
                               alter_ctx.tmp_name, true, true, *table_def))
        goto err_new_table_cleanup;
      /* in case of alter temp table send the tracker in OK packet */
      if (thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
              ->is_enabled())
        thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
            ->mark_as_changed(thd, {});
    }

    /* Open the table since we need to copy the data. */
    if (table->s->tmp_table != NO_TMP_TABLE) {
      Table_ref tbl(alter_ctx.new_db, alter_ctx.tmp_name, TL_READ_NO_INSERT);
      /* Table is in thd->temporary_tables */
      (void)open_temporary_table(thd, &tbl);
      new_table = tbl.table;
      /* Transfer dd::Table ownership to temporary table's share. */
      new_table->s->tmp_table_def = non_dd_table_def.release();
    } else {
      /* table is a normal table: Create temporary table in same directory */
      /* Open our intermediate table. */
      new_table =
          open_table_uncached(thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
                              alter_ctx.tmp_name, true, true, *table_def);
    }
    if (!new_table) goto err_new_table_cleanup;
    /*
      Note: In case of MERGE table, we do not attach children. We do not
      copy data for MERGE tables. Only the children have data.
    */

    // It's now safe to take the table level lock.
    if (lock_tables(thd, table_list, alter_ctx.tables_opened, 0))
      goto err_new_table_cleanup;
  }

  /*
    We do not copy data for MERGE tables. Only the children have data.
    MERGE tables have HA_NO_COPY_ON_ALTER set.
  */
  if (!(new_table->file->ha_table_flags() & HA_NO_COPY_ON_ALTER)) {
    new_table->next_number_field = new_table->found_next_number_field;
    THD_STAGE_INFO(thd, stage_copy_to_tmp_table);
    DBUG_EXECUTE_IF("abort_copy_table", {
      my_error(ER_LOCK_WAIT_TIMEOUT, MYF(0));
      goto err_new_table_cleanup;
    });

    if (copy_data_between_tables(thd, thd->m_stage_progress_psi, table,
                                 new_table, alter_info->create_list, &copied,
                                 &deleted, alter_info->keys_onoff, &alter_ctx))
      goto err_new_table_cleanup;

    DEBUG_SYNC(thd, "alter_after_copy_table");
  } else {
    /* Should be MERGE only */
    assert(new_table->file->ht->db_type == DB_TYPE_MRG_MYISAM);
    if (!table->s->tmp_table &&
        wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN))
      goto err_new_table_cleanup;
    THD_STAGE_INFO(thd, stage_manage_keys);
    DEBUG_SYNC(thd, "alter_table_manage_keys");
    alter_table_manage_keys(thd, table, table->file->indexes_are_disabled(),
                            alter_info->keys_onoff);
    assert(!(new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL));

    /* Prevent intermediate commits to invoke commit order */
    Implicit_substatement_state_guard substatement_guard(
        thd, enum_implicit_substatement_guard_mode ::
                 DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd))
      goto err_new_table_cleanup;
  }

  if (table->s->tmp_table != NO_TMP_TABLE) {
    /* Close lock if this is a transactional table */
    if (thd->lock) {
      if (thd->locked_tables_mode != LTM_LOCK_TABLES &&
          thd->locked_tables_mode != LTM_PRELOCKED_UNDER_LOCK_TABLES) {
        mysql_unlock_tables(thd, thd->lock);
        thd->lock = nullptr;
      } else {
        /*
          If LOCK TABLES list is not empty and contains this table,
          unlock the table and remove the table from this list.
        */
        mysql_lock_remove(thd, thd->lock, table);
      }
    }
    /* Remove link to old table and rename the new one */
    close_temporary_table(thd, table, true, true);
    /* Should pass the 'new_name' as we store table name in the cache */
    if (rename_temporary_table(thd, new_table, alter_ctx.new_db,
                               alter_ctx.new_name))
      goto err_new_table_cleanup;
    /*
      We don't replicate alter table statement on temporary tables
      in RBR mode.
    */
    if (!thd->is_current_stmt_binlog_format_row() &&
        write_bin_log(thd, true, thd->query().str, thd->query().length)) {
      /*
        We can't revert replacement of old table version with a new one
        at this point. So, if possible, commit the statement to avoid
        new table version being emptied by statement rollback.
      */
      if (!thd->transaction_rollback_request) {
        (void)trans_commit_stmt(thd);
        (void)trans_commit_implicit(thd);
      }
      return true;
    }

    // Do implicit commit for consistency with non-temporary table case/
    if (trans_commit_stmt(thd) || trans_commit_implicit(thd)) return true;

    goto end_temporary;
  }

  /*
    Close the intermediate table that will be the new table, but do
    not delete it! Even though MERGE tables do not have their children
    attached here it is safe to call close_temporary_table().
  */
  close_temporary_table(thd, new_table, true, false);
  new_table = nullptr;

  DEBUG_SYNC(thd, "alter_table_before_rename_result_table");
  DBUG_EXECUTE_IF("exit_after_alter_table_before_rename", {
    my_error(ER_UNKNOWN_ERROR, MYF(0));
    return true;
  });

  /*
    Data is copied. Now we:
    1) Wait until all other threads will stop using old version of table
       by upgrading shared metadata lock to exclusive one.
    2) Close instances of table open by this thread and replace them
       with placeholders to simplify reopen process.
    3) Rename the old table to a temp name, rename the new one to the
       old name.
    4) If we are under LOCK TABLES and don't do ALTER TABLE ... RENAME
       we reopen new version of table.
    5) Write statement to the binary log.
    6) If we are under LOCK TABLES and do ALTER TABLE ... RENAME we
       remove placeholders and release metadata locks.
    7) If we are not not under LOCK TABLES we rely on the caller
      (mysql_execute_command()) to release metadata locks.
  */

  THD_STAGE_INFO(thd, stage_rename_result_table);

  if (wait_while_table_is_used(thd, table, HA_EXTRA_PREPARE_FOR_RENAME))
    goto err_new_table_cleanup;

  if (collect_and_lock_fk_tables_for_complex_alter_table(
          thd, table_list, old_table_def, &alter_ctx, alter_info, old_db_type,
          new_db_type, &fk_invalidator))
    goto err_new_table_cleanup;

  /*
    To ensure DDL atomicity after this point support from both old and
    new engines is necessary. If either of them lacks such support let
    us commit transaction so changes to data-dictionary are more closely
    reflect situations in SEs.

    Also if new SE supports atomic DDL then we have not stored new table
    definition in on-disk data-dictionary so far. It is time to do this
    now if ALTER TABLE as a whole won't be atomic.
  */
  if (!atomic_replace) {
    if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        thd->dd_client()->store(non_dd_table_def.get()))
      goto err_new_table_cleanup;

    /* Prevent intermediate commits to invoke commit order */
    Implicit_substatement_state_guard substatement_guard(thd);

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd))
      goto err_new_table_cleanup;

    // Safety, in-memory dd::Table is no longer totally correct.
    non_dd_table_def.reset();
  }

  char backup_name[32];
  assert(sizeof(my_thread_id) == 4);
  snprintf(backup_name, sizeof(backup_name), "%s2-%lx-%x", tmp_file_prefix,
           current_pid, thd->thread_id());
  if (lower_case_table_names) my_casedn_str(files_charset_info, backup_name);

  close_all_tables_for_name(thd, table->s, false, nullptr);
  table_list->table = table = nullptr; /* Safety */

  /*
    Rename the old version to temporary name to have a backup in case
    anything goes wrong while renaming the new table.

    Take the X metadata lock on this temporary name too. This ensures that
    concurrent I_S queries won't try to open it. Assert to ensure we do not
    come here when ALTERing temporary table.
  */
  {
    assert(!is_tmp_table);
    MDL_request backup_name_mdl_request;
    MDL_REQUEST_INIT(&backup_name_mdl_request, MDL_key::TABLE, alter_ctx.db,
                     backup_name, MDL_EXCLUSIVE, MDL_STATEMENT);
    dd::cache::Dictionary_client::Auto_releaser releaser_2(thd->dd_client());
    const dd::Table *backup_table = nullptr;

    if (thd->mdl_context.acquire_lock(&backup_name_mdl_request,
                                      thd->variables.lock_wait_timeout) ||
        thd->dd_client()->acquire(alter_ctx.db, backup_name, &backup_table)) {
      /* purecov: begin tested */
      /*
        We need to clear THD::transaction_rollback_request (which might
        be set due to MDL deadlock) before attempting to remove new version
        of table.
      */
      if (thd->transaction_rollback_request) {
        trans_rollback_stmt(thd);
        trans_rollback(thd);
      }

      if (!atomic_replace) {
        (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                             alter_ctx.tmp_name, FN_IS_TMP);
      }
      goto err_with_mdl;
      /* purecov: end */
    }

    if (backup_table != nullptr) {
      /* purecov: begin tested */
      my_error(ER_TABLE_EXISTS_ERROR, MYF(0), backup_name);

      if (!atomic_replace) {
        (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                             alter_ctx.tmp_name, FN_IS_TMP);
      }
      goto err_with_mdl;
      /* purecov: end */
    }
  }

  if (mysql_rename_table(thd, old_db_type, alter_ctx.db, alter_ctx.table_name,
                         alter_ctx.db, alter_ctx.table_name, *schema,
                         alter_ctx.db, backup_name,
                         FN_TO_IS_TMP | (atomic_replace ? NO_DD_COMMIT : 0) |
                             NO_FK_RENAME | NO_CC_RENAME)) {
    // Rename to temporary name failed, delete the new table, abort ALTER.
    if (!atomic_replace) {
      /*
        In non-atomic mode situations when the SE has requested rollback
        should be handled already, by executing rollback right inside
        mysql_rename_table() call.
      */
      assert(!thd->transaction_rollback_request);
      (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                           alter_ctx.tmp_name, FN_IS_TMP);
    }
    goto err_with_mdl;
  }

  /*
    The below code assumes that only SE capable of atomic DDL support FK.
    This is somewhat simplifies error handling below.

    Note that we need to handle FKs atomically with this rename in order
    to handle scenario when, for example, MyISAM table is altered to InnoDB
    SE and some FKs are added at the same time.
  */
  assert(!(new_db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS) ||
         (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL));

  /*
    We also assume that we can't have non-atomic ALTER TABLE which
    will preserve any foreign keys (i.e. such ALTER TABLE can only
    drop all foreign keys on the table, or add new foreign keys to
    table which previously didn't have any).
  */
  assert(atomic_replace || alter_ctx.fk_count == 0);

  /*
    If both old and new SEs support atomic DDL then we have not stored
    new table definition in on-disk data-dictionary so far. It is time
    to do this now. However, before doing this we need to rename foreign
    keys in old table definition to temporary names to avoid conflicts
    with duplicate names.
  */
  if (atomic_replace) {
    if (alter_ctx.fk_count > 0 &&
        adjust_foreign_key_names_for_old_table_version(thd, alter_ctx.db,
                                                       backup_name))
      goto err_with_mdl;

    if (thd->dd_client()->store(non_dd_table_def.get())) goto err_with_mdl;

    // Safety, in-memory dd::Table is no longer totally correct.
    non_dd_table_def.reset();
  }

  // Rename the new table to the correct name.
  if (mysql_rename_table(
          thd, new_db_type, alter_ctx.new_db, alter_ctx.tmp_name, alter_ctx.db,
          alter_ctx.table_name, *new_schema, alter_ctx.new_db,
          alter_ctx.new_alias,
          (FN_FROM_IS_TMP |
           ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) ? NO_DD_COMMIT
                                                            : 0) |
           (alter_ctx.is_table_renamed() ? 0 : NO_FK_RENAME | NO_CC_RENAME))) ||
      ((new_db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS) &&
       adjust_fks_for_complex_alter_table(thd, table_list, &alter_ctx,
                                          alter_info, new_db_type,
                                          &fk_invalidator)) ||
      /*
        Try commit changes if ALTER TABLE as whole is not atomic and we have
        not done this in the above mysql_rename_table() call.
      */
      (!atomic_replace && (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
       trans_intermediate_ddl_commit(thd, false))) {
    // Rename failed, delete the temporary table.
    if (!atomic_replace) {
      if (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) {
        /*
          If ALTER TABLE as whole is not atomic and the above rename or
          FK changes have failed without cleaning up after themselves,
          we need to do this now.
        */
        (void)trans_intermediate_ddl_commit(thd, true);
      }

      /*
        In non-atomic mode situations when the SE has requested rollback
        should be handled already.
      */
      assert(!thd->transaction_rollback_request);

      (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                           alter_ctx.tmp_name, FN_IS_TMP);

      // Restore the backup of the original table to its original name.
      // If the operation fails, we need to retry it to avoid leaving
      // the dictionary inconsistent.
      //
      // This hack might become unnecessary once InnoDB stops acquiring
      // gap locks on DD tables (which might cause deadlocks).
      uint retries = 20;
      while (retries-- &&
             mysql_rename_table(
                 thd, old_db_type, alter_ctx.db, backup_name, alter_ctx.db,
                 backup_name, *schema, alter_ctx.db, alter_ctx.alias,
                 FN_FROM_IS_TMP | NO_FK_CHECKS | NO_FK_RENAME | NO_CC_RENAME))
        ;
    }
    goto err_with_mdl;
  }

  /*
    If ALTER TABLE is non-atomic and fails after this point it can add
    foreign keys and such addition won't be reverted. So we need to
    invalidate table objects for foreign key parents even on error.
  */
  if (!atomic_replace) invalidate_fk_parents_on_error = true;

  // Handle trigger name, check constraint names and histograms statistics.
  {
    dd::Table *backup_table = nullptr;
    dd::Table *new_dd_table = nullptr;
    if (thd->dd_client()->acquire_for_modification(alter_ctx.db, backup_name,
                                                   &backup_table) ||
        thd->dd_client()->acquire_for_modification(
            alter_ctx.new_db, alter_ctx.new_alias, &new_dd_table))
      goto err_with_mdl;
    assert(backup_table != nullptr && new_dd_table != nullptr);

    /*
      Check if this is an ALTER command that will cause histogram statistics to
      become invalid. If that is the case; remove the histogram statistics.

      This will take care of scenarios when COPY alter is used, but not INPLACE.
      Do this before the commit for non-transactional tables, because the
      new_dd_table is invalidated on commit.
    */
    if (alter_table_drop_histograms(thd, table_list, alter_info, create_info,
                                    columns, backup_table, new_dd_table))
      goto err_with_mdl; /* purecov: deadcode */

    bool update = (new_dd_table->check_constraints()->size() > 0);
    // Set mode for new_dd_table's check constraints.
    set_check_constraints_alter_mode(new_dd_table, alter_info);

    /*
      Check constraint names are unique per schema, we cannot create them while
      both table version exists. Adjust check constraint names in old table
      version.
    */
    if (adjust_check_constraint_names_for_old_table_version(thd, alter_ctx.db,
                                                            backup_table))
      goto err_with_mdl;

    // Reset check constraint's mode.
    reset_check_constraints_alter_mode(new_dd_table);

    /*
      Since trigger names have to be unique per schema, we cannot
      create them while both the old and the tmp version of the
      table exist.
    */
    if (backup_table->has_trigger()) {
      new_dd_table->copy_triggers(backup_table);
      backup_table->drop_all_triggers();
      update = true;
    }
    if (!is_checked_for_upgrade(*new_dd_table) &&
        is_checked_for_upgrade(*backup_table)) {
      new_dd_table->mark_as_checked_for_upgrade();
      update = true;
    }
    if (update) {
      if (thd->dd_client()->update(backup_table) ||
          thd->dd_client()->update(new_dd_table))
        goto err_with_mdl;

      /* Prevent intermediate commits to invoke commit order */
      Implicit_substatement_state_guard substatement_guard(thd);
      if (!atomic_replace && (trans_commit_stmt(thd) || trans_commit(thd)))
        goto err_with_mdl;
    }
  }

  // If the ALTER command was a rename, rename any existing histograms.
  if (alter_ctx.is_table_renamed() &&
      rename_histograms(thd, table_list->db, table_list->table_name, new_db,
                        new_name)) {
    goto err_with_mdl; /* purecov: deadcode */
  }

  // ALTER TABLE succeeded, delete the backup of the old table.
  if (quick_rm_table(thd, old_db_type, alter_ctx.db, backup_name,
                     FN_IS_TMP | (atomic_replace ? NO_DD_COMMIT : 0))) {
    /*
      The fact that deletion of the backup failed is not critical
      error, but still worth reporting as it might indicate serious
      problem with server.

      TODO: In !atomic_replace case we might need to do FK parents
            invalidation here. However currently our FKs are not
            even named correctly at this point, so we postpone
            fixing this issue until we solve FK naming problem.
    */
    goto err_with_mdl;
  }

end_inplace_noop:

  THD_STAGE_INFO(thd, stage_end);

  DBUG_EXECUTE_IF("sleep_alter_before_main_binlog", my_sleep(6000000););
  DEBUG_SYNC(thd, "alter_table_before_main_binlog");

  ha_binlog_log_query(thd, create_info->db_type, LOGCOM_ALTER_TABLE,
                      thd->query().str, thd->query().length, alter_ctx.db,
                      alter_ctx.table_name);

  assert(!(mysql_bin_log.is_open() &&
           thd->is_current_stmt_binlog_format_row() &&
           (create_info->options & HA_LEX_CREATE_TMP_TABLE)));

  /*
    If this is no-op ALTER TABLE we don't have transaction started.
    We can't use binlog's trx cache in this case as it requires active
    transaction with valid XID.
  */
  if (write_bin_log(thd, true, thd->query().str, thd->query().length,
                    atomic_replace && !is_noop))
    goto err_with_mdl;

  if (!is_noop) {
    Uncommitted_tables_guard uncommitted_tables(thd);

    uncommitted_tables.add_table(table_list);

    if (update_referencing_views_metadata(thd, table_list, new_db, new_name,
                                          !atomic_replace, &uncommitted_tables))
      goto err_with_mdl;

    if (alter_ctx.is_table_renamed())
      tdc_remove_table(thd, TDC_RT_REMOVE_ALL, alter_ctx.new_db,
                       alter_ctx.new_name, false);
  }

  // Commit if it was not done before in order to be able to reopen tables.
  if (atomic_replace && (trans_commit_stmt(thd) || trans_commit_implicit(thd)))
    goto err_with_mdl;

  if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && new_db_type->post_ddl)
    new_db_type->post_ddl(thd);
  if ((old_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && old_db_type->post_ddl)
    old_db_type->post_ddl(thd);

#ifndef WORKAROUND_TO_BE_REMOVED_BY_WL6049
  {
    Table_ref table_list_reopen(alter_ctx.new_db, alter_ctx.new_name,
                                alter_ctx.new_alias, TL_READ);
    table_list_reopen.mdl_request.ticket =
        alter_ctx.is_table_renamed() ? alter_ctx.target_mdl_request.ticket
                                     : mdl_ticket;

    Open_table_context ot_ctx(thd, MYSQL_OPEN_REOPEN);

    if (open_table(thd, &table_list_reopen, &ot_ctx)) return true;

    assert(table_list_reopen.table == thd->open_tables);
    close_thread_table(thd, &thd->open_tables);
  }
#endif

end_inplace:

  fk_invalidator.invalidate(thd);

  if (alter_ctx.is_table_renamed())
    thd->locked_tables_list.rename_locked_table(
        table_list, alter_ctx.new_db, alter_ctx.new_name,
        alter_ctx.target_mdl_request.ticket);

  {
    bool reopen_error = thd->locked_tables_list.reopen_tables(thd);

    if (thd->locked_tables_mode == LTM_LOCK_TABLES ||
        thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) {
      if (alter_ctx.is_table_renamed()) {
        /*
          Release metadata lock on old table name and keep the lock
          on the new one. We have to ignore reopen_error in this case
          as we will mess up FK invariants for LOCK TABLES otherwise.
        */
        thd->mdl_context.release_all_locks_for_name(mdl_ticket);
        thd->mdl_context.set_lock_duration(alter_ctx.target_mdl_request.ticket,
                                           MDL_EXPLICIT);
        alter_ctx.target_mdl_request.ticket->downgrade_lock(
            MDL_SHARED_NO_READ_WRITE);
        if (alter_ctx.is_database_changed())
          thd->mdl_context.set_lock_duration(
              alter_ctx.target_db_mdl_request.ticket, MDL_EXPLICIT);
      } else
        mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
    }

    if (reopen_error) return true;
  }

end_temporary:
  snprintf(alter_ctx.tmp_name, sizeof(alter_ctx.tmp_name),
           ER_THD(thd, ER_INSERT_INFO), (long)(copied + deleted), (long)deleted,
           (long)thd->get_stmt_da()->current_statement_cond_count());
  my_ok(thd, copied + deleted, 0L, alter_ctx.tmp_name);
  return false;

err_new_table_cleanup:
  if (create_info->options & HA_LEX_CREATE_TMP_TABLE) {
    if (new_table)
      close_temporary_table(thd, new_table, true, true);
    else if (!no_ha_table)
      rm_temporary_table(thd, new_db_type, alter_ctx.get_tmp_path(),
                         non_dd_table_def.get());
  } else {
    /* close_temporary_table() frees the new_table pointer. */
    if (new_table) close_temporary_table(thd, new_table, true, false);

    if (!(new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
      if (no_ha_table)  // Only remove from DD.
      {
        dd::cache::Dictionary_client::Auto_releaser releaser_3(
            thd->dd_client());
        const dd::Table *drop_table_def = nullptr;
        if (!thd->dd_client()->acquire(alter_ctx.new_db, alter_ctx.tmp_name,
                                       &drop_table_def)) {
          assert(drop_table_def != nullptr);
          bool result = dd::drop_table(thd, alter_ctx.new_db,
                                       alter_ctx.tmp_name, *drop_table_def);
          (void)trans_intermediate_ddl_commit(thd, result);
        }
      } else  // Remove from both DD and SE.
        (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                             alter_ctx.tmp_name, FN_IS_TMP);
    } else {
      trans_rollback_stmt(thd);
      /*
        Full rollback in case we have THD::transaction_rollback_request
        and to synchronize DD state in cache and on disk (as statement
        rollback doesn't clear DD cache of modified uncommitted objects).
      */
      trans_rollback(thd);
    }
    if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        new_db_type->post_ddl)
      new_db_type->post_ddl(thd);
  }

  if (alter_ctx.error_if_not_empty &
      Alter_table_ctx::GEOMETRY_WITHOUT_DEFAULT) {
    my_error(ER_INVALID_USE_OF_NULL, MYF(0));
  }

  /*
    No default value was provided for a DATE/DATETIME field, the
    current sql_mode doesn't allow the '0000-00-00' value and
    the table to be altered isn't empty.
    Report error here. Ignore error checkin for push_zero_date_warning()
    as we return true right below.
  */
  if ((alter_ctx.error_if_not_empty &
       Alter_table_ctx::DATETIME_WITHOUT_DEFAULT) &&
      (thd->variables.sql_mode & MODE_NO_ZERO_DATE) &&
      thd->get_stmt_da()->current_row_for_condition()) {
    (void)push_zero_date_warning(thd, alter_ctx.datetime_field);
  }
  return true;

err_with_mdl:
  /*
    An error happened while we were holding exclusive name metadata lock
    on table being altered. Before releasing locks we need to rollback
    changes to the data-dictionary, storage angine and binary log (if
    they were not committed earlier) and execute post DDL hooks.
    We also try to reopen old version of the table under LOCK TABLES
    if possible.
  */

  trans_rollback_stmt(thd);
  /*
    Full rollback in case we have THD::transaction_rollback_request
    and to synchronize DD state in cache and on disk (as statement
    rollback doesn't clear DD cache of modified uncommitted objects).
  */
  trans_rollback(thd);
  if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && new_db_type->post_ddl)
    new_db_type->post_ddl(thd);
  if ((old_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && old_db_type->post_ddl)
    old_db_type->post_ddl(thd);

  if (atomic_replace) {
    /*
      If both old and new storage engines support atomic DDL all changes
      were reverted at this point. So we can safely try to reopen table
      under old name.
    */
  } else {
    /*
      If ALTER TABLE ... RENAME ... ALGORITHM=COPY is non-atomic we can't
      be sure that rename step was reverted, so we simply remove table
      from the list of locked tables.
    */
    if (alter_ctx.is_table_renamed())
      thd->locked_tables_list.unlink_all_closed_tables(thd, nullptr, 0);
  }

  /*
    ALTER TABLE which changes table storage engine from MyISAM to InnoDB
    and adds foreign keys at the same time can fail after installing
    new table version. In this case we still need to invalidate table
    objects for parent tables to avoid creating discrepancy between
    data-dictionary and cache contents.
  */
  if (invalidate_fk_parents_on_error) fk_invalidator.invalidate(thd);

  (void)thd->locked_tables_list.reopen_tables(thd);

  if ((thd->locked_tables_mode == LTM_LOCK_TABLES ||
       thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES)) {
    /*
      Non-atomic ALTER TABLE ... RENAME ... ALGORITHM=COPY can add
      foreign keys if at the same time SE is changed from, e.g.,
      MyISAM to InnoDB. Since releasing metadata locks on old or new
      table name can break FK invariants for LOCK TABLES in various
      scenarios we keep both of them.
    */
    if (!atomic_replace && alter_ctx.is_table_renamed()) {
      thd->mdl_context.set_lock_duration(alter_ctx.target_mdl_request.ticket,
                                         MDL_EXPLICIT);
      alter_ctx.target_mdl_request.ticket->downgrade_lock(
          MDL_SHARED_NO_READ_WRITE);
      if (alter_ctx.is_database_changed())
        thd->mdl_context.set_lock_duration(
            alter_ctx.target_db_mdl_request.ticket, MDL_EXPLICIT);
    }
    mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
  }

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_thd_internal_api.cc
Function: thd_binlog_format
int thd_binlog_format(const THD *thd) {
  if (mysql_bin_log.is_open() && (thd->variables.option_bits & OPTION_BIN_LOG))
    return (int)thd->variables.binlog_format;
  else
    return BINLOG_FORMAT_UNSPEC;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partitioning/partition_handler.cc
Function: Partition_helper::get_auto_increment_first_field
void Partition_helper::get_auto_increment_first_field(
    ulonglong increment, ulonglong nb_desired_values, ulonglong *first_value,
    ulonglong *nb_reserved_values) {
  THD *thd = get_thd();
  DBUG_TRACE;
  DBUG_PRINT("info",
             ("inc: %lu desired_values: %lu first_value: %lu", (ulong)increment,
              (ulong)nb_desired_values, (ulong)*first_value));
  assert(increment && nb_desired_values);
  /*
    next_number_keypart is != 0 if the auto_increment column is a secondary
    column in the index (it is allowed in MyISAM)
  */
  assert(m_table->s->next_number_keypart == 0);
  *first_value = 0;

  /*
    Get a lock for handling the auto_increment in part_share
    for avoiding two concurrent statements getting the same number.
  */
  lock_auto_increment();

  /* Initialize if not already done. */
  if (!m_part_share->auto_inc_initialized) {
    initialize_auto_increment(false);
  }

  /*
    In a multi-row insert statement like INSERT SELECT and LOAD DATA
    where the number of candidate rows to insert is not known in advance
    we must hold a lock/mutex for the whole statement if we have statement
    based replication. Because the statement-based binary log contains
    only the first generated value used by the statement, and slaves assumes
    all other generated values used by this statement were consecutive to
    this first one, we must exclusively lock the generator until the statement
    is done.
  */
  int binlog_format = thd_binlog_format(thd);
  if (!m_auto_increment_safe_stmt_log_lock &&
      thd->lex->sql_command != SQLCOM_INSERT &&
      binlog_format != BINLOG_FORMAT_UNSPEC &&
      binlog_format != BINLOG_FORMAT_ROW) {
    DBUG_PRINT("info", ("locking auto_increment_safe_stmt_log_lock"));
    m_auto_increment_safe_stmt_log_lock = true;
  }

  /* this gets corrected (for offset/increment) in update_auto_increment */
  *first_value = m_part_share->next_auto_inc_val;
  m_part_share->next_auto_inc_val += nb_desired_values * increment;
  if (m_part_share->next_auto_inc_val < *first_value) {
    /* Overflow, set to max. */
    m_part_share->next_auto_inc_val = ULLONG_MAX;
  }

  unlock_auto_increment();
  DBUG_PRINT("info", ("*first_value: %lu", (ulong)*first_value));
  *nb_reserved_values = nb_desired_values;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Save_and_Restore_binlog_format_state::Save_and_Restore_binlog_format_state
  explicit Save_and_Restore_binlog_format_state(THD *thd)
      : m_thd(thd),
        m_global_binlog_format(thd->variables.binlog_format),
        m_current_stmt_binlog_format(BINLOG_FORMAT_STMT) {
    if (thd->is_current_stmt_binlog_format_row())
      m_current_stmt_binlog_format = BINLOG_FORMAT_ROW;

    thd->variables.binlog_format = BINLOG_FORMAT_STMT;
    thd->clear_current_stmt_binlog_format_row();
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Save_and_Restore_binlog_format_state::
    if (m_thd) {
      /*
        We can't disable auto-commit if there is ongoing transaction as this
        might easily break statement/session transaction invariants.
      */
      assert(m_thd->get_transaction()->is_empty(Transaction_ctx::STMT) &&
             m_thd->get_transaction()->is_empty(Transaction_ctx::SESSION));

      m_thd->variables.option_bits &= ~OPTION_AUTOCOMMIT;
      m_thd->variables.option_bits |= OPTION_NOT_AUTOCOMMIT;
    }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_handler.cc
Function: prepare_transaction_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_handler.cc
Function: prepare_transaction_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_handler.cc
Function: prepare_transaction_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_handler.cc
Function: prepare_transaction_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_group_replication.cc
Function: get_server_startup_prerequirements
void get_server_startup_prerequirements(Trans_context_info &requirements) {
  requirements.binlog_enabled = opt_bin_log;
  requirements.binlog_format = global_system_variables.binlog_format;
  requirements.binlog_checksum_options = binlog_checksum_options;
  requirements.gtid_mode = global_gtid_mode.get();
  requirements.log_replica_updates = opt_log_replica_updates;
  requirements.transaction_write_set_extraction =
      global_system_variables.transaction_write_set_extraction;
  requirements.mi_repository_type = opt_mi_repository_id;
  requirements.rli_repository_type = opt_rli_repository_id;
  requirements.parallel_applier_type = mts_parallel_option;
  requirements.parallel_applier_workers = opt_mts_replica_parallel_workers;
  requirements.parallel_applier_preserve_commit_order =
      opt_replica_preserve_commit_order;
  requirements.lower_case_table_names = lower_case_table_names;
  requirements.default_table_encryption =
      global_system_variables.default_table_encryption;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_value_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_value_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_value_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: transaction_write_set_check
static bool transaction_write_set_check(sys_var *self, THD *thd, set_var *var) {
  if (check_session_admin(self, thd, var)) return true;
  // Can't change the algorithm when group replication is enabled.
  if (is_group_replication_running()) {
    my_message(
        ER_GROUP_REPLICATION_RUNNING,
        "The write set algorithm cannot be changed when Group replication"
        " is running.",
        MYF(0));
    return true;
  }

  if ((var->is_global_persist()) &&
      global_system_variables.binlog_format != BINLOG_FORMAT_ROW) {
    my_error(ER_PREVENTS_VARIABLE_WITHOUT_RBR, MYF(0), self->name.str);
    return true;
  }

  if (var->type == OPT_SESSION &&
      thd->variables.binlog_format != BINLOG_FORMAT_ROW) {
    my_error(ER_PREVENTS_VARIABLE_WITHOUT_RBR, MYF(0), self->name.str);
    return true;
  }
  /*
    if in a stored function/trigger, it's too late to change
  */
  if (thd->in_sub_stmt) {
    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0), self->name.str);
    return true;
  }
  /*
    Make the session variable 'transaction_write_set_extraction' read-only
    inside a transaction.
  */
  if (thd->in_active_multi_stmt_transaction()) {
    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0), self->name.str);
    return true;
  }
  /*
    Disallow changing variable 'transaction_write_set_extraction' while
    binlog_transaction_dependency_tracking is different from COMMIT_ORDER.
  */
  if (mysql_bin_log.m_dependency_tracker.m_opt_tracking_mode !=
      DEPENDENCY_TRACKING_COMMIT_ORDER) {
    my_error(ER_WRONG_USAGE, MYF(0),
             "transaction_write_set_extraction (changed)",
             "binlog_transaction_dependency_tracking (!= COMMIT_ORDER)");
    return true;
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_func_sp::execute_impl
bool Item_func_sp::execute_impl(THD *thd) {
  bool err_status = true;
  Sub_statement_state statement_state;
  Security_context *save_security_ctx = thd->security_context();
  enum enum_sp_data_access access =
      (m_sp->m_chistics->daccess == SP_DEFAULT_ACCESS)
          ? SP_DEFAULT_ACCESS_MAPPING
          : m_sp->m_chistics->daccess;

  DBUG_TRACE;

  if (context->security_ctx) {
    /* Set view definer security context */
    thd->set_security_context(context->security_ctx);
  }
  if (sp_check_access(thd)) goto error;

  /*
    Throw an error if a non-deterministic function is called while
    statement-based replication (SBR) is active.
  */

  if (!m_deterministic && !trust_function_creators &&
      (access == SP_CONTAINS_SQL || access == SP_MODIFIES_SQL_DATA) &&
      (mysql_bin_log.is_open() &&
       thd->variables.binlog_format == BINLOG_FORMAT_STMT)) {
    my_error(ER_BINLOG_UNSAFE_ROUTINE, MYF(0));
    goto error;
  }

  /*
    Disable the binlogging if this is not a SELECT statement. If this is a
    SELECT, leave binlogging on, so execute_function() code writes the
    function call into binlog.
  */
  thd->reset_sub_statement_state(&statement_state, SUB_STMT_FUNCTION);
  err_status = m_sp->execute_function(thd, args, arg_count, sp_result_field);
  thd->restore_sub_statement_state(&statement_state);

error:
  thd->set_security_context(save_security_ctx);

  return err_status;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_ddl_table.cc
Function: Sql_cmd_create_table::execute
bool Sql_cmd_create_table::execute(THD *thd) {
  LEX *const lex = thd->lex;
  Query_block *const query_block = lex->query_block;
  Query_expression *const query_expression = lex->unit;
  Table_ref *const create_table = lex->query_tables;
  partition_info *part_info = lex->part_info;

  /*
    Code below (especially in mysql_create_table() and Query_result_create
    methods) may modify HA_CREATE_INFO structure in LEX, so we have to
    use a copy of this structure to make execution prepared statement-
    safe. A shallow copy is enough as this code won't modify any memory
    referenced from this structure.
  */
  HA_CREATE_INFO create_info(*lex->create_info);
  /*
    We need to copy alter_info for the same reasons of re-execution
    safety, only in case of Alter_info we have to do (almost) a deep
    copy.
  */
  Alter_info alter_info(*m_alter_info, thd->mem_root);

  if (thd->is_error()) {
    /* If out of memory when creating a copy of alter_info. */
    return true;
  }

  if (((lex->create_info->used_fields & HA_CREATE_USED_DATADIR) != 0 ||
       (lex->create_info->used_fields & HA_CREATE_USED_INDEXDIR) != 0) &&
      check_access(thd, FILE_ACL, any_db, nullptr, nullptr, false, false)) {
    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "FILE");
    return true;
  }

  if (!thd->is_plugin_fake_ddl()) {
    if (create_table_precheck(thd, query_expression_tables, create_table))
      return true;
  }

  /* Might have been updated in create_table_precheck */
  create_info.alias = create_table->alias;

  /*
    If no engine type was given, work out the default now
    rather than at parse-time.
  */
  if (!(create_info.used_fields & HA_CREATE_USED_ENGINE))
    create_info.db_type = create_info.options & HA_LEX_CREATE_TMP_TABLE
                              ? ha_default_temp_handlerton(thd)
                              : ha_default_handlerton(thd);

  assert(create_info.db_type != nullptr);
  if ((m_alter_info->flags & Alter_info::ANY_ENGINE_ATTRIBUTE) != 0 &&
      ((create_info.db_type->flags & HTON_SUPPORTS_ENGINE_ATTRIBUTE) == 0 &&
       DBUG_EVALUATE_IF("simulate_engine_attribute_support", false, true))) {
    my_error(ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED, MYF(0),
             ha_resolve_storage_engine_name(create_info.db_type));
    return true;
  }

  /*
    Assign target tablespace name to enable locking in lock_table_names().
    Reject invalid names.
  */
  if (create_info.tablespace) {
    if (validate_tablespace_name_length(create_info.tablespace) ||
        validate_tablespace_name(TS_CMD_NOT_DEFINED, create_info.tablespace,
                                 create_info.db_type))
      return true;

    if (lex_string_strmake(thd->mem_root, &create_table->target_tablespace_name,
                           create_info.tablespace,
                           strlen(create_info.tablespace)))
      return true;
  }

  // Reject invalid tablespace names specified for partitions.
  if (validate_partition_tablespace_name_lengths(part_info) ||
      validate_partition_tablespace_names(part_info, create_info.db_type))
    return true;

  /* Fix names if symlinked or relocated tables */
  if (prepare_index_and_data_dir_path(thd, &create_info.data_file_name,
                                      &create_info.index_file_name,
                                      create_table->table_name))
    return true;

  {
    partition_info *part = thd->lex->part_info;
    if (part != nullptr && has_external_data_or_index_dir(*part) &&
        check_access(thd, FILE_ACL, any_db, nullptr, nullptr, false, false)) {
      return true;
    }
    if (part && !(part = thd->lex->part_info->get_clone(thd, true)))
      return true;
    thd->work_part_info = part;
  }

  if (part_info != nullptr && part_info->part_expr &&
      part_info->part_expr->fixed) {  // @todo Code may be redundant
    part_info->fixed = true;
  }
  bool res = false;

  if (!query_block->field_list_is_empty())  // With select
  {
    /*
      CREATE TABLE...IGNORE/REPLACE SELECT... can be unsafe, unless
      ORDER BY PRIMARY KEY clause is used in SELECT statement. We therefore
      use row based logging if mixed or row based logging is available.
      TODO: Check if the order of the output of the select statement is
      deterministic. Waiting for BUG#42415
    */
    if (lex->is_ignore())
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_CREATE_IGNORE_SELECT);

    if (lex->duplicates == DUP_REPLACE)
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_CREATE_REPLACE_SELECT);

    /**
      Disallow creation of foreign keys if,

      - SE supports atomic DDL's.
      - The binlogging is enabled.
      - The binlog format is ROW.

      This is done to avoid complications involved in locking,
      updating and invalidation (in case of rollback) of DD cache
      for parent table.
    */
    if ((alter_info.flags & Alter_info::ADD_FOREIGN_KEY) &&
        (create_info.db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        mysql_bin_log.is_open() &&
        (thd->variables.option_bits & OPTION_BIN_LOG) &&
        thd->variables.binlog_format == BINLOG_FORMAT_ROW) {
      my_error(ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT, MYF(0));
      return true;
    }

    // Reject request to CREATE TABLE AS SELECT with START TRANSACTION.
    if (create_info.m_transactional_ddl) {
      my_error(ER_NOT_ALLOWED_WITH_START_TRANSACTION, MYF(0),
               "with CREATE TABLE ... AS SELECT statement.");
      return true;
    }

    /*
      If:
      a) we inside an SP and there was NAME_CONST substitution,
      b) binlogging is on (STMT mode),
      c) we log the SP as separate statements
      raise a warning, as it may cause problems
      (see 'NAME_CONST issues' in 'Binary Logging of Stored Programs')
     */
    if (thd->query_name_consts && mysql_bin_log.is_open() &&
        thd->variables.binlog_format == BINLOG_FORMAT_STMT &&
        !mysql_bin_log.is_query_in_union(thd, thd->query_id)) {
      uint splocal_refs = 0;
      /* Count SP local vars in the top-level SELECT list */
      for (Item *item : query_block->visible_fields()) {
        if (item->is_splocal()) splocal_refs++;
      }
      /*
        If it differs from number of NAME_CONST substitution applied,
        we may have a SOME_FUNC(NAME_CONST()) in the SELECT list,
        that may cause a problem with binary log (see BUG#35383),
        raise a warning.
      */
      if (splocal_refs != thd->query_name_consts)
        push_warning(
            thd, Sql_condition::SL_WARNING, ER_UNKNOWN_ERROR,
            "Invoked routine ran a statement that may cause problems with "
            "binary log, see 'NAME_CONST issues' in 'Binary Logging of Stored "
            "Programs' "
            "section of the manual.");
    }

    /*
      Disable non-empty MERGE tables with CREATE...SELECT. Too
      complicated. See Bug #26379. Empty MERGE tables are read-only
      and don't allow CREATE...SELECT anyway.
    */
    if (create_info.used_fields & HA_CREATE_USED_UNION) {
      my_error(ER_WRONG_OBJECT, MYF(0), create_table->db,
               create_table->table_name, "BASE TABLE");
      return true;
    }

    if (query_expression->is_prepared()) {
      cleanup(thd);
    }
    auto cleanup_se_guard = create_scope_guard(
        [lex] { lex->set_secondary_engine_execution_context(nullptr); });
    if (open_tables_for_query(thd, lex->query_tables, false)) return true;

    /* The table already exists */
    if (create_table->table || create_table->is_view()) {
      if (create_info.options & HA_LEX_CREATE_IF_NOT_EXISTS) {
        push_warning_printf(thd, Sql_condition::SL_NOTE, ER_TABLE_EXISTS_ERROR,
                            ER_THD(thd, ER_TABLE_EXISTS_ERROR),
                            create_info.alias);
        my_ok(thd);
        return false;
      } else {
        my_error(ER_TABLE_EXISTS_ERROR, MYF(0), create_info.alias);
        return false;
      }
    }

    /*
      Remove target table from main select and name resolution
      context. This can't be done earlier as it will break view merging in
      statements like "CREATE TABLE IF NOT EXISTS existing_view SELECT".
    */
    bool link_to_local;
    lex->unlink_first_table(&link_to_local);

    /* Updating any other table is prohibited in CTS statement */
    for (Table_ref *table = lex->query_tables; table;
         table = table->next_global) {
      if (table->lock_descriptor().type >= TL_WRITE_ALLOW_WRITE) {
        lex->link_first_table_back(create_table, link_to_local);

        my_error(ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT, MYF(0),
                 table->table_name, create_info.alias);
        return true;
      }
    }

    Query_result_create *result;
    if (!query_expression->is_prepared()) {
      const Prepare_error_tracker tracker(thd);
      Prepared_stmt_arena_holder ps_arena_holder(thd);
      result = new (thd->mem_root)
          Query_result_create(create_table, &query_block->fields,
                              lex->duplicates, query_expression_tables);
      if (result == nullptr) {
        lex->link_first_table_back(create_table, link_to_local);
        return true;
      }

      // Use the hypergraph optimizer for the SELECT statement, if enabled.
      lex->set_using_hypergraph_optimizer(
          thd->optimizer_switch_flag(OPTIMIZER_SWITCH_HYPERGRAPH_OPTIMIZER));

      if (query_expression->prepare(thd, result, nullptr, SELECT_NO_UNLOCK,
                                    0)) {
        lex->link_first_table_back(create_table, link_to_local);
        return true;
      }
      if (!thd->stmt_arena->is_regular() && lex->save_cmd_properties(thd)) {
        lex->link_first_table_back(create_table, link_to_local);
        return true;
      }
    } else {
      result = down_cast<Query_result_create *>(
          query_expression->query_result() != nullptr
              ? query_expression->query_result()
              : query_block->query_result());
      // Restore prepared statement properties, bind table and field information
      lex->restore_cmd_properties();
      bind_fields(thd->stmt_arena->item_list());
    }
    if (validate_use_secondary_engine(lex)) return true;

    result->set_two_fields(&create_info, &alter_info);

    // For objects acquired during table creation.
    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    Ignore_error_handler ignore_handler;
    Strict_error_handler strict_handler;
    if (lex->is_ignore())
      thd->push_internal_handler(&ignore_handler);
    else if (thd->is_strict_mode())
      thd->push_internal_handler(&strict_handler);

    res = populate_table(thd, lex);

    // Count the number of statements offloaded to a secondary storage engine.
    if (using_secondary_storage_engine() && lex->unit->is_executed())
      ++thd->status_var.secondary_engine_execution_count;

    if (lex->is_ignore() || thd->is_strict_mode()) thd->pop_internal_handler();
    lex->cleanup(false);
    thd->clear_current_query_costs();
    lex->clear_values_map();

    // Abort the result set if execution ended in error
    if (res) result->abort_result_set(thd);

    result->cleanup();

    lex->link_first_table_back(create_table, link_to_local);
    THD_STAGE_INFO(thd, stage_end);
  } else {
    Strict_error_handler strict_handler;
    /* Push Strict_error_handler */
    if (!lex->is_ignore() && thd->is_strict_mode())
      thd->push_internal_handler(&strict_handler);
    /* regular create */
    if (create_info.options & HA_LEX_CREATE_TABLE_LIKE) {
      /* CREATE TABLE ... LIKE ... */
      res = mysql_create_like_table(thd, create_table, query_expression_tables,
                                    &create_info);
    } else {
      /* Regular CREATE TABLE */
      res = mysql_create_table(thd, create_table, &create_info, &alter_info);
    }
    /* Pop Strict_error_handler */
    if (!lex->is_ignore() && thd->is_strict_mode()) thd->pop_internal_handler();
    if (!res) {
      /* in case of create temp tables if @@session_track_state_change is
         ON then send session state notification in OK packet */
      if (create_info.options & HA_LEX_CREATE_TMP_TABLE &&
          thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
              ->is_enabled())
        thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
            ->mark_as_changed(thd, {});
      my_ok(thd);
    }
  }
  // The following code is required to make CREATE TABLE re-execution safe.
  // @todo Consider refactoring this code.
  if (part_info != nullptr) {
    if (part_info->part_expr != nullptr &&
        part_info->part_expr->type() == Item::FIELD_ITEM)
      down_cast<Item_field *>(part_info->part_expr)->reset_field();

    if (part_info->subpart_expr != nullptr &&
        part_info->subpart_expr->type() == Item::FIELD_ITEM)
      down_cast<Item_field *>(part_info->subpart_expr)->reset_field();
  }
  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_gipk.cc
Function: validate_invisible_primary_key_generation not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_gipk.cc
Function: validate_invisible_primary_key_generation not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_gipk.cc
Function: validate_invisible_primary_key_generation not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::rollback
int MYSQL_BIN_LOG::rollback(THD *thd, bool all) {
  int error = 0;
  bool stuff_logged = false;
  binlog_cache_mngr *cache_mngr = thd_get_cache_mngr(thd);
  bool is_empty = false;

  DBUG_TRACE;
  DBUG_PRINT("enter",
             ("all: %s, cache_mngr: 0x%llx, thd->is_error: %s", YESNO(all),
              (ulonglong)cache_mngr, YESNO(thd->is_error())));
  /*
    Defer XA-transaction rollback until its XA-rollback event is recorded.
    When we are executing a ROLLBACK TO SAVEPOINT, we
    should only clear the caches since this function is called as part
    of the engine rollback.
    In other cases we roll back the transaction in the engines early
    since this will release locks and allow other transactions to
    start executing.
  */
  if (is_xa_rollback(thd)) {
    auto xs = thd->get_transaction()->xid_state();

    assert(all || !xs->is_binlogged() ||
           (!xs->is_detached() && thd->is_error()));

    is_empty = !xs->is_binlogged();

    if ((error = this->write_xa_to_cache(thd)) != 0) goto end;

    cache_mngr = thd_get_cache_mngr(thd);
  } else if (thd->lex->sql_command != SQLCOM_ROLLBACK_TO_SAVEPOINT)
    if ((error = trx_coordinator::rollback_in_engines(thd, all))) goto end;

  /*
    If there is no cache manager, or if there is nothing in the
    caches, there are no caches to roll back, so we're trivially done
    unless XA-ROLLBACK that yet to run rollback_low().
  */
  if (cache_mngr == nullptr || cache_mngr->is_binlog_empty()) {
    goto end;
  }

  DBUG_PRINT("debug", ("all.cannot_safely_rollback(): %s, trx_cache_empty: %s",
                       YESNO(thd->get_transaction()->cannot_safely_rollback(
                           Transaction_ctx::SESSION)),
                       YESNO(cache_mngr->trx_cache.is_binlog_empty())));
  DBUG_PRINT("debug",
             ("stmt.cannot_safely_rollback(): %s, stmt_cache_empty: %s",
              YESNO(thd->get_transaction()->cannot_safely_rollback(
                  Transaction_ctx::STMT)),
              YESNO(cache_mngr->stmt_cache.is_binlog_empty())));

  /*
    If an incident event is set we do not flush the content of the statement
    cache because it may be corrupted.
  */
  if (cache_mngr->stmt_cache.has_incident()) {
    const char *err_msg =
        "The content of the statement cache is corrupted "
        "while writing a rollback record of the transaction "
        "to the binary log.";
    error = write_incident(thd, true /*need_lock_log=true*/, err_msg);
    cache_mngr->stmt_cache.reset();
  } else if (!cache_mngr->stmt_cache.is_binlog_empty()) {
    if (thd->lex->sql_command == SQLCOM_CREATE_TABLE &&
        !thd->lex->query_block->field_list_is_empty() && /* With select */
        !(thd->lex->create_info->options & HA_LEX_CREATE_TMP_TABLE) &&
        thd->is_current_stmt_binlog_format_row()) {
      /*
        In row based binlog format, we reset the binlog statement cache
        when rolling back a single statement 'CREATE...SELECT' transaction,
        since the 'CREATE TABLE' event was put in the binlog statement cache.
      */
      cache_mngr->stmt_cache.reset();
    } else {
      if ((error = cache_mngr->stmt_cache.finalize(thd))) goto end;
      stuff_logged = true;
    }
  }

  if (ending_trans(thd, all)) {
    if (trans_cannot_safely_rollback(thd)) {
      auto xs = thd->get_transaction()->xid_state();
      std::string query{"ROLLBACK"};

      if (is_xa_rollback(thd)) {
        /* this block is relevant only for not prepared yet and "local" xa trx
         */
        assert(
            thd->get_transaction()->xid_state()->has_state(XID_STATE::XA_IDLE));

        std::ostringstream oss;
        oss << "XA ROLLBACK " << *xs->get_xid() << std::flush;
        query = oss.str();
      }
      /*
        If the transaction is being rolled back and contains changes that
        cannot be rolled back, the trx-cache's content is flushed.
      */
      Query_log_event end_evt(thd, query.data(), query.length(), true, false,
                              true, 0, true);
      error = thd->lex->sql_command != SQLCOM_XA_ROLLBACK
                  ? cache_mngr->trx_cache.finalize(thd, &end_evt)
                  : cache_mngr->trx_cache.finalize(thd, &end_evt, xs);
      stuff_logged = true;
    } else {
      /*
        If the transaction is being rolled back and its changes can be
        rolled back, the trx-cache's content is truncated.
      */
      error = cache_mngr->trx_cache.truncate(thd, all);

      DBUG_EXECUTE_IF("ensure_binlog_cache_is_reset", {
        /* Assert that binlog cache is reset at rollback time. */
        assert(binlog_cache_is_reset);
        binlog_cache_is_reset = false;
      };);
    }
  } else {
    /*
      If a statement is being rolled back, it is necessary to know
      exactly why a statement may not be safely rolled back as in
      some specific situations the trx-cache can be truncated.

      If a temporary table is created or dropped, the trx-cache is not
      truncated. Note that if the stmt-cache is used, there is nothing
      to truncate in the trx-cache.

      If a non-transactional table is updated and the binlog format is
      statement, the trx-cache is not truncated. The trx-cache is used
      when the direct option is off and a transactional table has been
      updated before the current statement in the context of the
      current transaction. Note that if the stmt-cache is used there is
      nothing to truncate in the trx-cache.

      If other binlog formats are used, updates to non-transactional
      tables are written to the stmt-cache and trx-cache can be safely
      truncated, if necessary.
    */
    if (thd->get_transaction()->has_dropped_temp_table(Transaction_ctx::STMT) ||
        thd->get_transaction()->has_created_temp_table(Transaction_ctx::STMT) ||
        (thd->get_transaction()->has_modified_non_trans_table(
             Transaction_ctx::STMT) &&
         thd->variables.binlog_format == BINLOG_FORMAT_STMT)) {
      /*
        If the statement is being rolled back and dropped or created a
        temporary table or modified a non-transactional table and the
        statement-based replication is in use, the statement's changes
        in the trx-cache are preserved.
      */
      cache_mngr->trx_cache.set_prev_position(MY_OFF_T_UNDEF);
    } else {
      /*
        Otherwise, the statement's changes in the trx-cache are
        truncated.
      */
      error = cache_mngr->trx_cache.truncate(thd, all);
    }
  }
  if (stuff_logged) {
    Transaction_ctx *trn_ctx = thd->get_transaction();
    trn_ctx->store_commit_parent(
        m_dependency_tracker.get_max_committed_timestamp());
  }

  DBUG_PRINT("debug", ("error: %d", error));
  if (error == 0 && stuff_logged) {
    CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP("before_invoke_before_commit_hook");
    if (RUN_HOOK(
            transaction, before_commit,
            (thd, all, thd_get_cache_mngr(thd)->get_trx_cache(),
             thd_get_cache_mngr(thd)->get_stmt_cache(),
             max<my_off_t>(max_binlog_cache_size, max_binlog_stmt_cache_size),
             false))) {
      // Reset the thread OK status before changing the outcome.
      if (thd->get_stmt_da()->is_ok())
        thd->get_stmt_da()->reset_diagnostics_area();
      my_error(ER_RUN_HOOK_ERROR, MYF(0), "before_commit");
      return RESULT_ABORTED;
    }
    // XA rollback is always accepted.
    assert(!thd->get_transaction()
                ->get_rpl_transaction_ctx()
                ->is_transaction_rollback());

    error = ordered_commit(thd, all, /* skip_commit */ true);

    // Inform hook listeners that a XA ROLLBACK did commit, that
    // is, did log a transaction to the binary log.
    if (!error && is_xa_rollback(thd))
      (void)RUN_HOOK(transaction, after_commit, (thd, all));
  }

  if (check_write_error(thd)) {
    /*
      We reach this point if the effect of a statement did not properly get into
      a cache and need to be rolled back.
    */
    error |= cache_mngr->trx_cache.truncate(thd, all);
  }

end:
  // The caches may be empty if an `XA ROLLBACK` was issued just after `XA
  // END`. In that case, the BCG will not be invoked and we need to
  // rollback in SEs and finalize GTID state.
  if (!error && !stuff_logged && is_xa_rollback(thd)) {
    error = trx_coordinator::rollback_in_engines(thd, all);
    if (!error && !thd->is_error()) {
      /*
        XA-rollback ignores the gtid_state, if the transaciton
        is empty.
      */
      if (is_empty && !thd->slave_thread) gtid_state->update_on_rollback(thd);
      /*
        XA-rollback commits the new gtid_state, if transaction
        is not empty.
      */
      else {
        gtid_state->update_on_commit(thd);
        /*
          Inform hook listeners that a XA ROLLBACK did commit, that
          is, did log a transaction to the binary log.
        */
        (void)RUN_HOOK(transaction, after_commit, (thd, all));
      }
    }
  }
  /*
    When a statement errors out on auto-commit mode it is rollback
    implicitly, so the same should happen to its GTID.
  */
  if (!thd->in_active_multi_stmt_transaction())
    gtid_state->update_on_rollback(thd);

  /*
    TODO: some errors are overwritten, which may cause problem,
    fix it later.
  */
  DBUG_PRINT("return", ("error: %d", error));
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: THD::decide_logging_format
int THD::decide_logging_format(Table_ref *tables) {
  DBUG_TRACE;
  DBUG_PRINT("info", ("query: %s", query().str));
  DBUG_PRINT("info", ("variables.binlog_format: %lu", variables.binlog_format));
  DBUG_PRINT("info", ("lex->get_stmt_unsafe_flags(): 0x%x",
                      lex->get_stmt_unsafe_flags()));

#if defined(ENABLED_DEBUG_SYNC)
  if (!is_attachable_ro_transaction_active())
    DEBUG_SYNC(this, "begin_decide_logging_format");
#endif

  reset_binlog_local_stmt_filter();

  /*
    We should not decide logging format if the binlog is closed or
    binlogging is off, or if the statement is filtered out from the
    binlog by filtering rules.
  */
  if (mysql_bin_log.is_open() && (variables.option_bits & OPTION_BIN_LOG) &&
      !(variables.binlog_format == BINLOG_FORMAT_STMT &&
        !binlog_filter->db_ok(m_db.str))) {
    /*
      Compute one bit field with the union of all the engine
      capabilities, and one with the intersection of all the engine
      capabilities.
    */
    handler::Table_flags flags_write_some_set = 0;
    handler::Table_flags flags_access_some_set = 0;
    handler::Table_flags flags_write_all_set =
        HA_BINLOG_ROW_CAPABLE | HA_BINLOG_STMT_CAPABLE;

    /*
       If different types of engines are about to be updated.
       For example: Innodb and Falcon; Innodb and MyIsam.
    */
    bool multi_write_engine = false;
    /*
       If different types of engines are about to be accessed
       and any of them is about to be updated. For example:
       Innodb and Falcon; Innodb and MyIsam.
    */
    bool multi_access_engine = false;
    /*
      Track if statement creates or drops a temporary table
      and log in ROW if it does.
*/
    bool is_create_drop_temp_table = false;
    /*
       Identifies if a table is changed.
    */
    bool is_write = false;
    /*
       A pointer to a previous table that was changed.
    */
    TABLE *prev_write_table = nullptr;
    /*
       A pointer to a previous table that was accessed.
    */
    TABLE *prev_access_table = nullptr;
    /*
      True if at least one table is transactional.
    */
    bool write_to_some_transactional_table = false;
    /*
      True if at least one table is non-transactional.
    */
    bool write_to_some_non_transactional_table = false;
    /*
       True if all non-transactional tables that has been updated
       are temporary.
    */
    bool write_all_non_transactional_are_tmp_tables = true;
    /**
      The number of tables used in the current statement,
      that should be replicated.
    */
    uint replicated_tables_count = 0;
    /**
      The number of tables written to in the current statement,
      that should not be replicated.
      A table should not be replicated when it is considered
      'local' to a MySQL instance.
      Currently, these tables are:
      - mysql.slow_log
      - mysql.general_log
      - mysql.slave_relay_log_info
      - mysql.slave_master_info
      - mysql.slave_worker_info
      - performance_schema.*
      - TODO: information_schema.*
      In practice, from this list, only performance_schema.* tables
      are written to by user queries.
    */
    uint non_replicated_tables_count = 0;
    /**
      Indicate whether we already reported a warning
      on modifying gtid_executed table.
    */
    int warned_gtid_executed_table = 0;
#ifndef NDEBUG
    {
      DBUG_PRINT("debug", ("prelocked_mode: %s",
                           get_locked_tables_mode_name(locked_tables_mode)));
    }
#endif

    if (variables.binlog_format != BINLOG_FORMAT_ROW && tables) {
      /*
        DML statements that modify a table with an auto_increment column based
        on rows selected from a table are unsafe as the order in which the rows
        are fetched from the select tables cannot be determined and may differ
        on master and slave.
       */
      if (has_write_table_with_auto_increment_and_query_block(tables))
        lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_WRITE_AUTOINC_SELECT);

      if (has_write_table_auto_increment_not_first_in_pk(tables))
        lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_AUTOINC_NOT_FIRST);

      /*
        A query that modifies autoinc column in sub-statement can make the
        master and slave inconsistent.
        We can solve these problems in mixed mode by switching to binlogging
        if at least one updated table is used by sub-statement
       */
      if (lex->requires_prelocking() &&
          has_write_table_with_auto_increment(lex->first_not_own_table()))
        lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_AUTOINC_COLUMNS);

      /*
        A query that modifies a table with a non-deterministic column default
        expression in a substatement, can make the master and the slave
        inconsistent. Switch to row logging in mixed mode, and raise a warning
        in statement mode.
      */
      if (lex->requires_prelocking() &&
          has_write_table_with_nondeterministic_default(
              lex->first_not_own_table()))
        lex->set_stmt_unsafe(
            LEX::BINLOG_STMT_UNSAFE_DEFAULT_EXPRESSION_IN_SUBSTATEMENT);

      /*
        A DML or DDL statement is unsafe if it reads a ACL table while
        modifying the table, because SE skips acquiring row locks.
        Therefore rows seen by DML or DDL may not have same effect on slave.

        We skip checking the same under lock tables mode, because we do
        not skip row locks on ACL table in this mode.
      */
      if (has_acl_table_read(this, tables)) {
        lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_ACL_TABLE_READ_IN_DML_DDL);
      }
    }

    /*
      Get the capabilities vector for all involved storage engines and
      mask out the flags for the binary log.
    */
    for (Table_ref *table = tables; table; table = table->next_global) {
      if (table->is_placeholder()) {
        /*
          Detect if this is a CREATE TEMPORARY or DROP of a
          temporary table. This will be used later in determining whether to
          log in ROW or STMT if MIXED replication is being used.
        */
        if (!is_create_drop_temp_table && !table->table &&
            ((lex->sql_command == SQLCOM_CREATE_TABLE &&
              (lex->create_info->options & HA_LEX_CREATE_TMP_TABLE)) ||
             ((lex->sql_command == SQLCOM_DROP_TABLE ||
               lex->sql_command == SQLCOM_TRUNCATE) &&
              find_temporary_table(this, table)))) {
          is_create_drop_temp_table = true;
        }
        continue;
      }
      handler::Table_flags const flags = table->table->file->ha_table_flags();

      DBUG_PRINT("info", ("table: %s; ha_table_flags: 0x%llx",
                          table->table_name, flags));

      if (table->table->no_replicate) {
        if (!warned_gtid_executed_table) {
          warned_gtid_executed_table =
              gtid_state->warn_or_err_on_modify_gtid_table(this, table);
          /*
            Do not allow users to modify the gtid_executed table
            explicitly by a XA transaction.
          */
          if (warned_gtid_executed_table == 2) return -1;
        }
        /*
          The statement uses a table that is not replicated.
          The following properties about the table:
          - persistent / transient
          - transactional / non transactional
          - temporary / permanent
          - read or write
          - multiple engines involved because of this table
          are not relevant, as this table is completely ignored.
          Because the statement uses a non replicated table,
          using STATEMENT format in the binlog is impossible.
          Either this statement will be discarded entirely,
          or it will be logged (possibly partially) in ROW format.
        */
        lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_SYSTEM_TABLE);

        if (table->lock_descriptor().type >= TL_WRITE_ALLOW_WRITE) {
          non_replicated_tables_count++;
          continue;
        }
      }

      replicated_tables_count++;

      bool trans = table->table->file->has_transactions();

      if (table->lock_descriptor().type >= TL_WRITE_ALLOW_WRITE) {
        write_to_some_transactional_table =
            write_to_some_transactional_table || trans;

        write_to_some_non_transactional_table =
            write_to_some_non_transactional_table || !trans;

        if (prev_write_table &&
            prev_write_table->file->ht != table->table->file->ht)
          multi_write_engine = true;

        if (table->table->s->tmp_table)
          lex->set_stmt_accessed_table(
              trans ? LEX::STMT_WRITES_TEMP_TRANS_TABLE
                    : LEX::STMT_WRITES_TEMP_NON_TRANS_TABLE);
        else
          lex->set_stmt_accessed_table(trans
                                           ? LEX::STMT_WRITES_TRANS_TABLE
                                           : LEX::STMT_WRITES_NON_TRANS_TABLE);

        /*
         Non-transactional updates are allowed when row binlog format is
         used and all non-transactional tables are temporary.
         Binlog format is checked on THD::is_dml_gtid_compatible() method.
        */
        if (!trans)
          write_all_non_transactional_are_tmp_tables =
              write_all_non_transactional_are_tmp_tables &&
              table->table->s->tmp_table;

        flags_write_all_set &= flags;
        flags_write_some_set |= flags;
        is_write = true;

        prev_write_table = table->table;

        /*
          It should be marked unsafe if a table which uses a fulltext parser
          plugin is modified. See also bug#48183.
        */
        if (!lex->is_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_FULLTEXT_PLUGIN)) {
          if (fulltext_unsafe_set(table->table->s))
            lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_FULLTEXT_PLUGIN);
        }
        /*
          INSERT...ON DUPLICATE KEY UPDATE on a table with more than one unique
          keys can be unsafe. Check for it if the flag is already not marked for
          the given statement.
        */
        if (!lex->is_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_INSERT_TWO_KEYS) &&
            lex->sql_command == SQLCOM_INSERT &&
            lex->duplicates == DUP_UPDATE) {
          uint keys = table->table->s->keys, i = 0, unique_keys = 0;
          for (KEY *keyinfo = table->table->s->key_info;
               i < keys && unique_keys <= 1; i++, keyinfo++) {
            if (keyinfo->flags & HA_NOSAME) unique_keys++;
          }
          if (unique_keys > 1)
            lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_INSERT_TWO_KEYS);
        }
      }
      if (lex->get_using_match()) {
        if (fulltext_unsafe_set(table->table->s))
          lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_FULLTEXT_PLUGIN);
      }

      flags_access_some_set |= flags;

      if (lex->sql_command != SQLCOM_CREATE_TABLE ||
          (lex->sql_command == SQLCOM_CREATE_TABLE &&
           ((lex->create_info->options & HA_LEX_CREATE_TMP_TABLE) ||
            (table->lock_descriptor().type < TL_WRITE_ALLOW_WRITE)))) {
        if (table->table->s->tmp_table)
          lex->set_stmt_accessed_table(
              trans ? LEX::STMT_READS_TEMP_TRANS_TABLE
                    : LEX::STMT_READS_TEMP_NON_TRANS_TABLE);
        else
          lex->set_stmt_accessed_table(trans ? LEX::STMT_READS_TRANS_TABLE
                                             : LEX::STMT_READS_NON_TRANS_TABLE);
      }

      if (prev_access_table &&
          prev_access_table->file->ht != table->table->file->ht)
        multi_access_engine = true;

      prev_access_table = table->table;
    }
    assert(!is_write || write_to_some_transactional_table ||
           write_to_some_non_transactional_table);
    /*
      write_all_non_transactional_are_tmp_tables may be true if any
      non-transactional table was not updated, so we fix its value here.
    */
    write_all_non_transactional_are_tmp_tables =
        write_all_non_transactional_are_tmp_tables &&
        write_to_some_non_transactional_table;

    DBUG_PRINT("info", ("flags_write_all_set: 0x%llx", flags_write_all_set));
    DBUG_PRINT("info", ("flags_write_some_set: 0x%llx", flags_write_some_set));
    DBUG_PRINT("info",
               ("flags_access_some_set: 0x%llx", flags_access_some_set));
    DBUG_PRINT("info", ("multi_write_engine: %d", multi_write_engine));
    DBUG_PRINT("info", ("multi_access_engine: %d", multi_access_engine));

    int error = 0;
    int unsafe_flags;

    /*
      With transactional data dictionary, CREATE TABLE runs as one statement
      in a multi-statement transaction internally. Revert this for the
      purposes of determining mixed statement safety.
    */
    const bool multi_stmt_trans = lex->sql_command != SQLCOM_CREATE_TABLE &&
                                  in_multi_stmt_transaction_mode();
    bool trans_table = trans_has_updated_trans_table(this);
    bool binlog_direct = variables.binlog_direct_non_trans_update;

    if (lex->is_mixed_stmt_unsafe(multi_stmt_trans, binlog_direct, trans_table,
                                  tx_isolation))
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_MIXED_STATEMENT);
    else if (multi_stmt_trans && trans_table && !binlog_direct &&
             lex->stmt_accessed_table(LEX::STMT_WRITES_NON_TRANS_TABLE))
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_NONTRANS_AFTER_TRANS);

    /*
      If more than one engine is involved in the statement and at
      least one is doing it's own logging (is *self-logging*), the
      statement cannot be logged atomically, so we generate an error
      rather than allowing the binlog to become corrupt.
    */
    if (multi_write_engine && (flags_write_some_set & HA_HAS_OWN_BINLOGGING))
      my_error((error = ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE),
               MYF(0));
    else if (multi_access_engine &&
             flags_access_some_set & HA_HAS_OWN_BINLOGGING)
      lex->set_stmt_unsafe(
          LEX::BINLOG_STMT_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE);

    /* XA is unsafe for statements */
    if (is_write &&
        !get_transaction()->xid_state()->has_state(XID_STATE::XA_NOTR))
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_XA);

    DBUG_EXECUTE_IF("make_stmt_only_engines",
                    { flags_write_all_set = HA_BINLOG_STMT_CAPABLE; };);

    /* both statement-only and row-only engines involved */
    if ((flags_write_all_set &
         (HA_BINLOG_STMT_CAPABLE | HA_BINLOG_ROW_CAPABLE)) == 0) {
      /*
        1. Error: Binary logging impossible since both row-incapable
           engines and statement-incapable engines are involved
      */
      my_error((error = ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE), MYF(0));
    }
    /* statement-only engines involved */
    else if ((flags_write_all_set & HA_BINLOG_ROW_CAPABLE) == 0) {
      if (lex->is_stmt_row_injection()) {
        /*
          4. Error: Cannot execute row injection since table uses
             storage engine limited to statement-logging
        */
        my_error((error = ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE), MYF(0));
      } else if (variables.binlog_format == BINLOG_FORMAT_ROW &&
                 sqlcom_can_generate_row_events(this->lex->sql_command)) {
        /*
          2. Error: Cannot modify table that uses a storage engine
             limited to statement-logging when BINLOG_FORMAT = ROW
        */
        my_error((error = ER_BINLOG_ROW_MODE_AND_STMT_ENGINE), MYF(0));
      } else if (variables.binlog_format == BINLOG_FORMAT_MIXED &&
                 ((unsafe_flags = lex->get_stmt_unsafe_flags()) != 0)) {
        /*
          3. Error: Cannot execute statement: binlogging of unsafe
             statement is impossible when storage engine is limited to
             statement-logging and BINLOG_FORMAT = MIXED.
        */
        for (int unsafe_type = 0; unsafe_type < LEX::BINLOG_STMT_UNSAFE_COUNT;
             unsafe_type++)
          if (unsafe_flags & (1 << unsafe_type))
            my_error(
                (error = ER_BINLOG_UNSAFE_AND_STMT_ENGINE), MYF(0),
                ER_THD_NONCONST(current_thd,
                                LEX::binlog_stmt_unsafe_errcode[unsafe_type]));
      } else if (is_write &&
                 ((unsafe_flags = lex->get_stmt_unsafe_flags()) != 0)) {
        /*
          7. Warning: Unsafe statement logged as statement due to
             binlog_format = STATEMENT
        */
        binlog_unsafe_warning_flags |= unsafe_flags;
        DBUG_PRINT("info", ("Scheduling warning to be issued by "
                            "binlog_query: '%s'",
                            ER_THD(current_thd, ER_BINLOG_UNSAFE_STATEMENT)));
        DBUG_PRINT("info", ("binlog_unsafe_warning_flags: 0x%x",
                            binlog_unsafe_warning_flags));
      }
      /* log in statement format! */
    }
    /* no statement-only engines */
    else {
      /* binlog_format = STATEMENT */
      if (variables.binlog_format == BINLOG_FORMAT_STMT) {
        if (lex->is_stmt_row_injection()) {
          /*
            6. Error: Cannot execute row injection since
               BINLOG_FORMAT = STATEMENT
          */
          my_error((error = ER_BINLOG_ROW_INJECTION_AND_STMT_MODE), MYF(0));
        } else if ((flags_write_all_set & HA_BINLOG_STMT_CAPABLE) == 0 &&
                   sqlcom_can_generate_row_events(this->lex->sql_command)) {
          /*
            5. Error: Cannot modify table that uses a storage engine
               limited to row-logging when binlog_format = STATEMENT
          */
          my_error((error = ER_BINLOG_STMT_MODE_AND_ROW_ENGINE), MYF(0), "");
        } else if (is_write &&
                   (unsafe_flags = lex->get_stmt_unsafe_flags()) != 0) {
          /*
            7. Warning: Unsafe statement logged as statement due to
               binlog_format = STATEMENT
          */
          binlog_unsafe_warning_flags |= unsafe_flags;
          DBUG_PRINT("info", ("Scheduling warning to be issued by "
                              "binlog_query: '%s'",
                              ER_THD(current_thd, ER_BINLOG_UNSAFE_STATEMENT)));
          DBUG_PRINT("info", ("binlog_unsafe_warning_flags: 0x%x",
                              binlog_unsafe_warning_flags));
        }
        /* log in statement format! */
      }
      /* No statement-only engines and binlog_format != STATEMENT.
         I.e., nothing prevents us from row logging if needed. */
      else {
        if (lex->is_stmt_unsafe() || lex->is_stmt_row_injection() ||
            lex->is_stmt_unsafe_with_mixed_mode() ||
            (flags_write_all_set & HA_BINLOG_STMT_CAPABLE) == 0 ||
            lex->stmt_accessed_table(LEX::STMT_READS_TEMP_TRANS_TABLE) ||
            lex->stmt_accessed_table(LEX::STMT_READS_TEMP_NON_TRANS_TABLE) ||
            is_create_drop_temp_table) {
#ifndef NDEBUG
          int flags = lex->get_stmt_unsafe_flags();
          DBUG_PRINT("info", ("setting row format for unsafe statement"));
          for (int i = 0; i < Query_tables_list::BINLOG_STMT_UNSAFE_COUNT;
               i++) {
            if (flags & (1 << i))
              DBUG_PRINT(
                  "info",
                  ("unsafe reason: %s",
                   ER_THD_NONCONST(
                       current_thd,
                       Query_tables_list::binlog_stmt_unsafe_errcode[i])));
          }
          DBUG_PRINT("info",
                     ("is_row_injection=%d", lex->is_stmt_row_injection()));
          DBUG_PRINT("info", ("stmt_capable=%llu",
                              (flags_write_all_set & HA_BINLOG_STMT_CAPABLE)));
          DBUG_PRINT("info", ("lex->is_stmt_unsafe_with_mixed_mode = %d",
                              lex->is_stmt_unsafe_with_mixed_mode()));
#endif
          /* log in row format! */
          set_current_stmt_binlog_format_row_if_mixed();
        }
      }
    }

    if (non_replicated_tables_count > 0) {
      if ((replicated_tables_count == 0) || !is_write) {
        DBUG_PRINT("info",
                   ("decision: no logging, no replicated table affected"));
        set_binlog_local_stmt_filter();
      } else {
        if (!is_current_stmt_binlog_format_row()) {
          my_error((error = ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES), MYF(0));
        } else {
          clear_binlog_local_stmt_filter();
        }
      }
    } else {
      clear_binlog_local_stmt_filter();
    }

    if (!error &&
        !is_dml_gtid_compatible(write_to_some_transactional_table,
                                write_to_some_non_transactional_table,
                                write_all_non_transactional_are_tmp_tables))
      error = 1;

    if (error) {
      DBUG_PRINT("info", ("decision: no logging since an error was generated"));
      return -1;
    }

    if (is_write &&
        lex->sql_command != SQLCOM_END /* rows-event applying by slave */) {
      /*
        Master side of DML in the STMT format events parallelization.
        All involving table db:s are stored in a abc-ordered name list.
        In case the number of databases exceeds MAX_DBS_IN_EVENT_MTS maximum
        the list gathering breaks since it won't be sent to the slave.
      */
      for (Table_ref *table = tables; table; table = table->next_global) {
        if (table->is_placeholder()) continue;

        assert(table->table);

        if (table->table->s->is_referenced_by_foreign_key()) {
          /*
             FK-referenced dbs can't be gathered currently. The following
             event will be marked for sequential execution on slave.
          */
          binlog_accessed_db_names = nullptr;
          add_to_binlog_accessed_dbs("");
          break;
        }
        if (!is_current_stmt_binlog_format_row())
          add_to_binlog_accessed_dbs(table->db);
      }
    }
    DBUG_PRINT("info",
               ("decision: logging in %s format",
                is_current_stmt_binlog_format_row() ? "ROW" : "STATEMENT"));

    if (variables.binlog_format == BINLOG_FORMAT_ROW &&
        (lex->sql_command == SQLCOM_UPDATE ||
         lex->sql_command == SQLCOM_UPDATE_MULTI ||
         lex->sql_command == SQLCOM_DELETE ||
         lex->sql_command == SQLCOM_DELETE_MULTI)) {
      String table_names;
      /*
        Generate a warning for UPDATE/DELETE statements that modify a
        BLACKHOLE table, as row events are not logged in row format.
      */
      for (Table_ref *table = tables; table; table = table->next_global) {
        if (table->is_placeholder()) continue;
        if (table->table->file->ht->db_type == DB_TYPE_BLACKHOLE_DB &&
            table->lock_descriptor().type >= TL_WRITE_ALLOW_WRITE) {
          table_names.append(table->table_name);
          table_names.append(",");
        }
      }
      if (!table_names.is_empty()) {
        bool is_update = (lex->sql_command == SQLCOM_UPDATE ||
                          lex->sql_command == SQLCOM_UPDATE_MULTI);
        /*
          Replace the last ',' with '.' for table_names
        */
        table_names.replace(table_names.length() - 1, 1, ".", 1);
        push_warning_printf(
            this, Sql_condition::SL_WARNING, WARN_ON_BLOCKHOLE_IN_RBR,
            ER_THD(this, WARN_ON_BLOCKHOLE_IN_RBR),
            is_update ? "UPDATE" : "DELETE", table_names.c_ptr());
      }
    }
  } else {
    DBUG_PRINT(
        "info",
        ("decision: no logging since "
         "mysql_bin_log.is_open() = %d "
         "and (options & OPTION_BIN_LOG) = 0x%llx "
         "and binlog_format = %lu "
         "and binlog_filter->db_ok(db) = %d",
         mysql_bin_log.is_open(), (variables.option_bits & OPTION_BIN_LOG),
         variables.binlog_format, binlog_filter->db_ok(m_db.str)));

    for (Table_ref *table = tables; table; table = table->next_global) {
      if (!table->is_placeholder() && table->table->no_replicate &&
          gtid_state->warn_or_err_on_modify_gtid_table(this, table))
        break;
    }
  }

#if defined(ENABLED_DEBUG_SYNC)
  if (!is_attachable_ro_transaction_active())
    DEBUG_SYNC(this, "end_decide_logging_format");
#endif

  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: THD::is_ddl_gtid_compatible
bool THD::is_ddl_gtid_compatible() {
  DBUG_TRACE;

  bool is_binlog_open{mysql_bin_log.is_open()};
  bool is_binlog_enabled_for_session{(variables.option_bits & OPTION_BIN_LOG) !=
                                     0};
  DBUG_PRINT("info", ("is_binlog_open:%d is_binlog_enabled_for_session:%d",
                      is_binlog_open, is_binlog_enabled_for_session));
  // If we are not going to log, then no problem, we can execute any
  // statement.
  if (!is_binlog_open || !is_binlog_enabled_for_session) return true;

  bool is_create_table{lex->sql_command == SQLCOM_CREATE_TABLE};
  bool is_create_temporary_table{false};
  bool is_create_table_select{false};
  bool is_create_table_atomic{false};
  if (is_create_table) {
    // Check this conditionally, since create_info and/or query_block
    // may be uninitialized if sql_command!=SQLCOM_CREATE_TABLE.
    is_create_temporary_table =
        (lex->create_info->options & HA_LEX_CREATE_TMP_TABLE);
    if (!is_create_temporary_table)
      is_create_table_select = !lex->query_block->field_list_is_empty();
    is_create_table_atomic =
        get_default_handlerton(this, lex->create_info->db_type)->flags &
        HTON_SUPPORTS_ATOMIC_DDL;
  }

  bool is_drop_table{lex->sql_command == SQLCOM_DROP_TABLE};
  bool is_drop_temporary_table{false};
  if (is_drop_table) is_drop_temporary_table = lex->drop_temporary;

  bool is_in_transaction{in_multi_stmt_transaction_mode()};

  bool is_in_sub_statement{in_sub_stmt != 0};

  bool is_binlog_format_statement{variables.binlog_format ==
                                  BINLOG_FORMAT_STMT};

  DBUG_PRINT("info", ("is_create_table:%d is_create_temporary_table:%d "
                      "is_create_table_select:%d is_create_table_atomic:%d "
                      "is_drop_table:%d is_drop_temporary_table:%d "
                      "is_in_transaction:%d is_in_sub_statement:%d "
                      "is_binlog_format_statement:%d",
                      is_create_table, is_create_temporary_table,
                      is_create_table_select, is_create_table_atomic,
                      is_drop_table, is_drop_temporary_table, is_in_transaction,
                      is_in_sub_statement, is_binlog_format_statement));

  if (is_create_table_select && !is_create_temporary_table &&
      !is_create_table_atomic) {
    /*
      CREATE ... SELECT (without TEMPORARY) for engines not supporting
      atomic DDL is unsafe because if binlog_format=row it will be
      logged as a CREATE TABLE followed by row events, re-executed
      non-atomically as two transactions, and then written to the
      slave's binary log as two separate transactions with the same
      GTID.
    */
    return handle_gtid_consistency_violation(
        this, ER_GTID_UNSAFE_CREATE_SELECT,
        ER_RPL_GTID_UNSAFE_STMT_CREATE_SELECT);
  }

  if ((is_create_temporary_table || is_drop_temporary_table) &&
      is_binlog_format_statement &&
      (is_in_transaction || is_in_sub_statement)) {
    /*
      When @@session.binlog_format=statement,
      [CREATE|DROP] TEMPORARY TABLE is unsafe to execute inside a
      transaction or Procedure, because the [CREATE|DROP] statement on
      the temporary table will be executed and written into binary log
      with a GTID even if the transaction or Procedure is rolled back.
    */
    return handle_gtid_consistency_violation(
        this, ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR,
        ER_SERVER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR);
  }

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster.cc
Function: ha_ndbcluster::table_flags
ulonglong ha_ndbcluster::table_flags(void) const {
  THD *thd = current_thd;
  ulonglong f = HA_NULL_IN_KEY | HA_AUTO_PART_KEY | HA_NO_PREFIX_CHAR_KEYS |
                HA_CAN_GEOMETRY | HA_CAN_BIT_FIELD |
                HA_PRIMARY_KEY_REQUIRED_FOR_POSITION | HA_PARTIAL_COLUMN_READ |
                HA_HAS_OWN_BINLOGGING | HA_BINLOG_ROW_CAPABLE |
                HA_COUNT_ROWS_INSTANT | HA_READ_BEFORE_WRITE_REMOVAL |
                HA_GENERATED_COLUMNS | 0;

  /*
    To allow for logging of NDB tables during stmt based logging;
    flag cabablity, but also turn off flag for OWN_BINLOGGING
  */
  if (thd->variables.binlog_format == BINLOG_FORMAT_STMT)
    f = (f | HA_BINLOG_STMT_CAPABLE) & ~HA_HAS_OWN_BINLOGGING;

  /*
     Allow MySQL Server to decide that STATEMENT logging should be used
     during TRUNCATE TABLE, thus writing the truncate query to the binlog
     in STATEMENT format. Basically this is shortcutting the logic
     in THD::decide_logging_format() to not handle the truncated
     table as a "no_replicate" table.
  */
  if (thd_sql_command(thd) == SQLCOM_TRUNCATE)
    f = (f | HA_BINLOG_STMT_CAPABLE) & ~HA_HAS_OWN_BINLOGGING;

  /**
   * To maximize join pushability we want const-table
   * optimization blocked if 'ndb_join_pushdown= on'
   */
  if (THDVAR(thd, join_pushdown)) f = f | HA_BLOCK_CONST_TABLE;

  return f;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster.cc
Function: ha_ndbcluster::start_statement
int ha_ndbcluster::start_statement(THD *thd, Thd_ndb *thd_ndb,
                                   uint table_count) {
  DBUG_TRACE;

  // Setup m_thd_ndb for quick access, to be used in all functions during trans
  m_thd_ndb = thd_ndb;

  m_thd_ndb->transaction_checks();

  if (table_count == 0) {
    const NdbTransaction *const trans = m_thd_ndb->trans;
    ndb_thd_register_trans(thd, trans == nullptr);

    if (thd_test_options(thd, OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN)) {
      m_thd_ndb->m_handler = nullptr;
    } else {
      // This is an autocommit, setup reference to this handler for use in
      // the commit phase, deferring execute for optimization reasons
      m_thd_ndb->m_handler = this;
    }

    if (trans == nullptr) {
      // Reset trans options
      m_thd_ndb->reset_trans_options();

      // Reset trans table stats
      m_thd_ndb->trans_tables.clear();

      // Check if NDB transaction should be started early
      const uint opti_node_select = THDVAR(thd, optimized_node_selection);
      DBUG_PRINT("enter", ("optimized_node_selection: %u", opti_node_select));
      if (!(opti_node_select & 2) || thd_sql_command(thd) == SQLCOM_LOAD) {
        int error;
        if (unlikely(!start_transaction(error))) {
          return error;
        }
      }

      if (!(thd_test_options(thd, OPTION_BIN_LOG)) ||
          thd->variables.binlog_format == BINLOG_FORMAT_STMT) {
        m_thd_ndb->set_trans_option(Thd_ndb::TRANS_NO_LOGGING);
      }
    }

  } else {
    // There are more than one handler involved, execute deferral not possible
    m_thd_ndb->m_handler = nullptr;
  }

  // store thread specific data first to set the right context
  m_autoincrement_prefetch = THDVAR(thd, autoincrement_prefetch_sz);

  release_blobs_buffer();

  // Register table stats for transaction
  m_trans_table_stats = m_thd_ndb->trans_tables.register_stats(m_share);
  if (m_trans_table_stats == nullptr) {
    return 1;
  }

  return 0;
}


