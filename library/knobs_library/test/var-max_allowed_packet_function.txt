-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: mysqld_list_processes
  This class implements callback function used by mysqld_list_processes() to
  list all the client process information.
*/
typedef Mem_root_array<thread_info *> Thread_info_array;
class List_process_list : public Do_THD_Impl {
 private:
  /* Username of connected client. */
  const char *m_user;
  Thread_info_array *m_thread_infos;
  /* THD of connected client. */
  THD *m_client_thd;
  size_t m_max_query_length;

 public:
  List_process_list(const char *user_value, Thread_info_array *thread_infos,
                    THD *thd_value, size_t max_query_length)
      : m_user(user_value),
        m_thread_infos(thread_infos),
        m_client_thd(thd_value),
        m_max_query_length(max_query_length) {
    push_deprecated_warn(m_client_thd, "INFORMATION_SCHEMA.PROCESSLIST",
                         "performance_schema.processlist");

    deprecated_use_i_s_processlist_last_timestamp = my_micro_time();
    deprecated_use_i_s_processlist_count++;
  }

  void operator()(THD *inspect_thd) override {
    DBUG_TRACE;

    thread_info *thd_info = nullptr;

    {
      MUTEX_LOCK(grd_secctx, &inspect_thd->LOCK_thd_security_ctx);

      Security_context *inspect_sctx = inspect_thd->security_context();

      LEX_CSTRING inspect_sctx_user = inspect_sctx->user();
      LEX_CSTRING inspect_sctx_host = inspect_sctx->host();
      LEX_CSTRING inspect_sctx_host_or_ip = inspect_sctx->host_or_ip();

      {
        MUTEX_LOCK(grd, &inspect_thd->LOCK_thd_protocol);

        if ((!(inspect_thd->get_protocol() &&
               inspect_thd->get_protocol()->connection_alive()) &&
             !inspect_thd->system_thread) ||
            (m_user && (inspect_thd->system_thread || !inspect_sctx_user.str ||
                        strcmp(inspect_sctx_user.str, m_user)))) {
          return;
        }
      }

      thd_info = new (m_client_thd->mem_root) thread_info;

      /* ID */
      thd_info->thread_id = inspect_thd->thread_id();

      /* USER */
      if (inspect_sctx_user.str)
        thd_info->user = m_client_thd->mem_strdup(inspect_sctx_user.str);
      else if (inspect_thd->system_thread)
        thd_info->user = "system user";
      else
        thd_info->user = "unauthenticated user";

      /* HOST */
      if (inspect_thd->peer_port &&
          (inspect_sctx_host.length || inspect_sctx->ip().length) &&
          m_client_thd->security_context()->host_or_ip().str[0]) {
        char *host =
            static_cast<char *>(m_client_thd->alloc(HOST_AND_PORT_LENGTH + 1));
        if (host)
          snprintf(host, HOST_AND_PORT_LENGTH + 1, "%s:%u",
                   inspect_sctx_host_or_ip.str, inspect_thd->peer_port);
        thd_info->host = host;
      } else
        thd_info->host = m_client_thd->mem_strdup(
            inspect_sctx_host_or_ip.str[0]
                ? inspect_sctx_host_or_ip.str
                : inspect_sctx_host.length ? inspect_sctx_host.str : "");
    }  // We've copied the security context, so release the lock.

    DBUG_EXECUTE_IF("processlist_acquiring_dump_threads_LOCK_thd_data", {
      if (inspect_thd->get_command() == COM_BINLOG_DUMP ||
          inspect_thd->get_command() == COM_BINLOG_DUMP_GTID)
        DEBUG_SYNC(m_client_thd,
                   "processlist_after_LOCK_thd_list_before_LOCK_thd_data");
    });
    /* DB */
    mysql_mutex_lock(&inspect_thd->LOCK_thd_data);
    const char *db = inspect_thd->db().str;
    if (db) thd_info->db = m_client_thd->mem_strdup(db);

    /* COMMAND */
    if (inspect_thd->killed == THD::KILL_CONNECTION)
      thd_info->proc_info = "Killed";
    thd_info->command = (int)inspect_thd->get_command();  // Used for !killed.

    /* STATE */
    thd_info->state_info = thread_state_info(m_client_thd, inspect_thd);

    mysql_mutex_unlock(&inspect_thd->LOCK_thd_data);

    /* INFO */
    mysql_mutex_lock(&inspect_thd->LOCK_thd_query);
    {
      const char *query_str = nullptr;
      size_t query_length = 0;

      /* If a rewritten query exists, use that. */
      if (inspect_thd->rewritten_query().length() > 0) {
        query_length = inspect_thd->rewritten_query().length();
        query_str = inspect_thd->rewritten_query().ptr();
      }
      /*
        Otherwise, use the original query. If the query contains password in
        plain text, we have the query re-written immediately after parsing and
        password string is replaced. However, there is a unsafe window before
        rewrite is done and in such case we should not display the plain text
        password.
      */
      else if (inspect_thd->safe_to_display()) {
        query_length = inspect_thd->query().length;
        query_str = inspect_thd->query().str;
      }

      /* In the stand-alone server, add "PLUGIN" as needed. */
      String buf;
      if (inspect_thd->is_a_srv_session()) {
        buf.append(query_length ? "PLUGIN: " : "PLUGIN");

        if (query_length) buf.append(query_str, query_length);

        query_str = buf.c_ptr();
        query_length = buf.length();
      }
      /* No else. We need fall-through */
      /* If we managed to create query info, set a copy on thd_info. */
      if (query_str) {
        const size_t width = min<size_t>(m_max_query_length, query_length);
        const char *q = m_client_thd->strmake(query_str, width);
        /* Safety: in case strmake failed, we set length to 0. */
        thd_info->query_string =
            CSET_STRING(q, q ? width : 0, inspect_thd->charset());
      }
    }
    mysql_mutex_unlock(&inspect_thd->LOCK_thd_query);

    /* MYSQL_TIME */
    thd_info->start_time_in_secs = inspect_thd->query_start_in_secs();

    m_thread_infos->push_back(thd_info);
  }
};


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: wrapper_to_string
  Helper function for wrapper_to_string() which adds a newline and indentation
  up to the specified level.

  @param[in,out] buffer  the buffer to write to
  @param[in]     level   how many nesting levels to add indentation for
  @retval false on success
  @retval true on error
*/
static bool newline_and_indent(String *buffer, size_t level) {
  // Append newline and two spaces per indentation level.
  return buffer->append('\n') ||
         buffer->fill(buffer->length() + level * 2, ' ');
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item_param::set_longdata
bool Item_param::set_longdata(const char *str, ulong length) {
  DBUG_TRACE;

  /*
    If client character set is multibyte, end of long data packet
    may hit at the middle of a multibyte character.  Additionally,
    if binary log is open we must write long data value to the
    binary log in character set of client. This is why we can't
    convert long data to connection character set as it comes
    (here), and first have to concatenate all pieces together,
    write query to the binary log and only then perform conversion.
  */
  if (str_value.length() + length > current_thd->variables.max_allowed_packet) {
    my_message(ER_UNKNOWN_ERROR,
               "Parameter of prepared statement which is set through "
               "mysql_send_long_data() is longer than "
               "'max_allowed_packet' bytes",
               MYF(0));
    return true;
  }

  if (str_value.append(str, length, &my_charset_bin)) return true;

  /*
    Currently, both source type and actual type is MYSQL_TYPE_INVALID.
    They will be set to proper values by Prepared_statement::insert_params().
  */
  m_param_state = LONG_DATA_VALUE;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_to_base64::val_str_ascii
  For the Items which have only val_str_ascii() method
  and don't have their own "native" val_str(),
  we provide a "wrapper" method to convert from ASCII
  to Item character set when it's necessary.
  Conversion happens only in case of "tricky" Item character set (e.g. UCS2).
  Normally conversion does not happen, and val_str_ascii() is immediately
  returned instead.
*/
String *Item_str_func::val_str_from_val_str_ascii(String *str, String *str2) {
  assert(fixed == 1);

  if (my_charset_is_ascii_based(collation.collation)) {
    String *res = val_str_ascii(str);
    if (res) res->set_charset(collation.collation);
    return res;
  }

  assert(str != str2);

  uint errors;
  String *res = val_str_ascii(str);
  if (!res) return nullptr;

  if ((null_value = str2->copy(res->ptr(), res->length(), &my_charset_latin1,
                               collation.collation, &errors)))
    return nullptr;

  return str2;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_to_base64::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_str_func::push_packet_overflow_warning
    return push_packet_overflow_warning(
        thd, m_cast_cs == &my_charset_bin ? "cast_as_binary" : func_name());
  }

  String *res = args[0]->val_str(str);
  if (res == nullptr) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_from_base64::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_concat::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_concat::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_concat_ws::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_concat_ws::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_replace::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_replace::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_insert::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_insert::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_repeat::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_repeat::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_space::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_space::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_rpad::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_rpad::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_lpad::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_lpad::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_charset_conversion::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_charset_conversion::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_load_file::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_export_set::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_export_set::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_quote::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_quote::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_weight_string::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_uncompress::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/regexp/regexp_engine.h
Function: regexp::Regexp_engine::HardLimit
  size_t HardLimit() {
    return current_thd->variables.max_allowed_packet / sizeof(UChar);
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/regexp/regexp_engine.cc
Function: regexp::Regexp_engine::Replace not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/regexp/regexp_engine.cc
Function: regexp::Regexp_engine::Replace not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/regexp/regexp_engine.cc
Function: regexp::Regexp_engine::Replace not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/regexp/regexp_engine.cc
Function: regexp::Regexp_engine::Replace not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/regexp/regexp_engine.cc
Function: regexp::Regexp_engine::Replace not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/regexp/regexp_engine.cc
Function: regexp::Regexp_engine::AppendReplacement
void Regexp_engine::AppendReplacement(const std::u16string &replacement) {
  DBUG_TRACE;

  int replacement_size = TryToAppendReplacement(replacement);

  if (m_error_code == U_BUFFER_OVERFLOW_ERROR) {
    size_t required_buffer_size = m_replace_buffer_pos + replacement_size;
    if (required_buffer_size >= HardLimit()) return;
    /*
      The buffer size was inadequate to write the replacement, but there is
      still room to try and grow the buffer before we hit the hard limit. ICU
      will now have set capacity to zero, m_replace_buffer to the newly
      allocated buffer, and m_error_code to U_BUFFER_OVERFLOW_ERROR. So we try
      once again, by resetting these values after reserving the extra space in
      the buffer.
    */
    m_replace_buffer.resize(required_buffer_size);
    m_error_code = U_ZERO_ERROR;
    TryToAppendReplacement(replacement);
  }
  m_replace_buffer_pos += replacement_size;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/regexp/regexp_engine.cc
Function: regexp::Regexp_engine::AppendTail
void Regexp_engine::AppendTail() {
  DBUG_TRACE;

  int tail_size = TryToAppendTail();

  if (m_error_code == U_BUFFER_OVERFLOW_ERROR) {
    size_t required_buffer_size = m_replace_buffer_pos + tail_size;
    if (required_buffer_size >= HardLimit()) return;

    /*
      The buffer size was inadequate to write the tail, but there is still
      room to try and grow the buffer before we hit the hard limit. ICU will
      now have worked in preflight mode, i.e. it has set capacity to zero and
      m_error_code to U_BUFFER_OVERFLOW_ERROR or
      U_STRING_NOT_TERMINATED_WARNING. So we try once again, by resetting
      these values after reserving the extra space in the buffer.
    */
    m_replace_buffer.resize(required_buffer_size);
    m_error_code = U_ZERO_ERROR;
    TryToAppendTail();
  }
  m_replace_buffer_pos += tail_size;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_binary.cc
Function: json_binary::serialize_json_value not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_binary.cc
Function: json_binary::serialize_json_value not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_binary.cc
Function: json_binary::serialize_json_value not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_binary.cc
Function: json_binary::serialize_json_value not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_binary.cc
Function: json_binary::serialize_json_value not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_geofunc.cc
Function: Item_func_spatial_collection::val_str
String *Item_func_geometry_from_text::val_str(String *str) {
  assert(fixed == 1);
  Geometry_buffer buffer;
  String arg_val;
  String *wkt = args[0]->val_str_ascii(&arg_val);
  bool reverse = false;
  bool srid_default_ordering = true;
  bool is_geographic = false;
  bool lat_long = false;

  if ((null_value = (args[0]->null_value))) {
    assert(is_nullable());
    return nullptr;
  }

  if (!wkt) {
    /*
      We've already found out that args[0]->null_value is false.
      Therefore, wkt should never be null.
    */
    assert(false);
    my_error(ER_GIS_INVALID_DATA, MYF(0), func_name());
    return error_str();
  }

  Gis_read_stream trs(current_thd, wkt->charset(), wkt->ptr(), wkt->length());
  gis::srid_t srid = 0;

  if (arg_count >= 2) {
    if (validate_srid_arg(args[1], &srid, &null_value, func_name()))
      return error_str();
    if (null_value) {
      assert(is_nullable());
      return nullptr;
    }
  }

  const dd::Spatial_reference_system *srs = nullptr;
  std::unique_ptr<dd::cache::Dictionary_client::Auto_releaser> releaser(
      new dd::cache::Dictionary_client::Auto_releaser(
          current_thd->dd_client()));
  if (srid != 0) {
    Srs_fetcher fetcher(current_thd);
    if (fetcher.acquire(srid, &srs)) {
      return error_str();
    }

    if (srs == nullptr) {
      my_error(ER_SRS_NOT_FOUND, MYF(0), srid);
      return error_str();
    } else if (srs->is_geographic()) {
      is_geographic = true;
      lat_long = srs->is_lat_long();
    }
  }

  if (arg_count == 3) {
    String axis_ordering_tmp;
    String *axis_order = args[2]->val_str_ascii(&axis_ordering_tmp);
    null_value = (args[2]->null_value);
    if (null_value) {
      assert(is_nullable());
      return nullptr;
    }
    std::map<std::string, std::string> options;
    if (options_parser::parse_string(axis_order, &options, func_name())) {
      return error_str();
    }

    for (auto pair : options) {
      const std::string key = pair.first;
      const std::string value = pair.second;

      if (key == "axis-order") {
        if (value == "lat-long") {
          reverse = true;
          srid_default_ordering = false;
        } else if (value == "long-lat") {
          reverse = false;
          srid_default_ordering = false;
        } else if (value == "srid-defined") {
          // This is the default.
        } else {
          my_error(ER_INVALID_OPTION_VALUE, MYF(0), value.c_str(), key.c_str(),
                   func_name());
          return error_str();
        }
      } else {
        my_error(ER_INVALID_OPTION_KEY, MYF(0), key.c_str(), func_name());
        return error_str();
      }
    }
  }

  if (srid_default_ordering && is_geographic && lat_long) {
    reverse = true;
  }
  String temp(wkt->length());

  Geometry *g = Geometry::create_from_wkt(&buffer, &trs, &temp, true);
  if (g == nullptr) {
    my_error(ER_GIS_INVALID_DATA, MYF(0), func_name());
    return error_str();
  }
  if (!is_allowed_wkb_type(g->get_type())) {
    my_error(ER_UNEXPECTED_GEOMETRY_TYPE, MYF(0), "WKT",
             g->get_class_info()->m_name.str, func_name());
    return error_str();
  }

  if (reverse && is_geographic) {
    if (g->reverse_coordinates()) {
      my_error(ER_GIS_INVALID_DATA, MYF(0), func_name());
      return error_str();
    }
  }

  if (is_geographic) {
    bool latitude_out_of_range;
    bool longitude_out_of_range;
    double out_of_range_coord_value;
    if (g->validate_coordinate_range(
            srs->angular_unit(), &longitude_out_of_range,
            &latitude_out_of_range, &out_of_range_coord_value)) {
      if (longitude_out_of_range) {
        my_error(ER_LONGITUDE_OUT_OF_RANGE, MYF(0), out_of_range_coord_value,
                 func_name(), srs->from_radians(-M_PI),
                 srs->from_radians(M_PI));
        return error_str();
      }

      if (latitude_out_of_range) {
        my_error(ER_LATITUDE_OUT_OF_RANGE, MYF(0), out_of_range_coord_value,
                 func_name(), srs->from_radians(-M_PI_2),
                 srs->from_radians(M_PI_2));
        return error_str();
      }

      my_error(ER_GIS_INVALID_DATA, MYF(0),
               func_name()); /* purecov: inspected */
      return error_str();    /* purecov: inspected */
    }
  }

  str->set_charset(&my_charset_bin);
  if (str->reserve(SRID_SIZE + temp.length())) return error_str();
  str->length(0);
  q_append(srid, str);
  str->append(temp);

  return str;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: log_loaded_block
int log_loaded_block(IO_CACHE *file) {
  DBUG_TRACE;
  LOAD_FILE_INFO *lf_info;
  uint block_len;
  /* buffer contains position where we started last read */
  uchar *buffer = (uchar *)my_b_get_buffer_start(file);
  uint max_event_size = current_thd->variables.max_allowed_packet;
  lf_info = (LOAD_FILE_INFO *)file->arg;
  if (lf_info->thd->is_current_stmt_binlog_format_row()) return 0;
  if (lf_info->last_pos_in_file != HA_POS_ERROR &&
      lf_info->last_pos_in_file >= my_b_get_pos_in_file(file))
    return 0;

  for (block_len = (uint)(my_b_get_bytes_in_buffer(file)); block_len > 0;
       buffer += min(block_len, max_event_size),
      block_len -= min(block_len, max_event_size)) {
    lf_info->last_pos_in_file = my_b_get_pos_in_file(file);
    if (lf_info->logged_data_file) {
      Append_block_log_event a(lf_info->thd, lf_info->thd->db().str, buffer,
                               min(block_len, max_event_size),
                               lf_info->log_delayed);
      if (mysql_bin_log.write_event(&a)) return 1;
    } else {
      Begin_load_query_log_event b(lf_info->thd, lf_info->thd->db().str, buffer,
                                   min(block_len, max_event_size),
                                   lf_info->log_delayed);
      if (mysql_bin_log.write_event(&b)) return 1;
      lf_info->logged_data_file = true;
    }
  }
  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_binlog_sender.cc
Function: Binlog_sender::init
void Binlog_sender::init() {
  DBUG_TRACE;
  THD *thd = m_thd;

  thd->push_diagnostics_area(&m_diag_area);
  init_heartbeat_period();
  m_last_event_sent_ts = now_in_nanosecs();

  m_linfo.thread_id = thd->thread_id();
  mysql_bin_log.register_log_info(&m_linfo);

  /* Initialize the buffer only once. */
  m_packet.mem_realloc(PACKET_MIN_SIZE);  // size of the buffer
  m_new_shrink_size = PACKET_MIN_SIZE;
  DBUG_PRINT("info", ("Initial packet->alloced_length: %zu",
                      m_packet.alloced_length()));

  if (!mysql_bin_log.is_open()) {
    set_fatal_error("Binary log is not open");
    return;
  }

  if (DBUG_EVALUATE_IF("simulate_no_server_id", true, server_id == 0)) {
    set_fatal_error("Misconfigured source - source server_id is 0");
    return;
  }

  if (m_using_gtid_protocol) {
    auto gtid_mode = global_gtid_mode.get();
    if (gtid_mode != Gtid_mode::ON) {
      char buf[MYSQL_ERRMSG_SIZE];
      sprintf(buf,
              "The replication sender thread cannot start in "
              "AUTO_POSITION mode: this server has GTID_MODE = %.192s "
              "instead of ON.",
              Gtid_mode::to_string(gtid_mode));
      set_fatal_error(buf);
      return;
    }
  }

  if (check_start_file()) return;

  LogErr(INFORMATION_LEVEL, ER_RPL_BINLOG_STARTING_DUMP, thd->thread_id(),
         thd->server_id, m_start_file, m_start_pos);

  if (RUN_HOOK(
          binlog_transmit, transmit_start,
          (thd, m_flag, m_start_file, m_start_pos, &m_observe_transmission))) {
    set_unknown_error("Failed to run hook 'transmit_start'");
    return;
  }
  m_transmit_started = true;

  init_checksum_alg();
  /*
    There are two ways to tell the server to not block:

    - Set the BINLOG_DUMP_NON_BLOCK flag.
      This is official, documented, not used by any mysql
      client, but used by some external users.

    - Set server_id=0.
      This is unofficial, undocumented, and used by
      mysqlbinlog -R since the beginning of time.

    When mysqlbinlog --stop-never is used, it sets a 'fake'
    server_id that defaults to 1 but can be set to anything
    else using stop-never-slave-server-id. This has the
    drawback that if the server_id conflicts with any other
    running slave, or with any other instance of mysqlbinlog
    --stop-never, then that other instance will be killed.  It
    is also an unnecessary burden on the user to have to
    specify a server_id different from all other server_ids
    just to avoid conflicts.

    As of MySQL 5.6.20 and 5.7.5, mysqlbinlog redundantly sets
    the BINLOG_DUMP_NONBLOCK flag when one or both of the
    following holds:
    - the --stop-never option is *not* specified

    In a far future, this means we can remove the unofficial
    functionality that server_id=0 implies nonblocking
    behavior. That will allow mysqlbinlog to use server_id=0
    always. That has the advantage that mysqlbinlog
    --stop-never cannot cause any running dump threads to be
    killed.
  */
  m_wait_new_events =
      !((thd->server_id == 0) || ((m_flag & BINLOG_DUMP_NON_BLOCK) != 0));
  /* Binary event can be vary large. So set it to max allowed packet. */
  thd->variables.max_allowed_packet = binary_log::max_log_event_size;

#ifndef NDEBUG
  if (opt_sporadic_binlog_dump_fail && (binlog_dump_count++ % 2))
    set_unknown_error(
        "Source fails in COM_BINLOG_DUMP because of "
        "--sporadic-binlog-dump-fail");
  m_event_count = 0;
#endif
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_binlog_sender.cc
Function: Binlog_sender::cleanup
void Binlog_sender::cleanup() {
  DBUG_TRACE;

  THD *thd = m_thd;

  if (m_transmit_started)
    (void)RUN_HOOK(binlog_transmit, transmit_stop, (thd, m_flag));

  mysql_bin_log.unregister_log_info(&m_linfo);

  thd->variables.max_allowed_packet =
      global_system_variables.max_allowed_packet;

  thd->pop_diagnostics_area();
  if (has_error())
    my_message(m_errno, m_errmsg, MYF(0));
  else
    my_eof(thd);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_binlog_sender.cc
Function: Binlog_sender::run
void Binlog_sender::run() {
  DBUG_TRACE;

  init();

  unsigned int max_event_size =
      std::max(m_thd->variables.max_allowed_packet,
               binlog_row_event_max_size + MAX_LOG_EVENT_HEADER);
  File_reader reader(opt_source_verify_checksum, max_event_size);
  my_off_t start_pos = m_start_pos;
  const char *log_file = m_linfo.log_file_name;
  bool is_index_file_reopened_on_binlog_disable = false;

  reader.allocator()->set_sender(this);
  while (!has_error() && !m_thd->killed) {
    /*
      Faked rotate event is only required in a few cases(see comment of the
      function). But even so, a faked rotate event is always sent before sending
      event log file, even if a rotate log event exists in last binlog and
      was already sent. The slave then gets an extra rotation and records
      two Rotate_log_events.

      The main issue here are some dependencies on mysqlbinlog, that should be
      solved in the future.
    */
    if (unlikely(fake_rotate_event(log_file, start_pos))) break;

    if (reader.open(log_file)) {
      set_fatal_error(log_read_error_msg(reader.get_error_type()));
      break;
    }

    THD_STAGE_INFO(m_thd, stage_sending_binlog_event_to_replica);
    if (send_binlog(reader, start_pos)) break;

    /* Will go to next file, need to copy log file name */
    set_last_file(log_file);

    THD_STAGE_INFO(m_thd,
                   stage_finished_reading_one_binlog_switching_to_next_binlog);
    DBUG_EXECUTE_IF("waiting_for_disable_binlog", {
      const char act[] =
          "now "
          "signal dump_thread_reached_wait_point "
          "wait_for continue_dump_thread no_clear_event";
      assert(!debug_sync_set_action(m_thd, STRING_WITH_LEN(act)));
    };);
    mysql_bin_log.lock_index();
    if (!mysql_bin_log.is_open()) {
      if (mysql_bin_log.open_index_file(mysql_bin_log.get_index_fname(),
                                        log_file, false)) {
        set_fatal_error(
            "Binary log is not open and failed to open index file "
            "to retrieve next file.");
        mysql_bin_log.unlock_index();
        break;
      }
      is_index_file_reopened_on_binlog_disable = true;
    }
    int error = mysql_bin_log.find_next_log(&m_linfo, false);
    mysql_bin_log.unlock_index();
    if (unlikely(error)) {
      DBUG_EXECUTE_IF("waiting_for_disable_binlog", {
        const char act[] = "now signal consumed_binlog";
        assert(!debug_sync_set_action(m_thd, STRING_WITH_LEN(act)));
      };);
      if (is_index_file_reopened_on_binlog_disable)
        mysql_bin_log.close(LOG_CLOSE_INDEX, true /*need_lock_log=true*/,
                            true /*need_lock_index=true*/);
      set_fatal_error("could not find next log");
      break;
    }

    start_pos = BIN_LOG_HEADER_SIZE;
    reader.close();
  }

  THD_STAGE_INFO(m_thd, stage_waiting_to_finalize_termination);
  char error_text[MAX_SLAVE_ERRMSG + 100];

  /*
    If the dump thread was killed because of a duplicate slave UUID we
    will fail throwing an error to the slave so it will not try to
    reconnect anymore.
  */
  mysql_mutex_lock(&m_thd->LOCK_thd_data);
  bool was_killed_by_duplicate_slave_id = m_thd->duplicate_slave_id;
  mysql_mutex_unlock(&m_thd->LOCK_thd_data);
  if (was_killed_by_duplicate_slave_id)
    set_fatal_error(
        "A replica with the same server_uuid/server_id as this replica "
        "has connected to the source");

  if (reader.is_open()) {
    if (is_fatal_error()) {
      /* output events range to error message */
      snprintf(error_text, sizeof(error_text),
               "%s; the first event '%s' at %lld, "
               "the last event read from '%s' at %lld, "
               "the last byte read from '%s' at %lld.",
               m_errmsg, m_start_file, m_start_pos, m_last_file, m_last_pos,
               log_file, reader.position());
      set_fatal_error(error_text);
    }

    reader.close();
  }

  cleanup();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: set_replica_max_allowed_packet
static void set_replica_max_allowed_packet(THD *thd, MYSQL *mysql) {
  DBUG_TRACE;
  // thd and mysql must be valid
  assert(thd && mysql);

  thd->variables.max_allowed_packet = replica_max_allowed_packet;
  /*
    Adding MAX_LOG_EVENT_HEADER_LEN to the max_packet_size on the I/O
    thread and the mysql->option max_allowed_packet, since a
    replication event can become this much  larger than
    the corresponding packet (query) sent from client to master.
  */
  thd->get_protocol_classic()->set_max_packet_size(replica_max_allowed_packet +
                                                   MAX_LOG_EVENT_HEADER);
  /*
    Skipping the setting of mysql->net.max_packet size to slave
    max_allowed_packet since this is done during mysql_real_connect.
  */
  mysql->options.max_allowed_packet =
      replica_max_allowed_packet + MAX_LOG_EVENT_HEADER;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_channel_service_interface.cc
Function: channel_create
int channel_create(const char *channel, Channel_creation_info *channel_info) {
  DBUG_TRACE;

  Master_info *mi = nullptr;
  int error = 0;
  LEX_MASTER_INFO *lex_mi = nullptr;

  bool thd_created = false;
  THD *thd = current_thd;

  // Don't create default channels
  if (!strcmp(channel_map.get_default_channel(), channel))
    return RPL_CHANNEL_SERVICE_DEFAULT_CHANNEL_CREATION_ERROR;

  /* Service channels are not supposed to use sql_replica_skip_counter */
  mysql_mutex_lock(&LOCK_sql_replica_skip_counter);
  if (sql_replica_skip_counter > 0)
    error = RPL_CHANNEL_SERVICE_SLAVE_SKIP_COUNTER_ACTIVE;
  mysql_mutex_unlock(&LOCK_sql_replica_skip_counter);
  if (error) return error;

  channel_map.wrlock();

  /* Get the Master_info of the channel */
  mi = channel_map.get_mi(channel);

  /* create a new channel if doesn't exist */
  if (!mi) {
    if ((error = add_new_channel(&mi, channel))) goto err;
  }

  lex_mi = new LEX_MASTER_INFO();
  lex_mi->channel = channel;
  lex_mi->host = channel_info->hostname;
  /*
    'group_replication_recovery' channel (*after recovery is done*)
    or 'group_replication_applier' channel wants to set the port number
    to '0' as there is no actual network usage on these channels.
  */
  lex_mi->port_opt = LEX_MASTER_INFO::LEX_MI_ENABLE;
  lex_mi->port = channel_info->port;
  lex_mi->user = channel_info->user;
  lex_mi->password = channel_info->password;
  lex_mi->sql_delay = channel_info->sql_delay;
  lex_mi->connect_retry = channel_info->connect_retry;
  if (channel_info->retry_count) {
    lex_mi->retry_count_opt = LEX_MASTER_INFO::LEX_MI_ENABLE;
    lex_mi->retry_count = channel_info->retry_count;
  }

  if (channel_info->auto_position) {
    lex_mi->auto_position = LEX_MASTER_INFO::LEX_MI_ENABLE;
    if ((mi && mi->is_auto_position()) ||
        channel_info->auto_position == RPL_SERVICE_SERVER_DEFAULT) {
      // So change master allows new configurations with a running SQL thread
      lex_mi->auto_position = LEX_MASTER_INFO::LEX_MI_UNCHANGED;
    }
  }

  if (channel_info->public_key_path) {
    lex_mi->public_key_path = channel_info->public_key_path;
  }

  if (channel_info->get_public_key) {
    lex_mi->get_public_key = LEX_MASTER_INFO::LEX_MI_ENABLE;
    if (mi && mi->get_public_key) {
      // So change master allows new configurations with a running SQL thread
      lex_mi->get_public_key = LEX_MASTER_INFO::LEX_MI_UNCHANGED;
    }
  } else {
    lex_mi->get_public_key = LEX_MASTER_INFO::LEX_MI_DISABLE;
    if (mi && !mi->get_public_key) {
      // So change master allows new configurations with a running SQL thread
      lex_mi->get_public_key = LEX_MASTER_INFO::LEX_MI_UNCHANGED;
    }
  }

  if (channel_info->compression_algorithm != nullptr) {
    lex_mi->compression_algorithm = channel_info->compression_algorithm;
  }
  if (channel_info->zstd_compression_level) {
    lex_mi->zstd_compression_level = channel_info->zstd_compression_level;
  }

  lex_mi->m_source_connection_auto_failover = LEX_MASTER_INFO::LEX_MI_UNCHANGED;
  if (channel_info->m_source_connection_auto_failover) {
    if (mi && !mi->is_source_connection_auto_failover()) {
      lex_mi->m_source_connection_auto_failover =
          LEX_MASTER_INFO::LEX_MI_ENABLE;
    }
  } else {
    if (mi && mi->is_source_connection_auto_failover()) {
      lex_mi->m_source_connection_auto_failover =
          LEX_MASTER_INFO::LEX_MI_DISABLE;
    }
  }

  if (channel_info->ssl_info != nullptr) {
    set_mi_ssl_options(lex_mi, channel_info->ssl_info);
  }

  if (mi) {
    if (!thd) {
      thd_created = true;
      thd = create_surrogate_thread();
    }

    if ((error = change_master(thd, mi, lex_mi,
                               channel_info->preserve_relay_logs))) {
      goto err;
    }
  }

  set_mi_settings(mi, channel_info);

  if (channel_map.is_group_replication_channel_name(mi->get_channel())) {
    thd->variables.max_allowed_packet = replica_max_allowed_packet;
    thd->get_protocol_classic()->set_max_packet_size(
        replica_max_allowed_packet + MAX_LOG_EVENT_HEADER);
  }

err:
  channel_map.unlock();

  if (thd_created) {
    delete_surrogate_thread(thd);
  }

  delete lex_mi;

  return error;
}


