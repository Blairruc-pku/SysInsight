-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: Opt_trace_start::Opt_trace_start not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: opt_trace_disable_if_no_security_context_access
void opt_trace_disable_if_no_security_context_access(THD *thd) {
  DBUG_TRACE;
  if (likely(!(thd->variables.optimizer_trace &
               Opt_trace_context::FLAG_ENABLED)) ||  // (1)
      thd->system_thread)                            // (2)
  {
    /*
      (1) We know that the routine's execution starts with "enabled=off".
      If it stays so until the routine ends, we needn't do security checks on
      the routine.
      If it does not stay so, it means the definer sets it to "on" somewhere
      in the routine's body. Then it is his conscious decision to generate
      traces, thus it is still correct to skip the security check.

      (2) Threads of the Events Scheduler have an unusual security context
      (thd->m_main_security_ctx.priv_user==NULL, see comment in
      Security_context::change_security_context()).
    */
    return;
  }
  Opt_trace_context *const trace = &thd->opt_trace;
  if (!trace->is_started()) {
    /*
      @@optimizer_trace has "enabled=on" but trace is not started.
      Either Opt_trace_start ctor was not called for our statement (3), or it
      was called but at that time, the variable had "enabled=off" (4).

      There are no known cases of (3).

      (4) suggests that the user managed to change the variable during
      execution of the statement, and this statement is using
      view/routine (note that we have not been able to provoke this, maybe
      this is impossible). If it happens it is suspicious.

      We disable I_S output. And we cannot do otherwise: we have no place to
      store a possible "missing privilege" information (no Opt_trace_stmt, as
      is_started() is false), so cannot do security checks, so cannot safely
      do tracing, so have to disable I_S output. And even then, we don't know
      when to re-enable I_S output, as we have no place to store the
      information "re-enable tracing at the end of this statement", and we
      don't even have a notion of statement here (statements in the optimizer
      trace world mean an Opt_trace_stmt object, and there is none here). So
      we must disable for the session's life.

      COM_FIELD_LIST opens views, thus used to be a case of (3). To avoid
      disabling I_S output for the session's life when this command is issued
      (like in: "SET OPTIMIZER_TRACE='ENABLED=ON';USE somedb;" in the 'mysql'
      command-line client), we have decided to create a Opt_trace_start for
      this command. The command itself is not traced though
      (SQLCOM_SHOW_FIELDS does not have CF_OPTIMIZER_TRACE).
    */
    assert(false);
    trace->disable_I_S_for_this_and_children();
    return;
  }
  /*
    Note that thd->m_main_security_ctx.master_access is probably invariant
    across the life of THD: GRANT/REVOKE don't affect global privileges of an
    existing connection, per the manual.
  */
  if (!(thd->m_main_security_ctx.check_access(GLOBAL_ACLS & ~GRANT_ACL)) &&
      (0 != strcmp(thd->m_main_security_ctx.priv_user().str,
                   thd->security_context()->priv_user().str) ||
       0 != my_strcasecmp(system_charset_info,
                          thd->m_main_security_ctx.priv_host().str,
                          thd->security_context()->priv_host().str)))
    trace->missing_privilege();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: opt_trace_disable_if_no_stored_proc_func_access
void opt_trace_disable_if_no_stored_proc_func_access(THD *thd, sp_head *sp) {
  DBUG_TRACE;
  if (likely(!(thd->variables.optimizer_trace &
               Opt_trace_context::FLAG_ENABLED)) ||
      thd->system_thread)
    return;
  Opt_trace_context *const trace = &thd->opt_trace;
  if (!trace->is_started()) {
    assert(false);
    trace->disable_I_S_for_this_and_children();
    return;
  }
  bool full_access;
  Security_context *const backup_thd_sctx = thd->security_context();
  DBUG_PRINT("opt", ("routine: '%s'", sp->m_name.str));
  thd->set_security_context(&thd->m_main_security_ctx);
  const bool rc = sp->check_show_access(thd, &full_access) || !full_access;
  thd->set_security_context(backup_thd_sctx);
  if (rc) trace->missing_privilege();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/opt_trace2server.cc
Function: opt_trace_disable_if_no_view_access
void opt_trace_disable_if_no_view_access(THD *thd, Table_ref *view,
                                         Table_ref *underlying_tables) {
  DBUG_TRACE;
  if (likely(!(thd->variables.optimizer_trace &
               Opt_trace_context::FLAG_ENABLED)) ||
      thd->system_thread)
    return;
  Opt_trace_context *const trace = &thd->opt_trace;
  if (!trace->is_started()) {
    assert(false);
    trace->disable_I_S_for_this_and_children();
    return;
  }
  DBUG_PRINT("opt", ("view: '%s'", view->table_name));
  Security_context *const backup_table_sctx = view->security_ctx;
  Security_context *const backup_thd_sctx = thd->security_context();
  const GRANT_INFO backup_grant_info = view->grant;

  view->security_ctx = nullptr;  // no SUID context for view
  // no SUID context for THD
  thd->set_security_context(&thd->m_main_security_ctx);
  const int rc = check_table_access(thd, SHOW_VIEW_ACL, view, false, 1, true);

  view->security_ctx = backup_table_sctx;
  thd->set_security_context(backup_thd_sctx);
  view->grant = backup_grant_info;

  if (rc) {
    trace->missing_privilege();
    return;
  }
  /*
    We needn't check SELECT privilege on this view. Some
    opt_trace_disable_if_no_tables_access() call has or will check it.

    Now we check underlying tables/views of our view:
  */
  opt_trace_disable_if_no_tables_access(thd, underlying_tables);
}


