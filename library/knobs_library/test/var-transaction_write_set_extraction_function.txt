-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::is_current_stmt_binlog_row_enabled_with_write_set_extraction
bool THD::is_current_stmt_binlog_row_enabled_with_write_set_extraction() const {
  return ((variables.transaction_write_set_extraction != HASH_ALGORITHM_OFF) &&
          is_current_stmt_binlog_format_row() &&
          !is_current_stmt_binlog_disabled());
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/handler.cc
Function: binlog_log_row
int binlog_log_row(TABLE *table, const uchar *before_record,
                   const uchar *after_record, Log_func *log_func) {
  bool error = false;
  THD *const thd = table->in_use;

  if (check_table_binlog_row_based(thd, table)) {
    if (thd->variables.transaction_write_set_extraction != HASH_ALGORITHM_OFF) {
      try {
        MY_BITMAP save_read_set;
        MY_BITMAP save_write_set;
        if (bitmap_init(&save_read_set, nullptr, table->s->fields) ||
            bitmap_init(&save_write_set, nullptr, table->s->fields)) {
          my_error(ER_OUT_OF_RESOURCES, MYF(0));
          return HA_ERR_RBR_LOGGING_FAILED;
        }

        Binlog_log_row_cleanup cleanup_sentry(*table, save_read_set,
                                              save_write_set);

        if (thd->variables.binlog_row_image == 0) {
          for (uint key_number = 0; key_number < table->s->keys; ++key_number) {
            if (((table->key_info[key_number].flags & (HA_NOSAME)) ==
                 HA_NOSAME)) {
              table->mark_columns_used_by_index_no_reset(key_number,
                                                         table->read_set);
              table->mark_columns_used_by_index_no_reset(key_number,
                                                         table->write_set);
            }
          }
        }
        std::array<const uchar *, 2> records{after_record, before_record};
        for (auto rec : records) {
          if (rec != nullptr) {
            assert(rec == table->record[0] || rec == table->record[1]);
            bool res = add_pke(table, thd, rec);
            if (res) return HA_ERR_RBR_LOGGING_FAILED;
          }
        }
      } catch (const std::bad_alloc &) {
        my_error(ER_OUT_OF_RESOURCES, MYF(0));
        return HA_ERR_RBR_LOGGING_FAILED;
      }
    }
    if (table->in_use->is_error()) return error ? HA_ERR_RBR_LOGGING_FAILED : 0;

    DBUG_DUMP("read_set 10", (uchar *)table->read_set->bitmap,
              (table->s->fields + 7) / 8);

    /*
      If there are no table maps written to the binary log, this is
      the first row handled in this statement. In that case, we need
      to write table maps for all locked tables to the binary log.
    */
    if (likely(!(error = write_locked_table_maps(thd)))) {
      /*
        We need to have a transactional behavior for SQLCOM_CREATE_TABLE
        (i.e. CREATE TABLE... SELECT * FROM TABLE) in order to keep a
        compatible behavior with the STMT based replication even when
        the table is not transactional. In other words, if the operation
        fails while executing the insert phase nothing is written to the
        binlog.
      */
      bool const has_trans = thd->lex->sql_command == SQLCOM_CREATE_TABLE ||
                             table->file->has_transactions();
      error = (*log_func)(thd, table, has_trans, before_record, after_record);
    }
  }

  return error ? HA_ERR_RBR_LOGGING_FAILED : 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_write_set_handler.cc
Function: generate_hash_pke not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_write_set_handler.cc
Function: generate_hash_pke not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_write_set_handler.cc
Function: generate_hash_pke not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_write_set_handler.cc
Function: generate_hash_pke not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_write_set_handler.cc
Function: generate_hash_pke not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_injector.cc
Function: injector::transaction::write_row not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_injector.cc
Function: injector::transaction::write_row not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_injector.cc
Function: injector::transaction::write_row not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_injector.cc
Function: injector::transaction::delete_row not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_injector.cc
Function: injector::transaction::delete_row not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_injector.cc
Function: injector::transaction::delete_row not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_injector.cc
Function: injector::transaction::update_row not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_injector.cc
Function: injector::transaction::update_row not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_injector.cc
Function: injector::transaction::update_row not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_trx_tracking.cc
Function: Writeset_trx_dependency_tracker::get_dependency
void Commit_order_trx_dependency_tracker::get_dependency(THD *thd,
                                                         int64 &sequence_number,
                                                         int64 &commit_parent) {
  Transaction_ctx *trn_ctx = thd->get_transaction();

  assert(trn_ctx->sequence_number > m_max_committed_transaction.get_offset());
  /*
    Prepare sequence_number and commit_parent relative to the current
    binlog.  This is done by subtracting the binlog's clock offset
    from the values.

    A transaction that commits after the binlog is rotated, can have a
    commit parent in the previous binlog. In this case, subtracting
    the offset from the sequence number results in a negative
    number. The commit parent dependency gets lost in such
    case. Therefore, we log the value SEQ_UNINIT in this case.
  */
  sequence_number =
      trn_ctx->sequence_number - m_max_committed_transaction.get_offset();

  if (trn_ctx->last_committed <= m_max_committed_transaction.get_offset())
    commit_parent = SEQ_UNINIT;
  else
    commit_parent =
        std::max(trn_ctx->last_committed, m_last_blocking_transaction) -
        m_max_committed_transaction.get_offset();

  if (is_trx_unsafe_for_parallel_slave(thd))
    m_last_blocking_transaction = trn_ctx->sequence_number;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_handler.cc
Function: prepare_transaction_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_handler.cc
Function: prepare_transaction_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_handler.cc
Function: prepare_transaction_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_handler.cc
Function: prepare_transaction_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_group_replication.cc
Function: get_server_startup_prerequirements
void get_server_startup_prerequirements(Trans_context_info &requirements) {
  requirements.binlog_enabled = opt_bin_log;
  requirements.binlog_format = global_system_variables.binlog_format;
  requirements.binlog_checksum_options = binlog_checksum_options;
  requirements.gtid_mode = global_gtid_mode.get();
  requirements.log_replica_updates = opt_log_replica_updates;
  requirements.transaction_write_set_extraction =
      global_system_variables.transaction_write_set_extraction;
  requirements.mi_repository_type = opt_mi_repository_id;
  requirements.rli_repository_type = opt_rli_repository_id;
  requirements.parallel_applier_type = mts_parallel_option;
  requirements.parallel_applier_workers = opt_mts_replica_parallel_workers;
  requirements.parallel_applier_preserve_commit_order =
      opt_replica_preserve_commit_order;
  requirements.lower_case_table_names = lower_case_table_names;
  requirements.default_table_encryption =
      global_system_variables.default_table_encryption;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_binlog_thread::fix_per_epoch_trans_settings
void Ndb_binlog_thread::fix_per_epoch_trans_settings(THD *thd) {
  // No effect for self logging engine
  // thd->variables.binlog_row_format

  // With HTON_NO_BINLOG_ROW_OPT handlerton flag setting has no effect
  // thd->variables.binlog_row_image

  // Compression settings should take effect next binlog transaction
  thd->variables.binlog_trx_compression = opt_ndb_log_trx_compression;
  thd->variables.binlog_trx_compression_type = 0;  // zstd
  thd->variables.binlog_trx_compression_level_zstd =
      opt_ndb_log_trx_compression_level_zstd;

  // Without HA_BLOB_PARTIAL_UPDATE setting has no effect
  // thd->variables.binlog_row_value_options & PARTIAL_JSON

  // Controls writing Rows_query_log events with the query to binlog, disable
  // since query is not known for changes received from NDB
  thd->variables.binlog_rows_query_log_events = false;

  // No effect unless statement-based binary logging
  // thd->variables.binlog_direct_non_trans_update

  // Setup writeset extraction based on --ndb-log-transaction-dependency
  thd->variables.transaction_write_set_extraction =
      opt_ndb_log_trans_dependency ? HASH_ALGORITHM_XXHASH64
                                   : HASH_ALGORITHM_OFF;

  // Charset setting
  thd->variables.character_set_client = &my_charset_latin1;
}


