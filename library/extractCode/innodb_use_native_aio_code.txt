-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/os/os0file.cc
Function: os_aio_func
dberr_t os_aio_func(IORequest &type, AIO_mode aio_mode, const char *name,
                    pfs_os_file_t file, void *buf, os_offset_t offset, ulint n,
                    bool read_only, fil_node_t *m1, void *m2) {
  ut_a(!type.is_log());
#ifdef WIN_ASYNC_IO 
  BOOL ret = TRUE;
#endif /* WIN_ASYNC_IO */

  const file::Block *e_block = type.get_encrypted_block();

#ifdef UNIV_DEBUG
  if (type.is_write() && e_block != nullptr) {
    ut_ad(os_block_get_frame(e_block) == buf);
  }
#endif /* UNIV_DEBUG */

  ut_ad(n > 0);
  ut_ad((n % OS_FILE_LOG_BLOCK_SIZE) == 0);
  ut_ad((offset % OS_FILE_LOG_BLOCK_SIZE) == 0);
  ut_ad(os_aio_validate_skip());

#ifdef WIN_ASYNC_IO
  ut_ad((n & 0xFFFFFFFFUL) == n);
#endif /* WIN_ASYNC_IO */

  if (aio_mode == AIO_mode::SYNC) {
    /* This is actually an ordinary synchronous read or write:
    no need to use an i/o-handler thread. NOTE that if we use
    Windows "async" overlapped i/o, Windows does not allow us to use
    ordinary synchronous operations etc. on the same file. The os_file_read()
    and os_file_write() are handling this case correctly.
    Also note that the Performance Schema instrumentation has
    been performed by current os_aio_func()'s wrapper function
    pfs_os_aio_func(). So we would no longer need to call
    Performance Schema instrumented os_file_read() and
    os_file_write(). Instead, we should use os_file_read_func()
    and os_file_write_func() */

    if (type.is_read()) {
      return (os_file_read_func(type, name, file.m_file, buf, offset, n));
    }

    ut_ad(type.is_write());
    return (os_file_write_func(type, name, file.m_file, buf, offset, n));
  }

try_again:

  auto array = AIO::select_slot_array(type, read_only, aio_mode);

  auto slot =
      array->reserve_slot(type, m1, m2, file, name, buf, offset, n, e_block);

  if (type.is_read()) {
    if (srv_use_native_aio) {
      ++os_n_file_reads;

      os_bytes_read_since_printout += n;
#ifdef WIN_ASYNC_IO
      ret = ReadFile(file.m_file, slot->ptr, slot->len, &slot->n_bytes,
                     &slot->control);
#elif defined(LINUX_NATIVE_AIO)
      if (!array->linux_dispatch(slot)) {
        goto err_exit;
      }
#endif /* WIN_ASYNC_IO */
    } else if (type.is_wake()) {
      AIO::wake_simulated_handler_thread(
          AIO::get_segment_no_from_slot(array, slot));
    }
  } else if (type.is_write()) {
    if (srv_use_native_aio) {
      ++os_n_file_writes;

#ifdef WIN_ASYNC_IO
      ret = WriteFile(file.m_file, slot->ptr, slot->len, &slot->n_bytes,
                      &slot->control);
#elif defined(LINUX_NATIVE_AIO)
      if (!array->linux_dispatch(slot)) {
        goto err_exit;
      }
#endif /* WIN_ASYNC_IO */

    } else if (type.is_wake()) {
      AIO::wake_simulated_handler_thread(
          AIO::get_segment_no_from_slot(array, slot));
    }
  } else {
    ut_error;
  }

#ifdef WIN_ASYNC_IO
  if (srv_use_native_aio) {
    if ((!ret && GetLastError() != ERROR_IO_PENDING) ||
        (ret && slot->len != slot->n_bytes)) {
      goto err_exit;
    }
  }
#endif /* WIN_ASYNC_IO */

  /* AIO request was queued successfully! */
  return (DB_SUCCESS);

#if defined LINUX_NATIVE_AIO || defined WIN_ASYNC_IO
err_exit:
#endif /* LINUX_NATIVE_AIO || WIN_ASYNC_IO */

  array->release_with_mutex(slot);
  if (os_file_handle_error(name, type.is_read() ? "aio read" : "aio write")) {
    goto try_again;
  }

  return (DB_IO_ERROR);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/os/os0file.cc
Function: AIO::wake_simulated_handler_thread
void AIO::wake_simulated_handler_thread(ulint global_segment) {
  ut_ad(!srv_use_native_aio);

  AIO *array{};

  auto segment = get_array_and_local_segment(array, global_segment);

  array->wake_simulated_handler_thread(global_segment, segment);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/os/os0file.cc
Function: os_aio_simulated_wake_handler_threads
void os_aio_simulated_wake_handler_threads() {
  if (srv_use_native_aio) {
    /* We do not use simulated aio: do nothing */

    return;
  }

  os_aio_recommend_sleep_for_read_threads = false;

  for (ulint i = 0; i < os_aio_n_segments; ++i) {
    AIO::wake_simulated_handler_thread(i);
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/os/os0file.cc
Function: AIO::reserve_slot
Slot *AIO::reserve_slot(IORequest &type, fil_node_t *m1, void *m2,
                        pfs_os_file_t file, const char *name, void *buf,
                        os_offset_t offset, ulint len,
                        const file::Block *e_block) {
  ut_a(!type.is_log());
#ifdef WIN_ASYNC_IO
  ut_a((len & 0xFFFFFFFFUL) == len);
#endif /* WIN_ASYNC_IO */

  /* No need of a mutex. Only reading constant fields */
  ut_ad(type.validate());

  const auto slots_per_seg = slots_per_segment();

  for (;;) {
    acquire();

    if (m_n_reserved != m_slots.size()) {
      break;
    }

    release();

    if (!srv_use_native_aio) {
      /* If the handler threads are suspended,
      wake them so that we get more slots */

      os_aio_simulated_wake_handler_threads();
    }

    os_event_wait(m_not_full);
  }

  /* We will check first, next(first), next(next(first))... which should be a
  permutation of values 0,..,m_slots.size()-1.*/
  auto find_slot = [this](size_t first, auto next) {
    size_t i = first;
    for (size_t counter = 0; counter < m_slots.size(); ++counter) {
      if (!at(i)->is_reserved) {
        return i;
      }
      i = next(i);
    }
    /* We know that there is a free slot, because m_n_reserved != m_slots.size()
    was checked under the mutex protection, which we still hold. Additionally
    the permutation generated by next() should visit all slots. If we checked
    m_slots.size() elements of the sequence and not found a free slot, then it
    was not a permutation, or there was no free slot.*/
    ut_error;
  };
  size_t free_index;
  if (srv_use_native_aio) {
    /* We assume the m_slots.size() cannot be changed during runtime. */
    ut_a(m_last_slot_used < m_slots.size());
    /* We iterate through slots starting with the last used and then trying next
    ones from consecutive segments to balance the incoming requests evenly
    between the AIO threads. */
    free_index = find_slot(m_last_slot_used, [&](size_t i) {
      i += slots_per_seg;
      if (i >= m_slots.size()) {
        /* Start again from the first segment, this time trying next slot in
        each segment. If we checked the last slot in segment, start with
        first slot. */
        i = (i + 1) % slots_per_seg;
      }
      return i;
    });
    m_last_slot_used = free_index;
  } else {
    /* We attempt to keep adjacent blocks in the same local
    segment. This can help in merging IO requests when we are
    doing simulated AIO */
    const size_t local_seg =
        (offset >> (UNIV_PAGE_SIZE_SHIFT + 6)) % m_n_segments;
    /* We start our search for an available slot from our preferred
    local segment and do a full scan of the array. */
    free_index = find_slot(local_seg * slots_per_seg,
                           [&](size_t i) { return (i + 1) % m_slots.size(); });
  }
  Slot *const slot = at(free_index);
  ut_a(slot->is_reserved == false);

  ++m_n_reserved;

  if (m_n_reserved == 1) {
    os_event_reset(m_is_empty);
  }

  if (m_n_reserved == m_slots.size()) {
    os_event_reset(m_not_full);
  }

  slot->is_reserved = true;
  slot->reservation_time = std::chrono::steady_clock::now();
  slot->m1 = m1;
  slot->m2 = m2;
  slot->file = file;
  slot->name = name;
#ifdef _WIN32
  slot->len = static_cast<DWORD>(len);
#else
  slot->len = static_cast<ulint>(len);
#endif /* _WIN32 */
  slot->type = type;
  slot->buf = static_cast<byte *>(buf);
  slot->ptr = slot->buf;
  slot->offset = offset;
  slot->err = DB_SUCCESS;
  if (type.is_read()) {
    /* The original size must not be specified for reads. */
    ut_ad(!slot->type.get_original_size());
    slot->type.set_original_size(static_cast<uint32_t>(len));
  } else if (type.is_write()) {
    /* The original size may be supplied by user in case the punch hole is
    requested, otherwise use the IO length specified. */
    if (slot->type.get_original_size() == 0) {
      slot->type.set_original_size(static_cast<uint32_t>(len));
    }
  }
  slot->io_already_done = false;
  slot->buf_block = nullptr;

  if (!srv_use_native_aio) {
    slot->buf_block = const_cast<file::Block *>(e_block);
  }

  if (srv_use_native_aio && offset > 0 && type.is_write() &&
      type.is_compressed()) {
    ulint compressed_len = len;

    ut_ad(!type.is_log());

    release();

    void *src_buf = slot->buf;

    if (e_block == nullptr) {
      slot->buf_block = os_file_compress_page(type, src_buf, &compressed_len);
    }

    slot->buf = static_cast<byte *>(src_buf);
    slot->ptr = slot->buf;
#ifdef _WIN32
    slot->len = static_cast<DWORD>(compressed_len);
#else
    slot->len = static_cast<ulint>(compressed_len);
#endif /* _WIN32 */
    slot->skip_punch_hole = !type.punch_hole();

    acquire();
  }

  /* We do encryption after compression, since if we do encryption
  before compression, the encrypted data will cause compression fail
  or low compression rate. */
  if (srv_use_native_aio && offset > 0 && type.is_write() &&
      (type.is_encrypted() || e_block != nullptr)) {
    file::Block *encrypted_block = nullptr;

    release();

    void *src_buf = slot->buf;
    ut_a(!type.is_log());
    if (e_block == nullptr) {
      encrypted_block = os_file_encrypt_page(type, src_buf, slot->len);
    } else {
      encrypted_block = const_cast<file::Block *>(e_block);
    }

    if (slot->buf_block != nullptr) {
      os_free_block(slot->buf_block);
    }

    slot->buf_block = encrypted_block;

    slot->buf = static_cast<byte *>(src_buf);

    slot->ptr = slot->buf;

    if (encrypted_block != nullptr) {
#ifdef _WIN32
      slot->len = static_cast<DWORD>(encrypted_block->m_size);
#else
      slot->len = static_cast<ulint>(encrypted_block->m_size);
#endif /* _WIN32 */
    }

    acquire();
  }

#ifdef WIN_ASYNC_IO
  {
    OVERLAPPED *control;

    control = &slot->control;
    control->Offset = (DWORD)offset & 0xFFFFFFFF;
    control->OffsetHigh = (DWORD)(offset >> 32);

    ResetEvent(slot->handle);
  }
#elif defined(LINUX_NATIVE_AIO)

  /* If we are not using native AIO skip this part. */
  if (srv_use_native_aio) {
    off_t aio_offset;

    /* Check if we are dealing with 64 bit arch.
    If not then make sure that offset fits in 32 bits. */
    aio_offset = (off_t)offset;

    ut_a(sizeof(aio_offset) >= sizeof(offset) ||
         ((os_offset_t)aio_offset) == offset);

    auto iocb = &slot->control;

    if (type.is_read()) {
      io_prep_pread(iocb, file.m_file, slot->ptr, slot->len, aio_offset);
    } else {
      ut_ad(type.is_write());
      io_prep_pwrite(iocb, file.m_file, slot->ptr, slot->len, aio_offset);
    }

    iocb->data = slot;

    slot->n_bytes = 0;
    slot->ret = 0;
  }
#endif /* LINUX_NATIVE_AIO */

  release();

  return (slot);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/os/os0file.cc
Function: AIO::init
dberr_t AIO::init() {
  ut_a(!m_slots.empty());

#ifdef _WIN32
  ut_a(m_handles == NULL);

  m_handles =
      ut::new_withkey<Handles>(UT_NEW_THIS_FILE_PSI_KEY, m_slots.size());
#endif /* _WIN32 */

  if (srv_use_native_aio) {
#ifdef LINUX_NATIVE_AIO
    dberr_t err = init_linux_native_aio();

    if (err != DB_SUCCESS) {
      return (err);
    }

#endif /* LINUX_NATIVE_AIO */
  }

  return (init_slots());
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/os/os0file.cc
Function: os_aio_handler 
dberr_t os_aio_handler(ulint segment, fil_node_t **m1, void **m2,
                       IORequest *request) {
  dberr_t err;

  if (srv_use_native_aio) {
    srv_set_io_thread_op_info(segment, "native aio handle");

#ifdef WIN_ASYNC_IO

    err = os_aio_windows_handler(segment, m1, m2, request);

#elif defined(LINUX_NATIVE_AIO)

    err = os_aio_linux_handler(segment, m1, m2, request);
#else
    ut_error;

    err = DB_ERROR; /* Eliminate compiler warning */

#endif /* WIN_ASYNC_IO */

  } else {
    srv_set_io_thread_op_info(segment, "simulated aio handle");

    err = os_aio_simulated_handler(segment, m1, m2, request);
  }

  return (err);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/os/os0file.cc
Function: os_file_get_last_error_low
static ulint os_file_get_last_error_low(bool report_all_errors,
                                        bool on_error_silent) {
  int err = errno;

  if (err == 0) {
    return 0;
  }

  if (report_all_errors ||
      (err != ENOSPC && err != EEXIST && !on_error_silent)) {
    ib::error(ER_IB_MSG_767)
        << "Operating system error number " << err << " in a file operation.";

    if (err == ENOENT) {
      ib::error(ER_IB_MSG_768) << "The error means the system"
                                  " cannot find the path specified.";

#ifndef UNIV_HOTBACKUP
      if (srv_is_being_started) {
        ib::error(ER_IB_MSG_769) << "If you are installing InnoDB,"
                                    " remember that you must create"
                                    " directories yourself, InnoDB"
                                    " does not create them.";
      }
#endif /* !UNIV_HOTBACKUP */
    } else if (err == EACCES) {
      ib::error(ER_IB_MSG_770) << "The error means mysqld does not have"
                                  " the access rights to the directory.";

    } else {
      if (strerror(err) != nullptr) {
        ib::error(ER_IB_MSG_771)
            << "Error number " << err << " means '" << strerror(err) << "'";
      }

      ib::info(ER_IB_MSG_772) << OPERATING_SYSTEM_ERROR_MSG;
    }
  }

  switch (err) {
    case ENOSPC:
      return OS_FILE_DISK_FULL;
    case ENOENT:
      return OS_FILE_NOT_FOUND;
    case EEXIST:
      return OS_FILE_ALREADY_EXISTS;
    case EXDEV:
    case ENOTDIR:
    case EISDIR:
      return OS_FILE_PATH_ERROR;
    case EAGAIN:
      if (srv_use_native_aio) {
        return OS_FILE_AIO_RESOURCES_RESERVED;
      }
      break;
    case EINTR:
      if (srv_use_native_aio) {
        return OS_FILE_AIO_INTERRUPTED;
      }
      break;
    case EACCES:
      return OS_FILE_ACCESS_VIOLATION;
    case ENAMETOOLONG:
      return OS_FILE_NAME_TOO_LONG;
    case EMFILE:
      return OS_FILE_TOO_MANY_OPENED;
  }
  return OS_FILE_ERROR_MAX + err;
}
