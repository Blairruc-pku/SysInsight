-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/mysqld.cc
Function: init_server_components
static int init_server_components() {
  DBUG_TRACE;
  /*
    We need to call each of these following functions to ensure that
    all things are initialized so that unireg_abort() doesn't fail
  */
  mdl_init();
  partitioning_init();
  if (table_def_init() || hostname_cache_init(host_cache_size))
    unireg_abort(MYSQLD_ABORT_EXIT);

  /*
    This load function has to be called after the opt_plugin_dir variable
    is initialized else it will fail to load.
    The unload of these components will be done by minimal_chassis_deinit().
    So, no need to call unload of these components.
    Since, it is an optional component required for GR, audit log etc. The
    error check of the service availability has to be done by those
    plugins/components.
  */
  if (!is_help_or_validate_option() && !opt_initialize)
    dynamic_loader_srv->load(component_urns, NUMBER_OF_COMPONENTS);

  /*
    Timers not needed if only starting with --help.
  */
  if (!is_help_or_validate_option()) {
    if (my_timer_initialize())
      LogErr(ERROR_LEVEL, ER_CANT_INIT_TIMER, errno);
    else
      have_statement_timeout = SHOW_OPTION_YES;
  }

  randominit(&sql_rand, (ulong)server_start_time, (ulong)server_start_time / 2);
  setup_fpu();

  setup_error_log();  // opens the log if needed

  enter_cond_hook = thd_enter_cond;
  exit_cond_hook = thd_exit_cond;
  enter_stage_hook = thd_enter_stage;
  set_waiting_for_disk_space_hook = thd_set_waiting_for_disk_space;
  is_killed_hook = thd_killed;

  xa::Transaction_cache::initialize();

  /*
    Try to read the previous run's error log and make it available in
    performance_schema.error_log. Activate all error logging services
    requested by the user in @@global.log_error_services (now that the
    component infrastructure is available), flush the buffered error
    messages to performance schema and to configured services, and end
    error log buffering.

    Pre-requisites:
    We depend on component_infrastructure_init() and setup_error_log()
    above. init_common_variables() additionally gives us a correctly
    set up umask etc., and keyring-migration may modify the log-target,
    so we wait that out as well. It should be safe to go before the
    component-autoload above ("component_urns") for the time being,
    but that may not be the case in the future, so we're playing it
    safe. Altogether by the time we get here, we're usually within
    a second of start-up, with a half-dozen or less messages buffered
    if no issues were encountered.
  */
  if (setup_error_log_components()) unireg_abort(MYSQLD_ABORT_EXIT);

  if (MDL_context_backup_manager::init()) {
    LogErr(ERROR_LEVEL, ER_OOM);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  /*
    initialize delegates for extension observers, errors have already
    been reported in the function
  */
  if (delegates_init()) unireg_abort(MYSQLD_ABORT_EXIT);

  /* need to configure logging before initializing storage engines */
  if (opt_log_replica_updates && !opt_bin_log) {
    LogErr(WARNING_LEVEL, ER_NEED_LOG_BIN, "--log-replica-updates");
  }
  if (binlog_format_used && !opt_bin_log)
    LogErr(WARNING_LEVEL, ER_NEED_LOG_BIN, "--binlog-format");

  /* Check that we have not let the format to unspecified at this point */
  assert((uint)global_system_variables.binlog_format <=
         array_elements(binlog_format_names) - 1);

  opt_server_id_mask =
      (opt_server_id_bits == 32) ? ~ulong(0) : (1 << opt_server_id_bits) - 1;
  if (server_id != (server_id & opt_server_id_mask)) {
    LogErr(ERROR_LEVEL, ER_SERVERID_TOO_LARGE);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  if (opt_bin_log) {
    /* Reports an error and aborts, if the --log-bin's path
       is a directory.*/
    if (opt_bin_logname &&
        opt_bin_logname[strlen(opt_bin_logname) - 1] == FN_LIBCHAR) {
      LogErr(ERROR_LEVEL, ER_NEED_FILE_INSTEAD_OF_DIR, "--log-bin",
             opt_bin_logname);
      unireg_abort(MYSQLD_ABORT_EXIT);
    }

    /* Reports an error and aborts, if the --log-bin-index's path
       is a directory.*/
    if (opt_binlog_index_name &&
        opt_binlog_index_name[strlen(opt_binlog_index_name) - 1] ==
            FN_LIBCHAR) {
      LogErr(ERROR_LEVEL, ER_NEED_FILE_INSTEAD_OF_DIR, "--log-bin-index",
             opt_binlog_index_name);
      unireg_abort(MYSQLD_ABORT_EXIT);
    }

    char buf[FN_REFLEN];
    const char *ln;
    if (log_bin_supplied) {
      /*
        Binary log basename defaults to "`hostname`-bin" name prefix
        if --log-bin is used without argument.
      */
      ln = mysql_bin_log.generate_name(opt_bin_logname, "-bin", buf);
    } else {
      /*
        Binary log basename defaults to "binlog" name prefix
        if --log-bin is not used.
      */
      ln = mysql_bin_log.generate_name(opt_bin_logname, "", buf);
    }

    if (!opt_bin_logname && !opt_binlog_index_name && log_bin_supplied) {
      /*
        User didn't give us info to name the binlog index file.
        Picking `hostname`-bin.index like did in 4.x, causes replication to
        fail if the hostname is changed later. So, we would like to instead
        require a name. But as we don't want to break many existing setups, we
        only give warning, not error.
      */
      LogErr(INFORMATION_LEVEL, ER_LOG_BIN_BETTER_WITH_NAME, ln);
    }
    if (ln == buf) {
      my_free(opt_bin_logname);
      opt_bin_logname = my_strdup(key_memory_opt_bin_logname, buf, MYF(0));
    }

    /*
      Skip opening the index file if we start with --help. This is necessary
      to avoid creating the file in an otherwise empty datadir, which will
      cause a succeeding 'mysqld --initialize' to fail.
    */
    if (!is_help_or_validate_option() &&
        mysql_bin_log.open_index_file(opt_binlog_index_name, ln, true)) {
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
  }

  if (opt_bin_log) {
    /*
      opt_bin_logname[0] needs to be checked to make sure opt binlog name is
      not an empty string, in case it is an empty string default file
      extension will be passed
     */
    if (log_bin_supplied) {
      log_bin_basename = rpl_make_log_name(
          key_memory_MYSQL_BIN_LOG_basename, opt_bin_logname,
          default_logfile_name,
          (opt_bin_logname && opt_bin_logname[0]) ? "" : "-bin");
    } else {
      log_bin_basename =
          rpl_make_log_name(key_memory_MYSQL_BIN_LOG_basename, opt_bin_logname,
                            default_binlogfile_name, "");
    }

    log_bin_index =
        rpl_make_log_name(key_memory_MYSQL_BIN_LOG_index, opt_binlog_index_name,
                          log_bin_basename, ".index");

    if ((!opt_binlog_index_name || !opt_binlog_index_name[0]) &&
        log_bin_index) {
      strmake(default_binlog_index_name,
              log_bin_index + dirname_length(log_bin_index),
              FN_REFLEN + index_ext_length - 1);
      opt_binlog_index_name = default_binlog_index_name;
    }

    if (log_bin_basename == nullptr || log_bin_index == nullptr) {
      LogErr(ERROR_LEVEL, ER_RPL_CANT_MAKE_PATHS, (int)FN_REFLEN, (int)FN_LEN);
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
  }

  DBUG_PRINT("debug",
             ("opt_bin_logname: %s, opt_relay_logname: %s, pidfile_name: %s",
              opt_bin_logname, opt_relay_logname, pidfile_name));

  /*
    opt_relay_logname[0] needs to be checked to make sure opt relaylog name is
    not an empty string, in case it is an empty string default file
    extension will be passed
   */
  relay_log_basename = rpl_make_log_name(
      key_memory_MYSQL_RELAY_LOG_basename, opt_relay_logname,
      default_logfile_name,
      (opt_relay_logname && opt_relay_logname[0]) ? "" : relay_ext);

  if (!opt_relay_logname || !opt_relay_logname[0]) {
    if (relay_log_basename) {
      strmake(default_relaylogfile_name,
              relay_log_basename + dirname_length(relay_log_basename),
              FN_REFLEN + relay_ext_length - 1);
      opt_relay_logname = default_relaylogfile_name;
    }
  } else
    opt_relay_logname_supplied = true;

  if (relay_log_basename != nullptr)
    relay_log_index = rpl_make_log_name(key_memory_MYSQL_RELAY_LOG_index,
                                        opt_relaylog_index_name,
                                        relay_log_basename, ".index");

  if (!opt_relaylog_index_name || !opt_relaylog_index_name[0]) {
    if (relay_log_index) {
      strmake(default_relaylog_index_name,
              relay_log_index + dirname_length(relay_log_index),
              FN_REFLEN + relay_ext_length + index_ext_length - 1);
      opt_relaylog_index_name = default_relaylog_index_name;
    }
  } else
    opt_relaylog_index_name_supplied = true;

  if (relay_log_basename == nullptr || relay_log_index == nullptr) {
    LogErr(ERROR_LEVEL, ER_RPL_CANT_MAKE_PATHS, (int)FN_REFLEN, (int)FN_LEN);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  if (log_bin_basename != nullptr &&
      !strcmp(log_bin_basename, relay_log_basename)) {
    const int bin_ext_length = 4;
    char default_binlogfile_name_from_hostname[FN_REFLEN + bin_ext_length];
    /* Generate default bin log file name. */
    strmake(default_binlogfile_name_from_hostname, default_logfile_name,
            FN_REFLEN - 1);
    strcat(default_binlogfile_name_from_hostname, "-bin");

    if (!default_relaylogfile_name[0]) {
      /* Generate default relay log file name. */
      strmake(default_relaylogfile_name, default_logfile_name, FN_REFLEN - 1);
      strcat(default_relaylogfile_name, relay_ext);
    }
    /*
      Reports an error and aborts, if the same base name is specified
      for both binary and relay logs.
    */
    LogErr(ERROR_LEVEL, ER_RPL_CANT_HAVE_SAME_BASENAME, log_bin_basename,
           "--log-bin", default_binlogfile_name,
           default_binlogfile_name_from_hostname, "--relay-log",
           default_relaylogfile_name);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  if (global_system_variables.binlog_row_value_options != 0) {
    const char *msg = nullptr;
    longlong err = ER_BINLOG_ROW_VALUE_OPTION_IGNORED;
    if (!opt_bin_log)
      msg = "the binary log is disabled";
    else if (global_system_variables.binlog_format == BINLOG_FORMAT_STMT)
      msg = "binlog_format=STATEMENT";
    else if (log_bin_use_v1_row_events) {
      msg = "binlog_row_value_options=PARTIAL_JSON";
      err = ER_BINLOG_USE_V1_ROW_EVENTS_IGNORED;
    } else if (global_system_variables.binlog_row_image ==
               BINLOG_ROW_IMAGE_FULL) {
      msg = "binlog_row_image=FULL";
      err = ER_BINLOG_ROW_VALUE_OPTION_USED_ONLY_FOR_AFTER_IMAGES;
    }
    if (msg) {
      switch (err) {
        case ER_BINLOG_ROW_VALUE_OPTION_IGNORED:
        case ER_BINLOG_ROW_VALUE_OPTION_USED_ONLY_FOR_AFTER_IMAGES:
          LogErr(WARNING_LEVEL, err, msg, "PARTIAL_JSON");
          break;
        case ER_BINLOG_USE_V1_ROW_EVENTS_IGNORED:
          LogErr(WARNING_LEVEL, err, msg);
          break;
        default:
          assert(0); /* purecov: deadcode */
      }
    }
  }

  /* call ha_init_key_cache() on all key caches to init them */
  process_key_caches(&ha_init_key_cache);

  /* Allow storage engine to give real error messages */
  if (ha_init_errors()) return 1;

  if (gtid_server_init()) {
    LogErr(ERROR_LEVEL, ER_CANT_INITIALIZE_GTID);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  if (opt_log_replica_updates && replicate_same_server_id) {
    if (opt_bin_log && global_gtid_mode.get() != Gtid_mode::ON) {
      LogErr(ERROR_LEVEL, ER_RPL_INFINITY_DENIED);
      unireg_abort(MYSQLD_ABORT_EXIT);
    } else
      LogErr(WARNING_LEVEL, ER_RPL_INFINITY_IGNORED);
  }

  {
    /*
      We have to call a function in log_resource.cc, or its references
      won't be visible to plugins.
    */
#ifndef NDEBUG
    int dummy =
#endif
        Log_resource::dummy_function_to_ensure_we_are_linked_into_the_server();
    assert(dummy == 1);
  }

  /*
    We need to initialize the UDF globals early before reading the proc table
    and before the server component initialization to allow other components
    to register their UDFs at init time and de-register them at deinit time.
  */
  udf_init_globals();

  /*
    Set tc_log to point to TC_LOG_DUMMY early in order to allow plugin_init()
    to commit attachable transaction after reading from mysql.plugin table.
    If necessary tc_log will be adjusted to point to correct TC_LOG instance
    later.
  */
  tc_log = &tc_log_dummy;

  /*
   Each server should have one UUID. We will create it automatically, if it
   does not exist. It should be initialized before opening binlog file. Because
   server's uuid will be stored into the new binlog file.
  */
  if (!is_help_or_validate_option() && init_server_auto_options()) {
    LogErr(ERROR_LEVEL, ER_CANT_CREATE_UUID);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  /*Load early plugins */
  if (plugin_register_early_plugins(&remaining_argc, remaining_argv,
                                    (is_help_or_validate_option())
                                        ? PLUGIN_INIT_SKIP_INITIALIZATION
                                        : 0)) {
    LogErr(ERROR_LEVEL, ER_CANT_INITIALIZE_EARLY_PLUGINS);
    unireg_abort(1);
  }

  /* Load builtin plugins, initialize MyISAM, CSV and InnoDB */
  if (plugin_register_builtin_and_init_core_se(&remaining_argc,
                                               remaining_argv)) {
    if (!opt_validate_config)
      LogErr(ERROR_LEVEL, ER_CANT_INITIALIZE_BUILTIN_PLUGINS);
    unireg_abort(1);
  }

  /*
    Needs to be done before dd::init() which runs DDL commands (for real)
    during instance initialization.
  */
  init_sql_command_flags();

  /*
    plugin_register_dynamic_and_init_all() needs DD initialized.
    Initialize DD to create data directory using current server.
  */
  if (opt_initialize) {
    if (!is_help_or_validate_option()) {
      if (dd::init(dd::enum_dd_init_type::DD_INITIALIZE)) {
        LogErr(ERROR_LEVEL, ER_DD_INIT_FAILED);
        unireg_abort(1);
      }

      if (dd::init(dd::enum_dd_init_type::DD_INITIALIZE_SYSTEM_VIEWS)) {
        LogErr(ERROR_LEVEL, ER_SYSTEM_VIEW_INIT_FAILED);
        unireg_abort(1);
      }
    }
  } else {
    /*
      Initialize DD in case of upgrade and normal normal server restart.
      It is detected if we are starting on old data directory or current
      data directory. If it is old data directory, DD tables are created.
      If server is starting on data directory with DD tables, DD is initialized.
    */
    if (!is_help_or_validate_option() &&
        dd::init(dd::enum_dd_init_type::DD_RESTART_OR_UPGRADE)) {
      LogErr(ERROR_LEVEL, ER_DD_INIT_FAILED);

      /* If clone recovery fails, we rollback the files to previous
      dataset and attempt to restart server. */
      int exit_code =
          clone_recovery_error ? MYSQLD_RESTART_EXIT : MYSQLD_ABORT_EXIT;
      unireg_abort(exit_code);
    }
  }

  /*
   During plugin initialization, a plugin may expect (depending on what the
   plugin actually does) to find a functional server, including:
   - mysql system tables
   - information schema tables
   - performance schema tables
   - data dictionary
   - components / services, including the registry service
   During the server installation, all these parts are not available yet, as
   they are created during the installation process with mysqld --initialize.

   As a result, plugins are not loaded during mysqld --initialize, so that
   the server install can proceed and complete before any plugin is loaded
   through any config file or pre-programmed command line.
  */
  int flags = 0;

  if (opt_noacl) flags |= PLUGIN_INIT_SKIP_PLUGIN_TABLE;
  if (is_help_or_validate_option())
    flags |= PLUGIN_INIT_SKIP_INITIALIZATION | PLUGIN_INIT_SKIP_PLUGIN_TABLE;
  if (opt_initialize) flags |= PLUGIN_INIT_SKIP_DYNAMIC_LOADING;

  /*
    In the case of upgrade, we need to delay initialization of plugins that
    depend on e.g. mysql tables that will be changed during upgrade.
  */
  if (!is_help_or_validate_option() && !opt_initialize &&
      !dd::upgrade::no_server_upgrade_required() &&
      opt_upgrade_mode != UPGRADE_MINIMAL)
    flags |= PLUGIN_INIT_DELAY_UNTIL_AFTER_UPGRADE;

  /*
    Initialize the cost model, but delete it after the plugins are initialized.
    Cost model is needed while dropping and creating pfs tables to
    update metadata of referencing views (if there are any).
   */
  init_optimizer_cost_module(true);
  {  // New scope in which the error handler hook is modified.
    ErrorHandlerFunctionPointer ehh_val = error_handler_hook;
    auto restore_ehh = create_scope_guard([ehh_val]() {
      assert(ehh_val == my_message_stderr);
      error_handler_hook = ehh_val;
    });
    error_handler_hook = +[](uint c, const char *s, myf f) {
      if (c != ER_NO_SUCH_TABLE || strstr(s, "mysql.server_cost") == nullptr) {
        my_message_stderr(c, s, f);
      }
    };
    if (plugin_register_dynamic_and_init_all(&remaining_argc, remaining_argv,
                                             flags)) {
      delete_optimizer_cost_module();
      // Delete all DD tables in case of error in initializing plugins.
      if (dd::upgrade_57::in_progress())
        (void)dd::init(dd::enum_dd_init_type::DD_DELETE);

      if (!opt_validate_config)
        LogErr(ERROR_LEVEL, ER_CANT_INITIALIZE_DYNAMIC_PLUGINS);
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
  }  // End of extra scope where missing server_cost errors are not logged
  assert(error_handler_hook == my_message_stderr);
  dynamic_plugins_are_initialized =
      true; /* Don't separate from init function */
  delete_optimizer_cost_module();

  LEX_CSTRING plugin_name = {STRING_WITH_LEN("thread_pool")};
  if (Connection_handler_manager::thread_handling !=
          Connection_handler_manager::SCHEDULER_ONE_THREAD_PER_CONNECTION ||
      plugin_is_ready(plugin_name, MYSQL_DAEMON_PLUGIN)) {
    auto res_grp_mgr = resourcegroups::Resource_group_mgr::instance();
    res_grp_mgr->disable_resource_group();
    res_grp_mgr->set_unsupport_reason("Thread pool plugin enabled");
  }

#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE
  /*
    A value of the variable dd_upgrade_flag is reset after
    dd::init(dd::enum_dd_init_type::DD_POPULATE_UPGRADE) returned.
    So make its copy to call init_pfs_tables() with right argument value later.
  */
  bool dd_upgrade_was_initiated = dd::upgrade_57::in_progress();
#endif

  if (!is_help_or_validate_option() && dd::upgrade_57::in_progress()) {
    // Populate DD tables with meta data from 5.7
    if (dd::init(dd::enum_dd_init_type::DD_POPULATE_UPGRADE)) {
      LogErr(ERROR_LEVEL, ER_DD_POPULATING_TABLES_FAILED);
      unireg_abort(1);
    }
    // Run after_dd_upgrade hook
    if (RUN_HOOK(server_state, after_dd_upgrade_from_57, (nullptr)))
      unireg_abort(MYSQLD_ABORT_EXIT);
  }

  /*
    Store server and plugin IS tables metadata into new DD.
    This is done after all the plugins are registered.
  */
  if (!is_help_or_validate_option() && !opt_initialize &&
      !dd::upgrade_57::in_progress() &&
      dd::init(dd::enum_dd_init_type::DD_UPDATE_I_S_METADATA)) {
    LogErr(ERROR_LEVEL, ER_DD_UPDATING_PLUGIN_MD_FAILED);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE
  if (!is_help_or_validate_option()) {
    /*
      Initialize the cost model, but delete it after the pfs is initialized.
      Cost model is needed while dropping and creating pfs tables to
      update metadata of referencing views (if there are any).
    */
    init_optimizer_cost_module(true);

    bool st;
    if (opt_initialize || dd_upgrade_was_initiated)
      st = dd::performance_schema::init_pfs_tables(
          dd::enum_dd_init_type::DD_INITIALIZE);
    else
      st = dd::performance_schema::init_pfs_tables(
          dd::enum_dd_init_type::DD_RESTART_OR_UPGRADE);

    /* Now that the pfs is initialized, delete the cost model. */
    delete_optimizer_cost_module();

    if (st) {
      LogErr(ERROR_LEVEL, ER_PERFSCHEMA_TABLES_INIT_FAILED);
      unireg_abort(1);
    }
  }
#endif

  bool recreate_non_dd_based_system_view = dd::upgrade::I_S_upgrade_required();
  if (!is_help_or_validate_option() && !opt_initialize &&
      !dd::upgrade::no_server_upgrade_required()) {
    if (opt_upgrade_mode == UPGRADE_MINIMAL)
      LogErr(WARNING_LEVEL, ER_SERVER_UPGRADE_SKIP);
    else {
      init_optimizer_cost_module(true);
      if (bootstrap::run_bootstrap_thread(nullptr, nullptr,
                                          &dd::upgrade::upgrade_system_schemas,
                                          SYSTEM_THREAD_SERVER_UPGRADE)) {
        LogErr(ERROR_LEVEL, ER_SERVER_UPGRADE_FAILED);
        unireg_abort(MYSQLD_ABORT_EXIT);
      }
      delete_optimizer_cost_module();
      recreate_non_dd_based_system_view = true;

      /*
        When upgrade is finished, we need to initialize the plugins that
        had their initialization delayed due to dependencies on the
        environment.

        TODO: Provide a better long term solution by re-ordering startup
              sequence and rewriting the way we create and upgrade server
              resources needed by plugins.
      */
      if (dd::upgrade::plugin_initialize_delayed_after_upgrade()) {
        unireg_abort(MYSQLD_ABORT_EXIT);
      }
    }
  }

  /*
    Re-create non DD based system views after a) if we upgraded system
    schemas b) I_S system view version is changed and server system views
    were recreated. c) If the database was upgraded. We do not update this
    in upgrade-minimal mode.
   */
  if (!is_help_or_validate_option() && !opt_initialize &&
      opt_upgrade_mode != UPGRADE_MINIMAL &&
      recreate_non_dd_based_system_view) {
    if (dd::init(
            dd::enum_dd_init_type::DD_INITIALIZE_NON_DD_BASED_SYSTEM_VIEWS)) {
      LogErr(ERROR_LEVEL, ER_SYSTEM_VIEW_INIT_FAILED);
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
  }

  auto res_grp_mgr = resourcegroups::Resource_group_mgr::instance();
  // Initialize the Resource group subsystem.
  if (!is_help_or_validate_option() && !opt_initialize) {
    if (res_grp_mgr->post_init()) {
      LogErr(ERROR_LEVEL, ER_RESOURCE_GROUP_POST_INIT_FAILED);
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
  }

  Session_tracker session_track_system_variables_check;
  LEX_STRING var_list;
  char *tmp_str;
  size_t len = strlen(global_system_variables.track_sysvars_ptr);
  tmp_str = (char *)my_malloc(PSI_NOT_INSTRUMENTED, len * sizeof(char) + 2,
                              MYF(MY_WME));
  strcpy(tmp_str, global_system_variables.track_sysvars_ptr);
  var_list.length = len;
  var_list.str = tmp_str;
  if (session_track_system_variables_check.server_boot_verify(
          system_charset_info, var_list)) {
    LogErr(ERROR_LEVEL, ER_TRACK_VARIABLES_BOGUS);
    if (tmp_str) my_free(tmp_str);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
  if (tmp_str) my_free(tmp_str);

  // Validate the configuration if --validate-config was specified.
  if (opt_validate_config && (remaining_argc > 1)) {
    bool saved_getopt_skip_unknown = my_getopt_skip_unknown;
    struct my_option no_opts[] = {{nullptr, 0, nullptr, nullptr, nullptr,
                                   nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0,
                                   nullptr, 0, nullptr}};

    my_getopt_skip_unknown = false;

    if (handle_options(&remaining_argc, &remaining_argv, no_opts,
                       mysqld_get_one_option))
      unireg_abort(MYSQLD_ABORT_EXIT);
    my_getopt_skip_unknown = saved_getopt_skip_unknown;
  }

  if (is_help_or_validate_option()) unireg_abort(MYSQLD_SUCCESS_EXIT);

  /* if the errmsg.sys is not loaded, terminate to maintain behaviour */
  if (!my_default_lc_messages->errmsgs->is_loaded()) {
    LogErr(ERROR_LEVEL, ER_CANT_READ_ERRMSGS);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  /* We have to initialize the storage engines before CSV logging */
  if (ha_init()) {
    LogErr(ERROR_LEVEL, ER_CANT_INIT_DBS);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  /* Initialize ndbinfo tables in DD */
  if (dd::ndbinfo::init_schema_and_tables(opt_upgrade_mode)) {
    LogErr(ERROR_LEVEL, ER_NDBINFO_UPGRADING_SCHEMA_FAIL);
    unireg_abort(1);
  }

  if (opt_initialize) log_output_options = LOG_FILE;

  /*
    Issue a warning if there were specified additional options to the
    log-output along with NONE. Probably this wasn't what user wanted.
  */
  if ((log_output_options & LOG_NONE) && (log_output_options & ~LOG_NONE))
    LogErr(WARNING_LEVEL, ER_LOG_OUTPUT_CONTRADICTORY);

  if (log_output_options & LOG_TABLE) {
    /* Fall back to log files if the csv engine is not loaded. */
    LEX_CSTRING csv_name = {STRING_WITH_LEN("csv")};
    if (!plugin_is_ready(csv_name, MYSQL_STORAGE_ENGINE_PLUGIN)) {
      LogErr(ERROR_LEVEL, ER_NO_CSV_NO_LOG_TABLES);
      log_output_options = (log_output_options & ~LOG_TABLE) | LOG_FILE;
    }
  }

  query_logger.set_handlers(log_output_options);

  // Open slow log file if enabled.
  query_logger.set_log_file(QUERY_LOG_SLOW);
  if (opt_slow_log && query_logger.reopen_log_file(QUERY_LOG_SLOW))
    opt_slow_log = false;

  // Open general log file if enabled.
  query_logger.set_log_file(QUERY_LOG_GENERAL);
  if (opt_general_log && query_logger.reopen_log_file(QUERY_LOG_GENERAL))
    opt_general_log = false;

  /*
    Set the default storage engines
  */
  if (initialize_storage_engine(default_storage_engine, "",
                                &global_system_variables.table_plugin))
    unireg_abort(MYSQLD_ABORT_EXIT);
  if (initialize_storage_engine(default_tmp_storage_engine, " temp",
                                &global_system_variables.temp_table_plugin))
    unireg_abort(MYSQLD_ABORT_EXIT);

  if (!opt_initialize && !opt_noacl) {
    set_externally_disabled_storage_engine_names(opt_disabled_storage_engines);

    // Log warning if default_storage_engine is a disabled storage engine.
    handlerton *default_se_handle =
        plugin_data<handlerton *>(global_system_variables.table_plugin);
    if (ha_is_storage_engine_disabled(default_se_handle))
      LogErr(WARNING_LEVEL, ER_DISABLED_STORAGE_ENGINE_AS_DEFAULT,
             "default_storage_engine", default_storage_engine);

    // Log warning if default_tmp_storage_engine is a disabled storage engine.
    handlerton *default_tmp_se_handle =
        plugin_data<handlerton *>(global_system_variables.temp_table_plugin);
    if (ha_is_storage_engine_disabled(default_tmp_se_handle))
      LogErr(WARNING_LEVEL, ER_DISABLED_STORAGE_ENGINE_AS_DEFAULT,
             "default_tmp_storage_engine", default_tmp_storage_engine);
  }

  DBUG_EXECUTE_IF("total_ha_2pc_equals_2", total_ha_2pc = 2;);
  if (total_ha_2pc > 1 || (1 == total_ha_2pc && opt_bin_log)) {
    if (opt_bin_log)
      tc_log = &mysql_bin_log;
    else
      tc_log = &tc_log_mmap;
  }

  if (Recovered_xa_transactions::init()) {
    LogErr(ERROR_LEVEL, ER_OOM);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  RUN_HOOK(server_state, before_recovery, (nullptr));
  if (tc_log->open(opt_bin_log ? opt_bin_logname : opt_tc_log_file)) {
    LogErr(ERROR_LEVEL, ER_CANT_INIT_TC_LOG);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  if (dd::reset_tables_and_tablespaces()) {
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
  ha_post_recover();

  /*
    Add prepared XA transactions into the cache of XA transactions and acquire
    mdl lock for every table involved in any of these prepared XA transactions.
    This step moved away from the function ha_recover() in order to avoid
    possible suspending on acquiring EXCLUSIVE mdl lock on tables inside the
    function dd::reset_tables_and_tablespaces() when table cache being reset.
  */
  if (Recovered_xa_transactions::instance()
          .recover_prepared_xa_transactions()) {
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  if (global_gtid_mode.get() == Gtid_mode::ON &&
      _gtid_consistency_mode != GTID_CONSISTENCY_MODE_ON) {
    LogErr(ERROR_LEVEL, ER_RPL_GTID_MODE_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  if (rpl_encryption.initialize()) {
    LogErr(ERROR_LEVEL, ER_SERVER_RPL_ENCRYPTION_UNABLE_TO_INITIALIZE);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }

  if (opt_bin_log) {
    /*
      Configures what object is used by the current log to store processed
      gtid(s). This is necessary in the MYSQL_BIN_LOG::MYSQL_BIN_LOG to
      correctly compute the set of previous gtids.
    */
    assert(!mysql_bin_log.is_relay_log);
    mysql_mutex_t *log_lock = mysql_bin_log.get_log_lock();
    mysql_mutex_lock(log_lock);

    if (mysql_bin_log.open_binlog(opt_bin_logname, nullptr, max_binlog_size,
                                  false, true /*need_lock_index=true*/,
                                  true /*need_sid_lock=true*/, nullptr)) {
      mysql_mutex_unlock(log_lock);
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
    mysql_mutex_unlock(log_lock);
  }

  /*
    When we pass non-zero values for both expire_logs_days and
    binlog_expire_logs_seconds at the server start-up, the value of
    expire_logs_days will be ignored and only binlog_expire_logs_seconds
    will be used.
  */
  if (binlog_expire_logs_seconds_supplied && expire_logs_days_supplied) {
    if (binlog_expire_logs_seconds != 0 && expire_logs_days != 0) {
      LogErr(WARNING_LEVEL, ER_EXPIRE_LOGS_DAYS_IGNORED);
      expire_logs_days = 0;
    }
  } else if (expire_logs_days_supplied)
    binlog_expire_logs_seconds = 0;
  assert(expire_logs_days == 0 || binlog_expire_logs_seconds == 0);

  if (!opt_bin_log) {
    if (binlog_expire_logs_seconds_supplied)
      LogErr(WARNING_LEVEL, ER_NEED_LOG_BIN, "--binlog-expire-logs-seconds");
    if (expire_logs_days_supplied)
      LogErr(WARNING_LEVEL, ER_NEED_LOG_BIN, "--expire_logs_days");
  }

  if (opt_myisam_log) (void)mi_log(1);

#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT)
  if (locked_in_memory && !getuid()) {
    if (setreuid((uid_t)-1, 0) == -1) {  // this should never happen
      LogErr(ERROR_LEVEL, ER_FAIL_SETREUID, strerror(errno));
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
    if (mlockall(MCL_CURRENT)) {
      LogErr(WARNING_LEVEL, ER_FAILED_TO_LOCK_MEM,
             errno); /* purecov: inspected */
      locked_in_memory = false;
    }
#ifndef _WIN32
    if (!user_info.IsVoid()) set_user(mysqld_user, user_info);
#endif
  } else
#endif
    locked_in_memory = false;

  rpl_acf_configuration_handler = new Rpl_acf_configuration_handler();
  if (rpl_acf_configuration_handler->init()) {
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
  rpl_source_io_monitor = new Source_IO_monitor();
  udf_load_service.init();

  /* Initialize the optimizer cost module */
  init_optimizer_cost_module(true);
  ft_init_stopwords();

  init_max_user_conn();

#if defined(MYSQL_ICU_DATADIR)
  init_icu_data_directory();
#endif  // MYSQL_ICU_DATADIR

  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: fix_max_relay_log_size
static bool fix_max_relay_log_size(sys_var *, THD *, enum_var_type) {
  Master_info *mi = nullptr;

  channel_map.wrlock();
  for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();
       it++) {
    mi = it->second;

    if (mi != nullptr)
      mi->rli->relay_log.set_max_size(max_relay_log_size ? max_relay_log_size
                                                         : max_binlog_size);
  }
  channel_map.unlock();
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: fix_max_binlog_size
static bool fix_max_binlog_size(sys_var *, THD *, enum_var_type) {
  mysql_bin_log.set_max_size(max_binlog_size);
  /*
    For multisource replication, this max size is set to all relay logs
    per channel. So, run through them
  */
  if (!max_relay_log_size) {
    Master_info *mi = nullptr;

    channel_map.wrlock();
    for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();
         it++) {
      mi = it->second;
      if (mi != nullptr) mi->rli->relay_log.set_max_size(max_binlog_size);
    }
    channel_map.unlock();
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::open_binlog
int MYSQL_BIN_LOG::open_binlog(const char *opt_name) {
  LOG_INFO log_info;
  int error = 1;

  /*
    This function is used for 2pc transaction coordination.  Hence, it
    is never used for relay logs.
  */
  assert(!is_relay_log);
  assert(total_ha_2pc > 1 || (1 == total_ha_2pc && opt_bin_log));
  assert(opt_name && opt_name[0]);

  if (!my_b_inited(&index_file)) {
    /* There was a failure to open the index file, can't open the binlog */
    cleanup();
    return 1;
  }

  if (using_heuristic_recover()) {
    /* generate a new binlog to mask a corrupted one */
    mysql_mutex_lock(&LOCK_log);
    open_binlog(opt_name, nullptr, max_binlog_size, false,
                true /*need_lock_index=true*/, true /*need_sid_lock=true*/,
                nullptr);
    mysql_mutex_unlock(&LOCK_log);
    cleanup();
    return 1;
  }

  if ((error = find_log_pos(&log_info, NullS, true /*need_lock_index=true*/))) {
    if (error != LOG_INFO_EOF)
      LogErr(ERROR_LEVEL, ER_BINLOG_CANT_FIND_LOG_IN_INDEX, error);
    else {
      /* should execute ha_recover */
      error = ha_recover();
      if (error)
        LogErr(ERROR_LEVEL, ER_BINLOG_CRASH_RECOVERY_ERROR_RETURNED_SE);
    }
    return error;
  }

  char log_name[FN_REFLEN];

  do {
    strmake(log_name, log_info.log_file_name, sizeof(log_name) - 1);
  } while (!(error = find_next_log(&log_info, true /*need_lock_index=true*/)));

  if (error != LOG_INFO_EOF) {
    LogErr(ERROR_LEVEL, ER_BINLOG_CANT_FIND_LOG_IN_INDEX, error);
    return error;
  }

  Binlog_file_reader binlog_file_reader(opt_source_verify_checksum);
  if (binlog_file_reader.open(log_name)) {
    LogErr(ERROR_LEVEL, ER_BINLOG_FILE_OPEN_FAILED,
           binlog_file_reader.get_error_str());
    return 1;
  }

  /*
    If the binary log was not properly closed it means that the server
    may have crashed. In that case, we need to call
    binlog::Binlog_recovery::recover()
    to:
      a) collect logged XIDs;
      b) complete the 2PC of the pending XIDs;
      c) collect the last valid position.

    Therefore, we do need to iterate over the binary log, even if
    total_ha_2pc == 1, to find the last valid group of events written.
    Later we will take this value and truncate the log if need be.
  */
  if (!read_binlog_in_use_flag(binlog_file_reader)) {
    /* should execute ha_recover */
    error = ha_recover();
    if (error) LogErr(ERROR_LEVEL, ER_BINLOG_CRASH_RECOVERY_ERROR_RETURNED_SE);
    return error;
  }

  LogErr(INFORMATION_LEVEL, ER_BINLOG_RECOVERING_AFTER_CRASH_USING, opt_name);

  binlog::Binlog_recovery bl_recovery{binlog_file_reader};
  bl_recovery.recover();

  my_off_t valid_pos = bl_recovery.get_valid_pos();
  my_off_t binlog_size = binlog_file_reader.ifile()->length();

  if (bl_recovery.is_binlog_malformed()) {
    LogErr(ERROR_LEVEL, ER_BINLOG_CRASH_RECOVERY_MALFORMED_LOG, log_name,
           valid_pos, binlog_file_reader.position(),
           bl_recovery.get_failure_message().data());
    return 1;
  }
  if (bl_recovery.has_engine_recovery_failed()) {
    /* truncate log file but do not clear LOG_EVENT_IN_USE_F flag */
    LogErr(ERROR_LEVEL, ER_BINLOG_CRASH_RECOVERY_ERROR_RETURNED_SE);
    if (!truncate_update_log_file(log_name, valid_pos, binlog_size, false)) {
      /* log error has been written */
    }
    return 1;
  }

  /* Trim the crashed binlog file to last valid transaction
     or event (non-transaction) base on valid_pos. */
  if (valid_pos > 0) {
    /* truncate log file and clear LOG_EVENT_IN_USE_F flag */
    if (!truncate_update_log_file(log_name, valid_pos, binlog_size, true)) {
      /* log error has been written */
      return 1;
    }
  }  // end if (valid_pos > 0)

  return 0;
}

--------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_rli.cc
Function: Relay_log_info::purge_relay_logs
int Relay_log_info::purge_relay_logs(THD *thd, const char **errmsg,
                                     bool delete_only) {
  int error = 0;
  const char *ln;
  /* name of the index file if opt_relaylog_index_name is set*/
  const char *log_index_name;
  /*
    Buffer to add channel name suffix when relay-log-index option is
    provided
   */
  char relay_bin_index_channel[FN_REFLEN];

  const char *ln_without_channel_name;
  /*
    Buffer to add channel name suffix when relay-log option is provided.
   */
  char relay_bin_channel[FN_REFLEN];

  char buffer[FN_REFLEN];

  mysql_mutex_t *log_lock = relay_log.get_log_lock();

  DBUG_TRACE;

  /*
    Even if inited==0, we still try to empty master_log_* variables. Indeed,
    inited==0 does not imply that they already are empty.

    It could be that slave's info initialization partly succeeded: for example
    if relay-log.info existed but all relay logs have been manually removed,
    init_info reads the old relay-log.info and fills rli->master_log_*, then
    init_info checks for the existence of the relay log, this fails and
    init_info leaves inited to 0.
    In that pathological case, master_log_pos* will be properly reinited at
    the next START SLAVE (as RESET SLAVE or CHANGE MASTER, the callers of
    purge_relay_logs, will delete bogus *.info files or replace them with
    correct files), however if the user does SHOW SLAVE STATUS before START
    SLAVE, he will see old, confusing master_log_*. In other words, we reinit
    master_log_* for SHOW SLAVE STATUS to display fine in any case.
  */
  group_master_log_name[0] = 0;
  group_master_log_pos = 0;

  /*
    Following the the relay log purge, the master_log_pos will be in sync
    with relay_log_pos, so the flag should be cleared. Refer bug#11766010.
  */

  is_group_master_log_pos_invalid = false;

  if (!inited) {
    DBUG_PRINT("info", ("inited == 0"));
    if (error_on_rli_init_info ||
        /*
          mi->reset means that the channel was reset but still exists. Channel
          shall have the index and the first relay log file.

          Those files shall be remove in a following RESET SLAVE ALL (even when
          channel was not inited again).
        */
        (mi->reset && delete_only)) {
      assert(relay_log.is_relay_log);
      ln_without_channel_name =
          relay_log.generate_name(opt_relay_logname, "-relay-bin", buffer);

      ln = add_channel_to_relay_log_name(relay_bin_channel, FN_REFLEN,
                                         ln_without_channel_name);
      if (opt_relaylog_index_name_supplied) {
        char index_file_withoutext[FN_REFLEN];
        relay_log.generate_name(opt_relaylog_index_name, "",
                                index_file_withoutext);

        log_index_name = add_channel_to_relay_log_name(
            relay_bin_index_channel, FN_REFLEN, index_file_withoutext);
      } else
        log_index_name = nullptr;

      if (relay_log.open_index_file(log_index_name, ln, true)) {
        LogErr(ERROR_LEVEL, ER_REPLICA_RELAY_LOG_PURGE_FAILED,
               "Failed to open relay log index file:",
               relay_log.get_index_fname());
        return 1;
      }
      mysql_mutex_lock(&mi->data_lock);
      mysql_mutex_lock(log_lock);
      if (relay_log.open_binlog(
              ln, nullptr,
              (max_relay_log_size ? max_relay_log_size : max_binlog_size), true,
              true /*need_lock_index=true*/, true /*need_sid_lock=true*/,
              mi->get_mi_description_event())) {
        mysql_mutex_unlock(log_lock);
        mysql_mutex_unlock(&mi->data_lock);
        LogErr(ERROR_LEVEL, ER_REPLICA_RELAY_LOG_PURGE_FAILED,
               "Failed to open relay log file:", relay_log.get_log_fname());
        return 1;
      }
      mysql_mutex_unlock(log_lock);
      mysql_mutex_unlock(&mi->data_lock);
    } else
      return 0;
  } else {
    assert(slave_running == 0);
    assert(mi->slave_running == 0);
  }
  /* Reset the transaction boundary parser and clear the last GTID queued */
  mi->transaction_parser.reset();
  mysql_mutex_lock(&mi->data_lock);
  mi->clear_gtid_monitoring_info();
  mysql_mutex_unlock(&mi->data_lock);

  slave_skip_counter = 0;
  mysql_mutex_lock(&data_lock);

  /**
    Clear the retrieved gtid set for this channel.
  */
  get_sid_lock()->wrlock();
  (const_cast<Gtid_set *>(get_gtid_set()))->clear_set_and_sid_map();
  get_sid_lock()->unlock();

  if (relay_log.reset_logs(thd, delete_only)) {
    *errmsg = "Failed during log reset";
    error = 1;
    goto err;
  }

  /* Save name of used relay log file */
  set_group_relay_log_name(relay_log.get_log_fname());
  group_relay_log_pos = BIN_LOG_HEADER_SIZE;
  if (!delete_only && count_relay_log_space()) {
    *errmsg = "Error counting relay log space";
    error = 1;
    goto err;
  }

  if (!inited && error_on_rli_init_info)
    relay_log.close(LOG_CLOSE_INDEX | LOG_CLOSE_STOP_EVENT,
                    true /*need_lock_log=true*/, true /*need_lock_index=true*/);
err:
#ifndef NDEBUG
  char buf[22];
#endif
  DBUG_PRINT("info", ("log_space_total: %s", llstr(log_space_total, buf)));
  mysql_mutex_unlock(&data_lock);
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_rli.cc
Function: Relay_log_info::rli_init_info
int Relay_log_info::rli_init_info(bool skip_received_gtid_set_recovery) {
  int error = 0;
  enum_return_check check_return = ERROR_CHECKING_REPOSITORY;
  const char *msg = nullptr;
  DBUG_TRACE;

  mysql_mutex_assert_owner(&data_lock);

  /*
    If Relay_log_info is issued again after a failed init_info(), for
    instance because of missing relay log files, it will generate new
    files and ignore the previous failure, to avoid that we set
    error_on_rli_init_info as true.
    This a consequence of the behaviour change, in the past server was
    stopped when there were replication initialization errors, now it is
    not and so init_info() must be aware of previous failures.
  */
  if (error_on_rli_init_info) goto err;

  if (inited) {
    return recovery_parallel_workers ? mts_recovery_groups(this) : 0;
  }

  slave_skip_counter = 0;
  abort_pos_wait = 0;
  log_space_limit = relay_log_space_limit;
  log_space_total = 0;
  tables_to_lock = nullptr;
  tables_to_lock_count = 0;

  char pattern[FN_REFLEN];
  (void)my_realpath(pattern, replica_load_tmpdir, 0);
  /*
   @TODO:
    In MSR, sometimes slave fail with the following error:
    Unable to use slave's temporary directory /tmp -
    Can't create/write to file
   '/tmp/SQL_LOAD-92d1eee0-9de4-11e3-8874-68730ad50fcb'    (Errcode: 17 - File
   exists), Error_code: 1

   */
  if (fn_format(pattern, PREFIX_SQL_LOAD, pattern, "",
                MY_SAFE_PATH | MY_RETURN_REAL_PATH) == NullS) {
    LogErr(ERROR_LEVEL, ER_REPLICA_CANT_USE_TEMPDIR, replica_load_tmpdir);
    return 1;
  }
  unpack_filename(slave_patternload_file, pattern);
  slave_patternload_file_size = strlen(slave_patternload_file);

  /*
    The relay log will now be opened, as a WRITE_CACHE IO_CACHE.
    Note that the I/O thread flushes it to disk after writing every
    event, in flush_info within the master info.
  */
  /*
    For the maximum log size, we choose max_relay_log_size if it is
    non-zero, max_binlog_size otherwise. If later the user does SET
    GLOBAL on one of these variables, fix_max_binlog_size and
    fix_max_relay_log_size will reconsider the choice (for example
    if the user changes max_relay_log_size to zero, we have to
    switch to using max_binlog_size for the relay log) and update
    relay_log.max_size (and mysql_bin_log.max_size).
  */
  {
    /* Reports an error and returns, if the --relay-log's path
       is a directory.*/
    if (opt_relay_logname &&
        opt_relay_logname[strlen(opt_relay_logname) - 1] == FN_LIBCHAR) {
      LogErr(ERROR_LEVEL, ER_RPL_RELAY_LOG_NEEDS_FILE_NOT_DIRECTORY,
             opt_relay_logname);
      return 1;
    }

    /* Reports an error and returns, if the --relay-log-index's path
       is a directory.*/
    if (opt_relaylog_index_name &&
        opt_relaylog_index_name[strlen(opt_relaylog_index_name) - 1] ==
            FN_LIBCHAR) {
      LogErr(ERROR_LEVEL, ER_RPL_RELAY_LOG_INDEX_NEEDS_FILE_NOT_DIRECTORY,
             opt_relaylog_index_name);
      return 1;
    }

    char buf[FN_REFLEN];
    /* The base name of the relay log file considering multisource rep */
    const char *ln;
    /*
      relay log name without channel prefix taking into account
      --relay-log option.
    */
    const char *ln_without_channel_name;
    static bool name_warning_sent = false;

    /*
      Buffer to add channel name suffix when relay-log option is provided.
    */
    char relay_bin_channel[FN_REFLEN];
    /*
      Buffer to add channel name suffix when relay-log-index option is provided
    */
    char relay_bin_index_channel[FN_REFLEN];

    /* name of the index file if opt_relaylog_index_name is set*/
    const char *log_index_name;

    ln_without_channel_name =
        relay_log.generate_name(opt_relay_logname, "-relay-bin", buf);

    ln = add_channel_to_relay_log_name(relay_bin_channel, FN_REFLEN,
                                       ln_without_channel_name);

    /* We send the warning only at startup, not after every RESET SLAVE */
    if (!opt_relay_logname_supplied && !opt_relaylog_index_name_supplied &&
        !name_warning_sent) {
      /*
        User didn't give us info to name the relay log index file.
        Picking `hostname`-relay-bin.index like we do, causes replication to
        fail if this slave's hostname is changed later. So, we would like to
        instead require a name. But as we don't want to break many existing
        setups, we only give warning, not error.
      */
      LogErr(WARNING_LEVEL, ER_RPL_PLEASE_USE_OPTION_RELAY_LOG,
             ln_without_channel_name);
      name_warning_sent = true;
    }

    /*
       If relay log index option is set, convert into channel specific
       index file. If the opt_relaylog_index has an extension, we strip
       it too. This is inconsistent to relay log names.
    */
    if (opt_relaylog_index_name_supplied) {
      char index_file_withoutext[FN_REFLEN];
      relay_log.generate_name(opt_relaylog_index_name, "",
                              index_file_withoutext);

      log_index_name = add_channel_to_relay_log_name(
          relay_bin_index_channel, FN_REFLEN, index_file_withoutext);
    } else
      log_index_name = nullptr;

    if (relay_log.open_index_file(log_index_name, ln, true)) {
      LogErr(ERROR_LEVEL, ER_RPL_OPEN_INDEX_FILE_FAILED);
      return 1;
    }

    if (!gtid_retrieved_initialized) {
      /* Store the GTID of a transaction spanned in multiple relay log files */
      Gtid_monitoring_info *partial_trx = mi->get_gtid_monitoring_info();
      partial_trx->clear();
#ifndef NDEBUG
      get_sid_lock()->wrlock();
      gtid_set->dbug_print("set of GTIDs in relay log before initialization");
      get_sid_lock()->unlock();
#endif
      /*
        In the init_gtid_set below we pass the mi->transaction_parser.
        This will be useful to ensure that we only add a GTID to
        the Retrieved_Gtid_Set for fully retrieved transactions. Also, it will
        be useful to ensure the Retrieved_Gtid_Set behavior when auto
        positioning is disabled (we could have transactions spanning multiple
        relay log files in this case).
        We will skip this initialization if relay_log_recovery is set in order
        to save time, as neither the GTIDs nor the transaction_parser state
        would be useful when the relay log will be cleaned up later when calling
        init_recovery.
      */
      if (!is_relay_log_recovery && !gtid_retrieved_initialized &&
          !skip_received_gtid_set_recovery &&
          relay_log.init_gtid_sets(
              gtid_set, nullptr, opt_replica_sql_verify_checksum,
              true /*true=need lock*/, &mi->transaction_parser, partial_trx)) {
        LogErr(ERROR_LEVEL, ER_RPL_CANT_INITIALIZE_GTID_SETS_IN_AM_INIT_INFO);
        return 1;
      }
      gtid_retrieved_initialized = true;
#ifndef NDEBUG
      get_sid_lock()->wrlock();
      gtid_set->dbug_print("set of GTIDs in relay log after initialization");
      get_sid_lock()->unlock();
#endif
    }
    /*
      Configures what object is used by the current log to store processed
      gtid(s). This is necessary in the MYSQL_BIN_LOG::MYSQL_BIN_LOG to
      correctly compute the set of previous gtids.
    */
    relay_log.set_previous_gtid_set_relaylog(gtid_set);
    /*
      note, that if open() fails, we'll still have index file open
      but a destructor will take care of that
    */

    mysql_mutex_t *log_lock = relay_log.get_log_lock();
    mysql_mutex_lock(log_lock);

    if (relay_log.open_binlog(
            ln, nullptr,
            (max_relay_log_size ? max_relay_log_size : max_binlog_size), true,
            true /*need_lock_index=true*/, true /*need_sid_lock=true*/,
            mi->get_mi_description_event())) {
      mysql_mutex_unlock(log_lock);
      LogErr(ERROR_LEVEL, ER_RPL_CANT_OPEN_LOG_IN_AM_INIT_INFO);
      return 1;
    }

    mysql_mutex_unlock(log_lock);
  }

  /*
   This checks if the repository was created before and thus there
   will be values to be read. Please, do not move this call after
   the handler->init_info().
 */
  if ((check_return = check_info()) == ERROR_CHECKING_REPOSITORY) {
    msg = "Error checking relay log repository";
    error = 1;
    goto err;
  }

  if (handler->init_info()) {
    msg = "Error reading relay log configuration";
    error = 1;
    goto err;
  }

  check_return = check_if_info_was_cleared(check_return);

  if (check_return & REPOSITORY_EXISTS) {
    if (read_info(handler)) {
      msg = "Error reading relay log configuration";
      error = 1;
      goto err;
    }

    /*
      Clone required cleanup must be done only once, thence we only
      do it when server is booting.
    */
    if (clone_startup && get_server_state() == SERVER_BOOTING) {
      char *channel_name =
          (const_cast<Relay_log_info *>(mi->rli))->get_channel();
      bool is_group_replication_channel =
          channel_map.is_group_replication_channel_name(channel_name);
      if (is_group_replication_channel) {
        if (Rpl_info_factory::reset_workers(this)) {
          msg =
              "Error cleaning relay log worker configuration for group "
              "replication after clone";
          error = 1;
          goto err;
        }
        if (clear_info()) {
          msg =
              "Error cleaning relay log configuration for group replication "
              "after clone";
          error = 1;
          goto err;
        }
        check_return = REPOSITORY_CLEARED;
      } else {
        if (!is_relay_log_recovery) {
          LogErr(WARNING_LEVEL, ER_RPL_RELAY_LOG_RECOVERY_INFO_AFTER_CLONE,
                 channel_name);
          // After a clone if we detect information is present we always invoke
          // relay log recovery. Not doing so would probably mean failure at
          // initialization due to missing relay log files.
          if (init_recovery(mi)) {
            msg = "Error on the relay log recovery after a clone operation";
            error = 1;
            goto err;
          }
        }
      }
    }
  }

  if (check_return == REPOSITORY_DOES_NOT_EXIST ||  // Hasn't been initialized
      check_return == REPOSITORY_CLEARED  // Was initialized but was RESET
  ) {
    /* Init relay log with first entry in the relay index file */
    if (reset_group_relay_log_pos(&msg)) {
      error = 1;
      goto err;
    }
    group_master_log_name[0] = 0;
    group_master_log_pos = 0;
  } else {
    if (is_relay_log_recovery) {
      if (init_recovery(mi)) {
        error = 1;
        goto err;
      }
    } else if (mi->is_gtid_only_mode()) {
      std::string index_entry_name;
      std::string errmsg;
      if (relay_log.find_first_log(index_entry_name, errmsg)) {
        /* purecov: begin tested */
        LogErr(ERROR_LEVEL, ER_RPL_CANNOT_OPEN_RELAY_LOG, errmsg.c_str());
        error = 1;
        goto err;
        /* purecov: end */
      }
      set_group_relay_log_name(index_entry_name.c_str());
      set_group_relay_log_pos(BIN_LOG_HEADER_SIZE);
    }

    if (!mi->is_gtid_only_mode() && is_group_relay_log_name_invalid(&msg)) {
      LogErr(ERROR_LEVEL, ER_RPL_MTA_RECOVERY_CANT_OPEN_RELAY_LOG,
             group_relay_log_name, std::to_string(group_relay_log_pos).c_str());
      error = 1;
      goto err;
    }
  }

  inited = true;
  error_on_rli_init_info = false;
  if (flush_info(RLI_FLUSH_IGNORE_SYNC_OPT | RLI_FLUSH_IGNORE_GTID_ONLY)) {
    msg = "Error reading relay log configuration";
    error = 1;
    goto err;
  }

  if (count_relay_log_space()) {
    msg = "Error counting relay log space";
    error = 1;
    goto err;
  }

  /*
    In case of MTS the recovery is deferred until the end of
    load_mi_and_rli_from_repositories.
  */
  if (!mi->rli->mts_recovery_group_cnt) is_relay_log_recovery = false;
  return error;

err:
  handler->end_info();
  inited = false;
  error_on_rli_init_info = true;
  if (msg) LogErr(ERROR_LEVEL, ER_RPL_AM_INIT_INFO_MSG, msg);
  relay_log.close(LOG_CLOSE_INDEX | LOG_CLOSE_STOP_EVENT,
                  true /*need_lock_log=true*/, true /*need_lock_index=true*/);
  return error;
}


