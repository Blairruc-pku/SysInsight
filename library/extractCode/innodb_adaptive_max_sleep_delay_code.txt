-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/srv/srv0conc.cc
Function: srv_conc_enter_innodb_with_atomics
static dberr_t srv_conc_enter_innodb_with_atomics(trx_t *trx) {
  ulint n_sleeps = 0;
  bool notified_mysql = false;

  ut_a(!trx->declared_to_be_inside_innodb);

  for (;;) {
    ulint sleep_in_us;

    if (srv_thread_concurrency == 0) {
      if (notified_mysql) {
        srv_conc.n_waiting.fetch_sub(1, std::memory_order_relaxed);

        thd_wait_end(trx->mysql_thd);
      }

      return DB_SUCCESS;
    }

    if (srv_conc.n_active.load(std::memory_order_relaxed) <
        (int32_t)srv_thread_concurrency) {
      /* Check if there are any free tickets. */
      const auto n_active =
          srv_conc.n_active.fetch_add(1, std::memory_order_acquire) + 1;

      if (n_active <= (int32_t)srv_thread_concurrency) {
        srv_enter_innodb_with_tickets(trx);

        if (notified_mysql) {
          srv_conc.n_waiting.fetch_sub(1, std::memory_order_relaxed);

          thd_wait_end(trx->mysql_thd);
        }

        if (srv_adaptive_max_sleep_delay > 0) {
          if (srv_thread_sleep_delay > 20 && n_sleeps == 1) {
            --srv_thread_sleep_delay;
          }

          if (srv_conc.n_waiting.load(std::memory_order_relaxed) == 0) {
            srv_thread_sleep_delay >>= 1;
          }
        }

        return DB_SUCCESS;
      }

      /* Since there were no free seats, we relinquish
      the overbooked ticket. */
      srv_conc.n_active.fetch_sub(1, std::memory_order_release);
    }

    if (!notified_mysql) {
      srv_conc.n_waiting.fetch_add(1, std::memory_order_relaxed);

      thd_wait_begin(trx->mysql_thd, THD_WAIT_USER_LOCK);

      notified_mysql = true;
    }

    DEBUG_SYNC_C("user_thread_waiting");
    trx->op_info = "sleeping before entering InnoDB";

    sleep_in_us = srv_thread_sleep_delay;

    /* Guard against overflow when adaptive sleep delay is on. */

    if (srv_adaptive_max_sleep_delay > 0 &&
        sleep_in_us > srv_adaptive_max_sleep_delay) {
      sleep_in_us = srv_adaptive_max_sleep_delay;
      srv_thread_sleep_delay = static_cast<ulong>(sleep_in_us);
    }

    std::this_thread::sleep_for(std::chrono::microseconds(sleep_in_us));

    trx->op_info = "";

    ++n_sleeps;

    if (srv_adaptive_max_sleep_delay > 0 && n_sleeps > 1) {
      ++srv_thread_sleep_delay;
    }

    if (trx_is_interrupted(trx)) {
      if (notified_mysql) {
        srv_conc.n_waiting.fetch_sub(1, std::memory_order_relaxed);

        thd_wait_end(trx->mysql_thd);
      }
      return DB_INTERRUPTED;
    }
  }
}


