-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/log/log0log.cc
Function: log_sys_init
dberr_t log_sys_init(bool expect_no_files, lsn_t flushed_lsn,
                     lsn_t &new_files_lsn) {
  ut_a(log_is_data_lsn(flushed_lsn));
  ut_a(log_sys == nullptr);

  new_files_lsn = 0;

  Log_files_context log_files_ctx{srv_log_group_home_dir,
                                  Log_files_ruleset::PRE_8_0_30};

  std::string root_path;
  bool found_files_in_root{false};
  dberr_t err =
      log_sys_check_directory(log_files_ctx, root_path, found_files_in_root);

  /* Report error if innodb_log_group_home_dir / datadir has not been found or
  could not be listed. It's a proper decision for all redo format versions:
    - older formats store there ib_logfile* files directly,
    - newer formats store there #innodb_redo subdirectory. */
  if (err != DB_SUCCESS) {
    ib::error(ER_IB_MSG_LOG_INIT_DIR_LIST_FAILED, root_path.c_str());
    return err;
  }

  Log_file_handle::s_on_before_read = [](Log_file_id, Log_file_type file_type,
                                         os_offset_t, os_offset_t read_size) {
    ut_a(file_type == Log_file_type::NORMAL);
    ut_a(srv_is_being_started);
#ifndef UNIV_HOTBACKUP
    srv_stats.data_read.add(read_size);
#endif /* !UNIV_HOTBACKUP */
  };

  Log_file_handle::s_on_before_write =
      [](Log_file_id file_id, Log_file_type file_type, os_offset_t write_offset,
         os_offset_t write_size) {
        ut_a(!srv_read_only_mode);
        if (!srv_is_being_started) {
          ut_a(log_sys != nullptr);
          auto file = log_sys->m_files.file(file_id);
          if (file_type == Log_file_type::NORMAL) {
            ut_a(file != log_sys->m_files.end());
            ut_a((file_id == log_sys->m_current_file.m_id &&
                  write_offset + write_size <= file->m_size_in_bytes) ||
                 write_offset + write_size <= LOG_FILE_HDR_SIZE);
          } else {
            ut_a(file == log_sys->m_files.end());
            ut_a(file_id == log_sys->m_current_file.next_id());
          }
        }
#ifndef UNIV_HOTBACKUP
        srv_stats.data_written.add(write_size);
#endif
      };

#ifndef _WIN32
  Log_file_handle::s_skip_fsyncs =
      (srv_unix_file_flush_method == SRV_UNIX_O_DSYNC ||
       srv_unix_file_flush_method == SRV_UNIX_NOSYNC);
#endif /* !_WIN32 */

  if (!found_files_in_root) {
    log_files_ctx =
        Log_files_context{srv_log_group_home_dir, Log_files_ruleset::CURRENT};

    std::string subdir_path;
    bool found_files_in_subdir{false};
    err = log_sys_check_directory(log_files_ctx, subdir_path,
                                  found_files_in_subdir);

    switch (err) {
      case DB_SUCCESS:
        if (expect_no_files && found_files_in_subdir) {
          ib::error(ER_IB_MSG_LOG_INIT_DIR_NOT_EMPTY_WONT_INITIALIZE,
                    subdir_path.c_str());
          return DB_ERROR;
        }
        if (!srv_read_only_mode) {
          /* The problem is that a lot of people is not aware
          that sending SHUTDOWN command does not end when the
          server is no longer running, but earlier (obvious!).
          Starting MySQL without waiting on previous instance
          stopped, seems a bad idea and it often led to
          quick failures here if we did not retry. */
          for (size_t retries = 0;; ++retries) {
            const auto remove_unused_files_ret =
                log_remove_unused_files(log_files_ctx);
            if (remove_unused_files_ret.first == DB_SUCCESS) {
              break;
            }
            ut_a(retries < 300);
            std::this_thread::sleep_for(std::chrono::seconds(1));
          }
        }
        break;
      case DB_NOT_FOUND:
        /* The #innodb_redo directory has not been found. */
        if (expect_no_files) {
          /* InnoDB needs to create new directory #innodb_redo. */
          if (!os_file_create_directory(subdir_path.c_str(), false)) {
            return DB_ERROR;
          }
        } else {
          /* InnoDB does not start if neither ib_logfile* files were found,
          nor the #innodb_redo directory was found. User should be informed
          about the problem and decide to either:
            - use older version of MySQL (<= 8.0.29) and do a non-fast shutdown,
            - or create the missing #innodb_redo */
          ib::error(ER_IB_MSG_LOG_INIT_DIR_MISSING_SUBDIR, LOG_DIRECTORY_NAME,
                    log_pre_8_0_30::FILE_BASE_NAME, root_path.c_str());
          return DB_ERROR;
        }
        break;
      default:
        ib::error(ER_IB_MSG_LOG_INIT_DIR_LIST_FAILED, subdir_path.c_str());
        return err;
    }

  } else {
    /* Found existing files in old location for redo files (PRE_8_0_30).
    If expected to see no files (and create new), return error emitting
    the error message. */
    if (expect_no_files) {
      ib::error(ER_IB_MSG_LOG_INIT_DIR_NOT_EMPTY_WONT_INITIALIZE,
                root_path.c_str());
      return DB_ERROR;
    }
  }

  log_sys_create();
  ut_a(log_sys != nullptr);
  log_t &log = *log_sys;

  bool is_concurrency_margin_safe;
  log_concurrency_margin(
      Log_files_capacity::soft_logical_capacity_for_hard(
          Log_files_capacity::hard_logical_capacity_for_physical(
              srv_redo_log_capacity_used)),
      is_concurrency_margin_safe);

  if (!is_concurrency_margin_safe) {
    os_offset_t min_redo_log_capacity = srv_redo_log_capacity_used;
    os_offset_t max_redo_log_capacity = LOG_CAPACITY_MAX;
    while (min_redo_log_capacity < max_redo_log_capacity) {
      const os_offset_t capacity_to_check =
          (min_redo_log_capacity + max_redo_log_capacity) / 2;

      log_concurrency_margin(
          Log_files_capacity::soft_logical_capacity_for_hard(
              Log_files_capacity::hard_logical_capacity_for_physical(
                  capacity_to_check)),
          is_concurrency_margin_safe);

      if (is_concurrency_margin_safe) {
        max_redo_log_capacity = capacity_to_check;
      } else {
        min_redo_log_capacity = capacity_to_check + 1;
      }
    }

    /* The innodb_redo_log_capacity is always rounded to 1M */
    min_redo_log_capacity =
        ut_uint64_align_up(min_redo_log_capacity, 1024UL * 1024);

    ib::error(ER_IB_MSG_LOG_PARAMS_CONCURRENCY_MARGIN_UNSAFE,
              ulonglong{srv_redo_log_capacity_used / 1024 / 1024},
              ulong{srv_thread_concurrency},
              ulonglong{min_redo_log_capacity / 1024 / 1024},
              INNODB_PARAMETERS_MSG);

    return DB_ERROR;
  }

  log.m_files_ctx = std::move(log_files_ctx);

  if (expect_no_files) {
    ut_a(srv_force_recovery < SRV_FORCE_NO_LOG_REDO);
    ut_a(!srv_read_only_mode);

    ut_a(log.m_files_ctx.m_files_ruleset == Log_files_ruleset::CURRENT);

    new_files_lsn = flushed_lsn;
    return log_files_create(log, flushed_lsn);
  }

  if (srv_force_recovery >= SRV_FORCE_NO_LOG_REDO) {
    return DB_SUCCESS;
  }

  Log_files_dict files{log.m_files_ctx};
  Log_format format;
  std::string creator_name;
  Log_flags log_flags;
  Log_uuid log_uuid;

  ut_a(srv_force_recovery < SRV_FORCE_NO_LOG_REDO);

  auto res = log_files_find_and_analyze(
      srv_read_only_mode, log.m_encryption_metadata, files, format,
      creator_name, log_flags, log_uuid);
  switch (res) {
    case Log_files_find_result::FOUND_VALID_FILES:
      log.m_format = format;
      log.m_creator_name = creator_name;
      log.m_log_flags = log_flags;
      log.m_log_uuid = log_uuid;
      log.m_files = std::move(files);
      break;

    case Log_files_find_result::FOUND_UNINITIALIZED_FILES:
      ut_a(format == Log_format::CURRENT);
      [[fallthrough]];
    case Log_files_find_result::FOUND_NO_FILES:
      ut_a(log.m_files_ctx.m_files_ruleset == Log_files_ruleset::CURRENT);
      ut_a(files.empty());

      if (srv_read_only_mode) {
        ut_a(srv_force_recovery < SRV_FORCE_NO_LOG_REDO);
        ib::error(ER_IB_MSG_LOG_FILES_CREATE_AND_READ_ONLY_MODE);
        return DB_ERROR;
      }

      {
        const auto ret = log_remove_files(log.m_files_ctx);
        ut_a(ret.first == DB_SUCCESS);
      }
      new_files_lsn =
          flushed_lsn % OS_FILE_LOG_BLOCK_SIZE == LOG_BLOCK_HDR_SIZE
              ? flushed_lsn
              : ut_uint64_align_up(flushed_lsn, OS_FILE_LOG_BLOCK_SIZE) +
                    LOG_BLOCK_HDR_SIZE;
      return log_files_create(log, new_files_lsn);

    case Log_files_find_result::SYSTEM_ERROR:
    case Log_files_find_result::FOUND_CORRUPTED_FILES:
    case Log_files_find_result::FOUND_DISABLED_FILES:
    case Log_files_find_result::FOUND_VALID_FILES_BUT_MISSING_NEWEST:
      return DB_ERROR;
  }

  /* Check format of the redo log and emit information to the error log,
  if the format was not the newest one. */
  err = log_sys_check_format(log);
  if (err != DB_SUCCESS) {
    return err;
  }

  /* Check creator of log files and mark fields of recv_sys: is_cloned_db,
  is_meb_db if needed. */
  err = log_sys_handle_creator(log);
  if (err != DB_SUCCESS) {
    return err;
  }

  if (log_file_header_check_flag(log_flags, LOG_HEADER_FLAG_NO_LOGGING)) {
    auto result = mtr_t::s_logging.disable(nullptr);
    /* Currently never fails. */
    ut_a(result == 0);
    srv_redo_log = false;
  }

  return DB_SUCCESS;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/log/log0chkp.cc
Function: log_concurrency_margin
sn_t log_concurrency_margin(lsn_t log_capacity, bool &is_safe) {
  /* Add number of background threads that might use mini-transactions
  and modify pages (generating new redo records). */

  /* NOTE: When srv_thread_concurrency = 0 (stands for unlimited thread
  concurrency), we compute the concurrency margin only for the background
  threads. There is no guarantee provided by the log_free_check calls then. */

  const size_t max_total_threads =
      srv_thread_concurrency + LOG_BACKGROUND_THREADS_USING_RW_MTRS;

  /* A thread, which keeps latches of the oldest dirty pages, might
  need to finish its mini-transaction to unlock those pages and allow
  to flush them and advance checkpoint (to reclaim free space in redo).
  Therefore check of free space must be performed when thread is not
  holding latches of pages (or other latches which prevent other threads,
  waiting for such latches, from finishing their mini-transactions).
  Ideally each thread should check for free space, when not holding any
  latches, before it starts next mini-transaction. However, to mitigate
  performance drawbacks, we decided that few (still, limited number)
  mini-transactions could be executed between consecutive such checks.
  Also, each mini-transaction needs to have limited space it might take
  in the redo log. Thanks to that, capacity of redo reserved by single
  thread between its consecutive checks of free space, is limited.
  It is guaranteed not to exceed:
      LOG_CHECKPOINT_FREE_PER_THREAD * UNIV_PAGE_SIZE.
  @note The aforementioned checks of free space are handled by calls to
  log_free_check(). */
  const auto margin_per_thread =
      LOG_CHECKPOINT_FREE_PER_THREAD * UNIV_PAGE_SIZE;

  /* We have guarantee to have at most max_threads concurrent threads.
  Each of them might need the free space reservation for itself, for
  writes between checks (because in the worst case, they could all
  check together there is enough space in the same time, before any
  of them starts to commit any mini-transaction.
  @note This mechanism works only if number of threads is really capped
  by the provided value. However, there is currently no semaphore which
  would ensure that the promise holds. What's more, we actually know that
  it holds only when innodb_thread_concurrency is non-zero (stands for
  limited concurrency). */
  sn_t margin = margin_per_thread * max_total_threads;

  /* Add margin for the log_files_governor, so it could safely use dummy
  log records to fill up the current redo log file if needed (during resize).
  @see LOG_FILES_DUMMY_INTAKE_SIZE */
  margin += LOG_FILES_DUMMY_INTAKE_SIZE;

  /* Add extra safety calculated from redo-size. This is yet another
  "just in case", but being proportional to the total redo capacity. */
  margin += ut_uint64_align_down(
      static_cast<lsn_t>(LOG_EXTRA_CONC_MARGIN_PCT / 100.0 * log_capacity),
      OS_FILE_LOG_BLOCK_SIZE);

  /* If maximum number of concurrent threads is relatively big in comparison
  to the total capacity of redo log, it might happen, that the concurrency
  margin required to avoid deadlocks, is too big. In such case, we use smaller
  margin and report that the margin is unsafe for current concurrency and redo
  capacity. It's up to user to take required steps to protect from deadlock. */

  const auto max_margin = log_translate_lsn_to_sn(ut_uint64_align_down(
      log_capacity *
          (LOG_CONCCURENCY_MARGIN_MAX_PCT + LOG_EXTRA_CONC_MARGIN_PCT) / 100.0,
      OS_FILE_LOG_BLOCK_SIZE));

  if (margin > max_margin) {
    margin = max_margin;
    is_safe = false;
  } else {
    is_safe = true;
  }

  return margin;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/log/log0chkp.cc
Function: log_update_concurrency_margin
void log_update_concurrency_margin(log_t &log) {
  ut_ad(srv_is_being_started || log_limits_mutex_own(log));

  const lsn_t log_capacity = log.m_capacity.soft_logical_capacity();

  bool is_safe;
  const sn_t margin = log_concurrency_margin(log_capacity, is_safe);

  log.concurrency_margin.store(margin);
  log.concurrency_margin_is_safe.store(is_safe);

  MONITOR_SET(MONITOR_LOG_CONCURRENCY_MARGIN, margin);
}


File: /root/LLVM/mysql-8.0.36/storage/innobase/handler/ha_innodb.cc
Function: innodb_thread_concurrency_update
static void innodb_thread_concurrency_update(THD *thd, SYS_VAR *, void *,
                                             const void *save) {
  srv_thread_concurrency = *static_cast<const ulong *>(save);

  ib::info(ER_IB_MSG_THREAD_CONCURRENCY_CHANGED, srv_thread_concurrency);

  log_files_thread_concurrency_updated(*log_sys);

  if (!log_sys->concurrency_margin_is_safe.load()) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, ER_WRONG_ARGUMENTS,
                        "Current innodb_thread_concurrency"
                        " is too big for safety of redo log files."
                        " Consider decreasing it or increasing"
                        " innodb_redo_log_capacity.");
  }
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/handler/ha_innodb.cc
Function: innobase_srv_conc_enter_innodb
static inline dberr_t innobase_srv_conc_enter_innodb(row_prebuilt_t *prebuilt) {
  /* We rely on server to do external_lock(F_UNLCK) to reset the
  srv_conc.n_active counter. */
  if (prebuilt->skip_concurrency_ticket()) {
    return DB_SUCCESS;
  }

  dberr_t err = DB_SUCCESS;
  trx_t *trx = prebuilt->trx;

  if (srv_thread_concurrency) {
    if (trx->n_tickets_to_enter_innodb > 0) {
      /* If trx has 'free tickets' to enter the engine left,
      then use one such ticket */

      --trx->n_tickets_to_enter_innodb;

    } else if (trx->mysql_thd != nullptr &&
               thd_is_replication_slave_thread(trx->mysql_thd)) {
      ut::wait_for(
          [&]() {
            return srv_conc_get_active_threads() <
                   (int32_t)srv_thread_concurrency;
          },
          get_srv_replication_delay());

    } else {
      err = srv_conc_enter_innodb(prebuilt);
    }
  }

  return err;
}


File: /root/LLVM/mysql-8.0.36/storage/innobase/include/ut0ut.ic
Function: bool not found.

File: /root/LLVM/mysql-8.0.36/storage/innobase/include/ut0ut.ic
Function: bool not found.

File: /root/LLVM/mysql-8.0.36/storage/innobase/include/ut0ut.ic
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/srv/srv0conc.cc
Function: srv_conc_enter_innodb_with_atomics
static dberr_t srv_conc_enter_innodb_with_atomics(trx_t *trx) {
  ulint n_sleeps = 0;
  bool notified_mysql = false;

  ut_a(!trx->declared_to_be_inside_innodb);

  for (;;) {
    ulint sleep_in_us;

    if (srv_thread_concurrency == 0) {
      if (notified_mysql) {
        srv_conc.n_waiting.fetch_sub(1, std::memory_order_relaxed);

        thd_wait_end(trx->mysql_thd);
      }

      return DB_SUCCESS;
    }

    if (srv_conc.n_active.load(std::memory_order_relaxed) <
        (int32_t)srv_thread_concurrency) {
      /* Check if there are any free tickets. */
      const auto n_active =
          srv_conc.n_active.fetch_add(1, std::memory_order_acquire) + 1;

      if (n_active <= (int32_t)srv_thread_concurrency) {
        srv_enter_innodb_with_tickets(trx);

        if (notified_mysql) {
          srv_conc.n_waiting.fetch_sub(1, std::memory_order_relaxed);

          thd_wait_end(trx->mysql_thd);
        }

        if (srv_adaptive_max_sleep_delay > 0) {
          if (srv_thread_sleep_delay > 20 && n_sleeps == 1) {
            --srv_thread_sleep_delay;
          }

          if (srv_conc.n_waiting.load(std::memory_order_relaxed) == 0) {
            srv_thread_sleep_delay >>= 1;
          }
        }

        return DB_SUCCESS;
      }

      /* Since there were no free seats, we relinquish
      the overbooked ticket. */
      srv_conc.n_active.fetch_sub(1, std::memory_order_release);
    }

    if (!notified_mysql) {
      srv_conc.n_waiting.fetch_add(1, std::memory_order_relaxed);

      thd_wait_begin(trx->mysql_thd, THD_WAIT_USER_LOCK);

      notified_mysql = true;
    }

    DEBUG_SYNC_C("user_thread_waiting");
    trx->op_info = "sleeping before entering InnoDB";

    sleep_in_us = srv_thread_sleep_delay;

    /* Guard against overflow when adaptive sleep delay is on. */

    if (srv_adaptive_max_sleep_delay > 0 &&
        sleep_in_us > srv_adaptive_max_sleep_delay) {
      sleep_in_us = srv_adaptive_max_sleep_delay;
      srv_thread_sleep_delay = static_cast<ulong>(sleep_in_us);
    }

    std::this_thread::sleep_for(std::chrono::microseconds(sleep_in_us));

    trx->op_info = "";

    ++n_sleeps;

    if (srv_adaptive_max_sleep_delay > 0 && n_sleeps > 1) {
      ++srv_thread_sleep_delay;
    }

    if (trx_is_interrupted(trx)) {
      if (notified_mysql) {
        srv_conc.n_waiting.fetch_sub(1, std::memory_order_relaxed);

        thd_wait_end(trx->mysql_thd);
      }
      return DB_INTERRUPTED;
    }
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/srv/srv0conc.cc
Function: srv_conc_force_enter_innodb
void srv_conc_force_enter_innodb(trx_t *trx) /*!< in: transaction object
                                             associated with the thread */
{
#ifdef UNIV_DEBUG
  {
    btrsea_sync_check check(trx->has_search_latch);

    ut_ad(!sync_check_iterate(check));
  }
#endif /* UNIV_DEBUG */

  if (!srv_thread_concurrency) {
    return;
  }

  ut_ad(srv_conc.n_active.load(std::memory_order_relaxed) >= 0);

  srv_conc.n_active.fetch_add(1, std::memory_order_acquire);

  trx->n_tickets_to_enter_innodb = 1;
  trx->declared_to_be_inside_innodb = true;
}


