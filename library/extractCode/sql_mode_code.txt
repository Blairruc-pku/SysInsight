-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partitioning/partition_handler.cc
Function: Partition_helper::ph_write_row
int Partition_helper::ph_write_row(uchar *buf) {
  uint32 part_id;
  int error;
  longlong func_value;
  bool have_auto_increment =
      m_table->next_number_field && buf == m_table->record[0];
  THD *thd = get_thd();
  sql_mode_t saved_sql_mode = thd->variables.sql_mode;
  bool saved_autoinc_field_has_expl_non_null_value =
      m_table->autoinc_field_has_explicit_non_null_value;
#ifndef NDEBUG
  my_bitmap_map *old_map;
#endif /* NDEBUG */
  DBUG_TRACE;
  assert(buf == m_table->record[0]);

  /*
    If we have an auto_increment column and we are writing a changed row
    or a new row, then update the auto_increment value in the record.
  */
  if (have_auto_increment) {
    error = m_handler->update_auto_increment();

    /*
      If we have failed to set the auto-increment value for this row,
      it is highly likely that we will not be able to insert it into
      the correct partition. We must check and fail if necessary.
    */
    if (error) return error;

    /*
      Don't allow generation of auto_increment value the partitions handler.
      If a partitions handler would change the value, then it might not
      match the partition any longer.
      This can occur if 'SET INSERT_ID = 0; INSERT (NULL)',
      So allow this by adding 'MODE_NO_AUTO_VALUE_ON_ZERO' to sql_mode.
      The partitions handler::next_insert_id must always be 0. Otherwise
      we need to forward release_auto_increment, or reset it for all
      partitions.
    */
    if (m_table->next_number_field->val_int() == 0) {
      m_table->autoinc_field_has_explicit_non_null_value = true;
      thd->variables.sql_mode |= MODE_NO_AUTO_VALUE_ON_ZERO;
    }
  }

#ifndef NDEBUG
  /* Temporary mark the partitioning fields as readable. */
  old_map = dbug_tmp_use_all_columns(m_table, m_table->read_set);
#endif /* NDEBUG */

  error = m_part_info->get_partition_id(m_part_info, &part_id, &func_value);

#ifndef NDEBUG
  dbug_tmp_restore_column_map(m_table->read_set, old_map);
#endif /* NDEBUG */

  if (unlikely(error)) {
    m_part_info->err_value = func_value;
    goto exit;
  }
  if (!m_part_info->is_partition_locked(part_id)) {
    DBUG_PRINT("info", ("Write to non-locked partition %u (func_value: %ld)",
                        part_id, (long)func_value));
    error = HA_ERR_NOT_IN_LOCK_PARTITIONS;
    goto exit;
  }
  m_last_part = part_id;
  DBUG_PRINT("info", ("Insert in partition %d", part_id));

  error = write_row_in_part(part_id, buf);

  if (have_auto_increment && !m_table->s->next_number_keypart) {
    set_auto_increment_if_higher();
  }
exit:
  thd->variables.sql_mode = saved_sql_mode;
  m_table->autoinc_field_has_explicit_non_null_value =
      saved_autoinc_field_has_expl_non_null_value;
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::Table_upgrade_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::Table_upgrade_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::Table_upgrade_guard::Table_upgrade_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::Table_upgrade_guard::Table_upgrade_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::Table_upgrade_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::Table_upgrade_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::migrate_table_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::migrate_table_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::Table_upgrade_guard::Table_upgrade_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::Table_upgrade_guard::Table_upgrade_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_upgrade_table.cc
Function: dd::ndb_upgrade::Table_upgrade_guard::Table_upgrade_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/set_var.cc
Function: throw_bounds_warning
bool throw_bounds_warning(THD *thd, const char *name, bool fixed, double v) {
  if (fixed) {
    char buf[64];

    my_gcvt(v, MY_GCVT_ARG_DOUBLE, static_cast<int>(sizeof(buf)) - 1, buf,
            nullptr);

    if (thd->variables.sql_mode & MODE_STRICT_ALL_TABLES) {
      my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), name, buf);
      return true;
    }
    push_warning_printf(thd, Sql_condition::SL_WARNING,
                        ER_TRUNCATED_WRONG_VALUE,
                        ER_THD(thd, ER_TRUNCATED_WRONG_VALUE), name, buf);
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp_head.cc
Function: sp_head::execute
bool sp_head::execute(THD *thd, bool merge_da_on_success) {
  char saved_cur_db_name_buf[NAME_LEN + 1];
  LEX_STRING saved_cur_db_name = {saved_cur_db_name_buf,
                                  sizeof(saved_cur_db_name_buf)};
  bool cur_db_changed = false;
  bool err_status = false;
  uint ip = 0;
  sql_mode_t save_sql_mode;
  Query_arena *old_arena;
  /* per-instruction arena */
  MEM_ROOT execute_mem_root(key_memory_sp_head_execute_root,
                            MEM_ROOT_BLOCK_SIZE);
  Query_arena execute_arena(&execute_mem_root,
                            Query_arena::STMT_INITIALIZED_FOR_SP),
      backup_arena;
  query_id_t old_query_id;
  LEX *old_lex;
  Item_change_list old_change_list;
  String old_packet;
  Object_creation_ctx *saved_creation_ctx;
  Diagnostics_area *caller_da = thd->get_stmt_da();
  Diagnostics_area sp_da(false);

  /*
    Just reporting a stack overrun error
    (@sa check_stack_overrun()) requires stack memory for error
    message buffer. Thus, we have to put the below check
    relatively close to the beginning of the execution stack,
    where available stack margin is still big. As long as the check
    has to be fairly high up the call stack, the amount of memory
    we "book" for has to stay fairly high as well, and hence
    not very accurate. The number below has been calculated
    by trial and error, and reflects the amount of memory necessary
    to execute a single stored procedure instruction, be it either
    an SQL statement, or, heaviest of all, a CALL, which involves
    parsing and loading of another stored procedure into the cache
    (@sa db_load_routine() and Bug#10100).

    TODO: that should be replaced by proper handling of stack overrun error.

    Stack size depends on the platform:
      - for most platforms (8 * STACK_MIN_SIZE) is enough;
      - for Solaris SPARC 64 (10 * STACK_MIN_SIZE) is required.
      - for clang and ASAN/UBSAN we need even more stack space.
  */

  {
#if defined(__clang__) && defined(HAVE_ASAN)
    const int sp_stack_size = 12 * STACK_MIN_SIZE;
#elif defined(__clang__) && defined(HAVE_UBSAN)
    const int sp_stack_size = 16 * STACK_MIN_SIZE;
#else
    const int sp_stack_size = 8 * STACK_MIN_SIZE;
#endif

    if (check_stack_overrun(thd, sp_stack_size, (uchar *)&old_packet))
      return true;
  }

  opt_trace_disable_if_no_security_context_access(thd);

  assert(!(m_flags & IS_INVOKED));
  m_flags |= IS_INVOKED;
  m_first_instance->m_first_free_instance = m_next_cached_sp;
  if (m_next_cached_sp) {
    DBUG_PRINT("info", ("first free for %p ++: %p->%p  level: %lu  flags %x",
                        m_first_instance, this, m_next_cached_sp,
                        m_next_cached_sp->m_recursion_level,
                        m_next_cached_sp->m_flags));
  }
  /*
    Check that if there are not any instances after this one then
    pointer to the last instance points on this instance or if there are
    some instances after this one then recursion level of next instance
    greater then recursion level of current instance on 1
  */
  assert((m_next_cached_sp == nullptr &&
          m_first_instance->m_last_cached_sp == this) ||
         (m_recursion_level + 1 == m_next_cached_sp->m_recursion_level));

  /*
    NOTE: The SQL Standard does not specify the context that should be
    preserved for stored routines. However, at SAP/Walldorf meeting it was
    decided that current database should be preserved.
  */
  if (m_db.length && (err_status = mysql_opt_change_db(
                          thd, to_lex_cstring(m_db), &saved_cur_db_name, false,
                          &cur_db_changed))) {
    goto done;
  }

  thd->is_slave_error = false;
  old_arena = thd->stmt_arena;

  /* Push a new Diagnostics Area. */
  thd->push_diagnostics_area(&sp_da);

  /*
    Switch query context. This has to be done early as this is sometimes
    allocated through sql_alloc
  */
  saved_creation_ctx = m_creation_ctx->set_n_backup(thd);

  /*
    We have to save/restore this info when we are changing call level to
    be able properly do close_thread_tables() in instructions.
  */
  old_query_id = thd->query_id;
  save_sql_mode = thd->variables.sql_mode;
  thd->variables.sql_mode = m_sql_mode;
  /**
    When inside a substatement (a stored function or trigger
    statement), clear the metadata observer in THD, if any.
    Remember the value of the observer here, to be able
    to restore it when leaving the substatement.

    We reset the observer to suppress errors when a substatement
    uses temporary tables. If a temporary table does not exist
    at start of the main statement, it's not prelocked
    and thus is not validated with other prelocked tables.

    Later on, when the temporary table is opened, metadata
    versions mismatch, expectedly.

    The proper solution for the problem is to re-validate tables
    of substatements (Bug#12257, Bug#27011, Bug#32868, Bug#33000),
    but it's not implemented yet.
  */
  thd->push_reprepare_observer(nullptr);

  /*
    It is also more efficient to save/restore current thd->lex once when
    do it in each instruction
  */
  old_lex = thd->lex;
  /*
    Save Item tree change list to avoid rollback something
    too early in the calling query.
  */
  thd->change_list.move_elements_to(&old_change_list);

  if (thd->is_classic_protocol()) {
    /*
      Cursors will use thd->packet, so they may corrupt data which was
      prepared for sending by upper level. OTOH cursors in the same routine
      can share this buffer safely so let use use routine-local packet
      instead of having own packet buffer for each cursor.

      It is probably safe to use same thd->convert_buff everywhere.
    */
    old_packet.swap(*thd->get_protocol_classic()->get_output_packet());
  }

  /*
    Switch to per-instruction arena here. We can do it since we cleanup
    arena after every instruction.
  */
  thd->swap_query_arena(execute_arena, &backup_arena);

  /*
    Save callers arena in order to store instruction results and out
    parameters in it later during sp_eval_func_item()
  */
  thd->sp_runtime_ctx->callers_arena = &backup_arena;

#if defined(ENABLED_PROFILING)
  /* Discard the initial part of executing routines. */
  thd->profiling->discard_current_query();
#endif
  do {
    sp_instr *i;

#if defined(ENABLED_PROFILING)
    /*
     Treat each "instr" of a routine as discrete unit that could be profiled.
     Profiling only records information for segments of code that set the
     source of the query, and almost all kinds of instructions in s-p do not.
    */
    thd->profiling->finish_current_query();
    thd->profiling->start_new_query("continuing inside routine");
#endif

    /* get_instr returns NULL when we're done. */
    i = get_instr(ip);
    if (i == nullptr) {
#if defined(ENABLED_PROFILING)
      thd->profiling->discard_current_query();
#endif
      break;
    }

    DBUG_PRINT("execute", ("Instruction %u", ip));

    /*
      We need to reset start_time to allow for time to flow inside a stored
      procedure. This is only done for SP since time is suppose to be constant
      during execution of triggers and functions.
    */
    reset_start_time_for_sp(thd);

    /*
      We have to set thd->stmt_arena before executing the instruction
      to store in the instruction item list all new items, created
      during the first execution (for example expanding of '*' or the
      items made during other permanent subquery transformations).
    */
    thd->stmt_arena = &i->m_arena;

    /*
      Will write this SP statement into binlog separately.
      TODO: consider changing the condition to "not inside event union".
    */
    if (thd->locked_tables_mode <= LTM_LOCK_TABLES)
      thd->user_var_events_alloc = thd->mem_root;

    sql_digest_state digest_state;
    sql_digest_state *parent_digest = thd->m_digest;
    thd->m_digest = &digest_state;

    mysql_thread_set_secondary_engine(false);

#ifdef HAVE_PSI_STATEMENT_INTERFACE
    PSI_statement_locker_state psi_state;
    PSI_statement_info *psi_info = i->get_psi_info();
    PSI_statement_locker *parent_locker;

    parent_locker = thd->m_statement_psi;
    thd->m_statement_psi = MYSQL_START_STATEMENT(
        &psi_state, psi_info->m_key, thd->db().str, thd->db().length,
        thd->charset(), this->m_sp_share);
#endif

    /*
      For now, we're mostly concerned with sp_instr_stmt, but that's
      likely to change in the future, so we'll do it right from the
      start.
    */
    if (thd->rewritten_query().length()) thd->reset_rewritten_query();

    err_status = i->execute(thd, &ip);

#ifdef HAVE_PSI_STATEMENT_INTERFACE
    MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());
    thd->m_statement_psi = parent_locker;
#endif

    thd->m_digest = parent_digest;

    cleanup_items(i->m_arena.item_list());

    /*
      If we've set thd->user_var_events_alloc to mem_root of this SP
      statement, clean all the events allocated in it.
    */
    if (thd->locked_tables_mode <= LTM_LOCK_TABLES) {
      thd->user_var_events.clear();
      thd->user_var_events_alloc = nullptr;  // DEBUG
    }

    // Free items created when executing the instruction, etc.
    thd->cleanup_after_query();

    // Release memory allocated during execution of the instruction
    execute_mem_root.ClearForReuse();

    /*
      Find and process SQL handlers unless it is a fatal error (fatal
      errors are not catchable by SQL handlers) or the connection has been
      killed during execution.
    */
#ifdef HAVE_PSI_ERROR_INTERFACE
    uint error_num = 0;
    if (thd->is_error()) error_num = thd->get_stmt_da()->mysql_errno();
#endif
    if (!thd->is_fatal_error() && !thd->killed &&
        thd->sp_runtime_ctx->handle_sql_condition(thd, &ip, i)) {
      err_status = false;
#ifdef HAVE_PSI_ERROR_INTERFACE
      if (error_num) MYSQL_LOG_ERROR(error_num, PSI_ERROR_OPERATION_HANDLED);
#endif
    }

    /* Reset sp_rcontext::end_partial_result_set flag. */
    thd->sp_runtime_ctx->end_partial_result_set = false;

  } while (!err_status && !thd->killed && !thd->is_fatal_error());

#if defined(ENABLED_PROFILING)
  thd->profiling->finish_current_query();
  thd->profiling->start_new_query("tail end of routine");
#endif

  // Restore query context.
  m_creation_ctx->restore_env(thd, saved_creation_ctx);

  // Restore arena.
  thd->swap_query_arena(backup_arena, &execute_arena);

  // Delete all cursors allocated during execution
  thd->sp_runtime_ctx->pop_all_cursors();

  if (thd->is_classic_protocol()) /* Restore all saved */
    old_packet.swap(*thd->get_protocol_classic()->get_output_packet());
  assert(thd->change_list.is_empty());
  old_change_list.move_elements_to(&thd->change_list);
  thd->lex = old_lex;
  thd->set_query_id(old_query_id);
  thd->variables.sql_mode = save_sql_mode;
  thd->pop_reprepare_observer();

  thd->stmt_arena = old_arena;

  if (err_status && thd->is_error() && !caller_da->is_error()) {
    /*
      If the SP ended with an exception, transfer the exception condition
      information to the Diagnostics Area of the caller.

      Note that no error might be set yet in the case of kill.
      It will be set later by mysql_execute_command() / execute_trigger().

      In the case of multi update, it is possible that we can end up
      executing a trigger after the update has failed. In this case,
      keep the exception condition from the caller_da and don't transfer.
    */
    caller_da->set_error_status(thd->get_stmt_da()->mysql_errno(),
                                thd->get_stmt_da()->message_text(),
                                thd->get_stmt_da()->returned_sqlstate());
  }

  /*
    - conditions generated during trigger execution should not be
    propagated to the caller on success;   (merge_da_on_success)
    - if there was an exception during execution, conditions should be
    propagated to the caller in any case.  (err_status)
  */
  if (err_status || merge_da_on_success) {
    /*
      If a routine body is empty or if a routine did not generate any
      conditions, do not duplicate our own contents by appending the contents
      of the called routine. We know that the called routine did not change its
      Diagnostics Area.

      On the other hand, if the routine body is not empty and some statement
      in the routine generates a condition, Diagnostics Area is guaranteed to
      have changed. In this case we know that the routine Diagnostics Area
      contains only new conditions, and thus we perform a copy.

      We don't use push_warning() here as to avoid invocation of
      condition handlers or escalation of warnings to errors.
    */
    if (!err_status && thd->get_stmt_da() != &sp_da) {
      /*
        If we are RETURNing directly from a handler and the handler has
        executed successfully, only transfer the conditions that were
        raised during handler execution. Conditions that were present
        when the handler was activated, are considered handled.
      */
      caller_da->copy_new_sql_conditions(thd, thd->get_stmt_da());
    } else  // err_status || thd->get_stmt_da() == sp_da
    {
      /*
        If we ended with an exception, or the SP exited without any handler
        active, transfer all conditions to the Diagnostics Area of the caller.
      */
      caller_da->copy_sql_conditions_from_da(thd, thd->get_stmt_da());
    }
  }

  // Restore the caller's original Diagnostics Area.
  while (thd->get_stmt_da() != &sp_da) thd->pop_diagnostics_area();
  thd->pop_diagnostics_area();
  assert(thd->get_stmt_da() == caller_da);

done:
  DBUG_PRINT(
      "info",
      ("err_status: %d  killed: %d  is_slave_error: %d  report_error: %d",
       err_status, thd->killed.load(), thd->is_slave_error, thd->is_error()));

  if (thd->killed) err_status = true;
  /*
    If the DB has changed, the pointer has changed too, but the
    original thd->db will then have been freed
  */
  if (cur_db_changed && thd->killed != THD::KILL_CONNECTION) {
    /*
      Force switching back to the saved current database, because it may be
      NULL. In this case, mysql_change_db() would generate an error.
    */

    err_status |= mysql_change_db(thd, to_lex_cstring(saved_cur_db_name), true);
  }
  m_flags &= ~IS_INVOKED;
  DBUG_PRINT("info", ("first free for %p --: %p->%p, level: %lu, flags %x",
                      m_first_instance, m_first_instance->m_first_free_instance,
                      this, m_recursion_level, m_flags));
  /*
    Check that we have one of following:

    1) there are not free instances which means that this instance is last
    in the list of instances (pointer to the last instance point on it and
    there are not other instances after this one in the list)

    2) There are some free instances which mean that first free instance
    should go just after this one and recursion level of that free instance
    should be on 1 more then recursion level of this instance.
  */
  assert((m_first_instance->m_first_free_instance == nullptr &&
          this == m_first_instance->m_last_cached_sp &&
          m_next_cached_sp == nullptr) ||
         (m_first_instance->m_first_free_instance != nullptr &&
          m_first_instance->m_first_free_instance == m_next_cached_sp &&
          m_first_instance->m_first_free_instance->m_recursion_level ==
              m_recursion_level + 1));
  m_first_instance->m_first_free_instance = this;

  return err_status;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: THD::is_strict_mode not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: THD::is_strict_mode not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: THD::is_strict_mode not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: THD::is_strict_mode not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: is_engine_substitution_allowed
inline bool is_engine_substitution_allowed(const THD *thd) {
  return !(thd->variables.sql_mode & MODE_NO_ENGINE_SUBSTITUTION);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: THD::is_fsp_truncate_mode not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: THD::is_fsp_truncate_mode not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: THD::is_fsp_truncate_mode not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.h
Function: THD::is_fsp_truncate_mode not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp_instr.cc
Function: sp_instr_set_trigger_field::exec_core
bool sp_instr_set_trigger_field::exec_core(THD *thd, uint *nextp) {
  *nextp = get_ip() + 1;
  thd->check_for_truncated_fields = CHECK_FIELD_ERROR_FOR_NULL;
  Strict_error_handler strict_handler(
      Strict_error_handler::ENABLE_SET_SELECT_STRICT_ERROR_HANDLER);
  /*
    Before Triggers are executed after the 'data' is assigned
    to the Field objects. If triggers wants to SET invalid value
    to the Field objects (NEW.<variable_name>= <Invalid value>),
    it should not be allowed.
  */
  if (thd->is_strict_mode() && !thd->lex->is_ignore())
    thd->push_internal_handler(&strict_handler);
  bool error = m_trigger_field->set_value(thd, &m_value_item);
  if (thd->is_strict_mode() && !thd->lex->is_ignore())
    thd->pop_internal_handler();
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_thd_internal_api.cc
Function: thd_is_strict_mode
bool thd_is_strict_mode(const THD *thd) { return thd->is_strict_mode(); }



-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/handler/handler0alter.cc
Function: ha_innobase::check_if_supported_inplace_alter not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/handler/handler0alter.cc
Function: ha_innobase::check_if_supported_inplace_alter not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: unpack_value_generator not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: unpack_value_generator not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: unpack_value_generator not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: unpack_value_generator not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: unpack_value_generator not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: unpack_value_generator not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: unpack_value_generator not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: unpack_value_generator not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: unpack_value_generator not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: unpack_value_generator not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/create_field.cc
Function: Create_field::init not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/create_field.cc
Function: Create_field::init not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: Strict_error_handler::handle_condition not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: Strict_error_handler::handle_condition not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: Strict_error_handler::handle_condition not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: Strict_error_handler::handle_condition not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: Strict_error_handler::handle_condition not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: Strict_error_handler::handle_condition not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_str::store
type_conversion_status Field_str::store(double nr) {
  ASSERT_COLUMN_MARKED_FOR_WRITE;
  char buff[DOUBLE_TO_STRING_CONVERSION_BUFFER_SIZE];
  uint local_char_length = field_length / charset()->mbmaxlen;
  size_t length = 0;
  bool error = (local_char_length == 0);

  // my_gcvt() requires width > 0, and we may have a CHAR(0) column.
  if (!error)
    length = my_gcvt(nr, MY_GCVT_ARG_DOUBLE, local_char_length, buff, &error);

  if (error) {
    THD *thd = current_thd;

    if (!thd->lex->is_ignore() && thd->is_strict_mode())
      set_warning(Sql_condition::SL_WARNING, ER_DATA_TOO_LONG, 1);
    else
      set_warning(Sql_condition::SL_WARNING, WARN_DATA_TRUNCATED, 1);
  }
  return store(buff, length, &my_charset_numeric);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_new_decimal::store
type_conversion_status Field_new_decimal::store(double nr) {
  ASSERT_COLUMN_MARKED_FOR_WRITE;
  DBUG_TRACE;
  my_decimal decimal_value;

  int conv_err = double2my_decimal(E_DEC_FATAL_ERROR & ~E_DEC_OVERFLOW, nr,
                                   &decimal_value);
  return store_internal_with_error_check(this, conv_err, &decimal_value);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::store
type_conversion_status Field_temporal::store(longlong nr, bool unsigned_val) {
  ASSERT_COLUMN_MARKED_FOR_WRITE;
  int warnings = 0;
  MYSQL_TIME ltime;
  type_conversion_status error =
      convert_number_to_TIME(nr, unsigned_val, 0, &ltime, &warnings);
  if (error == TYPE_OK || error == TYPE_NOTE_TRUNCATED)
    error = store_internal(&ltime, &warnings);
  else {
    assert(warnings != 0);  // Must be set by convert_number_to_TIME

    if (warnings & (MYSQL_TIME_WARN_ZERO_DATE | MYSQL_TIME_WARN_ZERO_IN_DATE) &&
        !current_thd->is_strict_mode())
      error = TYPE_NOTE_TIME_TRUNCATED;
  }
  if (warnings && set_warnings(ErrConvString(nr, unsigned_val), warnings))
    return TYPE_ERR_BAD_VALUE;

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::store_lldiv_t not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::store_lldiv_t not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_blob::store_internal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_blob::store_internal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_longstr::report_if_important_data not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_longstr::report_if_important_data not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_bit::store
type_conversion_status Field_bit::store(double nr) {
  if (nr < LLONG_MIN)
    return Field_bit::store(static_cast<longlong>(LLONG_MIN), false);
  if (nr > LLONG_MAX_DOUBLE)
    return Field_bit::store(static_cast<longlong>(LLONG_MAX), false);
  return Field_bit::store(static_cast<longlong>(nr), false);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_bit_as_char::store not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_bit_as_char::store not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: generate_create_field not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: generate_create_field not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestamp::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestamp::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestamp::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestamp::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestamp::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestamp::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestamp::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestamp::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::set_datetime_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::set_datetime_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::set_datetime_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::set_datetime_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::set_datetime_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::set_datetime_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::set_datetime_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_temporal::set_datetime_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestampf::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestampf::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestampf::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestampf::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestampf::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestampf::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestampf::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_timestampf::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetimef::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_datetime::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_time_common::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_time_common::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_time_common::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_time_common::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_newdate::date_flags not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::val_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::val_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::val_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::val_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::cmp not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::cmp not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::cmp not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::cmp not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::make_sort_key not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::make_sort_key not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::make_sort_key not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::make_sort_key not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field_conv.cc
Function: do_copy_blob not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field_conv.cc
Function: do_copy_blob not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field_conv.cc
Function: field_conv_slow
type_conversion_status field_conv_slow(Field *to, const Field *from) {
  const enum_field_types from_type = from->type();
  const enum_field_types to_type = to->type();
  const enum_field_types from_real_type = from->real_type();
  const enum_field_types to_real_type = to->real_type();

  if ((to_type == MYSQL_TYPE_JSON) && (from_type == MYSQL_TYPE_JSON)) {
    Field_json *to_json = down_cast<Field_json *>(to);
    const Field_json *from_json = down_cast<const Field_json *>(from);
    return to_json->store(from_json);
  }
  if (from->is_array()) {
    assert(to->is_array() && from_real_type == to_real_type &&
           from->charset() == to->charset());
    const Field_blob *from_blob = down_cast<const Field_blob *>(from);
    Field_blob *to_blob = down_cast<Field_blob *>(to);
    return to_blob->store(from_blob);
  }
  if (to_real_type == MYSQL_TYPE_VARCHAR &&
      from_real_type == MYSQL_TYPE_VARCHAR &&
      to->charset() == from->charset()) {
    Field_varstring *to_vc = down_cast<Field_varstring *>(to);
    const Field_varstring *from_vc = down_cast<const Field_varstring *>(from);
    if (to_vc->get_length_bytes() == from_vc->get_length_bytes()) {
      copy_field_varstring(to_vc, from_vc);
      return TYPE_OK;
    }
  }
  if (to_type == MYSQL_TYPE_BLOB) {  // Be sure the value is stored
    Field_blob *blob = (Field_blob *)to;
    return blob->store(from);
  }
  if (from_real_type == MYSQL_TYPE_ENUM && to_real_type == MYSQL_TYPE_ENUM &&
      from->val_int() == 0) {
    ((Field_enum *)(to))->store_type(0);
    return TYPE_OK;
  } else if (is_temporal_type(from_type) && from_type != MYSQL_TYPE_YEAR &&
             to->result_type() == INT_RESULT) {
    MYSQL_TIME ltime;
    longlong nr;
    if (from_type == MYSQL_TYPE_TIME) {
      from->get_time(&ltime);
      if (current_thd->is_fsp_truncate_mode())
        nr = TIME_to_ulonglong_time(ltime);
      else
        nr = TIME_to_ulonglong_time_round(ltime);
    } else {
      from->get_date(&ltime, TIME_FUZZY_DATE);
      if (current_thd->is_fsp_truncate_mode())
        nr = TIME_to_ulonglong_datetime(ltime);
      else {
        nr = propagate_datetime_overflow(current_thd, [&](int *w) {
          return TIME_to_ulonglong_datetime_round(ltime, w);
        });
      }
    }
    return to->store(ltime.neg ? -nr : nr, false);
  } else if (is_temporal_type(from_type) && from_type != MYSQL_TYPE_YEAR &&
             (to->result_type() == REAL_RESULT ||
              to->result_type() == DECIMAL_RESULT ||
              to->result_type() == INT_RESULT)) {
    my_decimal tmp;
    /*
      We prefer DECIMAL as the safest precise type:
      double supports only 15 digits, which is not enough for DATETIME(6).
    */
    return to->store_decimal(from->val_decimal(&tmp));
  } else if (is_temporal_type(from_type) && from_type != MYSQL_TYPE_YEAR &&
             is_temporal_type(to_type) && to_type != MYSQL_TYPE_YEAR) {
    return copy_time_to_time(from, to);
  } else if (from_type == MYSQL_TYPE_JSON &&
             (is_integer_type(to_type) || to_type == MYSQL_TYPE_YEAR)) {
    return to->store(from->val_int(), from->is_flag_set(UNSIGNED_FLAG));
  } else if (from_type == MYSQL_TYPE_JSON && to_type == MYSQL_TYPE_NEWDECIMAL) {
    my_decimal buff;
    return to->store_decimal(from->val_decimal(&buff));
  } else if (from_type == MYSQL_TYPE_JSON &&
             (to_type == MYSQL_TYPE_FLOAT || to_type == MYSQL_TYPE_DOUBLE)) {
    return to->store(from->val_real());
  } else if (from_type == MYSQL_TYPE_JSON && is_temporal_type(to_type)) {
    MYSQL_TIME ltime;
    bool res = true;
    switch (to_type) {
      case MYSQL_TYPE_TIME:
        res = from->get_time(&ltime);
        break;
      case MYSQL_TYPE_DATETIME:
      case MYSQL_TYPE_TIMESTAMP:
      case MYSQL_TYPE_DATE:
      case MYSQL_TYPE_NEWDATE:
        res = from->get_date(&ltime, 0);
        break;
      default:  // MYSQL_TYPE_YEAR is handled as an integer above
        assert(false);
    }
    /*
      Field_json::get_time and get_date set ltime to zero, and we store it in
      the `to` field, so in case conversion errors are ignored we can read zeros
      instead of garbage.
    */
    type_conversion_status store_res = to->store_time(&ltime);
    return res ? TYPE_ERR_BAD_VALUE : store_res;
  } else if ((from->result_type() == STRING_RESULT &&
              (to->result_type() == STRING_RESULT ||
               (from_real_type != MYSQL_TYPE_ENUM &&
                from_real_type != MYSQL_TYPE_SET))) ||
             to_type == MYSQL_TYPE_DECIMAL) {
    char buff[MAX_FIELD_WIDTH];
    String result(buff, sizeof(buff), from->charset());
    from->val_str(&result);
    /*
      We use c_ptr_quick() here to make it easier if to is a float/double
      as the conversion routines will do a copy of the result doesn't
      end with \0. Can be replaced with .ptr() when we have our own
      string->double conversion.
    */
    return to->store(result.c_ptr_quick(), result.length(), from->charset());
  } else if (from->result_type() == REAL_RESULT)
    return to->store(from->val_real());
  else if (from->result_type() == DECIMAL_RESULT) {
    my_decimal buff;
    return to->store_decimal(from->val_decimal(&buff));
  } else
    return to->store(from->val_int(), from->is_flag_set(UNSIGNED_FLAG));
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field_conv.cc
Function: Copy_field::get_copy_func not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field_conv.cc
Function: Copy_field::get_copy_func not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field_conv.cc
Function: Copy_field::get_copy_func not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field_conv.cc
Function: Copy_field::get_copy_func not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field_conv.cc
Function: fields_are_memcpyable
bool fields_are_memcpyable(const Field *to, const Field *from) {
  assert(to != from);

  const enum_field_types to_type = to->type();
  const enum_field_types from_real_type = from->real_type();
  const enum_field_types to_real_type = to->real_type();

  THD *thd = current_thd;

  if (to_real_type != from_real_type) {
    return false;
  }
  if (to_type == MYSQL_TYPE_JSON || to_real_type == MYSQL_TYPE_GEOMETRY ||
      to_real_type == MYSQL_TYPE_VARCHAR || to_real_type == MYSQL_TYPE_ENUM ||
      to_real_type == MYSQL_TYPE_SET || to_real_type == MYSQL_TYPE_BIT) {
    return false;
  }
  if (from->is_array()) {
    return false;
  }
  if (is_blob_type(to_type) && to->table->copy_blobs) {
    return false;
  }
  if (to->charset() != from->charset()) {
    return false;
  }
  if (to->pack_length() != from->pack_length()) {
    return false;
  }
  if (to->is_flag_set(UNSIGNED_FLAG) != from->is_flag_set(UNSIGNED_FLAG)) {
    return false;
  }
  if (to->table->s->db_low_byte_first != from->table->s->db_low_byte_first) {
    return false;
  }
  if (to_real_type == MYSQL_TYPE_NEWDECIMAL) {
    if (to->field_length != from->field_length ||
        down_cast<const Field_num *>(to)->dec !=
            down_cast<const Field_num *>(from)->dec) {
      return false;
    }
  }
  if (is_temporal_type_with_time(to_type)) {
    if (to->decimals() != from->decimals()) {
      return false;
    }
  }
  if (thd->variables.sql_mode &
      (MODE_NO_ZERO_IN_DATE | MODE_NO_ZERO_DATE | MODE_INVALID_DATES)) {
    if (to_type == MYSQL_TYPE_DATE || to_type == MYSQL_TYPE_DATETIME) {
      return false;
    }
    if (thd->variables.explicit_defaults_for_timestamp &&
        to_type == MYSQL_TYPE_TIMESTAMP) {
      return false;
    }
  }
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_func_sleep::val_int
longlong Item_func_sleep::val_int() {
  THD *thd = current_thd;
  Interruptible_wait timed_cond(thd);
  mysql_cond_t cond;
  double timeout;
  int error;

  assert(fixed == 1);

  timeout = args[0]->val_real();

  /*
    Report error or warning depending on the value of SQL_MODE.
    If SQL is STRICT then report error, else report warning and continue
    execution.
  */

  if (args[0]->null_value || timeout < 0) {
    if (!thd->lex->is_ignore() && thd->is_strict_mode()) {
      my_error(ER_WRONG_ARGUMENTS, MYF(0), "sleep.");
      return 0;
    } else
      push_warning_printf(thd, Sql_condition::SL_WARNING, ER_WRONG_ARGUMENTS,
                          ER_THD(thd, ER_WRONG_ARGUMENTS), "sleep.");
  }
  /*
    On 64-bit OSX mysql_cond_timedwait() waits forever
    if passed abstime time has already been exceeded by
    the system time.
    When given a very short timeout (< 10 mcs) just return
    immediately.
    We assume that the lines between this test and the call
    to mysql_cond_timedwait() will be executed in less than 0.00001 sec.
  */
  if (timeout < 0.00001) return 0;

  timed_cond.set_timeout((ulonglong)(timeout * 1000000000.0));

  mysql_cond_init(key_item_func_sleep_cond, &cond);
  mysql_mutex_lock(&LOCK_item_func_sleep);

  thd->ENTER_COND(&cond, &LOCK_item_func_sleep, &stage_user_sleep, nullptr);

  error = 0;
  thd_wait_begin(thd, THD_WAIT_SLEEP);
  while (!thd->killed) {
    error = timed_cond.wait(&cond, &LOCK_item_func_sleep);
    if (is_timeout(error)) break;
    error = 0;
  }
  thd_wait_end(thd);
  mysql_mutex_unlock(&LOCK_item_func_sleep);
  thd->EXIT_COND(nullptr);

  mysql_cond_destroy(&cond);

  return (error == 0);  // Return 1 killed
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_source_pos_wait::val_int
longlong Item_source_pos_wait::val_int() {
  assert(fixed == 1);
  THD *thd = current_thd;
  String *log_name = args[0]->val_str(&value);
  int event_count = 0;

  null_value = false;
  if (thd->slave_thread || !log_name || !log_name->length()) {
    null_value = true;
    return 0;
  }
  Master_info *mi;
  longlong pos = (ulong)args[1]->val_int();
  double timeout = (arg_count >= 3) ? args[2]->val_real() : 0;
  if (timeout < 0) {
    if (thd->is_strict_mode()) {
      my_error(ER_WRONG_ARGUMENTS, MYF(0), "SOURCE_POS_WAIT.");
    } else {
      push_warning_printf(thd, Sql_condition::SL_WARNING, ER_WRONG_ARGUMENTS,
                          ER_THD(thd, ER_WRONG_ARGUMENTS), "SOURCE_POS_WAIT.");
      null_value = true;
    }
    return 0;
  }

  channel_map.rdlock();

  if (arg_count == 4) {
    String *channel_str;
    if (!(channel_str = args[3]->val_str(&value))) {
      null_value = true;
      return 0;
    }

    mi = channel_map.get_mi(channel_str->ptr());

  } else {
    if (channel_map.get_num_instances() > 1) {
      mi = nullptr;
      my_error(ER_REPLICA_MULTIPLE_CHANNELS_CMD, MYF(0));
    } else
      mi = channel_map.get_default_channel_mi();
  }

  if (mi != nullptr) mi->inc_reference();

  channel_map.unlock();

  if (mi == nullptr || (event_count = mi->rli->wait_for_pos(thd, log_name, pos,
                                                            timeout)) == -2) {
    null_value = true;
    event_count = 0;
  }

  if (mi != nullptr) mi->dec_reference();
  return event_count;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_func_minus::resolve_type
bool Item_func_minus::resolve_type(THD *thd) {
  if (Item_num_op::resolve_type(thd)) return true;
  if (unsigned_flag && (thd->variables.sql_mode & MODE_NO_UNSIGNED_SUBTRACTION))
    unsigned_flag = false;
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_func::signal_divide_by_null
void Item_func::signal_divide_by_null() {
  THD *thd = current_thd;
  if (thd->variables.sql_mode & MODE_ERROR_FOR_DIVISION_BY_ZERO)
    push_warning(thd, Sql_condition::SL_WARNING, ER_DIVISION_BY_ZERO,
                 ER_THD(thd, ER_DIVISION_BY_ZERO));
  null_value = true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_str_func::fix_fields
bool Item_str_func::fix_fields(THD *thd, Item **ref) {
  bool res = Item_func::fix_fields(thd, ref);
  /*
    In Item_str_func::check_well_formed_result() we may set null_value
    flag on the same condition as in test() below.
  */
  set_nullable(is_nullable() || thd->is_strict_mode());
  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_eval_expr
bool sp_eval_expr(THD *thd, Field *result_field, Item **expr_item_ptr) {
  Item *expr_item;
  Strict_error_handler strict_handler(
      Strict_error_handler::ENABLE_SET_SELECT_STRICT_ERROR_HANDLER);
  enum_check_fields save_check_for_truncated_fields =
      thd->check_for_truncated_fields;
  unsigned int stmt_unsafe_rollback_flags =
      thd->get_transaction()->get_unsafe_rollback_flags(Transaction_ctx::STMT);

  if (!*expr_item_ptr) goto error;

  if (!(expr_item = sp_prepare_func_item(thd, expr_item_ptr))) goto error;

  /*
    Set THD flags to emit warnings/errors in case of overflow/type errors
    during saving the item into the field.

    Save original values and restore them after save.
  */

  thd->check_for_truncated_fields = CHECK_FIELD_ERROR_FOR_NULL;
  thd->get_transaction()->reset_unsafe_rollback_flags(Transaction_ctx::STMT);

  /*
    Variables declared within SP/SF with DECLARE keyword like
      DECLARE var INTEGER;
    will follow the rules of assignment corresponding to the data type column
    in a table. So, STRICT mode gives error if an invalid value is assigned
    to the variable here.
  */
  if (thd->is_strict_mode() && !thd->lex->is_ignore())
    thd->push_internal_handler(&strict_handler);
  // Save the value in the field. Convert the value if needed.
  expr_item->save_in_field(result_field, false);

  if (thd->is_strict_mode() && !thd->lex->is_ignore())
    thd->pop_internal_handler();
  thd->check_for_truncated_fields = save_check_for_truncated_fields;
  thd->get_transaction()->set_unsafe_rollback_flags(Transaction_ctx::STMT,
                                                    stmt_unsafe_rollback_flags);

  if (!thd->is_error()) return false;

error:
  /*
    In case of error during evaluation, leave the result field set to NULL.
    Sic: we can't do it in the beginning of the function because the
    result field might be needed for its own re-evaluation, e.g. case of
    set x = x + 1;
  */
  result_field->set_null();
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: create_string not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: create_string not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: create_string not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: create_string not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: create_string not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: create_string not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_compile not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_compile not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_compile not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_compile not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_compile not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_compile not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_compile not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_compile not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_compile not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_binlog_create_routine_stmt not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: sp_binlog_create_routine_stmt not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_ddl_table.cc
Function: Sql_cmd_create_table::execute
bool Sql_cmd_create_table::execute(THD *thd) {
  LEX *const lex = thd->lex;
  Query_block *const query_block = lex->query_block;
  Query_expression *const query_expression = lex->unit;
  Table_ref *const create_table = lex->query_tables;
  partition_info *part_info = lex->part_info;

  /*
    Code below (especially in mysql_create_table() and Query_result_create
    methods) may modify HA_CREATE_INFO structure in LEX, so we have to
    use a copy of this structure to make execution prepared statement-
    safe. A shallow copy is enough as this code won't modify any memory
    referenced from this structure.
  */
  HA_CREATE_INFO create_info(*lex->create_info);
  /*
    We need to copy alter_info for the same reasons of re-execution
    safety, only in case of Alter_info we have to do (almost) a deep
    copy.
  */
  Alter_info alter_info(*m_alter_info, thd->mem_root);

  if (thd->is_error()) {
    /* If out of memory when creating a copy of alter_info. */
    return true;
  }

  if (((lex->create_info->used_fields & HA_CREATE_USED_DATADIR) != 0 ||
       (lex->create_info->used_fields & HA_CREATE_USED_INDEXDIR) != 0) &&
      check_access(thd, FILE_ACL, any_db, nullptr, nullptr, false, false)) {
    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "FILE");
    return true;
  }

  if (!thd->is_plugin_fake_ddl()) {
    if (create_table_precheck(thd, query_expression_tables, create_table))
      return true;
  }

  /* Might have been updated in create_table_precheck */
  create_info.alias = create_table->alias;

  /*
    If no engine type was given, work out the default now
    rather than at parse-time.
  */
  if (!(create_info.used_fields & HA_CREATE_USED_ENGINE))
    create_info.db_type = create_info.options & HA_LEX_CREATE_TMP_TABLE
                              ? ha_default_temp_handlerton(thd)
                              : ha_default_handlerton(thd);

  assert(create_info.db_type != nullptr);
  if ((m_alter_info->flags & Alter_info::ANY_ENGINE_ATTRIBUTE) != 0 &&
      ((create_info.db_type->flags & HTON_SUPPORTS_ENGINE_ATTRIBUTE) == 0 &&
       DBUG_EVALUATE_IF("simulate_engine_attribute_support", false, true))) {
    my_error(ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED, MYF(0),
             ha_resolve_storage_engine_name(create_info.db_type));
    return true;
  }

  /*
    Assign target tablespace name to enable locking in lock_table_names().
    Reject invalid names.
  */
  if (create_info.tablespace) {
    if (validate_tablespace_name_length(create_info.tablespace) ||
        validate_tablespace_name(TS_CMD_NOT_DEFINED, create_info.tablespace,
                                 create_info.db_type))
      return true;

    if (lex_string_strmake(thd->mem_root, &create_table->target_tablespace_name,
                           create_info.tablespace,
                           strlen(create_info.tablespace)))
      return true;
  }

  // Reject invalid tablespace names specified for partitions.
  if (validate_partition_tablespace_name_lengths(part_info) ||
      validate_partition_tablespace_names(part_info, create_info.db_type))
    return true;

  /* Fix names if symlinked or relocated tables */
  if (prepare_index_and_data_dir_path(thd, &create_info.data_file_name,
                                      &create_info.index_file_name,
                                      create_table->table_name))
    return true;

  {
    partition_info *part = thd->lex->part_info;
    if (part != nullptr && has_external_data_or_index_dir(*part) &&
        check_access(thd, FILE_ACL, any_db, nullptr, nullptr, false, false)) {
      return true;
    }
    if (part && !(part = thd->lex->part_info->get_clone(thd, true)))
      return true;
    thd->work_part_info = part;
  }

  if (part_info != nullptr && part_info->part_expr &&
      part_info->part_expr->fixed) {  // @todo Code may be redundant
    part_info->fixed = true;
  }
  bool res = false;

  if (!query_block->field_list_is_empty())  // With select
  {
    /*
      CREATE TABLE...IGNORE/REPLACE SELECT... can be unsafe, unless
      ORDER BY PRIMARY KEY clause is used in SELECT statement. We therefore
      use row based logging if mixed or row based logging is available.
      TODO: Check if the order of the output of the select statement is
      deterministic. Waiting for BUG#42415
    */
    if (lex->is_ignore())
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_CREATE_IGNORE_SELECT);

    if (lex->duplicates == DUP_REPLACE)
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_CREATE_REPLACE_SELECT);

    /**
      Disallow creation of foreign keys if,

      - SE supports atomic DDL's.
      - The binlogging is enabled.
      - The binlog format is ROW.

      This is done to avoid complications involved in locking,
      updating and invalidation (in case of rollback) of DD cache
      for parent table.
    */
    if ((alter_info.flags & Alter_info::ADD_FOREIGN_KEY) &&
        (create_info.db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        mysql_bin_log.is_open() &&
        (thd->variables.option_bits & OPTION_BIN_LOG) &&
        thd->variables.binlog_format == BINLOG_FORMAT_ROW) {
      my_error(ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT, MYF(0));
      return true;
    }

    // Reject request to CREATE TABLE AS SELECT with START TRANSACTION.
    if (create_info.m_transactional_ddl) {
      my_error(ER_NOT_ALLOWED_WITH_START_TRANSACTION, MYF(0),
               "with CREATE TABLE ... AS SELECT statement.");
      return true;
    }

    /*
      If:
      a) we inside an SP and there was NAME_CONST substitution,
      b) binlogging is on (STMT mode),
      c) we log the SP as separate statements
      raise a warning, as it may cause problems
      (see 'NAME_CONST issues' in 'Binary Logging of Stored Programs')
     */
    if (thd->query_name_consts && mysql_bin_log.is_open() &&
        thd->variables.binlog_format == BINLOG_FORMAT_STMT &&
        !mysql_bin_log.is_query_in_union(thd, thd->query_id)) {
      uint splocal_refs = 0;
      /* Count SP local vars in the top-level SELECT list */
      for (Item *item : query_block->visible_fields()) {
        if (item->is_splocal()) splocal_refs++;
      }
      /*
        If it differs from number of NAME_CONST substitution applied,
        we may have a SOME_FUNC(NAME_CONST()) in the SELECT list,
        that may cause a problem with binary log (see BUG#35383),
        raise a warning.
      */
      if (splocal_refs != thd->query_name_consts)
        push_warning(
            thd, Sql_condition::SL_WARNING, ER_UNKNOWN_ERROR,
            "Invoked routine ran a statement that may cause problems with "
            "binary log, see 'NAME_CONST issues' in 'Binary Logging of Stored "
            "Programs' "
            "section of the manual.");
    }

    /*
      Disable non-empty MERGE tables with CREATE...SELECT. Too
      complicated. See Bug #26379. Empty MERGE tables are read-only
      and don't allow CREATE...SELECT anyway.
    */
    if (create_info.used_fields & HA_CREATE_USED_UNION) {
      my_error(ER_WRONG_OBJECT, MYF(0), create_table->db,
               create_table->table_name, "BASE TABLE");
      return true;
    }

    if (query_expression->is_prepared()) {
      cleanup(thd);
    }
    auto cleanup_se_guard = create_scope_guard(
        [lex] { lex->set_secondary_engine_execution_context(nullptr); });
    if (open_tables_for_query(thd, lex->query_tables, false)) return true;

    /* The table already exists */
    if (create_table->table || create_table->is_view()) {
      if (create_info.options & HA_LEX_CREATE_IF_NOT_EXISTS) {
        push_warning_printf(thd, Sql_condition::SL_NOTE, ER_TABLE_EXISTS_ERROR,
                            ER_THD(thd, ER_TABLE_EXISTS_ERROR),
                            create_info.alias);
        my_ok(thd);
        return false;
      } else {
        my_error(ER_TABLE_EXISTS_ERROR, MYF(0), create_info.alias);
        return false;
      }
    }

    /*
      Remove target table from main select and name resolution
      context. This can't be done earlier as it will break view merging in
      statements like "CREATE TABLE IF NOT EXISTS existing_view SELECT".
    */
    bool link_to_local;
    lex->unlink_first_table(&link_to_local);

    /* Updating any other table is prohibited in CTS statement */
    for (Table_ref *table = lex->query_tables; table;
         table = table->next_global) {
      if (table->lock_descriptor().type >= TL_WRITE_ALLOW_WRITE) {
        lex->link_first_table_back(create_table, link_to_local);

        my_error(ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT, MYF(0),
                 table->table_name, create_info.alias);
        return true;
      }
    }

    Query_result_create *result;
    if (!query_expression->is_prepared()) {
      const Prepare_error_tracker tracker(thd);
      Prepared_stmt_arena_holder ps_arena_holder(thd);
      result = new (thd->mem_root)
          Query_result_create(create_table, &query_block->fields,
                              lex->duplicates, query_expression_tables);
      if (result == nullptr) {
        lex->link_first_table_back(create_table, link_to_local);
        return true;
      }

      // Use the hypergraph optimizer for the SELECT statement, if enabled.
      lex->set_using_hypergraph_optimizer(
          thd->optimizer_switch_flag(OPTIMIZER_SWITCH_HYPERGRAPH_OPTIMIZER));

      if (query_expression->prepare(thd, result, nullptr, SELECT_NO_UNLOCK,
                                    0)) {
        lex->link_first_table_back(create_table, link_to_local);
        return true;
      }
      if (!thd->stmt_arena->is_regular() && lex->save_cmd_properties(thd)) {
        lex->link_first_table_back(create_table, link_to_local);
        return true;
      }
    } else {
      result = down_cast<Query_result_create *>(
          query_expression->query_result() != nullptr
              ? query_expression->query_result()
              : query_block->query_result());
      // Restore prepared statement properties, bind table and field information
      lex->restore_cmd_properties();
      bind_fields(thd->stmt_arena->item_list());
    }
    if (validate_use_secondary_engine(lex)) return true;

    result->set_two_fields(&create_info, &alter_info);

    // For objects acquired during table creation.
    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    Ignore_error_handler ignore_handler;
    Strict_error_handler strict_handler;
    if (lex->is_ignore())
      thd->push_internal_handler(&ignore_handler);
    else if (thd->is_strict_mode())
      thd->push_internal_handler(&strict_handler);

    res = populate_table(thd, lex);

    // Count the number of statements offloaded to a secondary storage engine.
    if (using_secondary_storage_engine() && lex->unit->is_executed())
      ++thd->status_var.secondary_engine_execution_count;

    if (lex->is_ignore() || thd->is_strict_mode()) thd->pop_internal_handler();
    lex->cleanup(false);
    thd->clear_current_query_costs();
    lex->clear_values_map();

    // Abort the result set if execution ended in error
    if (res) result->abort_result_set(thd);

    result->cleanup();

    lex->link_first_table_back(create_table, link_to_local);
    THD_STAGE_INFO(thd, stage_end);
  } else {
    Strict_error_handler strict_handler;
    /* Push Strict_error_handler */
    if (!lex->is_ignore() && thd->is_strict_mode())
      thd->push_internal_handler(&strict_handler);
    /* regular create */
    if (create_info.options & HA_LEX_CREATE_TABLE_LIKE) {
      /* CREATE TABLE ... LIKE ... */
      res = mysql_create_like_table(thd, create_table, query_expression_tables,
                                    &create_info);
    } else {
      /* Regular CREATE TABLE */
      res = mysql_create_table(thd, create_table, &create_info, &alter_info);
    }
    /* Pop Strict_error_handler */
    if (!lex->is_ignore() && thd->is_strict_mode()) thd->pop_internal_handler();
    if (!res) {
      /* in case of create temp tables if @@session_track_state_change is
         ON then send session state notification in OK packet */
      if (create_info.options & HA_LEX_CREATE_TMP_TABLE &&
          thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
              ->is_enabled())
        thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
            ->mark_as_changed(thd, {});
      my_ok(thd);
    }
  }
  // The following code is required to make CREATE TABLE re-execution safe.
  // @todo Consider refactoring this code.
  if (part_info != nullptr) {
    if (part_info->part_expr != nullptr &&
        part_info->part_expr->type() == Item::FIELD_ITEM)
      down_cast<Item_field *>(part_info->part_expr)->reset_field();

    if (part_info->subpart_expr != nullptr &&
        part_info->subpart_expr->type() == Item::FIELD_ITEM)
      down_cast<Item_field *>(part_info->subpart_expr)->reset_field();
  }
  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_ddl_table.cc
Function: Sql_cmd_create_or_drop_index_base::execute
bool Sql_cmd_create_or_drop_index_base::execute(THD *thd) {
  /*
    CREATE INDEX and DROP INDEX are implemented by calling ALTER
    TABLE with proper arguments.

    In the future ALTER TABLE will notice that the request is to
    only add indexes and create these one by one for the existing
    table without having to do a full rebuild.
  */

  LEX *const lex = thd->lex;
  Query_block *const query_block = lex->query_block;
  Table_ref *const first_table = query_block->get_table_list();
  Table_ref *const all_tables = first_table;

  /* Prepare stack copies to be re-execution safe */
  HA_CREATE_INFO create_info;
  Alter_info alter_info(*m_alter_info, thd->mem_root);

  if (thd->is_fatal_error()) /* out of memory creating a copy of alter_info */
    return true;             // OOM

  if (check_one_table_access(thd, INDEX_ACL, all_tables)) return true;
  /*
    Currently CREATE INDEX or DROP INDEX cause a full table rebuild
    and thus classify as slow administrative statements just like
    ALTER TABLE.
  */
  thd->enable_slow_log = opt_log_slow_admin_statements;

  create_info.db_type = nullptr;
  create_info.row_type = ROW_TYPE_NOT_USED;
  create_info.default_table_charset = thd->variables.collation_database;

  /* Push Strict_error_handler */
  Strict_error_handler strict_handler;
  if (thd->is_strict_mode()) thd->push_internal_handler(&strict_handler);
  assert(!query_block->order_list.elements);
  const bool res =
      mysql_alter_table(thd, first_table->db, first_table->table_name,
                        &create_info, first_table, &alter_info);
  /* Pop Strict_error_handler */
  if (thd->is_strict_mode()) thd->pop_internal_handler();
  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_load.cc
Function: Sql_cmd_load_table::execute
bool Sql_cmd_load_table::execute(THD *thd) {
  LEX *const lex = thd->lex;

  uint privilege =
      (lex->duplicates == DUP_REPLACE ? INSERT_ACL | DELETE_ACL : INSERT_ACL) |
      (m_is_local_file ? 0 : FILE_ACL);

  if (m_is_local_file) {
    if (!thd->get_protocol()->has_client_capability(CLIENT_LOCAL_FILES) ||
        !opt_local_infile) {
      my_error(ER_CLIENT_LOCAL_FILES_DISABLED, MYF(0));
      return true;
    }
  }

  if (check_one_table_access(thd, privilege, lex->query_tables)) return true;

  /* Push strict / ignore error handler */
  Ignore_error_handler ignore_handler;
  Strict_error_handler strict_handler;
  if (thd->lex->is_ignore())
    thd->push_internal_handler(&ignore_handler);
  else if (thd->is_strict_mode())
    thd->push_internal_handler(&strict_handler);

  lex->set_using_hypergraph_optimizer(
      thd->optimizer_switch_flag(OPTIMIZER_SWITCH_HYPERGRAPH_OPTIMIZER));

  bool res = execute_inner(thd, lex->duplicates);

  /* Pop ignore / strict error handler */
  if (thd->lex->is_ignore() || thd->is_strict_mode())
    thd->pop_internal_handler();

  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_load.cc
Function: Sql_cmd_load_table::execute_inner not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_load.cc
Function: Sql_cmd_load_table::execute_inner not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_load.cc
Function: Sql_cmd_load_table::execute_inner not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_load.cc
Function: Sql_cmd_load_table::execute_inner not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_signal.cc
Function: Sql_cmd_common_signal::eval_signal_informations not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_signal.cc
Function: Sql_cmd_common_signal::eval_signal_informations not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_signal.cc
Function: assign_condition_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_signal.cc
Function: assign_condition_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::Transaction_state::restore
void THD::Transaction_state::restore(THD *thd) {
  thd->set_transaction(this->m_trx);

  thd->restore_ha_data(this->m_ha_data);

  thd->tx_isolation = this->m_tx_isolation;
  thd->variables.sql_mode = this->m_sql_mode;
  thd->tx_read_only = this->m_tx_read_only;
  thd->variables.option_bits = this->m_thd_option_bits;

  thd->m_transaction_psi = this->m_transaction_psi;
  thd->server_status = this->m_server_status;
  thd->lex->sql_command = this->m_sql_command;
  thd->in_lock_tables = this->m_in_lock_tables;
  thd->time_zone_used = this->m_time_zone_used;
  thd->transaction_rollback_request = this->m_transaction_rollback_request;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::Transaction_state::backup
void THD::Transaction_state::backup(THD *thd) {
  this->m_sql_command = thd->lex->sql_command;
  this->m_trx = thd->get_transaction();

  thd->backup_ha_data(&this->m_ha_data);

  this->m_tx_isolation = thd->tx_isolation;
  this->m_tx_read_only = thd->tx_read_only;
  this->m_thd_option_bits = thd->variables.option_bits;
  this->m_sql_mode = thd->variables.sql_mode;
  this->m_transaction_psi = thd->m_transaction_psi;
  this->m_server_status = thd->server_status;
  this->m_in_lock_tables = thd->in_lock_tables;
  this->m_time_zone_used = thd->time_zone_used;
  this->m_transaction_rollback_request = thd->transaction_rollback_request;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::Attachable_trx::Attachable_trx not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::Attachable_trx::Attachable_trx not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::init
void THD::init(void) {
  plugin_thdvar_init(this, m_enable_plugins);
  /*
    variables= global_system_variables above has reset
    variables.pseudo_thread_id to 0. We need to correct it here to
    avoid temporary tables replication failure.
  */
  variables.pseudo_thread_id = m_thread_id;

  /*
    NOTE: reset_connection command will reset the THD to its default state.
    All system variables whose scope is SESSION ONLY should be set to their
    default values here.
  */
  reset_first_successful_insert_id();
  user_time.tv_sec = user_time.tv_usec = 0;
  start_time.tv_sec = start_time.tv_usec = 0;
  set_time();
  auto_inc_intervals_forced.clear();
  {
    ulong tmp;
    tmp = sql_rnd_with_mutex();
    randominit(&rand,
               tmp + static_cast<ulong>(reinterpret_cast<uintptr_t>(&rand)),
               tmp + (ulong)::atomic_global_query_id);
  }

  server_status = SERVER_STATUS_AUTOCOMMIT;
  if (variables.sql_mode & MODE_NO_BACKSLASH_ESCAPES)
    server_status |= SERVER_STATUS_NO_BACKSLASH_ESCAPES;

  get_transaction()->reset_unsafe_rollback_flags(Transaction_ctx::SESSION);
  get_transaction()->reset_unsafe_rollback_flags(Transaction_ctx::STMT);
  open_options = ha_open_options;
  update_lock_default =
      (variables.low_priority_updates ? TL_WRITE_LOW_PRIORITY : TL_WRITE);
  insert_lock_default =
      (variables.low_priority_updates ? TL_WRITE_LOW_PRIORITY
                                      : TL_WRITE_CONCURRENT_INSERT);
  tx_isolation = (enum_tx_isolation)variables.transaction_isolation;
  tx_read_only = variables.transaction_read_only;
  tx_priority = 0;
  thd_tx_priority = 0;
  update_charset();
  reset_current_stmt_binlog_format_row();
  reset_binlog_local_stmt_filter();
  memset(&status_var, 0, sizeof(status_var));
  binlog_row_event_extra_data = nullptr;

  if (variables.sql_log_bin)
    variables.option_bits |= OPTION_BIN_LOG;
  else
    variables.option_bits &= ~OPTION_BIN_LOG;

#if defined(ENABLED_DEBUG_SYNC)
  /* Initialize the Debug Sync Facility. See debug_sync.cc. */
  debug_sync_init_thread(this);
#endif /* defined(ENABLED_DEBUG_SYNC) */

  /* Initialize session_tracker and create all tracker objects */
  session_tracker.init(this->charset());
  session_tracker.enable(this);

  owned_gtid.clear();
  owned_sid.clear();
  m_se_gtid_flags.reset();
  owned_gtid.dbug_print(nullptr, "set owned_gtid (clear) in THD::init");

  /*
    This will clear the writeset session history and re-set delegate state to
    INIT
  */
  rpl_thd_ctx.init();

  /*
    This variable is used to temporarily disable the password validation plugin
    when a RANDOM PASSWORD is generated during SET PASSWORD,CREATE USER or
    ALTER USER statements.
  */
  m_disable_password_validation = false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: Lex_input_stream::reset
void Lex_input_stream::reset(const char *buffer, size_t length) {
  yylineno = 1;
  yytoklen = 0;
  yylval = nullptr;
  lookahead_token = grammar_selector_token;
  static Lexer_yystype dummy_yylval;
  lookahead_yylval = &dummy_yylval;
  skip_digest = false;
  /*
    Lex_input_stream modifies the query string in one special case (sic!).
    yyUnput() modifises the string when patching version comments.
    This is done to prevent newer slaves from executing a different
    statement than older masters.

    For now, cast away const here. This means that e.g. SHOW PROCESSLIST
    can see partially patched query strings. It would be better if we
    could replicate the query string as is and have the slave take the
    master version into account.
  */
  m_ptr = const_cast<char *>(buffer);
  m_tok_start = nullptr;
  m_tok_end = nullptr;
  m_end_of_query = buffer + length;
  m_buf = buffer;
  m_buf_length = length;
  m_echo = true;
  m_cpp_tok_start = nullptr;
  m_cpp_tok_end = nullptr;
  m_body_utf8 = nullptr;
  m_cpp_utf8_processed_ptr = nullptr;
  next_state = MY_LEX_START;
  found_semicolon = nullptr;
  ignore_space = m_thd->variables.sql_mode & MODE_IGNORE_SPACE;
  stmt_prepare_mode = false;
  multi_statements = true;
  in_comment = NO_COMMENT;
  m_underscore_cs = nullptr;
  m_cpp_ptr = m_cpp_buf;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: lex_one_token
static int lex_one_token(Lexer_yystype *yylval, THD *thd) {
  uchar c = 0;
  bool comment_closed;
  int tokval, result_state;
  uint length;
  enum my_lex_states state;
  Lex_input_stream *lip = &thd->m_parser_state->m_lip;
  const CHARSET_INFO *cs = thd->charset();
  const my_lex_states *state_map = cs->state_maps->main_map;
  const uchar *ident_map = cs->ident_map;

  lip->yylval = yylval;  // The global state

  lip->start_token();
  state = lip->next_state;
  lip->next_state = MY_LEX_START;
  for (;;) {
    switch (state) {
      case MY_LEX_START:  // Start of token
        // Skip starting whitespace
        while (state_map[c = lip->yyPeek()] == MY_LEX_SKIP) {
          if (c == '\n') lip->yylineno++;

          lip->yySkip();
        }

        /* Start of real token */
        lip->restart_token();
        c = lip->yyGet();
        state = state_map[c];
        break;
      case MY_LEX_CHAR:  // Unknown or single char token
      case MY_LEX_SKIP:  // This should not happen
        if (c == '-' && lip->yyPeek() == '-' &&
            (my_isspace(cs, lip->yyPeekn(1)) ||
             my_iscntrl(cs, lip->yyPeekn(1)))) {
          state = MY_LEX_COMMENT;
          break;
        }

        if (c == '-' && lip->yyPeek() == '>')  // '->'
        {
          lip->yySkip();
          lip->next_state = MY_LEX_START;
          if (lip->yyPeek() == '>') {
            lip->yySkip();
            return JSON_UNQUOTED_SEPARATOR_SYM;
          }
          return JSON_SEPARATOR_SYM;
        }

        if (c != ')') lip->next_state = MY_LEX_START;  // Allow signed numbers

        /*
          Check for a placeholder: it should not precede a possible identifier
          because of binlogging: when a placeholder is replaced with its value
          in a query for the binlog, the query must stay grammatically correct.
        */
        if (c == '?' && lip->stmt_prepare_mode && !ident_map[lip->yyPeek()])
          return (PARAM_MARKER);

        return ((int)c);

      case MY_LEX_IDENT_OR_NCHAR:
        if (lip->yyPeek() != '\'') {
          state = MY_LEX_IDENT;
          break;
        }
        /* Found N'string' */
        lip->yySkip();  // Skip '
        if (!(yylval->lex_str.str = get_text(lip, 2, 1))) {
          state = MY_LEX_CHAR;  // Read char by char
          break;
        }
        yylval->lex_str.length = lip->yytoklen;
        return (NCHAR_STRING);

      case MY_LEX_IDENT_OR_DOLLAR_QUOTE:
        state = MY_LEX_IDENT;
        push_deprecated_warn_no_replacement(
            lip->m_thd, "$ as the first character of an unquoted identifier");
        break;

      case MY_LEX_IDENT_OR_HEX:
        if (lip->yyPeek() == '\'') {  // Found x'hex-number'
          state = MY_LEX_HEX_NUMBER;
          break;
        }
        [[fallthrough]];
      case MY_LEX_IDENT_OR_BIN:
        if (lip->yyPeek() == '\'') {  // Found b'bin-number'
          state = MY_LEX_BIN_NUMBER;
          break;
        }
        [[fallthrough]];
      case MY_LEX_IDENT:
        const char *start;
        if (use_mb(cs)) {
          result_state = IDENT_QUOTED;
          switch (my_mbcharlen(cs, lip->yyGetLast())) {
            case 1:
              break;
            case 0:
              if (my_mbmaxlenlen(cs) < 2) break;
              [[fallthrough]];
            default:
              int l =
                  my_ismbchar(cs, lip->get_ptr() - 1, lip->get_end_of_query());
              if (l == 0) {
                state = MY_LEX_CHAR;
                continue;
              }
              lip->skip_binary(l - 1);
          }
          while (ident_map[c = lip->yyGet()]) {
            switch (my_mbcharlen(cs, c)) {
              case 1:
                break;
              case 0:
                if (my_mbmaxlenlen(cs) < 2) break;
                [[fallthrough]];
              default:
                int l;
                if ((l = my_ismbchar(cs, lip->get_ptr() - 1,
                                     lip->get_end_of_query())) == 0)
                  break;
                lip->skip_binary(l - 1);
            }
          }
        } else {
          for (result_state = c; ident_map[c = lip->yyGet()]; result_state |= c)
            ;
          /* If there were non-ASCII characters, mark that we must convert */
          result_state = result_state & 0x80 ? IDENT_QUOTED : IDENT;
        }
        length = lip->yyLength();
        start = lip->get_ptr();
        if (lip->ignore_space) {
          /*
            If we find a space then this can't be an identifier. We notice this
            below by checking start != lex->ptr.
          */
          for (; state_map[c] == MY_LEX_SKIP; c = lip->yyGet()) {
            if (c == '\n') lip->yylineno++;
          }
        }
        if (start == lip->get_ptr() && c == '.' && ident_map[lip->yyPeek()])
          lip->next_state = MY_LEX_IDENT_SEP;
        else {  // '(' must follow directly if function
          lip->yyUnget();
          if ((tokval = find_keyword(lip, length, c == '('))) {
            lip->next_state = MY_LEX_START;  // Allow signed numbers
            return (tokval);                 // Was keyword
          }
          lip->yySkip();  // next state does a unget
        }
        yylval->lex_str = get_token(lip, 0, length);

        /*
           Note: "SELECT _bla AS 'alias'"
           _bla should be considered as a IDENT if charset haven't been found.
           So we don't use MYF(MY_WME) with get_charset_by_csname to avoid
           producing an error.
        */

        if (yylval->lex_str.str[0] == '_') {
          auto charset_name = yylval->lex_str.str + 1;
          const CHARSET_INFO *underscore_cs =
              get_charset_by_csname(charset_name, MY_CS_PRIMARY, MYF(0));
          if (underscore_cs) {
            lip->warn_on_deprecated_charset(underscore_cs, charset_name);
            if (underscore_cs == &my_charset_utf8mb4_0900_ai_ci) {
              /*
                If underscore_cs is utf8mb4, and the collation of underscore_cs
                is the default collation of utf8mb4, then update underscore_cs
                with a value of the default_collation_for_utf8mb4 system
                variable:
              */
              underscore_cs = thd->variables.default_collation_for_utf8mb4;
            }
            yylval->charset = underscore_cs;
            lip->m_underscore_cs = underscore_cs;

            lip->body_utf8_append(lip->m_cpp_text_start,
                                  lip->get_cpp_tok_start() + length);
            return (UNDERSCORE_CHARSET);
          }
        }

        lip->body_utf8_append(lip->m_cpp_text_start);

        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
                                      lip->m_cpp_text_end);

        return (result_state);  // IDENT or IDENT_QUOTED

      case MY_LEX_IDENT_SEP:  // Found ident and now '.'
        yylval->lex_str.str = const_cast<char *>(lip->get_ptr());
        yylval->lex_str.length = 1;
        c = lip->yyGet();  // should be '.'
        if (uchar next_c = lip->yyPeek(); ident_map[next_c]) {
          lip->next_state =
              MY_LEX_IDENT_START;  // Next is an ident (not a keyword)
          if (next_c == '$')       // We got .$ident
            push_deprecated_warn_no_replacement(
                lip->m_thd,
                "$ as the first character of an unquoted identifier");
        } else  // Probably ` or "
          lip->next_state = MY_LEX_START;

        return ((int)c);

      case MY_LEX_NUMBER_IDENT:  // number or ident which num-start
        if (lip->yyGetLast() == '0') {
          c = lip->yyGet();
          if (c == 'x') {
            while (my_isxdigit(cs, (c = lip->yyGet())))
              ;
            if ((lip->yyLength() >= 3) && !ident_map[c]) {
              /* skip '0x' */
              yylval->lex_str = get_token(lip, 2, lip->yyLength() - 2);
              return (HEX_NUM);
            }
            lip->yyUnget();
            state = MY_LEX_IDENT_START;
            break;
          } else if (c == 'b') {
            while ((c = lip->yyGet()) == '0' || c == '1')
              ;
            if ((lip->yyLength() >= 3) && !ident_map[c]) {
              /* Skip '0b' */
              yylval->lex_str = get_token(lip, 2, lip->yyLength() - 2);
              return (BIN_NUM);
            }
            lip->yyUnget();
            state = MY_LEX_IDENT_START;
            break;
          }
          lip->yyUnget();
        }

        while (my_isdigit(cs, (c = lip->yyGet())))
          ;
        if (!ident_map[c]) {  // Can't be identifier
          state = MY_LEX_INT_OR_REAL;
          break;
        }
        if (c == 'e' || c == 'E') {
          // The following test is written this way to allow numbers of type 1e1
          if (my_isdigit(cs, lip->yyPeek()) || (c = (lip->yyGet())) == '+' ||
              c == '-') {  // Allow 1E+10
            if (my_isdigit(cs,
                           lip->yyPeek()))  // Number must have digit after sign
            {
              lip->yySkip();
              while (my_isdigit(cs, lip->yyGet()))
                ;
              yylval->lex_str = get_token(lip, 0, lip->yyLength());
              return (FLOAT_NUM);
            }
          }
          lip->yyUnget();
        }
        [[fallthrough]];
      case MY_LEX_IDENT_START:  // We come here after '.'
        result_state = IDENT;
        if (use_mb(cs)) {
          result_state = IDENT_QUOTED;
          while (ident_map[c = lip->yyGet()]) {
            switch (my_mbcharlen(cs, c)) {
              case 1:
                break;
              case 0:
                if (my_mbmaxlenlen(cs) < 2) break;
                [[fallthrough]];
              default:
                int l;
                if ((l = my_ismbchar(cs, lip->get_ptr() - 1,
                                     lip->get_end_of_query())) == 0)
                  break;
                lip->skip_binary(l - 1);
            }
          }
        } else {
          for (result_state = 0; ident_map[c = lip->yyGet()]; result_state |= c)
            ;
          /* If there were non-ASCII characters, mark that we must convert */
          result_state = result_state & 0x80 ? IDENT_QUOTED : IDENT;
        }
        if (c == '.' && ident_map[lip->yyPeek()])
          lip->next_state = MY_LEX_IDENT_SEP;  // Next is '.'

        yylval->lex_str = get_token(lip, 0, lip->yyLength());

        lip->body_utf8_append(lip->m_cpp_text_start);

        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
                                      lip->m_cpp_text_end);

        return (result_state);

      case MY_LEX_USER_VARIABLE_DELIMITER:  // Found quote char
      {
        uint double_quotes = 0;
        char quote_char = c;  // Used char
        for (;;) {
          c = lip->yyGet();
          if (c == 0) {
            lip->yyUnget();
            return ABORT_SYM;  // Unmatched quotes
          }

          int var_length;
          if ((var_length = my_mbcharlen(cs, c)) == 1) {
            if (c == quote_char) {
              if (lip->yyPeek() != quote_char) break;
              c = lip->yyGet();
              double_quotes++;
              continue;
            }
          } else if (use_mb(cs)) {
            if ((var_length = my_ismbchar(cs, lip->get_ptr() - 1,
                                          lip->get_end_of_query())))
              lip->skip_binary(var_length - 1);
          }
        }
        if (double_quotes)
          yylval->lex_str = get_quoted_token(
              lip, 1, lip->yyLength() - double_quotes - 1, quote_char);
        else
          yylval->lex_str = get_token(lip, 1, lip->yyLength() - 1);
        if (c == quote_char) lip->yySkip();  // Skip end `
        lip->next_state = MY_LEX_START;

        lip->body_utf8_append(lip->m_cpp_text_start);

        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
                                      lip->m_cpp_text_end);

        return (IDENT_QUOTED);
      }
      case MY_LEX_INT_OR_REAL:  // Complete int or incomplete real
        if (c != '.') {         // Found complete integer number.
          yylval->lex_str = get_token(lip, 0, lip->yyLength());
          return int_token(yylval->lex_str.str, (uint)yylval->lex_str.length);
        }
        [[fallthrough]];
      case MY_LEX_REAL:  // Incomplete real number
        while (my_isdigit(cs, c = lip->yyGet()))
          ;

        if (c == 'e' || c == 'E') {
          c = lip->yyGet();
          if (c == '-' || c == '+') c = lip->yyGet();  // Skip sign
          if (!my_isdigit(cs, c)) {                    // No digit after sign
            state = MY_LEX_CHAR;
            break;
          }
          while (my_isdigit(cs, lip->yyGet()))
            ;
          yylval->lex_str = get_token(lip, 0, lip->yyLength());
          return (FLOAT_NUM);
        }
        yylval->lex_str = get_token(lip, 0, lip->yyLength());
        return (DECIMAL_NUM);

      case MY_LEX_HEX_NUMBER:  // Found x'hexstring'
        lip->yySkip();         // Accept opening '
        while (my_isxdigit(cs, (c = lip->yyGet())))
          ;
        if (c != '\'') return (ABORT_SYM);          // Illegal hex constant
        lip->yySkip();                              // Accept closing '
        length = lip->yyLength();                   // Length of hexnum+3
        if ((length % 2) == 0) return (ABORT_SYM);  // odd number of hex digits
        yylval->lex_str = get_token(lip,
                                    2,            // skip x'
                                    length - 3);  // don't count x' and last '
        return (HEX_NUM);

      case MY_LEX_BIN_NUMBER:  // Found b'bin-string'
        lip->yySkip();         // Accept opening '
        while ((c = lip->yyGet()) == '0' || c == '1')
          ;
        if (c != '\'') return (ABORT_SYM);  // Illegal hex constant
        lip->yySkip();                      // Accept closing '
        length = lip->yyLength();           // Length of bin-num + 3
        yylval->lex_str = get_token(lip,
                                    2,            // skip b'
                                    length - 3);  // don't count b' and last '
        return (BIN_NUM);

      case MY_LEX_CMP_OP:  // Incomplete comparison operator
        if (state_map[lip->yyPeek()] == MY_LEX_CMP_OP ||
            state_map[lip->yyPeek()] == MY_LEX_LONG_CMP_OP)
          lip->yySkip();
        if ((tokval = find_keyword(lip, lip->yyLength() + 1, false))) {
          lip->next_state = MY_LEX_START;  // Allow signed numbers
          return (tokval);
        }
        state = MY_LEX_CHAR;  // Something fishy found
        break;

      case MY_LEX_LONG_CMP_OP:  // Incomplete comparison operator
        if (state_map[lip->yyPeek()] == MY_LEX_CMP_OP ||
            state_map[lip->yyPeek()] == MY_LEX_LONG_CMP_OP) {
          lip->yySkip();
          if (state_map[lip->yyPeek()] == MY_LEX_CMP_OP) lip->yySkip();
        }
        if ((tokval = find_keyword(lip, lip->yyLength() + 1, false))) {
          lip->next_state = MY_LEX_START;  // Found long op
          return (tokval);
        }
        state = MY_LEX_CHAR;  // Something fishy found
        break;

      case MY_LEX_BOOL:
        if (c != lip->yyPeek()) {
          state = MY_LEX_CHAR;
          break;
        }
        lip->yySkip();
        tokval = find_keyword(lip, 2, false);  // Is a bool operator
        lip->next_state = MY_LEX_START;        // Allow signed numbers
        return (tokval);

      case MY_LEX_STRING_OR_DELIMITER:
        if (thd->variables.sql_mode & MODE_ANSI_QUOTES) {
          state = MY_LEX_USER_VARIABLE_DELIMITER;
          break;
        }
        /* " used for strings */
        [[fallthrough]];
      case MY_LEX_STRING:  // Incomplete text string
        if (!(yylval->lex_str.str = get_text(lip, 1, 1))) {
          state = MY_LEX_CHAR;  // Read char by char
          break;
        }
        yylval->lex_str.length = lip->yytoklen;

        lip->body_utf8_append(lip->m_cpp_text_start);

        lip->body_utf8_append_literal(
            thd, &yylval->lex_str,
            lip->m_underscore_cs ? lip->m_underscore_cs : cs,
            lip->m_cpp_text_end);

        lip->m_underscore_cs = nullptr;

        return (TEXT_STRING);

      case MY_LEX_COMMENT:  //  Comment
        thd->m_parser_state->add_comment();
        while ((c = lip->yyGet()) != '\n' && c)
          ;
        lip->yyUnget();        // Safety against eof
        state = MY_LEX_START;  // Try again
        break;
      case MY_LEX_LONG_COMMENT: /* Long C comment? */
        if (lip->yyPeek() != '*') {
          state = MY_LEX_CHAR;  // Probable division
          break;
        }
        thd->m_parser_state->add_comment();
        /* Reject '/' '*', since we might need to turn off the echo */
        lip->yyUnget();

        lip->save_in_comment_state();

        if (lip->yyPeekn(2) == '!') {
          lip->in_comment = DISCARD_COMMENT;
          /* Accept '/' '*' '!', but do not keep this marker. */
          lip->set_echo(false);
          lip->yySkip();
          lip->yySkip();
          lip->yySkip();

          /*
            The special comment format is very strict:
            '/' '*' '!', followed by exactly
            1 digit (major), 2 digits (minor), then 2 digits (dot).
            32302 -> 3.23.02
            50032 -> 5.0.32
            50114 -> 5.1.14
          */
          char version_str[6];
          if (my_isdigit(cs, (version_str[0] = lip->yyPeekn(0))) &&
              my_isdigit(cs, (version_str[1] = lip->yyPeekn(1))) &&
              my_isdigit(cs, (version_str[2] = lip->yyPeekn(2))) &&
              my_isdigit(cs, (version_str[3] = lip->yyPeekn(3))) &&
              my_isdigit(cs, (version_str[4] = lip->yyPeekn(4)))) {
            if (!my_isspace(cs, lip->yyPeekn(5))) {
              push_warning(thd, Sql_condition::SL_WARNING,
                           ER_WARN_NO_SPACE_VERSION_COMMENT,
                           ER_THD(thd, ER_WARN_NO_SPACE_VERSION_COMMENT));
            }

            version_str[5] = 0;
            ulong version;
            version = strtol(version_str, nullptr, 10);

            if (version <= MYSQL_VERSION_ID) {
              /* Accept 'M' 'm' 'm' 'd' 'd' */
              lip->yySkipn(5);
              /* Expand the content of the special comment as real code */
              lip->set_echo(true);
              state = MY_LEX_START;
              break; /* Do not treat contents as a comment.  */
            } else {
              /*
                Patch and skip the conditional comment to avoid it
                being propagated infinitely (eg. to a slave).
              */
              char *pcom = lip->yyUnput(' ');
              comment_closed = !consume_comment(lip, 1);
              if (!comment_closed) {
                *pcom = '!';
              }
              /* version allowed to have one level of comment inside. */
            }
          } else {
            /* Not a version comment. */
            state = MY_LEX_START;
            lip->set_echo(true);
            break;
          }
        } else {
          if (lip->in_comment != NO_COMMENT) {
            push_warning(
                lip->m_thd, Sql_condition::SL_WARNING,
                ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
                ER_THD(lip->m_thd, ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX));
          }
          lip->in_comment = PRESERVE_COMMENT;
          lip->yySkip();  // Accept /
          lip->yySkip();  // Accept *
          comment_closed = !consume_comment(lip, 0);
          /* regular comments can have zero comments inside. */
        }
        /*
          Discard:
          - regular '/' '*' comments,
          - special comments '/' '*' '!' for a future version,
          by scanning until we find a closing '*' '/' marker.

          Nesting regular comments isn't allowed.  The first
          '*' '/' returns the parser to the previous state.

          /#!VERSI oned containing /# regular #/ is allowed #/

                  Inside one versioned comment, another versioned comment
                  is treated as a regular discardable comment.  It gets
                  no special parsing.
        */

        /* Unbalanced comments with a missing '*' '/' are a syntax error */
        if (!comment_closed) return (ABORT_SYM);
        state = MY_LEX_START;  // Try again
        lip->restore_in_comment_state();
        break;
      case MY_LEX_END_LONG_COMMENT:
        if ((lip->in_comment != NO_COMMENT) && lip->yyPeek() == '/') {
          /* Reject '*' '/' */
          lip->yyUnget();
          /* Accept '*' '/', with the proper echo */
          lip->set_echo(lip->in_comment == PRESERVE_COMMENT);
          lip->yySkipn(2);
          /* And start recording the tokens again */
          lip->set_echo(true);

          /*
            C-style comments are replaced with a single space (as it
            is in C and C++).  If there is already a whitespace
            character at this point in the stream, the space is
            not inserted.

            See also ISO/IEC 9899:1999 §5.1.1.2
            ("Programming languages — C")
          */
          if (!my_isspace(cs, lip->yyPeek()) &&
              lip->get_cpp_ptr() != lip->get_cpp_buf() &&
              !my_isspace(cs, *(lip->get_cpp_ptr() - 1)))
            lip->cpp_inject(' ');

          lip->in_comment = NO_COMMENT;
          state = MY_LEX_START;
        } else
          state = MY_LEX_CHAR;  // Return '*'
        break;
      case MY_LEX_SET_VAR:  // Check if ':='
        if (lip->yyPeek() != '=') {
          state = MY_LEX_CHAR;  // Return ':'
          break;
        }
        lip->yySkip();
        return (SET_VAR);
      case MY_LEX_SEMICOLON:  // optional line terminator
        state = MY_LEX_CHAR;  // Return ';'
        break;
      case MY_LEX_EOL:
        if (lip->eof()) {
          lip->yyUnget();  // Reject the last '\0'
          lip->set_echo(false);
          lip->yySkip();
          lip->set_echo(true);
          /* Unbalanced comments with a missing '*' '/' are a syntax error */
          if (lip->in_comment != NO_COMMENT) return (ABORT_SYM);
          lip->next_state = MY_LEX_END;  // Mark for next loop
          return (END_OF_INPUT);
        }
        state = MY_LEX_CHAR;
        break;
      case MY_LEX_END:
        lip->next_state = MY_LEX_END;
        return (0);  // We found end of input last time

        /* Actually real shouldn't start with . but allow them anyhow */
      case MY_LEX_REAL_OR_POINT:
        if (my_isdigit(cs, lip->yyPeek()))
          state = MY_LEX_REAL;  // Real
        else {
          state = MY_LEX_IDENT_SEP;  // return '.'
          lip->yyUnget();            // Put back '.'
        }
        break;
      case MY_LEX_USER_END:  // end '@' of user@hostname
        switch (state_map[lip->yyPeek()]) {
          case MY_LEX_STRING:
          case MY_LEX_USER_VARIABLE_DELIMITER:
          case MY_LEX_STRING_OR_DELIMITER:
            break;
          case MY_LEX_USER_END:
            lip->next_state = MY_LEX_SYSTEM_VAR;
            break;
          default:
            lip->next_state = MY_LEX_HOSTNAME;
            break;
        }
        yylval->lex_str.str = const_cast<char *>(lip->get_ptr());
        yylval->lex_str.length = 1;
        return ((int)'@');
      case MY_LEX_HOSTNAME:  // end '@' of user@hostname
        for (c = lip->yyGet();
             my_isalnum(cs, c) || c == '.' || c == '_' || c == '$';
             c = lip->yyGet())
          ;
        yylval->lex_str = get_token(lip, 0, lip->yyLength());
        return (LEX_HOSTNAME);
      case MY_LEX_SYSTEM_VAR:
        yylval->lex_str.str = const_cast<char *>(lip->get_ptr());
        yylval->lex_str.length = 1;
        lip->yySkip();  // Skip '@'
        lip->next_state =
            (state_map[lip->yyPeek()] == MY_LEX_USER_VARIABLE_DELIMITER
                 ? MY_LEX_START
                 : MY_LEX_IDENT_OR_KEYWORD);
        return ((int)'@');
      case MY_LEX_IDENT_OR_KEYWORD:
        /*
          We come here when we have found two '@' in a row.
          We should now be able to handle:
          [(global | local | session) .]variable_name
        */

        for (result_state = 0; ident_map[c = lip->yyGet()]; result_state |= c)
          ;
        /* If there were non-ASCII characters, mark that we must convert */
        result_state = result_state & 0x80 ? IDENT_QUOTED : IDENT;

        if (c == '.') lip->next_state = MY_LEX_IDENT_SEP;
        length = lip->yyLength();
        if (length == 0) return (ABORT_SYM);  // Names must be nonempty.
        if ((tokval = find_keyword(lip, length, false))) {
          lip->yyUnget();   // Put back 'c'
          return (tokval);  // Was keyword
        }
        yylval->lex_str = get_token(lip, 0, length);

        lip->body_utf8_append(lip->m_cpp_text_start);

        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
                                      lip->m_cpp_text_end);

        return (result_state);
    }
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: get_text not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: get_text not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: get_text not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: get_text not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: get_text not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: get_text not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: get_text not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: get_text not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex.cc
Function: find_keyword
static int find_keyword(Lex_input_stream *lip, uint len, bool function) {
  const char *tok = lip->get_tok_start();

  const SYMBOL *symbol =
      function ? Lex_hash::sql_keywords_and_funcs.get_hash_symbol(tok, len)
               : Lex_hash::sql_keywords.get_hash_symbol(tok, len);

  if (symbol) {
    lip->yylval->keyword.symbol = symbol;
    lip->yylval->keyword.str = const_cast<char *>(tok);
    lip->yylval->keyword.length = len;

    if ((symbol->tok == NOT_SYM) &&
        (lip->m_thd->variables.sql_mode & MODE_HIGH_NOT_PRECEDENCE))
      return NOT2_SYM;
    if ((symbol->tok == OR_OR_SYM) &&
        !(lip->m_thd->variables.sql_mode & MODE_PIPES_AS_CONCAT)) {
      push_deprecated_warn(lip->m_thd, "|| as a synonym for OR", "OR");
      return OR2_SYM;
    }

    lip->yylval->optimizer_hints = nullptr;
    if (symbol->group & SG_HINTABLE_KEYWORDS) {
      lip->add_digest_token(symbol->tok, lip->yylval);
      if (consume_optimizer_hints(lip)) return ABORT_SYM;
      lip->skip_digest = true;
    }

    return symbol->tok;
  }
  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.cc
Function: Hint_scanner::Hint_scanner not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.cc
Function: Hint_scanner::Hint_scanner not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.cc
Function: Hint_scanner::Hint_scanner not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.cc
Function: Hint_scanner::Hint_scanner not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.cc
Function: Hint_scanner::Hint_scanner not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.cc
Function: Hint_scanner::Hint_scanner not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.h
Function: int not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.h
Function: int not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.h
Function: int not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.h
Function: int not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_partition.cc
Function: add_partition_options
static int add_partition_options(File fptr, partition_element *p_elem) {
  int err = 0;

  err += add_space(fptr);
  if (p_elem->tablespace_name) {
    err += add_string(fptr, "TABLESPACE = ");
    err += add_ident_string(fptr, p_elem->tablespace_name);
    err += add_space(fptr);
  }
  if (p_elem->nodegroup_id != UNDEF_NODEGROUP)
    err += add_keyword_int(fptr, "NODEGROUP", (longlong)p_elem->nodegroup_id);
  if (p_elem->part_max_rows)
    err += add_keyword_int(fptr, "MAX_ROWS", (longlong)p_elem->part_max_rows);
  if (p_elem->part_min_rows)
    err += add_keyword_int(fptr, "MIN_ROWS", (longlong)p_elem->part_min_rows);
  if (!(current_thd->variables.sql_mode & MODE_NO_DIR_IN_CREATE)) {
    if (p_elem->data_file_name)
      err += add_keyword_path(fptr, "DATA DIRECTORY", p_elem->data_file_name);
    if (p_elem->index_file_name)
      err += add_keyword_path(fptr, "INDEX DIRECTORY", p_elem->index_file_name);
  }
  if (p_elem->part_comment)
    err += add_keyword_string(fptr, "COMMENT", true, p_elem->part_comment);
  return err + add_engine(fptr, p_elem->engine_type);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Sql_mode_parse_guard::Sql_mode_parse_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Sql_mode_parse_guard::Sql_mode_parse_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Sql_mode_parse_guard::Sql_mode_parse_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Sql_mode_parse_guard::Sql_mode_parse_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Sql_mode_parse_guard::Sql_mode_parse_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Sql_mode_parse_guard::Sql_mode_parse_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Sql_mode_parse_guard::Sql_mode_parse_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Sql_mode_parse_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/thd_raii.h
Function: Sql_mode_parse_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_schema_event_handler::Lock_wait_timeout_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_schema_event_handler::Lock_wait_timeout_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_schema_event_handler::Lock_wait_timeout_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_schema_event_handler::Lock_wait_timeout_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_binlog_index_table_util::remove_rows_for_file not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_binlog_index_table_util::remove_rows_for_file not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_binlog_index_table_util::remove_rows_for_file not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_binlog_index_table_util::remove_rows_for_file not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/server_component/mysql_system_variable_update_imp.cc
Function: prepare_thread_and_validate not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/server_component/mysql_system_variable_update_imp.cc
Function: prepare_thread_and_validate not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_locks_acquire_exclusive not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_locks_acquire_exclusive not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_locks_acquire_exclusive not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_locks_acquire_exclusive not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_locks_acquire_exclusive not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_resolver.cc
Function: Query_block::apply_local_transforms
bool Query_block::apply_local_transforms(THD *thd, bool prune) {
  DBUG_TRACE;

  assert(first_execution);

  /*
    If query block contains one or more merged derived tables/views,
    walk through lists of columns in select lists and remove unused columns.
  */
  if (derived_table_count) delete_unused_merged_columns(&m_table_nest);

  for (Query_expression *unit = first_inner_query_expression(); unit;
       unit = unit->next_query_expression())
    for (auto qt : unit->query_terms<>())
      if (qt->query_block()->apply_local_transforms(thd, true)) return true;

  // Convert all outer joins to inner joins if possible
  if (simplify_joins(thd, &m_table_nest, true, false, &m_where_cond))
    return true;
  if (record_join_nest_info(&m_table_nest)) return true;
  build_bitmap_for_nested_joins(&m_table_nest, 0);

  /*
    Here are the reasons why we do the following check here (i.e. late).
    * setup_fields () may have done split_sum_func () on aggregate items of
    the SELECT list, so for reliable comparison of the ORDER BY list with
    the SELECT list, we need to wait until split_sum_func() is done with
    the ORDER BY list.
    * we get resolved expressions "most of the time", which is always a good
    thing. Some outer references may not be resolved, though.
    * we need nested_join::used_tables, and this member is set in
    simplify_joins()
    * simplify_joins() does outer-join-to-inner conversion, which increases
    opportunities for functional dependencies (weak-to-strong, which is
    unusable, becomes strong-to-strong).
    * check_only_full_group_by() is dependent on processing done by
    simplify_joins() (for example it uses the value of
    Query_block::outer_join).

    The drawback is that the checks are after resolve_subquery(), so can
    meet strange "internally added" items.

    Note that when we are creating a view, simplify_joins() doesn't run so
    check_only_full_group_by() cannot run, any error will be raised only
    when the view is later used (SELECTed...)
  */
  if ((is_distinct() || is_grouped()) &&
      (thd->variables.sql_mode & MODE_ONLY_FULL_GROUP_BY) &&
      check_only_full_group_by(thd))
    return true;

  /*
    Prune partitions for all query blocks after query block merging, if
    pruning is wanted.
  */
  if (partitioned_table_count && prune) {
    for (Table_ref *tbl = leaf_tables; tbl; tbl = tbl->next_leaf) {
      /*
        This will only prune constant conditions, which will be used for
        lock pruning.
      */
      if (prune_partitions(thd, tbl->table, this,
                           tbl->join_cond() ? tbl->join_cond() : m_where_cond))
        return true; /* purecov: inspected */

      if (tbl->table->all_partitions_pruned_away &&
          !tbl->is_inner_table_of_outer_join())
        set_empty_query();
    }
  }
  /*
     Pushing conditions down to derived tables must be done after validity
     checks of grouped queries done above; indeed, by replacing columns
     with expressions, inside equalities of WHERE, pushdown makes the checks
     impossible.
     The said validity checks must be done after simplify_joins() has been
     done on all query blocks. While pushdown must be done on the outer
     most query block first, then on subqueries.
     These circular dependencies explain why:
     - pushdown is done after all local transformations have been applied.
     - a pushed-down condition cannot help to convert LEFT JOIN to inner join
     inside a derived table's definition.
   */
  if (outer_query_block() == nullptr && push_conditions_to_derived_tables(thd))
    return true;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_select.cc
Function: store_key::copy not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_select.cc
Function: store_key::copy not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_select.cc
Function: store_key::copy not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_select.cc
Function: store_key::copy not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_select.cc
Function: store_key::copy not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_select.cc
Function: store_key::copy not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_select.cc
Function: store_key::copy not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_select.cc
Function: store_key::copy not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_select.cc
Function: store_key::copy not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: get_quote_char_for_identifier not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: get_quote_char_for_identifier not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: get_quote_char_for_identifier not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: get_quote_char_for_identifier not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: view_store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: view_store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: view_store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: view_store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: view_store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: view_store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: view_store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: view_store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_create_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_key_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_key_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_key_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_key_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_key_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_key_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_key_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: store_key_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: append_directory not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: append_directory not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: append_directory not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: append_directory not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: get_viable_handlerton_for_create not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: get_viable_handlerton_for_create not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_prepare_create_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_prepare_create_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_prepare_create_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_prepare_create_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: create_table_impl not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: create_table_impl not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: create_table_impl not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: create_table_impl not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: copy_data_between_tables not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_datetime_with_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_datetime_with_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_datetime_with_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_datetime_with_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_datetime_with_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_datetime_with_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_datetime_with_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_datetime_with_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_datetime_with_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_datetime_with_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: str_to_time_with_warn
bool str_to_time_with_warn(String *str, MYSQL_TIME *l_time) {
  MYSQL_TIME_STATUS status;
  my_time_flags_t flags = 0;
  THD *thd = current_thd;

  if (current_thd->is_fsp_truncate_mode()) flags = TIME_FRAC_TRUNCATE;

  bool ret_val = propagate_datetime_overflow(
      current_thd, &status.warnings, str_to_time(str, l_time, flags, &status));
  if (ret_val || status.warnings) {
    if (make_truncated_value_warning(thd, Sql_condition::SL_WARNING,
                                     ErrConvString(str), MYSQL_TIMESTAMP_TIME,
                                     NullS))
      return true;
  }
  check_deprecated_datetime_format(current_thd, str->charset(), status);
  if (!ret_val)
    if (convert_time_zone_displacement(thd->time_zone(), l_time)) return true;

  return ret_val;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: lldiv_t_to_time
static bool lldiv_t_to_time(lldiv_t lld, MYSQL_TIME *ltime, int *warnings) {
  if (number_to_time(lld.quot, ltime, warnings)) return true;
  /*
    Both lld.quot and lld.rem can give negative result value,
    thus combine them using "|=".
  */
  if ((ltime->neg |= (lld.rem < 0))) lld.rem = -lld.rem;
  ltime->second_part = static_cast<ulong>(lld.rem / 1000);
  return time_add_nanoseconds_adjust_frac(ltime, lld.rem % 1000, warnings,
                                          current_thd->is_fsp_truncate_mode());
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_from_unixtime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_from_unixtime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_time::get_time
bool Item_typecast_time::get_time(MYSQL_TIME *ltime) {
  if (get_arg0_time(ltime)) return true;
  my_time_adjust_frac(ltime, decimals, current_thd->is_fsp_truncate_mode());

  /*
    For MYSQL_TIMESTAMP_TIME value we can have non-zero day part,
    which we should not lose.
  */
  if (ltime->time_type != MYSQL_TIMESTAMP_TIME) datetime_to_time(ltime);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_maketime::get_time
bool Item_func_maketime::get_time(MYSQL_TIME *ltime) {
  assert(fixed == 1);
  bool overflow = false;
  longlong hour = args[0]->val_int();
  if ((null_value = args[0]->null_value)) return true;

  longlong minute = args[1]->val_int();
  if ((null_value = args[1]->null_value)) return true;

  my_decimal tmp, *sec = args[2]->val_decimal(&tmp);
  if (sec == nullptr) return (null_value = true);
  if ((null_value = args[2]->null_value)) return true;

  lldiv_t second;
  if ((null_value = (my_decimal2lldiv_t(E_DEC_FATAL_ERROR, sec, &second) ||
                     minute < 0 || minute > 59 || second.quot < 0 ||
                     second.quot > 59 || second.rem < 0)))
    return true;

  set_zero_time(ltime, MYSQL_TIMESTAMP_TIME);

  /* Check for integer overflows */
  if (hour < 0) {
    if (args[0]->unsigned_flag)
      overflow = true;
    else
      ltime->neg = true;
  }
  if (-hour > UINT_MAX || hour > UINT_MAX) overflow = true;

  if (!overflow) {
    ltime->hour = (uint)((hour < 0 ? -hour : hour));
    ltime->minute = (uint)minute;
    ltime->second = (uint)second.quot;
    int warnings = 0;
    ltime->second_part = static_cast<ulong>(second.rem / 1000);
    if (adjust_time_range_with_warn(ltime, decimals)) return true;
    time_add_nanoseconds_adjust_frac(ltime, second.rem % 1000, &warnings,
                                     current_thd->is_fsp_truncate_mode());

    if (!warnings) return false;
  }

  // Return maximum value (positive or negative)
  set_max_hhmmss(ltime);
  char
      buf[MAX_BIGINT_WIDTH /* hh */ + 6 /* :mm:ss */ + 10 /* .fffffffff */ + 1];
  char *ptr = longlong10_to_str(hour, buf, args[0]->unsigned_flag ? 10 : -10);
  int len = (int)(ptr - buf) +
            sprintf(ptr, ":%02u:%02u", (uint)minute, (uint)second.quot);
  if (second.rem) {
    /*
      Display fractional part up to nanoseconds (9 digits),
      which is the maximum precision of my_decimal2lldiv_t().
    */
    int dec = min(args[2]->decimals, uint8{9});
    len += sprintf(buf + len, ".%0*lld", dec,
                   second.rem / (ulong)log_10_int[9 - dec]);
  }
  assert(strlen(buf) < sizeof(buf));
  return make_truncated_value_warning(current_thd, Sql_condition::SL_WARNING,
                                      ErrConvString(buf, len),
                                      MYSQL_TIMESTAMP_TIME, NullS);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: sec_to_time
static bool sec_to_time(lldiv_t seconds, MYSQL_TIME *ltime) {
  int warning = 0;

  set_zero_time(ltime, MYSQL_TIMESTAMP_TIME);

  if (seconds.quot < 0 || seconds.rem < 0) {
    ltime->neg = true;
    seconds.quot = -seconds.quot;
    seconds.rem = -seconds.rem;
  }

  if (seconds.quot > TIME_MAX_VALUE_SECONDS) {
    set_max_hhmmss(ltime);
    return true;
  }

  ltime->hour = (uint)(seconds.quot / 3600);
  uint sec = (uint)(seconds.quot % 3600);
  ltime->minute = sec / 60;
  ltime->second = sec % 60;
  time_add_nanoseconds_adjust_frac(ltime, static_cast<uint>(seconds.rem),
                                   &warning,
                                   current_thd->is_fsp_truncate_mode());

  adjust_time_range(ltime, &warning);
  return warning ? true : false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_date::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_datetime::get_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_str_to_date::resolve_type
bool Item_func_str_to_date::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, 2)) return true;
  set_nullable(true);
  cached_timestamp_type = MYSQL_TIMESTAMP_DATETIME;
  set_data_type_datetime(DATETIME_MAX_DECIMALS);
  sql_mode = thd->variables.sql_mode &
             (MODE_NO_ZERO_DATE | MODE_NO_ZERO_IN_DATE | MODE_INVALID_DATES);
  if (args[1]->const_item() && args[1]->may_eval_const_item(thd)) {
    char format_buff[64];
    String format_str(format_buff, sizeof(format_buff), &my_charset_bin);
    String *format = args[1]->val_str(&format_str);
    if (!args[1]->null_value) fix_from_format(format->ptr(), format->length());
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_str_to_date::val_datetime not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_str_to_date::val_datetime not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_str_to_date::val_datetime not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_str_to_date::val_datetime not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_str_to_date::val_datetime not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: fix_sql_mode
static bool fix_sql_mode(sys_var *self, THD *thd, enum_var_type type) {
  if (!self->is_global_persist(type)) {
    /* Update thd->server_status */
    if (thd->variables.sql_mode & MODE_NO_BACKSLASH_ESCAPES)
      thd->server_status |= SERVER_STATUS_NO_BACKSLASH_ESCAPES;
    else
      thd->server_status &= ~SERVER_STATUS_NO_BACKSLASH_ESCAPES;
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/trigger.cc
Function: Trigger::create_from_parser not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/trigger.cc
Function: Trigger::create_from_parser not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/trigger.cc
Function: Trigger::parse
bool Trigger::parse(THD *thd, bool is_upgrade) {
  sql_mode_t sql_mode_saved = thd->variables.sql_mode;
  thd->variables.sql_mode = m_sql_mode;

  Parser_state parser_state;
  String full_trigger_definition;

  // Trigger definition contains full trigger statement in .TRG file.
  if (is_upgrade) {
    if (full_trigger_definition.append(get_definition().str,
                                       get_definition().length)) {
      thd->variables.sql_mode = sql_mode_saved;
      return true;
    }
  } else if (create_full_trigger_definition(thd, &full_trigger_definition)) {
    thd->variables.sql_mode = sql_mode_saved;
    return true;
  }

  /*
    Allocate a memory buffer on the memroot and copy there a full trigger
    definition statement.
  */
  if (lex_string_strmake(m_mem_root, &m_full_trigger_definition,
                         full_trigger_definition.c_ptr_quick(),
                         full_trigger_definition.length()))
    return true;

  if (parser_state.init(thd, m_full_trigger_definition.str,
                        m_full_trigger_definition.length)) {
    thd->variables.sql_mode = sql_mode_saved;
    return true;
  }

  LEX *lex_saved = thd->lex;

  LEX lex;
  thd->lex = &lex;
  lex_start(thd);

  LEX_CSTRING current_db_name_saved = thd->db();
  thd->reset_db(m_db_name);

  Deprecated_trigger_syntax_handler error_handler;
  thd->push_internal_handler(&error_handler);

  sp_rcontext *sp_runtime_ctx_saved = thd->sp_runtime_ctx;
  thd->sp_runtime_ctx = nullptr;

  sql_digest_state *digest_saved = thd->m_digest;
  PSI_statement_locker *statement_locker_saved = thd->m_statement_psi;
  thd->m_digest = nullptr;
  thd->m_statement_psi = nullptr;

  Trigger_creation_ctx *creation_ctx = Trigger_creation_ctx::create(
      thd, m_db_name, m_subject_table_name, m_client_cs_name,
      m_connection_cl_name, m_db_cl_name);
  bool parse_error = false;
  if (creation_ctx != nullptr)
    parse_error = parse_sql(thd, &parser_state, creation_ctx);

  thd->m_digest = digest_saved;
  thd->m_statement_psi = statement_locker_saved;
  thd->sp_runtime_ctx = sp_runtime_ctx_saved;
  thd->variables.sql_mode = sql_mode_saved;

  thd->pop_internal_handler();

  bool fatal_error = false;
  if (creation_ctx == nullptr) {
    fatal_error = true;
    goto cleanup;
  }
  /*
    Not strictly necessary to invoke this method here, since we know
    that we've parsed CREATE TRIGGER and not an
    UPDATE/DELETE/INSERT/REPLACE/LOAD/CREATE TABLE, but we try to
    maintain the invariant that this method is called for each
    distinct statement, in case its logic is extended with other
    types of analyses in future.
  */
  lex.set_trg_event_type_for_tables();

  // Ensure that lex.sp_head is NULL in case of parse errors.

  assert(!parse_error || (parse_error && lex.sphead == nullptr));

  // That's it in case of parse error.

  if (parse_error) {
    // Remember parse error message.
    set_parse_error_message(error_handler.get_error_message());
    goto cleanup;
  }

  /*
    Set trigger name, event and action time for upgrade scenario.
    .TRG file does not contain these fields explicitly. Their value
    can be determined while parsing the trigger definition.
  */
  if (is_upgrade) {
    // Make a copy of trigger name and set it.
    LEX_CSTRING trigger_name;
    if (lex_string_strmake(m_mem_root, &trigger_name, lex.spname->m_name.str,
                           lex.spname->m_name.length)) {
      fatal_error = true;
      goto cleanup;
    }

    LEX_CSTRING trigger_def;
    if (lex_string_strmake(m_mem_root, &trigger_def, lex.sphead->m_body.str,
                           lex.sphead->m_body.length)) {
      fatal_error = true;
      goto cleanup;
    }

    LEX_CSTRING trigger_def_utf8;
    if (lex_string_strmake(m_mem_root, &trigger_def_utf8,
                           lex.sphead->m_body_utf8.str,
                           lex.sphead->m_body_utf8.length)) {
      fatal_error = true;
      goto cleanup;
    }

    set_trigger_name(trigger_name);
    set_trigger_def(trigger_def);
    set_trigger_def_utf8(trigger_def_utf8);

    // Set correct m_event and m_action_time.
    assert(m_event == TRG_EVENT_MAX);
    assert(m_action_time == TRG_ACTION_MAX);

    m_event = lex.sphead->m_trg_chistics.event;
    m_action_time = lex.sphead->m_trg_chistics.action_time;
  }

  assert(m_event == lex.sphead->m_trg_chistics.event);
  assert(m_action_time == lex.sphead->m_trg_chistics.action_time);

  // Take ownership of SP object.

  assert(!m_sp);

  m_sp = lex.sphead;
  lex.sphead = nullptr; /* Prevent double cleanup. */

  /*
    Set some SP attributes.

    NOTE: sp_head::set_info() is required on slave.
  */

  m_sp->set_info(0,  // CREATED timestamp (not used for triggers)
                 0,  // MODIFIED timestamp (not used for triggers)
                 &lex.sp_chistics, m_sql_mode);

  assert(!m_sp->get_creation_ctx());
  m_sp->set_creation_ctx(creation_ctx);

  /*
    construct_definer_value() that is called from the constructor of
    class Trigger guarantees that the definer has not empty value.
  */
  assert(m_definer.length);

  // Set the definer attribute in SP.
  m_sp->set_definer(m_definer.str, m_definer.length);

#ifdef HAVE_PSI_SP_INTERFACE
  m_sp->m_sp_share = MYSQL_GET_SP_SHARE(to_uint(enum_sp_type::TRIGGER),
                                        m_sp->m_db.str, m_sp->m_db.length,
                                        m_sp->m_name.str, m_sp->m_name.length);
#endif

cleanup:
  lex_end(&lex);
  thd->reset_db(current_db_name_saved);
  thd->lex = lex_saved;

  return fatal_error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::coerce_date not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/event_data_objects.cc
Function: Event_job_data::execute
bool Event_job_data::execute(THD *thd, bool drop) {
  String sp_sql;
  Security_context event_sctx, *save_sctx = nullptr;
  mem_root_deque<Item *> empty_item_list(thd->mem_root);
  bool ret = true;
  sql_digest_state *parent_digest = thd->m_digest;
  PSI_statement_locker *parent_locker = thd->m_statement_psi;

  DBUG_TRACE;

  mysql_reset_thd_for_next_command(thd);

  /*
    MySQL parser currently assumes that current database is either
    present in THD or all names in all statements are fully specified.
    And yet not fully specified names inside stored programs must be
    be supported, even if the current database is not set:
    CREATE PROCEDURE db1.p1() BEGIN CREATE TABLE t1; END//
    -- in this example t1 should be always created in db1 and the statement
    must parse even if there is no current database.

    To support this feature and still address the parser limitation,
    we need to set the current database here.
    We don't have to call mysql_change_db, since the checks performed
    in it are unnecessary for the purpose of parsing, and
    mysql_change_db will be invoked anyway later, to activate the
    procedure database before it's executed.
  */
  thd->set_db(m_schema_name);

  lex_start(thd);

  if (event_sctx.change_security_context(thd, m_definer_user, m_definer_host,
                                         m_schema_name.str, &save_sctx)) {
    LogErr(ERROR_LEVEL, ER_EVENT_EXECUTION_FAILED_CANT_AUTHENTICATE_USER,
           m_definer.str, m_schema_name.str, m_event_name.str);
    goto end;
  }

  /*
    In case the definer user has SYSTEM_USER privilege then make THD
    non-killable through the users who do not have SYSTEM_USER privilege,
    OR vice-versa.
    Recalculate the connection_admin flag state as well (CONNECTION_ADMIN
    privilege).
    Note - Do not forget to reset the flags after the saved security
    context is restored.
  */
  if (save_sctx) {
    set_system_user_flag(thd);
    set_connection_admin_flag(thd);
  }

  if (check_access(thd, EVENT_ACL, m_schema_name.str, nullptr, nullptr, false,
                   false)) {
    /*
      This aspect of behavior is defined in the worklog,
      and this is how triggers work too: if TRIGGER
      privilege is revoked from trigger definer,
      triggers are not executed.
    */
    LogErr(ERROR_LEVEL, ER_EVENT_EXECUTION_FAILED_USER_LOST_EVEN_PRIVILEGE,
           m_definer.str, m_schema_name.str, m_event_name.str);
    goto end;
  }

  /*
    Set up global thread attributes to reflect the properties of
    this Event. We can simply reset these instead of usual
    backup/restore employed in stored programs since we know that
    this is a top level statement and the worker thread is
    allocated exclusively to execute this event.
  */

  thd->variables.sql_mode = m_sql_mode;
  thd->variables.time_zone = m_time_zone;

  if (construct_sp_sql(thd, &sp_sql)) goto end;

  /*
    If enabled, log the quoted form to performance_schema.error_log.
    We enclose it in faux guillemets to differentiate the enclosing
    quotation seen in the log from the SQL-level quotation from
    construct_sp_sql()'s (which calls append_identifier() in sql_show,
    and thus ultimately get_quote_char_for_identifier() which evaluates
    thd->variables.sql_mode & MODE_ANSI_QUOTES).

    We're logging with a priority of SYSTEM_LEVEL so we won't have to
    worry abot log_error_verbosity. (ERROR_LEVEL would also achieve
    that, but then mysql-test-run.pl would rightfully complain about
    the error in the log.)
  */
  DBUG_EXECUTE_IF("log_event_query_string", {
    LEX_STRING sm1;
    LEX_STRING sm2;
    sql_mode_string_representation(thd, thd->variables.sql_mode, &sm1);
    sql_mode_string_representation(thd, m_sql_mode, &sm2);
    LogEvent()
        .errcode(ER_CONDITIONAL_DEBUG)
        .prio(SYSTEM_LEVEL)
        .message("Query string to be compiled: \"%s\"/\"%s\" >>%s<<\n", sm1.str,
                 sm2.str, sp_sql.c_ptr_safe());
  });

  thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());

  {
    Parser_state parser_state;

    if (parser_state.init(thd, thd->query().str, thd->query().length)) goto end;

    thd->m_digest = nullptr;
    thd->m_statement_psi = nullptr;
    if (parse_sql(thd, &parser_state, m_creation_ctx)) {
      LogErr(ERROR_LEVEL, ER_EVENT_ERROR_DURING_COMPILATION,
             thd->is_fatal_error() ? "fatal " : "", m_schema_name.str,
             m_event_name.str);
      thd->m_digest = parent_digest;
      thd->m_statement_psi = parent_locker;
      goto end;
    }
    thd->m_digest = parent_digest;
    thd->m_statement_psi = parent_locker;
  }

  {
    sp_head *sphead = thd->lex->sphead;

    assert(sphead);

    if (thd->enable_slow_log) sphead->m_flags |= sp_head::LOG_SLOW_STATEMENTS;
    sphead->m_flags |= sp_head::LOG_GENERAL_LOG;

    sphead->set_info(0, 0, &thd->lex->sp_chistics, m_sql_mode);
    sphead->set_creation_ctx(m_creation_ctx);
    sphead->optimize();

    sphead->m_type = enum_sp_type::EVENT;
#ifdef HAVE_PSI_SP_INTERFACE
    sphead->m_sp_share = MYSQL_GET_SP_SHARE(
        to_uint(enum_sp_type::EVENT), m_schema_name.str, m_schema_name.length,
        m_event_name.str, m_event_name.length);
#endif

    ret = sphead->execute_procedure(thd, &empty_item_list);
    /*
      There is no pre-locking and therefore there should be no
      tables open and locked left after execute_procedure.
    */
  }

end:
  if (drop && !thd->is_fatal_error()) {
    /*
      We must do it here since here we're under the right authentication
      ID of the event definer.
    */
    LogErr(INFORMATION_LEVEL, ER_EVENT_DROPPING, m_schema_name.str,
           m_event_name.str);
    /*
      Construct a query for the binary log, to ensure the event is dropped
      on the slave
    */
    if (construct_drop_event_sql(thd, &sp_sql, m_schema_name, m_event_name))
      ret = true;
    else {
      ulong saved_master_access;

      thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());
      /*
        Drop should be executed as a separate transaction.
        Commit any open transaction before executing the drop event.
      */
      ret = trans_commit_stmt(thd) || trans_commit(thd);

      // Prevent InnoDB from automatically committing the InnoDB transaction
      // after updating the data-dictionary table.
      Disable_autocommit_guard autocommit_guard(thd);

      /*
        NOTE: even if we run in read-only mode, we should be able to lock
        the mysql.event table for writing. In order to achieve this, we
        should call mysql_lock_tables() under the super-user.

        Same goes for transaction access mode.
        Temporarily reset it to read-write.
      */

      saved_master_access = thd->security_context()->master_access();
      thd->security_context()->set_master_access(saved_master_access |
                                                 SUPER_ACL);
      bool save_tx_read_only = thd->tx_read_only;
      thd->tx_read_only = false;

      ret = Events::drop_event(thd, m_schema_name, m_event_name, false);

      thd->tx_read_only = save_tx_read_only;
      thd->security_context()->set_master_access(saved_master_access);
    }
  }

  if (save_sctx) {
    event_sctx.restore_security_context(thd, save_sctx);
    /* Restore the original values in THD */
    set_system_user_flag(thd);
    set_connection_admin_flag(thd);
  }

  thd->lex->cleanup(true);
  thd->end_statement();
  thd->cleanup_after_query();
  /* Avoid races with SHOW PROCESSLIST */
  thd->reset_query();

  DBUG_PRINT("info", ("EXECUTED %s.%s  ret: %d", m_schema_name.str,
                      m_event_name.str, ret));

  return ret;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_authentication.cc
Function: server_mpvio_update_thd
static void server_mpvio_update_thd(THD *thd, MPVIO_EXT *mpvio) {
  thd->max_client_packet_length = mpvio->max_client_packet_length;
  if (mpvio->protocol->has_client_capability(CLIENT_INTERACTIVE))
    thd->variables.net_wait_timeout = thd->variables.net_interactive_timeout;
  thd->security_context()->assign_user(
      mpvio->auth_info.user_name,
      (mpvio->auth_info.user_name ? strlen(mpvio->auth_info.user_name) : 0));
  if (mpvio->acl_user) {
    thd->security_context()->lock_account(mpvio->acl_user->account_locked);
  }
  if (mpvio->auth_info.user_name) my_free(mpvio->auth_info.user_name);
  LEX_CSTRING sctx_user = thd->security_context()->user();
  mpvio->auth_info.user_name = const_cast<char *>(sctx_user.str);
  mpvio->auth_info.user_name_length = sctx_user.length;
  if (thd->get_protocol()->has_client_capability(CLIENT_IGNORE_SPACE))
    thd->variables.sql_mode |= MODE_IGNORE_SPACE;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_auth_cache.cc
Function: acl_load
static bool acl_load(THD *thd, Table_ref *tables) {
  TABLE *table;
  unique_ptr_destroy_only<RowIterator> iterator;
  bool return_val = true;
  bool check_no_resolve = specialflag & SPECIAL_NO_RESOLVE;
  char tmp_name[NAME_LEN + 1];
  sql_mode_t old_sql_mode = thd->variables.sql_mode;
  DBUG_TRACE;

  DBUG_EXECUTE_IF(
      "wl_9262_set_max_length_hostname",
      thd->security_context()->assign_priv_host("oh_my_gosh_this_is_a_long_"
                                                "hostname_look_at_it_it_has_60"
                                                "_char",
                                                60);
      thd->security_context()->assign_host("oh_my_gosh_this_is_a_long_"
                                           "hostname_look_at_it_it_has_60"
                                           "_char",
                                           60);
      thd->security_context()->set_host_or_ip_ptr(););

  thd->variables.sql_mode &= ~MODE_PAD_CHAR_TO_FULL_LENGTH;

  grant_version++; /* Privileges updated */

  clear_and_init_db_cache();  // Clear locked hostname cache
  init_acl_memory();          // Allocate the memory blocks in the MEM_ROOT

  if (read_user_table(thd, tables[0].table)) goto end;

  /*
    Prepare reading from the mysql.db table
  */
  iterator = init_table_iterator(thd, table = tables[1].table,
                                 /*ignore_not_found_rows=*/false,
                                 /*count_examined_rows=*/false);
  if (iterator == nullptr) goto end;
  table->use_all_columns();
  acl_dbs->clear();
  int read_rec_errcode;
  while (!(read_rec_errcode = iterator->Read())) {
    /* Reading record in mysql.db */
    ACL_DB db;
    db.host.update_hostname(
        get_field(&global_acl_memory, table->field[MYSQL_DB_FIELD_HOST]));
    db.db = get_field(&global_acl_memory, table->field[MYSQL_DB_FIELD_DB]);
    if (!db.db) {
      LogErr(WARNING_LEVEL, ER_AUTHCACHE_DB_IGNORED_EMPTY_NAME);
      continue;
    }
    db.user = get_field(&global_acl_memory, table->field[MYSQL_DB_FIELD_USER]);
    if (check_no_resolve && hostname_requires_resolving(db.host.get_host()) &&
        strcmp(db.host.get_host(), "localhost") != 0) {
      LogErr(WARNING_LEVEL, ER_AUTHCACHE_DB_SKIPPED_NEEDS_RESOLVE, db.db,
             db.user ? db.user : "",
             db.host.get_host() ? db.host.get_host() : "");
    }
    db.access = get_access(table, 3, nullptr);
    db.access = fix_rights_for_db(db.access);
    if (lower_case_table_names) {
      /*
        convert db to lower case and give a warning if the db wasn't
        already in lower case
      */
      (void)my_stpcpy(tmp_name, db.db);
      my_casedn_str(files_charset_info, db.db);
      if (strcmp(db.db, tmp_name) != 0) {
        LogErr(WARNING_LEVEL, ER_AUTHCACHE_DB_ENTRY_LOWERCASED_REVOKE_WILL_FAIL,
               db.db, db.user ? db.user : "",
               db.host.get_host() ? db.host.get_host() : "");
      }
    }
    db.sort = get_sort(3, db.host.get_host(), db.db, db.user);
    if (table->s->fields <= 9) {  // Without grant
      if (db.access & CREATE_ACL)
        db.access |= REFERENCES_ACL | INDEX_ACL | ALTER_ACL;
    }
    acl_dbs->push_back(db);
  }  // END reading records from mysql.db tables

  iterator.reset();
  if (read_rec_errcode > 0) goto end;

  std::sort(acl_dbs->begin(), acl_dbs->end(), ACL_compare());
  acl_dbs->shrink_to_fit();

  /* Prepare to read records from the mysql.proxies_priv table */
  acl_proxy_users->clear();

  if (tables[2].table) {
    iterator = init_table_iterator(thd, table = tables[2].table,
                                   /*ignore_not_found_rows=*/false,
                                   /*count_examined_rows=*/false);
    if (iterator == nullptr) goto end;
    table->use_all_columns();
    while (!(read_rec_errcode = iterator->Read())) {
      /* Reading record in mysql.proxies_priv */
      ACL_PROXY_USER proxy;
      proxy.init(table, &global_acl_memory);
      if (proxy.check_validity(check_no_resolve)) continue;
      if (acl_proxy_users->push_back(proxy)) {
        goto end;
      }
    }  // END reading records from the mysql.proxies_priv table

    iterator.reset();
    if (read_rec_errcode > 0) goto end;

    std::sort(acl_proxy_users->begin(), acl_proxy_users->end(), ACL_compare());
  } else {
    LogErr(WARNING_LEVEL, ER_AUTHCACHE_TABLE_PROXIES_PRIV_MISSING);
  }
  acl_proxy_users->shrink_to_fit();
  validate_user_plugin_records();
  init_check_host();

  /* Load dynamic privileges */
  if (tables[3].table) {
    if (populate_dynamic_privilege_caches(thd, &tables[3])) {
      return_val = true;
      goto end;
    }
  } else {
    LogErr(WARNING_LEVEL, ER_MISSING_GRANT_SYSTEM_TABLE);
  }

  initialized = true;
  return_val = false;

end:
  thd->variables.sql_mode = old_sql_mode;
  DBUG_EXECUTE_IF("induce_acl_load_failure", return_val = true;);
  return return_val;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_auth_cache.cc
Function: grant_load
static bool grant_load(THD *thd, Table_ref *tables) {
  bool return_val = true;
  int error;
  TABLE *t_table = nullptr, *c_table = nullptr;
  bool check_no_resolve = specialflag & SPECIAL_NO_RESOLVE;
  sql_mode_t old_sql_mode = thd->variables.sql_mode;
  DBUG_TRACE;

  thd->variables.sql_mode &= ~MODE_PAD_CHAR_TO_FULL_LENGTH;

  column_priv_hash.reset(
      new malloc_unordered_multimap<string,
                                    unique_ptr_destroy_only<GRANT_TABLE>>(
          key_memory_acl_memex));

  t_table = tables[0].table;
  c_table = tables[1].table;
  error = t_table->file->ha_index_init(0, true);
  DBUG_EXECUTE_IF("wl7158_grant_load_1", t_table->file->ha_index_end();
                  error = HA_ERR_LOCK_DEADLOCK;);
  if (error) {
    acl_print_ha_error(error);
    goto end_index_init;
  }
  t_table->use_all_columns();
  c_table->use_all_columns();

  error = t_table->file->ha_index_first(t_table->record[0]);
  assert(t_table->file->ht->db_type == DB_TYPE_NDBCLUSTER ||
         error != HA_ERR_LOCK_DEADLOCK);
  assert(t_table->file->ht->db_type == DB_TYPE_NDBCLUSTER ||
         error != HA_ERR_LOCK_WAIT_TIMEOUT);
  DBUG_EXECUTE_IF("wl7158_grant_load_2", error = HA_ERR_LOCK_DEADLOCK;);
  if (error) {
    if (error == HA_ERR_END_OF_FILE)
      return_val = false;  // Return Ok.
    else
      acl_print_ha_error(error);
  } else {
    Swap_mem_root_guard guard(thd, &memex);
    do {
      GRANT_TABLE *mem_check = new (thd->mem_root) GRANT_TABLE(t_table);

      if (!mem_check) {
        /* This could only happen if we are out memory */
        goto end_unlock;
      }

      if (mem_check->init(c_table)) {
        destroy(mem_check);
        goto end_unlock;
      }

      if (check_no_resolve) {
        if (hostname_requires_resolving(mem_check->host.get_host()) &&
            strcmp(mem_check->host.get_host(), "localhost") != 0) {
          LogErr(WARNING_LEVEL, ER_AUTHCACHE_TABLES_PRIV_SKIPPED_NEEDS_RESOLVE,
                 mem_check->tname, mem_check->user ? mem_check->user : "",
                 mem_check->host.get_host() ? mem_check->host.get_host() : "");
        }
      }

      if (!mem_check->ok()) {
        destroy(mem_check);
      } else {
        column_priv_hash->emplace(
            mem_check->hash_key,
            unique_ptr_destroy_only<GRANT_TABLE>(mem_check));
      }
      error = t_table->file->ha_index_next(t_table->record[0]);
      assert(t_table->file->ht->db_type == DB_TYPE_NDBCLUSTER ||
             error != HA_ERR_LOCK_DEADLOCK);
      assert(t_table->file->ht->db_type == DB_TYPE_NDBCLUSTER ||
             error != HA_ERR_LOCK_WAIT_TIMEOUT);
      DBUG_EXECUTE_IF("wl7158_grant_load_3", error = HA_ERR_LOCK_DEADLOCK;);
      if (error) {
        if (error != HA_ERR_END_OF_FILE)
          acl_print_ha_error(error);
        else
          return_val = false;
        goto end_unlock;
      }

    } while (true);
  }

end_unlock:
  t_table->file->ha_index_end();
end_index_init:
  thd->variables.sql_mode = old_sql_mode;
  return return_val;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_auth_cache.cc
Function: reload_roles_cache
static bool reload_roles_cache(THD *thd, Table_ref *tablelst) {
  DBUG_TRACE;
  assert(tablelst);
  sql_mode_t old_sql_mode = thd->variables.sql_mode;
  thd->variables.sql_mode &= ~MODE_PAD_CHAR_TO_FULL_LENGTH;

  /*
    Attempt to reload the role cache only if the role_edges and
    default_roles tables exist.
  */
  if ((tablelst[0].table) && (tablelst[1].table) &&
      populate_roles_caches(thd, tablelst)) {
    thd->variables.sql_mode = old_sql_mode;
    return true;
  }

  thd->variables.sql_mode = old_sql_mode;
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_show_create_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_show_create_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_show_create_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_show_create_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: change_password not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: change_password not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: change_password not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: change_password not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: change_password not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: change_password not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_drop_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_drop_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_drop_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: change_password not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: change_password not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_drop_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_drop_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_drop_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_drop_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user.cc
Function: mysql_drop_user not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/bootstrap.cc
Function: bootstrap::run_bootstrap_thread not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/bootstrap.cc
Function: bootstrap::run_bootstrap_thread not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: View_metadata_updater_context::View_metadata_updater_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: View_metadata_updater_context::View_metadata_updater_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: View_metadata_updater_context::View_metadata_updater_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: View_metadata_updater_context:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: View_metadata_updater_context:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: View_metadata_updater_context:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: View_metadata_updater_context:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: View_metadata_updater_context::View_metadata_updater_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: View_metadata_updater_context::View_metadata_updater_context not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/handler.cc
Function: handler::update_auto_increment
int handler::update_auto_increment() {
  ulonglong nr, nb_reserved_values = 0;
  bool append = false;
  THD *thd = table->in_use;
  struct System_variables *variables = &thd->variables;
  assert(table_share->tmp_table != NO_TMP_TABLE || m_lock_type != F_UNLCK);
  DBUG_TRACE;

  /*
    next_insert_id is a "cursor" into the reserved interval, it may go greater
    than the interval, but not smaller.
  */
  assert(next_insert_id >= auto_inc_interval_for_cur_row.minimum());

  if ((nr = table->next_number_field->val_int()) != 0 ||
      (table->autoinc_field_has_explicit_non_null_value &&
       thd->variables.sql_mode & MODE_NO_AUTO_VALUE_ON_ZERO)) {
    /*
      First test if the query was aborted due to strict mode constraints.
    */
    if (thd->is_error() &&
        thd->get_stmt_da()->mysql_errno() == ER_TRUNCATED_WRONG_VALUE)
      return HA_ERR_AUTOINC_ERANGE;

    /*
      Update next_insert_id if we had already generated a value in this
      statement (case of INSERT VALUES(null),(3763),(null):
      the last NULL needs to insert 3764, not the value of the first NULL plus
      1).
      Also we should take into account the the sign of the value.
      Since auto_increment value can't have negative value we should update
      next_insert_id only in case when we INSERTing explicit positive value.
      It means that for a table that has SIGNED INTEGER column when we execute
      the following statement
      INSERT INTO t1 VALUES( NULL), (-1), (NULL)
      we shouldn't call adjust_next_insert_id_after_explicit_value()
      and the result row will be (1, -1, 2) (for new opened connection
      to the server). On the other hand, for the statement
      INSERT INTO t1 VALUES( NULL), (333), (NULL)
      we should call adjust_next_insert_id_after_explicit_value()
      and result row will be (1, 333, 334).
    */
    if (table->next_number_field->is_unsigned() || ((longlong)nr) > 0)
      adjust_next_insert_id_after_explicit_value(nr);

    insert_id_for_cur_row = 0;  // didn't generate anything
    return 0;
  }

  if (next_insert_id > table->next_number_field->get_max_int_value())
    return HA_ERR_AUTOINC_READ_FAILED;

  if ((nr = next_insert_id) >= auto_inc_interval_for_cur_row.maximum()) {
    /* next_insert_id is beyond what is reserved, so we reserve more. */
    const Discrete_interval *forced = thd->auto_inc_intervals_forced.get_next();
    if (forced != nullptr) {
      nr = forced->minimum();
      /*
        In a multi insert statement when the number of affected rows is known
        then reserve those many number of auto increment values. So that
        interval will be starting value to starting value + number of affected
        rows * increment of auto increment.
       */
      nb_reserved_values = (estimation_rows_to_insert > 0)
                               ? estimation_rows_to_insert
                               : forced->values();
    } else {
      /*
        handler::estimation_rows_to_insert was set by
        handler::ha_start_bulk_insert(); if 0 it means "unknown".
      */
      ulonglong nb_desired_values;
      /*
        If an estimation was given to the engine:
        - use it.
        - if we already reserved numbers, it means the estimation was
        not accurate, then we'll reserve 2*AUTO_INC_DEFAULT_NB_ROWS the 2nd
        time, twice that the 3rd time etc.
        If no estimation was given, use those increasing defaults from the
        start, starting from AUTO_INC_DEFAULT_NB_ROWS.
        Don't go beyond a max to not reserve "way too much" (because
        reservation means potentially losing unused values).
        Note that in prelocked mode no estimation is given.
      */

      if ((auto_inc_intervals_count == 0) && (estimation_rows_to_insert > 0))
        nb_desired_values = estimation_rows_to_insert;
      else if ((auto_inc_intervals_count == 0) &&
               (thd->lex->bulk_insert_row_cnt > 0)) {
        /*
          For multi-row inserts, if the bulk inserts cannot be started, the
          handler::estimation_rows_to_insert will not be set. But we still
          want to reserve the autoinc values.
        */
        nb_desired_values = thd->lex->bulk_insert_row_cnt;
      } else /* go with the increasing defaults */
      {
        /* avoid overflow in formula, with this if() */
        if (auto_inc_intervals_count <= AUTO_INC_DEFAULT_NB_MAX_BITS) {
          nb_desired_values =
              AUTO_INC_DEFAULT_NB_ROWS * (1 << auto_inc_intervals_count);
          nb_desired_values =
              std::min(nb_desired_values, ulonglong(AUTO_INC_DEFAULT_NB_MAX));
        } else
          nb_desired_values = AUTO_INC_DEFAULT_NB_MAX;
      }
      /* This call ignores all its parameters but nr, currently */
      get_auto_increment(variables->auto_increment_offset,
                         variables->auto_increment_increment, nb_desired_values,
                         &nr, &nb_reserved_values);
      if (nr == ULLONG_MAX) return HA_ERR_AUTOINC_READ_FAILED;  // Mark failure

      /*
        That rounding below should not be needed when all engines actually
        respect offset and increment in get_auto_increment(). But they don't
        so we still do it. Wonder if for the not-first-in-index we should do
        it. Hope that this rounding didn't push us out of the interval; even
        if it did we cannot do anything about it (calling the engine again
        will not help as we inserted no row).
      */
      nr = compute_next_insert_id(nr - 1, variables);
    }

    if (table->s->next_number_keypart == 0) {
      /* We must defer the appending until "nr" has been possibly truncated */
      append = true;
    } else {
      /*
        For such auto_increment there is no notion of interval, just a
        singleton. The interval is not even stored in
        thd->auto_inc_interval_for_cur_row, so we are sure to call the engine
        for next row.
      */
      DBUG_PRINT("info", ("auto_increment: special not-first-in-index"));
    }
  }

  if (unlikely(nr == ULLONG_MAX)) return HA_ERR_AUTOINC_ERANGE;

  DBUG_PRINT("info", ("auto_increment: %lu", (ulong)nr));

  if (unlikely(table->next_number_field->store((longlong)nr, true))) {
    /*
      first test if the query was aborted due to strict mode constraints
    */
    if (thd->is_error() &&
        thd->get_stmt_da()->mysql_errno() == ER_WARN_DATA_OUT_OF_RANGE)
      return HA_ERR_AUTOINC_ERANGE;

    /*
      field refused this value (overflow) and truncated it, use the result of
      the truncation (which is going to be inserted); however we try to
      decrease it to honour auto_increment_* variables.
      That will shift the left bound of the reserved interval, we don't
      bother shifting the right bound (anyway any other value from this
      interval will cause a duplicate key).
    */
    nr = prev_insert_id(table->next_number_field->val_int(), variables);
    if (unlikely(table->next_number_field->store((longlong)nr, true)))
      nr = table->next_number_field->val_int();
  }
  if (append) {
    auto_inc_interval_for_cur_row.replace(nr, nb_reserved_values,
                                          variables->auto_increment_increment);
    auto_inc_intervals_count++;
    /* Row-based replication does not need to store intervals in binlog */
    if (mysql_bin_log.is_open() && !thd->is_current_stmt_binlog_format_row())
      thd->auto_inc_intervals_in_cur_stmt_for_binlog.append(
          auto_inc_interval_for_cur_row.minimum(),
          auto_inc_interval_for_cur_row.values(),
          variables->auto_increment_increment);
  }

  /*
    Record this autogenerated value. If the caller then
    succeeds to insert this value, it will call
    record_first_successful_insert_id_in_cur_stmt()
    which will set first_successful_insert_id_in_cur_stmt if it's not
    already set.
  */
  insert_id_for_cur_row = nr;
  /*
    Set next insert id to point to next auto-increment value to be able to
    handle multi-row statements.
  */
  set_next_insert_id(compute_next_insert_id(nr, variables));

  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::val_date_temporal
longlong Item::val_date_temporal() {
  MYSQL_TIME ltime;
  const sql_mode_t mode = current_thd->variables.sql_mode;
  const my_time_flags_t flags =
      TIME_FUZZY_DATE | (mode & MODE_INVALID_DATES ? TIME_INVALID_DATES : 0) |
      (mode & MODE_NO_ZERO_IN_DATE ? TIME_NO_ZERO_IN_DATE : 0) |
      (mode & MODE_NO_ZERO_DATE ? TIME_NO_ZERO_DATE : 0);
  if (get_date(&ltime, flags)) return error_int();
  return TIME_to_longlong_datetime_packed(ltime);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::save_date_in_field
type_conversion_status Item::save_date_in_field(Field *field) {
  MYSQL_TIME ltime;
  my_time_flags_t flags = TIME_FUZZY_DATE;
  const sql_mode_t mode = current_thd->variables.sql_mode;
  if (mode & MODE_INVALID_DATES) flags |= TIME_INVALID_DATES;
  if (get_date(&ltime, flags))
    return set_field_to_null_with_conversions(field, false);
  field->set_notnull();
  return field->store_time(&ltime, decimals);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::save_in_field_no_warnings not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::save_in_field_no_warnings not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::save_in_field_no_warnings not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::save_in_field_no_warnings not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::save_in_field_no_warnings not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::save_in_field_no_warnings not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::save_in_field_no_warnings not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::save_in_field_no_warnings not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item.cc
Function: Item::save_in_field_no_warnings not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: convert_constant_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: convert_constant_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: convert_constant_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: convert_constant_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: convert_constant_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: convert_constant_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: convert_constant_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: convert_constant_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: convert_constant_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: convert_constant_item not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: Item_func_like::eval_escape_clause
bool Item_func_like::eval_escape_clause(THD *thd) {
  assert(!escape_evaluated);
  escape_evaluated = true;

  const bool no_backslash_escapes =
      thd->variables.sql_mode & MODE_NO_BACKSLASH_ESCAPES;

  // No ESCAPE clause is specified. The default escape character is backslash,
  // unless NO_BACKSLASH_ESCAPES mode is enabled.
  if (!escape_was_used_in_parsing()) {
    m_escape = no_backslash_escapes ? 0 : '\\';
    return false;
  }

  Item *escape_item = args[2];
  String buf;
  const String *escape_str = escape_item->val_str(&buf);
  if (thd->is_error()) return true;

  // Use backslash as escape character if the escape clause evaluates to NULL.
  // (For backward compatibility. The SQL standard says the LIKE expression
  // should evaluate to NULL in this case.)
  if (escape_item->null_value) {
    m_escape = '\\';
    return false;
  }

  // An empty escape sequence means there is no escape character. An empty
  // escape sequence is not accepted in NO_BACKSLASH_ESCAPES mode.
  if (escape_str->is_empty()) {
    if (no_backslash_escapes) {
      my_error(ER_WRONG_ARGUMENTS, MYF(0), "ESCAPE");
      return true;
    }
    m_escape = 0;
    return false;
  }

  // Accept at most one character.
  if (escape_str->numchars() > 1) {
    my_error(ER_WRONG_ARGUMENTS, MYF(0), "ESCAPE");
    return true;
  }

  const char *escape_str_ptr = escape_str->ptr();

  // For multi-byte character sets, we store the Unicode code point of the
  // escape character.
  if (use_mb(cmp.cmp_collation.collation)) {
    const CHARSET_INFO *cs = escape_str->charset();
    my_wc_t wc;
    int rc = cs->cset->mb_wc(
        cs, &wc, pointer_cast<const uchar *>(escape_str_ptr),
        pointer_cast<const uchar *>(escape_str_ptr) + escape_str->length());
    if (rc <= 0) {
      my_error(ER_WRONG_ARGUMENTS, MYF(0), "ESCAPE");
      return true;
    }
    m_escape = wc;
    return false;
  }

  // For single-byte character sets, we store the native code instead of the
  // Unicode code point. The escape character is converted to the character set
  // of the comparator if they differ.
  const CHARSET_INFO *cs = cmp.cmp_collation.collation;
  size_t unused;
  if (escape_str->needs_conversion(escape_str->length(), escape_str->charset(),
                                   cs, &unused)) {
    char ch;
    uint errors;
    size_t cnvlen =
        copy_and_convert(&ch, 1, cs, escape_str_ptr, escape_str->length(),
                         escape_str->charset(), &errors);
    if (cnvlen == 0) {
      my_error(ER_WRONG_ARGUMENTS, MYF(0), "ESCAPE");
      return true;
    }
    m_escape = static_cast<uchar>(ch);
  } else {
    m_escape = static_cast<uchar>(escape_str_ptr[0]);
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str_no_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str_no_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str_no_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str_no_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str_no_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str_no_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str_no_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: get_mysql_time_from_str_no_warn not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: extract_value_for_hash_join not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: extract_value_for_hash_join not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: extract_value_for_hash_join not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_cmpfunc.cc
Function: extract_value_for_hash_join not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_create.cc
Function: create_temporal_literal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_json_func.cc
Function: Item_func_json_value::create_json_value_default
Item_func_json_value::create_json_value_default(THD *thd, Item *item) {
  MEM_ROOT *const mem_root = thd->mem_root;

  auto default_value = make_unique_destroy_only<Default_value>(mem_root);
  if (default_value == nullptr) return nullptr;

  // Evaluate the defaults under strict mode, so that an error is raised if the
  // default value cannot be converted to the target type without warnings.
  Strict_error_handler strict_handler{
      Strict_error_handler::ENABLE_SET_SELECT_STRICT_ERROR_HANDLER};
  auto strict_handler_guard =
      create_scope_guard([thd, saved_sql_mode = thd->variables.sql_mode]() {
        thd->pop_internal_handler();
        thd->variables.sql_mode = saved_sql_mode;
      });
  thd->push_internal_handler(&strict_handler);
  thd->variables.sql_mode |=
      MODE_STRICT_ALL_TABLES | MODE_NO_ZERO_DATE | MODE_NO_ZERO_IN_DATE;
  thd->variables.sql_mode &= ~MODE_INVALID_DATES;

  // Check that the default value is within the range of the return type.
  switch (m_cast_target) {
    case ITEM_CAST_SIGNED_INT:
    case ITEM_CAST_UNSIGNED_INT: {
      StringBuffer<STRING_BUFFER_USUAL_SIZE> string_buffer;
      const String *string_value = item->val_str(&string_buffer);
      if (thd->is_error()) return nullptr;
      assert(string_value != nullptr);
      const CHARSET_INFO *const cs = string_value->charset();
      const char *const start = string_value->ptr();
      const char *const end_of_string = start + string_value->length();
      const char *end_of_number = end_of_string;
      int error = 0;
      const int64_t value =
          cs->cset->strtoll10(cs, start, &end_of_number, &error);
      if (end_of_number != end_of_string) {
        ErrConvString err(string_value);
        my_error(ER_TRUNCATED_WRONG_VALUE, MYF(0),
                 unsigned_flag ? "INTEGER UNSIGNED" : "INTEGER SIGNED",
                 err.ptr());
        return nullptr;
      }
      if (error > 0 ||
          (!unsigned_flag && error == 0 &&
           static_cast<uint64_t>(value) > INT64_MAX) ||
          (unsigned_flag && error == -1)) {
        my_error(ER_DATA_OUT_OF_RANGE, MYF(0),
                 unsigned_flag ? "UNSIGNED DEFAULT" : "SIGNED DEFAULT",
                 func_name());
        return nullptr;
      }
      default_value->integer_default = value;
      break;
    }
    case ITEM_CAST_DATE: {
      MYSQL_TIME *ltime = new (mem_root) MYSQL_TIME;
      if (ltime == nullptr) return nullptr;
      if (item->get_date(ltime, 0)) return nullptr;
      assert(!thd->is_error());
      default_value->temporal_default = ltime;
      break;
    }
    case ITEM_CAST_YEAR: {
      StringBuffer<STRING_BUFFER_USUAL_SIZE> string_buffer;
      const String *string_value = item->val_str(&string_buffer);
      if (thd->is_error()) return nullptr;
      assert(string_value != nullptr);
      const CHARSET_INFO *const cs = string_value->charset();
      const char *const start = string_value->ptr();
      const char *const end_of_string = start + string_value->length();
      const char *end_of_number = end_of_string;
      int error = 0;
      const int64_t value =
          cs->cset->strtoll10(cs, start, &end_of_number, &error);
      if (end_of_number != end_of_string) {
        ErrConvString err(string_value);
        my_error(ER_TRUNCATED_WRONG_VALUE, MYF(0), "YEAR", err.ptr());
        return nullptr;
      }
      if (error != 0 || (value > 2155) || (value < 1901 && value != 0)) {
        my_error(ER_DATA_OUT_OF_RANGE, MYF(0), "YEAR", func_name());
        return nullptr;
      }
      default_value->integer_default = value;
      break;
    }
    case ITEM_CAST_TIME: {
      MYSQL_TIME *ltime = new (mem_root) MYSQL_TIME;
      if (ltime == nullptr) return nullptr;
      if (item->get_time(ltime)) return nullptr;
      assert(!thd->is_error());
      if (actual_decimals(ltime) > decimals) {
        my_error(ER_DATA_OUT_OF_RANGE, MYF(0), "TIME DEFAULT", func_name());
        return nullptr;
      }
      default_value->temporal_default = ltime;
      break;
    }
    case ITEM_CAST_DATETIME: {
      MYSQL_TIME *ltime = new (mem_root) MYSQL_TIME;
      if (ltime == nullptr) return nullptr;
      if (item->get_date(ltime, TIME_DATETIME_ONLY)) return nullptr;
      assert(!thd->is_error());
      if (actual_decimals(ltime) > decimals) {
        my_error(ER_DATA_OUT_OF_RANGE, MYF(0), "TIME DEFAULT", func_name());
        return nullptr;
      }
      default_value->temporal_default = ltime;
      break;
    }
    case ITEM_CAST_CHAR: {
      StringBuffer<STRING_BUFFER_USUAL_SIZE> string_buffer;
      const String *string_value = item->val_str(&string_buffer);
      if (thd->is_error()) return nullptr;
      assert(string_value != nullptr);
      if (string_value->numchars() > max_char_length()) {
        my_error(ER_DATA_OUT_OF_RANGE, MYF(0), "CHAR DEFAULT", func_name());
        return nullptr;
      }
      if (my_charset_same(collation.collation, string_value->charset())) {
        default_value->string_default = {string_value->dup(mem_root),
                                         string_value->length()};
        if (default_value->string_default.str == nullptr) return nullptr;
      } else {
        String converted_string;
        unsigned errors;
        if (converted_string.copy(string_value->ptr(), string_value->length(),
                                  string_value->charset(), collation.collation,
                                  &errors))
          return nullptr; /* purecov: inspected */
        if (errors > 0) {
          my_error(ER_DATA_OUT_OF_RANGE, MYF(0), "CHAR DEFAULT", func_name());
          return nullptr;
        }
        default_value->string_default = {converted_string.dup(mem_root),
                                         converted_string.length()};
        if (default_value->string_default.str == nullptr) return nullptr;
      }
      break;
    }
    case ITEM_CAST_DECIMAL: {
      my_decimal *buffer = new (mem_root) my_decimal;
      if (buffer == nullptr) return nullptr;
      const my_decimal *value = item->val_decimal(buffer);
      if (thd->is_error()) return nullptr;
      if (!decimal_within_range(this, value) || value->frac > decimals) {
        my_error(ER_DATA_OUT_OF_RANGE, MYF(0), "DECIMAL DEFAULT", func_name());
        return nullptr;
      }
      default_value->decimal_default = value;
      break;
    }
    case ITEM_CAST_JSON: {
      StringBuffer<STRING_BUFFER_USUAL_SIZE> string_buffer;
      const String *string_value = item->val_str(&string_buffer);
      if (thd->is_error()) return nullptr;
      assert(string_value != nullptr);
      JsonParseDefaultErrorHandler parse_handler(func_name(), 0);
      if (parse_json(*string_value, &default_value->json_default, true,
                     parse_handler, JsonDocumentDefaultDepthHandler)) {
        my_error(ER_INVALID_DEFAULT, MYF(0), func_name());
        return nullptr;
      }
      break;
    }
    case ITEM_CAST_FLOAT: {
      const double value = item->val_real();
      if (thd->is_error()) return nullptr;
      if (value > std::numeric_limits<float>::max() ||
          value < std::numeric_limits<float>::lowest()) {
        my_error(ER_DATA_OUT_OF_RANGE, MYF(0), "FLOAT DEFAULT", func_name());
        return nullptr;
      }
      // The value is within range of FLOAT. Finally, cast it to float to get
      // rid of any extra (double) precision that doesn't fit in a FLOAT.
      default_value->real_default = static_cast<float>(value);
      break;
    }
    case ITEM_CAST_DOUBLE: {
      const double value = item->val_real();
      if (thd->is_error()) return nullptr;
      default_value->real_default = value;
      break;
    }
    /* purecov: begin inspected */
    case ITEM_CAST_POINT:
      my_error(ER_INVALID_CAST_TO_GEOMETRY, MYF(0), "JSON", "POINT");
      return nullptr;
    case ITEM_CAST_LINESTRING:
      my_error(ER_INVALID_CAST_TO_GEOMETRY, MYF(0), "JSON", "LINESTRING");
      return nullptr;
    case ITEM_CAST_POLYGON:
      my_error(ER_INVALID_CAST_TO_GEOMETRY, MYF(0), "JSON", "POLYGON");
      return nullptr;
    case ITEM_CAST_MULTIPOINT:
      my_error(ER_INVALID_CAST_TO_GEOMETRY, MYF(0), "JSON", "MULTIPOINT");
      return nullptr;
    case ITEM_CAST_MULTILINESTRING:
      my_error(ER_INVALID_CAST_TO_GEOMETRY, MYF(0), "JSON", "MULTILINESTRING");
      return nullptr;
    case ITEM_CAST_MULTIPOLYGON:
      my_error(ER_INVALID_CAST_TO_GEOMETRY, MYF(0), "JSON", "MULTIPOLYGON");
      return nullptr;
    case ITEM_CAST_GEOMETRYCOLLECTION:
      my_error(ER_INVALID_CAST_TO_GEOMETRY, MYF(0), "JSON",
               "GEOMETRYCOLLECTION");
      return nullptr;
      /* purecov: end */
  }

  return default_value;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_sum.cc
Function: Item_sum::check_sum_func
bool Item_sum::check_sum_func(THD *thd, Item **ref) {
  DBUG_TRACE;

  if (m_is_window_function) {
    update_used_tables();
    thd->lex->m_deny_window_func = save_deny_window_func;
    return false;
  }

  const nesting_map allow_sum_func = thd->lex->allow_sum_func;
  const nesting_map nest_level_map = (nesting_map)1
                                     << base_query_block->nest_level;

  assert(thd->lex->current_query_block() == base_query_block);
  assert(aggr_query_block == nullptr);

  /*
    max_aggr_level is the level of the innermost qualifying query block of
    the column references of this set function. If the set function contains
    no column references, max_aggr_level is -1.
    max_aggr_level cannot be greater than nest level of the current query block.
  */
  assert(max_aggr_level <= base_query_block->nest_level);

  if (base_query_block->nest_level == max_aggr_level) {
    /*
      The function must be aggregated in the current query block,
      and it must be referred within a clause where it is valid
      (ie. HAVING clause, ORDER BY clause or SELECT list)
    */
    if ((allow_sum_func & nest_level_map) != 0)
      aggr_query_block = base_query_block;
  } else if (max_aggr_level >= 0 || !(allow_sum_func & nest_level_map)) {
    /*
      Look for an outer query block where the set function should be
      aggregated. If it finds such a query block, then aggr_query_block is set
      to this query block
    */
    for (Query_block *sl = base_query_block->outer_query_block();
         sl && sl->nest_level >= max_aggr_level; sl = sl->outer_query_block()) {
      if (allow_sum_func & ((nesting_map)1 << sl->nest_level))
        aggr_query_block = sl;
    }
  } else  // max_aggr_level < 0
  {
    /*
      Set function without column reference is aggregated in innermost query,
      without any validation.
    */
    aggr_query_block = base_query_block;
  }

  if (aggr_query_block == nullptr && (allow_sum_func & nest_level_map) != 0 &&
      !(thd->variables.sql_mode & MODE_ANSI))
    aggr_query_block = base_query_block;

  /*
    At this place a query block where the set function is to be aggregated
    has been found and is assigned to aggr_query_block, or aggr_query_block is
    NULL to indicate an invalid set function.

    Additionally, check whether possible nested set functions are acceptable
    here: their aggregation level must be greater than this set function's
    aggregation level.
  */
  if (aggr_query_block == nullptr ||
      aggr_query_block->nest_level <= max_sum_func_level) {
    my_error(ER_INVALID_GROUP_FUNC_USE, MYF(0));
    return true;
  }

  for (uint i = 0; i < arg_count; i++) {
    if (args[i]->has_aggregation() &&
        WalkItem(args[i], enum_walk::SUBQUERY_POSTFIX, [this](Item *subitem) {
          if (subitem->type() != Item::SUM_FUNC_ITEM) return false;
          Item_sum *si = down_cast<Item_sum *>(subitem);
          return si->aggr_query_block == this->aggr_query_block;
        })) {
      my_error(ER_INVALID_GROUP_FUNC_USE, MYF(0));
      return true;
    }
  }

  if (aggr_query_block != base_query_block) {
    referenced_by[0] = ref;
    /*
      Add the set function to the list inner_sum_func_list for the
      aggregating query block.

      @note
        Now we 'register' only set functions that are aggregated in outer
        query blocks. Actually it makes sense to link all set functions for
        a query block in one chain. It would simplify the process of 'splitting'
        for set functions.
    */
    if (!aggr_query_block->inner_sum_func_list)
      next_sum = this;
    else {
      next_sum = aggr_query_block->inner_sum_func_list->next_sum;
      aggr_query_block->inner_sum_func_list->next_sum = this;
    }
    aggr_query_block->inner_sum_func_list = this;
    aggr_query_block->with_sum_func = true;

    /*
      Mark subqueries as containing set function all the way up to the
      set function's aggregation query block.
      Note that we must not mark the Item of calculation context itself
      because with_sum_func on the aggregation query block is already set above.

      has_aggregation() being set for an Item means that this Item refers
      (somewhere in it, e.g. one of its arguments if it's a function) directly
      or indirectly to a set function that is calculated in a
      context "outside" of the Item (e.g. in the current or outer query block).

      with_sum_func being set for a query block means that this query block
      has set functions directly referenced (i.e. not through a subquery).

      If, going up, we meet a derived table, we do nothing special for it:
      it doesn't need this information.
    */
    for (Query_block *sl = base_query_block; sl && sl != aggr_query_block;
         sl = sl->outer_query_block()) {
      if (sl->master_query_expression()->item)
        sl->master_query_expression()->item->set_aggregation();
    }

    base_query_block->mark_as_dependent(aggr_query_block, true);
  }

  if (in_sum_func) {
    /*
      If the set function is nested adjust the value of
      max_sum_func_level for the containing set function.
      We take into account only set functions that are to be aggregated on
      the same level or outer compared to the nest level of the containing
      set function.
      But we must always pass up the max_sum_func_level because it is
      the maximum nest level of all directly and indirectly contained
      set functions. We must do that even for set functions that are
      aggregated inside of their containing set function's nest level
      because the containing function may contain another containing
      function that is to be aggregated outside or on the same level
      as its parent's nest level.
    */
    if (in_sum_func->base_query_block->nest_level >=
        aggr_query_block->nest_level)
      in_sum_func->max_sum_func_level = max(in_sum_func->max_sum_func_level,
                                            int8(aggr_query_block->nest_level));
    in_sum_func->max_sum_func_level =
        max(in_sum_func->max_sum_func_level, max_sum_func_level);
  }

  aggr_query_block->set_agg_func_used(true);
  if (sum_func() == JSON_AGG_FUNC)
    aggr_query_block->set_json_agg_func_used(true);
  update_used_tables();
  thd->lex->in_sum_func = in_sum_func;
  thd->lex->m_deny_window_func = save_deny_window_func;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partition_info.cc
Function: partition_info::fix_column_value_functions not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partition_info.cc
Function: partition_info::fix_column_value_functions not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partition_info.cc
Function: partition_info::fix_column_value_functions not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partition_info.cc
Function: partition_info::fix_column_value_functions not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partition_info.cc
Function: partition_info::fix_column_value_functions not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partition_info.cc
Function: partition_info::fix_column_value_functions not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partition_info.cc
Function: partition_info::fix_column_value_functions not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partition_info.cc
Function: warn_if_dir_in_part_elem
static void warn_if_dir_in_part_elem(THD *thd, partition_element *part_elem) {
  if (thd->variables.sql_mode & MODE_NO_DIR_IN_CREATE) {
    if (part_elem->data_file_name)
      push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_OPTION_IGNORED,
                          ER_THD(thd, WARN_OPTION_IGNORED), "DATA DIRECTORY");
    if (part_elem->index_file_name)
      push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_OPTION_IGNORED,
                          ER_THD(thd, WARN_OPTION_IGNORED), "INDEX DIRECTORY");
    part_elem->data_file_name = part_elem->index_file_name = nullptr;
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/query_result.cc
Function: Query_result_export::prepare not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/query_result.cc
Function: Query_result_export::prepare not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/query_result.cc
Function: Query_result_export::prepare not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/query_result.cc
Function: Query_result_export::prepare not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: save_value_and_handle_conversion not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: save_value_and_handle_conversion not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: save_value_and_handle_conversion not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: save_value_and_handle_conversion not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: save_value_and_handle_conversion not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: save_value_and_handle_conversion not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: save_value_and_handle_conversion not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: save_value_and_handle_conversion not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: save_value_and_handle_conversion not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sp.cc
Function: prepare_params_string_from_dd_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sp.cc
Function: prepare_params_string_from_dd_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sp.cc
Function: prepare_params_string_from_dd_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sp.cc
Function: prepare_params_string_from_dd_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sp.cc
Function: prepare_params_string_from_dd_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sp.cc
Function: prepare_params_string_from_dd_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sp.cc
Function: prepare_params_string_from_dd_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Query_log_event::do_apply_event
int Query_log_event::do_apply_event(Relay_log_info const *rli) {
  return do_apply_event(rli, query, q_len);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Rotate_log_event::do_update_pos
int Rotate_log_event::do_update_pos(Relay_log_info *rli) {
  int error = 0;
  DBUG_TRACE;
#ifndef NDEBUG
  char buf[32];
#endif

  DBUG_PRINT("info", ("server_id=%lu; ::server_id=%lu", (ulong)this->server_id,
                      (ulong)::server_id));
  DBUG_PRINT("info", ("new_log_ident: %s", this->new_log_ident));
  DBUG_PRINT("info", ("pos: %s", llstr(this->pos, buf)));

  DBUG_EXECUTE_IF("block_on_master_pos_4_rotate", {
    if (server_id == 1 && pos == 4) {
      std::string action =
          "now signal signal.reach_pos_4_rotate_event wait_for "
          "signal.rotate_event_continue";
      assert(
          !debug_sync_set_action(current_thd, action.c_str(), action.size()));
    }
  });

  /*
    If we are in a transaction or in a group: the only normal case is
    when the I/O thread was copying a big transaction, then it was
    stopped and restarted: we have this in the relay log:

    BEGIN
    ...
    ROTATE (a fake one)
    ...
    COMMIT or ROLLBACK

    In that case, we don't want to touch the coordinates which
    correspond to the beginning of the transaction.  Starting from
    5.0.0, there also are some rotates from the slave itself, in the
    relay log, which shall not change the group positions.
  */

  /*
    The way we check if SQL thread is currently in a group is different
    for STS and MTS.
  */
  bool in_group = rli->is_parallel_exec()
                      ? (rli->mts_group_status == Relay_log_info::MTS_IN_GROUP)
                      : rli->is_in_group();

  if ((server_id != ::server_id || rli->replicate_same_server_id) &&
      !is_relay_log_event() && !in_group) {
    if (!is_mts_db_partitioned(rli) &&
        (server_id != ::server_id || rli->replicate_same_server_id)) {
      // force the coordinator to start a new binlog segment.
      static_cast<Mts_submode_logical_clock *>(rli->current_mts_submode)
          ->start_new_group();
    }
    if (rli->is_parallel_exec()) {
      /*
        Rotate events are special events that are handled as a
        synchronization point. For that reason, the checkpoint
        routine is being called here.
      */
      if ((error = mta_checkpoint_routine(rli, false))) goto err;
    }

    mysql_mutex_lock(&rli->data_lock);
    DBUG_PRINT("info", ("old group_source_log_name: '%s'  "
                        "old group_source_log_pos: %lu",
                        rli->get_group_master_log_name(),
                        (ulong)rli->get_group_master_log_pos()));

    memcpy(const_cast<char *>(rli->get_group_master_log_name()), new_log_ident,
           ident_len + 1);
    rli->notify_group_master_log_name_update();
    /*
      Execution coordinate update by Rotate itself needs forced flush
      otherwise in crash case MTS won't be able to find the starting point
      for recovery.
      It is safe to update the last executed coordinates because all Worker
      assignments prior to Rotate has been already processed (as well as
      above call to @c mta_checkpoint_routine has harvested their
      contribution to the last executed coordinates).
    */
    if ((error = rli->inc_group_relay_log_pos(
             pos, false /* need_data_lock=false */, true /* force flush */))) {
      mysql_mutex_unlock(&rli->data_lock);
      goto err;
    }

    DBUG_PRINT("info", ("new group_source_log_name: '%s'  "
                        "new group_source_log_pos: %lu",
                        rli->get_group_master_log_name(),
                        (ulong)rli->get_group_master_log_pos()));
    mysql_mutex_unlock(&rli->data_lock);
    if (rli->is_parallel_exec()) {
      bool real_event = server_id && !is_artificial_event();
      rli->reset_notified_checkpoint(
          0, real_event ? common_header->when.tv_sec + (time_t)exec_time : 0,
          real_event);
    }

    /*
      Reset thd->variables.option_bits and sql_mode etc, because this could be
      the signal of a master's downgrade from 5.0 to 4.0. However, no need to
      reset rli_description_event: indeed, if the next master is 5.0
      (even 5.0.1) we will soon get a Format_desc; if the next master is 4.0
      then the events are in the slave's format (conversion).
    */
    set_slave_thread_options(thd);
    set_slave_thread_default_charset(thd, rli);
    thd->variables.sql_mode = global_system_variables.sql_mode;
    thd->variables.auto_increment_increment =
        thd->variables.auto_increment_offset = 1;
    /*
      Rotate_log_events are generated on Slaves with server_id=0
      for all the ignored events, so that the positions in the repository
      is updated properly even for ignored events.

      This kind of Rotate_log_event is generated when

        1) the event is generated on the same host and reached due
           to circular replication (server_id == ::server_id)

        2) the event is from the host which is listed in ignore_server_ids

        3) IO thread is receiving HEARTBEAT event from the master

        4) IO thread is receiving PREVIOUS_GTID_LOG_EVENT from the master.

      We have to free thd's mem_root here after we update the positions
      in the repository table. Otherwise, imagine a situation where
      Slave is keep getting ignored events only and no other (non-ignored)
      events from the Master, Slave never executes free_root (that generally
      happens from Query_log_event::do_apply_event or
      Rows_log_event::do_apply_event when they find end of the group event).
    */
    if (server_id == 0) thd->mem_root->ClearForReuse();
  } else
    rli->inc_event_relay_log_pos();

err:
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Rows_log_event::do_apply_event
int Rows_log_event::do_apply_event(Relay_log_info const *rli) {
  DBUG_TRACE;
  TABLE *table = nullptr;
  int error = 0;

  /*
    'thd' has been set by exec_relay_log_event(), just before calling
    do_apply_event(). We still check here to prevent future coding
    errors.
  */
  assert(rli->info_thd == thd);

  /*
    If there is no locks taken, this is the first binrow event seen
    after the table map events.  We should then lock all the tables
    used in the transaction and proceed with execution of the actual
    event.
  */
  if (!thd->lock) {
    /*
      Lock_tables() reads the contents of thd->lex, so they must be
      initialized.

      We also call the mysql_reset_thd_for_next_command(), since this
      is the logical start of the next "statement". Note that this
      call might reset the value of current_stmt_binlog_format, so
      we need to do any changes to that value after this function.
    */
    lex_start(thd);
    mysql_reset_thd_for_next_command(thd);

    enum_gtid_statement_status state = gtid_pre_statement_checks(thd);
    if (state == GTID_STATEMENT_EXECUTE) {
      if (gtid_pre_statement_post_implicit_commit_checks(thd))
        state = GTID_STATEMENT_CANCEL;
    }

    if (state == GTID_STATEMENT_CANCEL) {
      uint mysql_error = thd->get_stmt_da()->mysql_errno();
      assert(mysql_error != 0);
      rli->report(ERROR_LEVEL, mysql_error, "Error executing row event: '%s'",
                  thd->get_stmt_da()->message_text());
      thd->is_slave_error = true;
      return -1;
    } else if (state == GTID_STATEMENT_SKIP)
      goto end;

    /*
      The current statement is just about to begin and
      has not yet modified anything. Note, all.modified is reset
      by mysql_reset_thd_for_next_command.
    */
    thd->get_transaction()->reset_unsafe_rollback_flags(Transaction_ctx::STMT);
    /*
      This is a row injection, so we flag the "statement" as
      such. Note that this code is called both when the slave does row
      injections and when the BINLOG statement is used to do row
      injections.
    */
    thd->lex->set_stmt_row_injection();

    /*
      There are a few flags that are replicated with each row event.
      Make sure to set/clear them before executing the main body of
      the event.
    */
    if (get_flags(NO_FOREIGN_KEY_CHECKS_F))
      thd->variables.option_bits |= OPTION_NO_FOREIGN_KEY_CHECKS;
    else
      thd->variables.option_bits &= ~OPTION_NO_FOREIGN_KEY_CHECKS;

    if (get_flags(RELAXED_UNIQUE_CHECKS_F))
      thd->variables.option_bits |= OPTION_RELAXED_UNIQUE_CHECKS;
    else
      thd->variables.option_bits &= ~OPTION_RELAXED_UNIQUE_CHECKS;

    thd->binlog_row_event_extra_data = m_extra_row_info.get_ndb_info();

    /* A small test to verify that objects have consistent types */
    assert(sizeof(thd->variables.option_bits) ==
           sizeof(OPTION_RELAXED_UNIQUE_CHECKS));
    DBUG_EXECUTE_IF("rows_log_event_before_open_table", {
      const char action[] =
          "now SIGNAL before_open_table WAIT_FOR go_ahead_sql";
      assert(!debug_sync_set_action(thd, STRING_WITH_LEN(action)));
    };);
    if (open_and_lock_tables(thd, rli->tables_to_lock, 0)) {
      if (thd->is_error()) {
        uint actual_error = thd->get_stmt_da()->mysql_errno();
        if (ignored_error_code(actual_error)) {
          if (log_error_verbosity >= 2)
            rli->report(WARNING_LEVEL, actual_error,
                        "Error executing row event: '%s'",
                        thd->get_stmt_da()->message_text());
          thd->get_stmt_da()->reset_condition_info(thd);
          clear_all_errors(thd, const_cast<Relay_log_info *>(rli));
          error = 0;
          goto end;
        } else {
          rli->report(ERROR_LEVEL, actual_error,
                      "Error executing row event: '%s'",
                      thd->get_stmt_da()->message_text());
          thd->is_slave_error = true;
        }
      }
      return 1;
    }

    /*
      When the open and locking succeeded, we check all tables to
      ensure that they still have the correct type.
    */

    {
      DBUG_PRINT("debug",
                 ("Checking compability of tables to lock - tables_to_lock: %p",
                  rli->tables_to_lock));

      /**
        When using RBR and MyISAM MERGE tables the base tables that make
        up the MERGE table can be appended to the list of tables to lock.

        Thus, we just check compatibility for those that tables that have
        a correspondent table map event (ie, those that are actually going
        to be accessed while applying the event). That's why the loop stops
        at rli->tables_to_lock_count .

        NOTE: The base tables are added here are removed when
              close_thread_tables is called.
       */
      Table_ref *table_list_ptr = rli->tables_to_lock;
      for (uint i = 0; table_list_ptr && (i < rli->tables_to_lock_count);
           table_list_ptr = table_list_ptr->next_global, i++) {
        /*
          Below if condition takes care of skipping base tables that
          make up the MERGE table (which are added by open_tables()
          call). They are added next to the merge table in the list.
          For eg: If RPL_Table_ref is t3->t1->t2 (where t1 and t2
          are base tables for merge table 't3'), open_tables will modify
          the list by adding t1 and t2 again immediately after t3 in the
          list (*not at the end of the list*). New table_to_lock list will
          look like t3->t1'->t2'->t1->t2 (where t1' and t2' are Table_ref
          objects added by open_tables() call). There is no flag(or logic) in
          open_tables() that can skip adding these base tables to the list.
          So the logic here should take care of skipping them.

          tables_to_lock_count logic will take care of skipping base tables
          that are added at the end of the list.
          For eg: If RPL_Table_ref is t1->t2->t3, open_tables will modify
          the list into t1->t2->t3->t1'->t2'. t1' and t2' will be skipped
          because tables_to_lock_count logic in this for loop.
        */
        if (table_list_ptr->parent_l) continue;
        /*
          We can use a down cast here since we know that every table added
          to the tables_to_lock is a RPL_Table_ref (or child table which is
          skipped above).
        */
        RPL_Table_ref *ptr = static_cast<RPL_Table_ref *>(table_list_ptr);
        assert(ptr->m_tabledef_valid);
        TABLE *conv_table;
        if (!ptr->m_tabledef.compatible_with(thd,
                                             const_cast<Relay_log_info *>(rli),
                                             ptr->table, &conv_table)) {
          DBUG_PRINT("debug",
                     ("Table: %s.%s is not compatible with source",
                      ptr->table->s->db.str, ptr->table->s->table_name.str));
          if (thd->is_slave_error) {
            const_cast<Relay_log_info *>(rli)->slave_close_thread_tables(thd);
            return ERR_BAD_TABLE_DEF;
          } else {
            thd->get_stmt_da()->reset_condition_info(thd);
            clear_all_errors(thd, const_cast<Relay_log_info *>(rli));
            error = 0;
            goto end;
          }
        }
        DBUG_PRINT("debug", ("Table: %s.%s is compatible with source"
                             " - conv_table: %p",
                             ptr->table->s->db.str,
                             ptr->table->s->table_name.str, conv_table));
        ptr->m_conv_table = conv_table;
      }
    }

    /*
      ... and then we add all the tables to the table map and but keep
      them in the tables to lock list.
     */
    Table_ref *ptr = rli->tables_to_lock;
    for (uint i = 0; ptr && (i < rli->tables_to_lock_count);
         ptr = ptr->next_global, i++) {
      /*
        Please see comment in above 'for' loop to know the reason
        for this if condition
      */
      if (ptr->parent_l) continue;
      const_cast<Relay_log_info *>(rli)->m_table_map.set_table(ptr->table_id,
                                                               ptr->table);
    }

    /*
      Validate applied binlog events with plugin requirements.
    */
    int out_value = 0;
    int hook_error =
        RUN_HOOK(binlog_relay_io, applier_log_event, (thd, out_value));
    if (hook_error || out_value) {
      char buf[256];
      uint applier_error = ER_APPLIER_LOG_EVENT_VALIDATION_ERROR;

      if (hook_error) {
        applier_error = ER_RUN_HOOK_ERROR;
        strcpy(buf, "applier_log_event");
      } else {
        if (!thd->owned_gtid_is_empty() && thd->owned_gtid.sidno > 0) {
          thd->owned_gtid.to_string(thd->owned_sid, buf);
        } else {
          strcpy(buf, "ANONYMOUS");
        }
      }

      if (thd->slave_thread) {
        rli->report(ERROR_LEVEL, applier_error,
                    ER_THD_NONCONST(thd, applier_error), buf);
        thd->is_slave_error = true;
        const_cast<Relay_log_info *>(rli)->slave_close_thread_tables(thd);
      } else {
        /*
          For the cases in which a 'BINLOG' statement is set to
          execute in a user session
        */
        my_printf_error(applier_error, ER_THD_NONCONST(thd, applier_error),
                        MYF(0), buf);
      }
      return applier_error;
    }
  }

  table = m_table =
      const_cast<Relay_log_info *>(rli)->m_table_map.get_table(m_table_id);

  DBUG_PRINT("debug",
             ("m_table: %p, m_table_id: %llu", m_table, m_table_id.id()));

  /*
    A row event comprising of a P_S table
    - should not be replicated (i.e executed) by the slave SQL thread.
    - should not be executed by the client in the  form BINLOG '...' stmts.
  */
  if (table && table->s->table_category == TABLE_CATEGORY_PERFORMANCE)
    table = nullptr;

  if (table) {
    table_def *table_def = nullptr;
    TABLE *conv_table = nullptr;
    rli->get_table_data(table, &table_def, &conv_table);
    m_column_view = cs::util::ReplicatedColumnsViewFactory::
        get_columns_view_with_inbound_filters(thd, table, table_def);

    /*
     Translate received replicated column bitmaps into local table column
     bitmaps. This is needed when the table has columns that are to be excluded
     from replication - hidden generated columns, for instance.
    */
    m_column_view->translate_bitmap(this->m_cols, this->m_local_cols);
    if (this->m_cols.bitmap != this->m_cols_ai.bitmap)
      m_column_view->translate_bitmap(this->m_cols_ai, this->m_local_cols_ai);
    else
      this->m_local_cols_ai.bitmap = this->m_local_cols.bitmap;

    /*
      table == NULL means that this table should not be replicated
      (this was set up by Table_map_log_event::do_apply_event()
      which tested replicate-* rules).
    */

    Applier_security_context_guard security_context{rli, thd};
    const char *privilege_missing = nullptr;
    if (!security_context.skip_priv_checks()) {
      std::vector<std::tuple<ulong, const TABLE *, Rows_log_event *>> l;
      switch (get_general_type_code()) {
        case binary_log::WRITE_ROWS_EVENT: {
          l.push_back(std::make_tuple(INSERT_ACL, this->m_table, this));
          if (!security_context.has_access(l)) {
            privilege_missing = "INSERT";
          }
          break;
        }
        case binary_log::DELETE_ROWS_EVENT: {
          l.push_back(std::make_tuple(DELETE_ACL, this->m_table, this));
          if (!security_context.has_access(l)) {
            privilege_missing = "DELETE";
          }
          break;
        }
        case binary_log::UPDATE_ROWS_EVENT:
        case binary_log::PARTIAL_UPDATE_ROWS_EVENT: {
          l.push_back(std::make_tuple(UPDATE_ACL, this->m_table, this));
          if (!security_context.has_access(l)) {
            privilege_missing = "UPDATE";
          }
          break;
        }
        default: {
          assert(false);
        }
      }
    }
    if (privilege_missing != nullptr) {
      rli->report(ERROR_LEVEL, ER_TABLEACCESS_DENIED_ERROR,
                  ER_THD(thd, ER_TABLEACCESS_DENIED_ERROR), privilege_missing,
                  security_context.get_username().data(),
                  security_context.get_hostname().data(),
                  table->s->table_name.str);
      return ER_TABLEACCESS_DENIED_ERROR;
    }

    bool no_columns_to_update = false;
    // set the database
    LEX_CSTRING thd_db;
    LEX_CSTRING current_db_name_saved = thd->db();
    thd_db.str = table->s->db.str;
    thd_db.length = table->s->db.length;
    thd->reset_db(thd_db);
    thd->set_command(COM_QUERY);
    PSI_stage_info *stage = nullptr;

    /*
      It's not needed to set_time() but
      1) it continues the property that "Time" in SHOW PROCESSLIST shows how
      much slave is behind
      2) it will be needed when we allow replication from a table with no
      TIMESTAMP column to a table with one.
      So we call set_time(), like in SBR. Presently it changes nothing.
    */
    thd->set_time(&(common_header->when));

    thd->binlog_row_event_extra_data = m_extra_row_info.get_ndb_info();

    /*
      Now we are in a statement and will stay in a statement until we
      see a STMT_END_F.

      We set this flag here, before actually applying any rows, in
      case the SQL thread is stopped and we need to detect that we're
      inside a statement and halting abruptly might cause problems
      when restarting.
     */
    const_cast<Relay_log_info *>(rli)->set_flag(Relay_log_info::IN_STMT);

    /*
      If there is a GIPK solely on the replica, then the rows are never
      complete. Also we have to count with the GIPK on the replica that is
      filtered on the size or with the extra columns on the right of the replica
      when the source has a GIPK.
    */
    bool source_has_gipk = table_def->is_gipk_present_on_source_table();
    bool replica_has_gipk = table_has_generated_invisible_primary_key(table);
    size_t event_width =
        (source_has_gipk && !replica_has_gipk) ? m_width - 1 : m_width;
    size_t replica_row_width = m_column_view->filtered_size();

    bool extra_gipk_on_replica = replica_has_gipk && !source_has_gipk;

    if (!extra_gipk_on_replica && event_width == replica_row_width &&
        bitmap_is_set_all(&m_cols))
      set_flags(COMPLETE_ROWS_F);

    /*
      Set tables write and read sets.

      Read_set contains all slave columns (in case we are going to fetch
      a complete record from slave)

      Write_set equals the m_cols bitmap sent from master but it can be
      longer if slave has extra columns.
    */

    bitmap_set_all(table->read_set);
    bitmap_set_all(table->write_set);

    /*
      Call mark_generated_columns() to set read_set/write_set bits of the
      virtual generated columns as required in order to get these computed.
      This is needed since all columns need to have a value in the before
      image for the record when doing the update (some storage engines will
      use this for maintaining of secondary indexes). This call is required
      even for DELETE events to set write_set bit in order to satisfy
      ASSERTs in Field_*::store functions.

      binlog_prepare_row_image() function, which will be called from
      binlogging functions (binlog_update_row() and binlog_delete_row())
      will take care of removing these spurious fields required during
      execution but not needed for binlogging. In case of inserts, there
      are no spurious fields (all generated columns are required to be written
      into the binlog).
    */
    switch (get_general_type_code()) {
      case binary_log::DELETE_ROWS_EVENT:
        bitmap_intersect(table->read_set, &this->m_local_cols);
        stage = &stage_rpl_apply_row_evt_delete;
        if (m_table->vfield) m_table->mark_generated_columns(false);
        break;
      case binary_log::UPDATE_ROWS_EVENT:
        bitmap_intersect(table->read_set, &this->m_local_cols);
        bitmap_intersect(table->write_set, &this->m_local_cols_ai);
        if (m_table->vfield) m_table->mark_generated_columns(true);
        /* Skip update rows events that don't have data for this server's table.
         */
        if (!is_any_column_signaled_for_table(table, &this->m_local_cols_ai))
          no_columns_to_update = true;
        stage = &stage_rpl_apply_row_evt_update;
        break;
      case binary_log::WRITE_ROWS_EVENT:
        /*
          For 'WRITE_ROWS_EVENT, the execution order for 'mark_generated_rows()'
          and bitset intersection between 'write_set' and 'm_cols', is inverted.
          This behaviour is necessary due to an inconsistency, between storage
          engines, regarding the 'm_cols' bitset and generated columns: while
          non-NDB engines always include the generated columns for write-rows
          events, NDB doesn't if not necessary. The previous execution order
          would set all generated columns bits to '1' in 'write_set', since
          'mark_generated_columns()' is expecting that every column is present
          in the log event. This would break replication of generated columns
          for NDB.

          For engines that include every column in write-rows events, this order
          makes no difference, assuming that the master uses the same engine,
          since the master will include all the bits in the image.

          For use-cases that use different storage engines, specifically NDB
          and some other, this order may break replication due to the
          differences in behaviour regarding generated columns bits, in
          wrote-rows event bitsets. This issue should be further addressed by
          storage engines handlers, by converging behaviour regarding such use
          cases.
        */
        /* WRITE ROWS EVENTS store the bitmap in the m_cols bitmap */
        if (m_table->vfield) m_table->mark_generated_columns(false);
        bitmap_intersect(table->write_set, &this->m_local_cols);
        stage = &stage_rpl_apply_row_evt_write;
        break;
      default:
        assert(false);
    }

    if (thd->slave_thread)  // set the mode for slave
      this->rbr_exec_mode = replica_exec_mode_options;
    else  // set the mode for user thread
      this->rbr_exec_mode = thd->variables.rbr_exec_mode_options;

    // Do event specific preparations
    error = do_before_row_operations(rli);

    /*
      Bug#56662 Assertion failed: next_insert_id == 0, file handler.cc
      Don't allow generation of auto_increment value when processing
      rows event by setting 'MODE_NO_AUTO_VALUE_ON_ZERO'. The exception
      to this rule happens when the auto_inc column exists on some
      extra columns on the slave. In that case, do not force
      MODE_NO_AUTO_VALUE_ON_ZERO.
    */
    sql_mode_t saved_sql_mode = thd->variables.sql_mode;
    if (!is_auto_inc_in_extra_columns(rli))
      thd->variables.sql_mode |= MODE_NO_AUTO_VALUE_ON_ZERO;

    // row processing loop

    /*
      set the initial time of this ROWS statement if it was not done
      before in some other ROWS event.
     */
    const_cast<Relay_log_info *>(rli)->set_row_stmt_start_timestamp();

    const uchar *saved_m_curr_row = m_curr_row;

    int (Rows_log_event::*do_apply_row_ptr)(Relay_log_info const *) = nullptr;

    /**
       Skip update rows events that don't have data for this slave's
       table.
     */
    if (no_columns_to_update) goto AFTER_MAIN_EXEC_ROW_LOOP;

    /**
       If there are no columns marked in the read_set for this table,
       that means that we cannot lookup any row using the available BI
       in the binary log. Thence, we immediately raise an error:
       HA_ERR_END_OF_FILE.
     */

    if ((m_rows_lookup_algorithm != ROW_LOOKUP_NOT_NEEDED) &&
        !is_any_column_signaled_for_table(table, &this->m_local_cols)) {
      error = HA_ERR_END_OF_FILE;
      goto AFTER_MAIN_EXEC_ROW_LOOP;
    }
    switch (m_rows_lookup_algorithm) {
      case ROW_LOOKUP_HASH_SCAN:
        do_apply_row_ptr = &Rows_log_event::do_hash_scan_and_update;
        break;

      case ROW_LOOKUP_INDEX_SCAN:
        do_apply_row_ptr = &Rows_log_event::do_index_scan_and_update;
        break;

      case ROW_LOOKUP_TABLE_SCAN:
        do_apply_row_ptr = &Rows_log_event::do_table_scan_and_update;
        break;

      case ROW_LOOKUP_NOT_NEEDED:
        assert(get_general_type_code() == binary_log::WRITE_ROWS_EVENT);

        /* No need to scan for rows, just apply it */
        do_apply_row_ptr = &Rows_log_event::do_apply_row;
        break;

      default:
        assert(0);
        error = 1;
        goto AFTER_MAIN_EXEC_ROW_LOOP;
        break;
    }

    assert(stage != nullptr);
    THD_STAGE_INFO(thd, *stage);

#ifdef HAVE_PSI_STAGE_INTERFACE
    m_psi_progress.set_progress(mysql_set_stage(stage->m_key));
#endif

    do {
      DBUG_PRINT("info", ("calling do_apply_row_ptr"));

      error = (this->*do_apply_row_ptr)(rli);

      if (handle_idempotent_and_ignored_errors(rli, &error)) break;

      /* this advances m_curr_row */
      do_post_row_operations(rli, error);

    } while (!error && (m_curr_row != m_rows_end));

#ifdef HAVE_PSI_STAGE_INTERFACE
    m_psi_progress.end_work();
#endif

  AFTER_MAIN_EXEC_ROW_LOOP:

    if (saved_m_curr_row != m_curr_row && !table->file->has_transactions()) {
      /*
        Usually, the trans_commit_stmt() propagates unsafe_rollback_flags
        from statement to transaction level. However, we cannot rely on
        this when row format is in use as several events can be processed
        before calling this function. This happens because it is called
        only when the latest event generated by a statement is processed.

        There are however upper level functions that execute per event
        and check transaction's status. So if the unsafe_rollback_flags
        are not propagated here, this can lead to errors.

        For example, a transaction that updates non-transactional tables
        may be stopped in the middle thus leading to inconsistencies
        after a restart.
      */
      thd->get_transaction()->mark_modified_non_trans_table(
          Transaction_ctx::STMT);
      thd->get_transaction()->merge_unsafe_rollback_flags();
    }

    /*
      Restore the sql_mode after the rows event is processed.
    */
    thd->variables.sql_mode = saved_sql_mode;

    {
      /*
        The following failure injecion works in cooperation with tests
        setting @@global.debug= 'd,stop_replica_middle_group'.
        The sql thread receives the killed status and will proceed
        to shutdown trying to finish incomplete events group.
       */
      DBUG_EXECUTE_IF("stop_replica_middle_group", {
        if (thd->get_transaction()->cannot_safely_rollback(
                Transaction_ctx::SESSION)) {
          auto thd_rli = (thd->system_thread == SYSTEM_THREAD_SLAVE_SQL
                              ? const_cast<Relay_log_info *>(rli)
                              : static_cast<Slave_worker *>(
                                    const_cast<Relay_log_info *>(rli))
                                    ->c_rli);
          thd_rli->abort_slave = 1;
        }
      };);
    }

    if ((error = do_after_row_operations(rli, error)) &&
        ignored_error_code(convert_handler_error(error, thd, table))) {
      slave_rows_error_report(
          INFORMATION_LEVEL, error, rli, thd, table, get_type_str(),
          const_cast<Relay_log_info *>(rli)->get_rpl_log_name(),
          (ulong)common_header->log_pos);
      thd->get_stmt_da()->reset_condition_info(thd);
      clear_all_errors(thd, const_cast<Relay_log_info *>(rli));
      error = 0;
    }

    // reset back the db
    thd->reset_db(current_db_name_saved);
  }  // if (table)

  if (error) {
    slave_rows_error_report(
        ERROR_LEVEL, error, rli, thd, table, get_type_str(),
        const_cast<Relay_log_info *>(rli)->get_rpl_log_name(),
        (ulong)common_header->log_pos);
    /*
      @todo We should probably not call
      reset_current_stmt_binlog_format_row() from here.
      /Sven
    */
    thd->reset_current_stmt_binlog_format_row();
    thd->is_slave_error = true;
    return error;
  }

end:
  if (get_flags(STMT_END_F)) {
    if ((error = rows_event_stmt_cleanup(rli, thd))) {
      if (table)
        slave_rows_error_report(
            ERROR_LEVEL, thd->is_error() ? 0 : error, rli, thd, table,
            get_type_str(),
            const_cast<Relay_log_info *>(rli)->get_rpl_log_name(),
            (ulong)common_header->log_pos);
      else {
        rli->report(
            ERROR_LEVEL,
            thd->is_error() ? thd->get_stmt_da()->mysql_errno() : error,
            "Error in cleaning up after an event of type:%s; %s; the group"
            " log file/position: %s %lu",
            get_type_str(),
            thd->is_error() ? thd->get_stmt_da()->message_text()
                            : "unexpected error",
            const_cast<Relay_log_info *>(rli)->get_rpl_log_name(),
            (ulong)common_header->log_pos);
      }
    }
    /* We are at end of the statement (STMT_END_F flag), lets clean
      the memory which was used from thd's mem_root now.
      This needs to be done only if we are here in SQL thread context.
      In other flow ( in case of a regular thread which can happen
      when the thread is applying BINLOG'...' row event) we should
      *not* try to free the memory here. It will be done latter
      in dispatch_command() after command execution is completed.
     */
    if (thd->slave_thread) thd->mem_root->ClearForReuse();
  }
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: append_query_string not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: append_query_string not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: append_query_string not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: append_query_string not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Query_log_event::Query_log_event not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Query_log_event::Query_log_event not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Execute_load_query_log_event::Execute_load_query_log_event not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Execute_load_query_log_event::Execute_load_query_log_event not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_factory.cc
Function: Rpl_info_factory::load_channel_names_from_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_factory.cc
Function: Rpl_info_factory::load_channel_names_from_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_factory.cc
Function: Rpl_info_factory::load_channel_names_from_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_factory.cc
Function: Rpl_info_factory::load_channel_names_from_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_factory.cc
Function: Rpl_info_factory::load_channel_names_from_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_check_info
enum_return_check Rpl_info_table::do_check_info() {
  TABLE *table = nullptr;
  sql_mode_t saved_mode;
  Open_tables_backup backup;
  enum_return_check return_check = ERROR_CHECKING_REPOSITORY;

  DBUG_TRACE;

  THD *thd = access->create_thd();
  saved_mode = thd->variables.sql_mode;

  /*
    Opens and locks the rpl_info table before accessing it.
  */
  if (access->open_table(thd, to_lex_cstring(str_schema),
                         to_lex_cstring(str_table), get_number_info(), TL_READ,
                         &table, &backup)) {
    LogErr(WARNING_LEVEL, ER_RPL_CANT_OPEN_INFO_TABLE, str_schema.str,
           str_table.str);

    return_check = ERROR_CHECKING_REPOSITORY;
    goto end;
  }

  /*
    Points the cursor at the row to be read according to the
    keys.
  */
  if (access->find_info(field_values, table) != FOUND_ID) {
    /*
       We cannot simply call my_error here because it does not
       really means that there was a failure but only that the
       record was not found.
    */
    return_check = REPOSITORY_DOES_NOT_EXIST;
    goto end;
  }
  return_check = REPOSITORY_EXISTS;

end:
  /*
    Unlocks and closes the rpl_info table.
  */
  access->close_table(thd, table, &backup,
                      return_check == ERROR_CHECKING_REPOSITORY);
  thd->variables.sql_mode = saved_mode;
  access->drop_thd(thd);
  return return_check;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_flush_info
int Rpl_info_table::do_flush_info(const bool force) {
  int error = 1;
  enum enum_return_id res = FOUND_ID;
  TABLE *table = nullptr;
  sql_mode_t saved_mode;
  Open_tables_backup backup;

  DBUG_TRACE;

  if (!(force || (sync_period && ++(sync_counter) >= sync_period))) return 0;

  THD *thd = access->create_thd();

  sync_counter = 0;
  saved_mode = thd->variables.sql_mode;
  ulonglong saved_options = thd->variables.option_bits;
  thd->variables.option_bits &= ~OPTION_BIN_LOG;
  thd->is_operating_substatement_implicitly = true;

  /*
    Opens and locks the rpl_info table before accessing it.
  */
  if (access->open_table(thd, to_lex_cstring(str_schema),
                         to_lex_cstring(str_table), get_number_info(), TL_WRITE,
                         &table, &backup))
    goto end;

  /*
    Points the cursor at the row to be read according to the
    keys. If the row is not found an error is reported.
  */
  if ((res = access->find_info(field_values, table)) == NOT_FOUND_ID) {
    /*
      Prepares the information to be stored before calling ha_write_row.
    */
    empty_record(table);
    if (access->store_info_values(get_number_info(), table->field,
                                  field_values))
      goto end;

    /*
      Inserts a new row into rpl_info table.
    */
    if ((error = table->file->ha_write_row(table->record[0]))) {
      table->file->print_error(error, MYF(0));
      /*
        This makes sure that the error is 1 and not the status returned
        by the handler.
      */
      error = 1;
      goto end;
    }
    error = 0;
  } else if (res == FOUND_ID) {
    /*
      Prepares the information to be stored before calling ha_update_row.
    */
    store_record(table, record[1]);
    if (access->store_info_values(get_number_info(), table->field,
                                  field_values))
      goto end;

    /*
      Updates a row in the rpl_info table.
    */
    if ((error =
             table->file->ha_update_row(table->record[1], table->record[0])) &&
        error != HA_ERR_RECORD_IS_THE_SAME) {
      table->file->print_error(error, MYF(0));
      /*
        This makes sure that the error is 1 and not the status returned
        by the handler.
      */
      error = 1;
      goto end;
    }
    error = 0;
  }

end:
  DBUG_EXECUTE_IF("mta_debug_concurrent_access", {
    while (thd->system_thread == SYSTEM_THREAD_SLAVE_WORKER &&
           mta_debug_concurrent_access < 2 && mta_debug_concurrent_access > 0) {
      DBUG_PRINT("mts", ("Waiting while locks are acquired to show "
                         "concurrency in mts: %u %u\n",
                         mta_debug_concurrent_access, thd->thread_id()));
      my_sleep(6000000);
    }
  };);

  /*
    Unlocks and closes the rpl_info table.
  */
  error = access->close_table(thd, table, &backup, error) || error;
  thd->is_operating_substatement_implicitly = false;
  thd->variables.sql_mode = saved_mode;
  thd->variables.option_bits = saved_options;
  access->drop_thd(thd);
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_clean_info
int Rpl_info_table::do_clean_info() {
  int error = 1;
  enum enum_return_id res = FOUND_ID;
  TABLE *table = nullptr;
  sql_mode_t saved_mode;
  Open_tables_backup backup;

  DBUG_TRACE;

  THD *thd = access->create_thd();

  saved_mode = thd->variables.sql_mode;
  ulonglong saved_options = thd->variables.option_bits;
  thd->variables.option_bits &= ~OPTION_BIN_LOG;

  /*
    Opens and locks the rpl_info table before accessing it.
  */
  if (access->open_table(thd, to_lex_cstring(str_schema),
                         to_lex_cstring(str_table), get_number_info(), TL_WRITE,
                         &table, &backup))
    goto end;

  /*
    Points the cursor at the row to be deleted according to the
    keys. If the row is not found, the execution proceeds normally.
  */
  if ((res = access->find_info(field_values, table)) == FOUND_ID) {
    /*
      Deletes a row in the rpl_info table.
    */
    if ((error = table->file->ha_delete_row(table->record[0]))) {
      table->file->print_error(error, MYF(0));
      goto end;
    }
  }
  error = (res == ERROR_ID);
end:
  /*
    Unlocks and closes the rpl_info table.
  */
  error = access->close_table(thd, table, &backup, error) || error;
  thd->variables.sql_mode = saved_mode;
  thd->variables.option_bits = saved_options;
  access->drop_thd(thd);
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_update_is_transactional
bool Rpl_info_table::do_update_is_transactional() {
  bool error = true;
  sql_mode_t saved_mode;
  TABLE *table = nullptr;
  Open_tables_backup backup;

  DBUG_TRACE;

  THD *thd = access->create_thd();
  saved_mode = thd->variables.sql_mode;
  ulonglong saved_options = thd->variables.option_bits;
  thd->variables.option_bits &= ~OPTION_BIN_LOG;

  /*
    Opens and locks the rpl_info table before accessing it.
  */
  if (access->open_table(thd, to_lex_cstring(str_schema),
                         to_lex_cstring(str_table), get_number_info(), TL_READ,
                         &table, &backup))
    goto end;

  is_transactional = table->file->has_transactions();
  error = false;

end:
  error = access->close_table(thd, table, &backup, false) || error;
  thd->variables.sql_mode = saved_mode;
  thd->variables.option_bits = saved_options;
  access->drop_thd(thd);
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_init_info
int Rpl_info_table::do_init_info() { return do_init_info(FIND_KEY, 0); }



-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_reset_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_reset_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_reset_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_reset_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_reset_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_count_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_count_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_count_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_count_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::do_count_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::table_in_use not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::table_in_use not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::table_in_use not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::table_in_use not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_info_table.cc
Function: Rpl_info_table::table_in_use not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_event.cc
Function: dd::set_event_attributes not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_event.cc
Function: dd::set_event_attributes not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_routine.cc
Function: dd::fill_dd_routine_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_routine.cc
Function: dd::fill_dd_routine_info not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_view.cc
Function: dd::fill_dd_view_columns not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_view.cc
Function: dd::fill_dd_view_columns not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_view.cc
Function: dd::fill_dd_view_columns not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_view.cc
Function: dd::fill_dd_view_columns not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_view.cc
Function: dd::fill_dd_view_columns not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_view.cc
Function: dd::fill_dd_view_columns not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_view.cc
Function: dd::fill_dd_view_columns not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_view.cc
Function: dd::fill_dd_view_columns not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_view.cc
Function: dd::fill_dd_view_columns not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/upgrade/server.cc
Function: dd::upgrade::Routine_event_context_guard::Routine_event_context_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/upgrade/server.cc
Function: dd::upgrade::Routine_event_context_guard::Routine_event_context_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/upgrade/server.cc
Function: dd::upgrade::Routine_event_context_guard::Routine_event_context_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/upgrade/server.cc
Function: dd::upgrade::Routine_event_context_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/upgrade/server.cc
Function: dd::upgrade::Routine_event_context_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/upgrade/server.cc
Function: dd::upgrade::Routine_event_context_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/upgrade/server.cc
Function: dd::upgrade::Routine_event_context_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/upgrade.cc
Function: dd::upgrade_57::fill_dd_and_finalize not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/upgrade.cc
Function: dd::upgrade_57::fill_dd_and_finalize not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/transaction_impl.cc
Function: dd::Update_dictionary_tables_ctx::Update_dictionary_tables_ctx not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/transaction_impl.cc
Function: dd::Update_dictionary_tables_ctx::Update_dictionary_tables_ctx not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/transaction_impl.cc
Function: dd::Update_dictionary_tables_ctx::Update_dictionary_tables_ctx not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/transaction_impl.cc
Function: dd::Update_dictionary_tables_ctx:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/transaction_impl.cc
Function: dd::Update_dictionary_tables_ctx:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/transaction_impl.cc
Function: dd::Update_dictionary_tables_ctx:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/transaction_impl.cc
Function: dd::Update_dictionary_tables_ctx:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/transaction_impl.cc
Function: dd::Update_dictionary_tables_ctx::Update_dictionary_tables_ctx not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/transaction_impl.cc
Function: dd::Update_dictionary_tables_ctx::Update_dictionary_tables_ctx not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/event.cc
Function: dd::upgrade_57::migrate_event_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/event.cc
Function: dd::upgrade_57::migrate_event_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/routine.cc
Function: dd::upgrade_57::migrate_routine_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/routine.cc
Function: dd::upgrade_57::migrate_routine_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/routine.cc
Function: dd::upgrade_57::migrate_routine_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/routine.cc
Function: dd::upgrade_57::migrate_routine_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/routine.cc
Function: dd::upgrade_57::migrate_routine_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/routine.cc
Function: dd::upgrade_57::migrate_routine_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::migrate_table_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::migrate_table_to_dd not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::Table_upgrade_guard::Table_upgrade_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::Table_upgrade_guard::Table_upgrade_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::Table_upgrade_guard::Table_upgrade_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::Table_upgrade_guard::Table_upgrade_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::Table_upgrade_guard::Table_upgrade_guard not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::Table_upgrade_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::Table_upgrade_guard:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_local_connection.cc
Function: Ndb_privilege_upgrade_connection::Ndb_privilege_upgrade_connection not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_local_connection.cc
Function: Ndb_privilege_upgrade_connection::Ndb_privilege_upgrade_connection not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_local_connection.cc
Function: Ndb_privilege_upgrade_connection::Ndb_privilege_upgrade_connection not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_local_connection.cc
Function: Ndb_privilege_upgrade_connection:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_local_connection.cc
Function: Ndb_privilege_upgrade_connection:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_local_connection.cc
Function: Ndb_privilege_upgrade_connection:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_local_connection.cc
Function: Ndb_privilege_upgrade_connection:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_local_connection.cc
Function: Ndb_privilege_upgrade_connection::Ndb_privilege_upgrade_connection not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_local_connection.cc
Function: Ndb_privilege_upgrade_connection::Ndb_privilege_upgrade_connection not found.

