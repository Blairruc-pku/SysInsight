-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_manager.cc
Function: start_handle_manager
void start_handle_manager() {
  DBUG_TRACE;
  abort_manager = false;
  if (flush_time && flush_time != ~(ulong)0L) {
    my_thread_handle hThread;
    int error;
    if ((error =
             mysql_thread_create(key_thread_handle_manager, &hThread,
                                 &connection_attrib, handle_manager, nullptr)))
      LogErr(WARNING_LEVEL, ER_CANT_CREATE_HANDLE_MGR_THREAD, error);
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_manager.cc
Function: handle_manager not found.
static void *handle_manager(void *arg [[maybe_unused]]) {
  int error = 0;
  struct timespec abstime;
  bool reset_flush_time = true;
  my_thread_init();
  {
    DBUG_TRACE;

    manager_thread = my_thread_self();
    manager_thread_in_use = true;

    for (;;) {
      mysql_mutex_lock(&LOCK_manager);
      /* XXX: This will need to be made more general to handle different
       * polling needs. */
      if (flush_time) {
        if (reset_flush_time) {
          set_timespec(&abstime, flush_time);
          reset_flush_time = false;
        }
        while ((!error || error == EINTR) && !abort_manager)
          error = mysql_cond_timedwait(&COND_manager, &LOCK_manager, &abstime);
      } else {
        while ((!error || error == EINTR) && !abort_manager)
          error = mysql_cond_wait(&COND_manager, &LOCK_manager);
      }
      mysql_mutex_unlock(&LOCK_manager);

      if (abort_manager) break;

      if (is_timeout(error)) {
        tdc_flush_unused_tables();
        error = 0;
        reset_flush_time = true;
      }
    }
    manager_thread_in_use = false;
  }  // Can't use DBUG_RETURN after my_thread_end
  my_thread_end();
  return (nullptr);
}

