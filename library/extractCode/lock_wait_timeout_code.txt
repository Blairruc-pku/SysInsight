-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/mysqld.cc
Function: do_create_native_table_for_pfs
bool do_create_native_table_for_pfs(THD *thd, const Plugin_table *t) {
  const char *schema_name = t->get_schema_name();
  const char *table_name = t->get_name();
  MDL_request table_request;
  MDL_REQUEST_INIT(&table_request, MDL_key::TABLE, schema_name, table_name,
                   MDL_EXCLUSIVE, MDL_TRANSACTION);

  if (thd->mdl_context.acquire_lock(&table_request,
                                    thd->variables.lock_wait_timeout)) {
    /* Error, failed to get MDL lock. */
    return true;
  }

  tdc_remove_table(thd, TDC_RT_REMOVE_ALL, schema_name, table_name, false);

  if (dd::create_native_table(thd, t)) {
    /* Error, failed to create DD table. */
    return true;
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/mysqld.cc
Function: do_drop_native_table_for_pfs
static bool do_drop_native_table_for_pfs(THD *thd, const char *schema_name,
                                         const char *table_name) {
  MDL_request table_request;
  MDL_REQUEST_INIT(&table_request, MDL_key::TABLE, schema_name, table_name,
                   MDL_EXCLUSIVE, MDL_TRANSACTION);

  if (thd->mdl_context.acquire_lock(&table_request,
                                    thd->variables.lock_wait_timeout)) {
    /* Error, failed to get MDL lock. */
    return true;
  }

  tdc_remove_table(thd, TDC_RT_REMOVE_ALL, schema_name, table_name, false);

  if (dd::drop_native_table(thd, schema_name, table_name)) {
    /* Error, failed to destroy DD table. */
    return true;
  }

  return false;
}
-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_mgr.cc
Function: resourcegroups::Resource_group_mgr::acquire_shared_mdl_for_resource_group
bool Resource_group_mgr::acquire_shared_mdl_for_resource_group(
    THD *thd, const char *res_grp_name, enum_mdl_duration lock_duration,
    MDL_ticket **ticket, bool try_acquire) {
  DBUG_TRACE;

  MDL_key mdl_key;
  dd::Resource_group::create_mdl_key(res_grp_name, &mdl_key);

  MDL_request mdl_request;
  MDL_REQUEST_INIT_BY_KEY(&mdl_request, &mdl_key, MDL_INTENTION_EXCLUSIVE,
                          lock_duration);

  bool res = try_acquire ? thd->mdl_context.acquire_lock(&mdl_request, 0)
                         : thd->mdl_context.acquire_lock(
                               &mdl_request, thd->variables.lock_wait_timeout);
  if (!res && ticket != nullptr) *ticket = mdl_request.ticket;

  return res;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: wait_while_table_is_used
bool wait_while_table_is_used(THD *thd, TABLE *table,
                              enum ha_extra_function function) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("table: '%s'  share: %p  db_stat: %u  version: %lu",
                       table->s->table_name.str, table->s, table->db_stat,
                       table->s->version()));

  if (thd->mdl_context.upgrade_shared_lock(table->mdl_ticket, MDL_EXCLUSIVE,
                                           thd->variables.lock_wait_timeout))
    return true;

  tdc_remove_table(thd, TDC_RT_REMOVE_NOT_OWN, table->s->db.str,
                   table->s->table_name.str, false);
  /* extra() call must come only after all instances above are closed */
  (void)table->file->ha_extra(function);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: read_histograms
static bool read_histograms(THD *thd, TABLE_SHARE *share,
                            const dd::Schema *schema,
                            const dd::Abstract_table *table_def) {
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  MDL_request_list mdl_requests;
  for (const auto column : table_def->columns()) {
    if (column->is_se_hidden()) continue;

    MDL_key mdl_key;
    dd::Column_statistics::create_mdl_key(schema->name(), table_def->name(),
                                          column->name(), &mdl_key);

    MDL_request *request = new (thd->mem_root) MDL_request;
    MDL_REQUEST_INIT_BY_KEY(request, &mdl_key, MDL_SHARED_READ, MDL_STATEMENT);
    mdl_requests.push_front(request);
  }

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true; /* purecov: deadcode */

  for (const auto column : table_def->columns()) {
    if (column->is_se_hidden()) continue;

    const histograms::Histogram *histogram = nullptr;
    if (histograms::find_histogram(thd, schema->name().c_str(),
                                   table_def->name().c_str(),
                                   column->name().c_str(), &histogram)) {
      // Any error is reported by the dictionary subsystem.
      return true; /* purecov: deadcode */
    }

    if (histogram != nullptr) {
      /*
        Make a clone of the histogram so it survives together with the
        TABLE_SHARE in case the original histogram is thrown out of the
        dictionary cache.
      */
      const histograms::Histogram *histogram_copy =
          histogram->clone(&share->mem_root);
      share->m_histograms->emplace(column->ordinal_position() - 1,
                                   histogram_copy);
    }
  }

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_table
bool open_table(THD *thd, Table_ref *table_list, Open_table_context *ot_ctx) {
  TABLE *table = nullptr;
  TABLE_SHARE *share = nullptr;
  const char *key;
  size_t key_length;
  const char *alias = table_list->alias;
  uint flags = ot_ctx->get_flags();
  MDL_ticket *mdl_ticket = nullptr;
  int error = 0;

  DBUG_TRACE;

  // Temporary tables and derived tables are not allowed:
  assert(!is_temporary_table(table_list) && !table_list->is_derived());

  /*
    The table must not be opened already. The table can be pre-opened for
    some statements if it is a temporary table.

    open_temporary_table() must be used to open temporary tables.
    A derived table cannot be opened with this.
  */
  assert(table_list->is_view() || table_list->table == nullptr);

  /* an open table operation needs a lot of the stack space */
  if (check_stack_overrun(thd, STACK_MIN_SIZE_FOR_OPEN, (uchar *)&alias))
    return true;

  // New DD- In current_thd->is_strict_mode() mode we call open_table
  // on new DD tables like mysql.tables/* when CREATE fails and we
  // try to abort the operation and invoke quick_rm_table().
  // Currently, we ignore deleting table in strict mode. Need to fix this.
  // TODO.

  DBUG_EXECUTE_IF("kill_query_on_open_table_from_tz_find", {
    /*
      When on calling my_tz_find the following
      tables are opened in specified order: time_zone_name,
      time_zone, time_zone_transition_type,
      time_zone_transition. Emulate killing a query
      on opening the second table in the list.
    */
    if (!strcmp("time_zone", table_list->table_name))
      thd->killed = THD::KILL_QUERY;
  });

  if (!(flags & MYSQL_OPEN_IGNORE_KILLED) && thd->killed) return true;

  /*
    Check if we're trying to take a write lock in a read only transaction.

    Note that we allow write locks on log tables as otherwise logging
    to general/slow log would be disabled in read only transactions.
  */
  if (table_list->mdl_request.is_write_lock_request() && thd->tx_read_only &&
      !(flags & (MYSQL_LOCK_LOG_TABLE | MYSQL_OPEN_HAS_MDL_LOCK))) {
    my_error(ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION, MYF(0));
    return true;
  }

  /*
    FLUSH TABLES is ignored for DD, I_S and P_S tables/views.
    Hence setting MYSQL_OPEN_IGNORE_FLUSH flag.
  */
  if (table_list->is_system_view || belongs_to_dd_table(table_list) ||
      belongs_to_p_s(table_list))
    flags |= MYSQL_OPEN_IGNORE_FLUSH;

  key_length = get_table_def_key(table_list, &key);

  // If a table in a secondary storage engine has been requested,
  // adjust the key to refer to the secondary table.
  std::string secondary_key;
  if ((flags & MYSQL_OPEN_SECONDARY_ENGINE) != 0) {
    secondary_key = create_table_def_key_secondary(
        table_list->get_db_name(), table_list->get_table_name());
    key = secondary_key.data();
    key_length = secondary_key.length();
  }

  /*
    If we're in pre-locked or LOCK TABLES mode, let's try to find the
    requested table in the list of pre-opened and locked tables. If the
    table is not there, return an error - we can't open not pre-opened
    tables in pre-locked/LOCK TABLES mode.

    There is a special case where we allow opening not pre-opened tables
    in LOCK TABLES mode for new DD tables. The reason is as following.
    With new DD, IS system views need to be accessible in LOCK TABLE
    mode without user explicitly calling LOCK TABLE on IS view or its
    underlying DD tables. This is required to keep the old behavior the
    MySQL server had without new DD.

    In case user executes IS system view under LOCK TABLE mode
    (LTM and not prelocking), then MySQL server implicitly opens system
    view and related DD tables. Such DD tables are then implicitly closed
    upon end of statement execution.

    Our goal is to hide DD tables from users, so there is no possibility of
    explicit locking DD table using LOCK TABLE. In case user does LOCK TABLE
    on IS system view explicitly, MySQL server throws a error.

    TODO: move this block into a separate function.
  */
  if (thd->locked_tables_mode && !(flags & MYSQL_OPEN_GET_NEW_TABLE) &&
      !(in_LTM(thd) &&
        (table_list->is_system_view || belongs_to_dd_table(table_list) ||
         belongs_to_p_s(table_list)))) {  // Using table locks
    TABLE *best_table = nullptr;
    int best_distance = INT_MIN;
    for (table = thd->open_tables; table; table = table->next) {
      if (table->s->table_cache_key.length == key_length &&
          !memcmp(table->s->table_cache_key.str, key, key_length)) {
        if (!my_strcasecmp(system_charset_info, table->alias, alias) &&
            table->query_id != thd->query_id && /* skip tables already used */
            (thd->locked_tables_mode == LTM_LOCK_TABLES ||
             table->query_id == 0)) {
          int distance = ((int)table->reginfo.lock_type -
                          (int)table_list->lock_descriptor().type);

          /*
            Find a table that either has the exact lock type requested,
            or has the best suitable lock. In case there is no locked
            table that has an equal or higher lock than requested,
            we us the closest matching lock to be able to produce an error
            message about wrong lock mode on the table. The best_table
            is changed if bd < 0 <= d or bd < d < 0 or 0 <= d < bd.

            distance <  0 - No suitable lock found
            distance >  0 - we have lock mode higher then we require
            distance == 0 - we have lock mode exactly which we need
          */
          if ((best_distance < 0 && distance > best_distance) ||
              (distance >= 0 && distance < best_distance)) {
            best_distance = distance;
            best_table = table;
            if (best_distance == 0) {
              /*
                We have found a perfect match and can finish iterating
                through open tables list. Check for table use conflict
                between calling statement and SP/trigger is done in
                lock_tables().
              */
              break;
            }
          }
        }
      }
    }
    if (best_table) {
      table = best_table;
      table->query_id = thd->query_id;
      DBUG_PRINT("info", ("Using locked table"));
      goto reset;
    }
    /*
      Is this table a view and not a base table?
      (it is work around to allow to open view with locked tables,
      real fix will be made after definition cache will be made)

      Since opening of view which was not explicitly locked by LOCK
      TABLES breaks metadata locking protocol (potentially can lead
      to deadlocks) it should be disallowed.
    */
    if (thd->mdl_context.owns_equal_or_stronger_lock(
            MDL_key::TABLE, table_list->db, table_list->table_name,
            MDL_SHARED)) {
      /*
        Note that we can't be 100% sure that it is a view since it's
        possible that we either simply have not found unused TABLE
        instance in THD::open_tables list or were unable to open table
        during prelocking process (in this case in theory we still
        should hold shared metadata lock on it).
      */
      dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
      const dd::View *view = nullptr;
      if (!thd->dd_client()->acquire(table_list->db, table_list->table_name,
                                     &view) &&
          view != nullptr) {
        /*
          If parent_l of the table_list is non null then a merge table
          has this view as child table, which is not supported.
        */
        if (table_list->parent_l) {
          my_error(ER_WRONG_MRG_TABLE, MYF(0));
          return true;
        }

        /*
          In the case of a CREATE, add a dummy LEX object to
          indicate the presence of a view amd skip processing the
          existing view.
        */
        if (table_list->open_strategy == Table_ref::OPEN_FOR_CREATE)
          return add_view_place_holder(thd, table_list);

        if (!tdc_open_view(thd, table_list, key, key_length)) {
          assert(table_list->is_view());
          return false;  // VIEW
        }
      }
    }
    /*
      No table in the locked tables list. In case of explicit LOCK TABLES
      this can happen if a user did not include the table into the list.
      In case of pre-locked mode locked tables list is generated automatically,
      so we may only end up here if the table did not exist when
      locked tables list was created.
    */
    if (thd->locked_tables_mode == LTM_PRELOCKED)
      my_error(ER_NO_SUCH_TABLE, MYF(0), table_list->db, table_list->alias);
    else
      my_error(ER_TABLE_NOT_LOCKED, MYF(0), alias);
    return true;
  }

  // Non pre-locked/LOCK TABLES mode, and not using secondary storage engine.
  // This is the normal use case.

  if ((flags & (MYSQL_OPEN_HAS_MDL_LOCK | MYSQL_OPEN_SECONDARY_ENGINE)) == 0) {
    /*
      We are not under LOCK TABLES and going to acquire write-lock/
      modify the base table. We need to acquire protection against
      global read lock until end of this statement in order to have
      this statement blocked by active FLUSH TABLES WITH READ LOCK.

      We don't block acquire this protection under LOCK TABLES as
      such protection already acquired at LOCK TABLES time and
      not released until UNLOCK TABLES.

      We don't block statements which modify only temporary tables
      as these tables are not preserved by backup by any form of
      backup which uses FLUSH TABLES WITH READ LOCK.

      TODO: The fact that we sometimes acquire protection against
            GRL only when we encounter table to be write-locked
            slightly increases probability of deadlock.
            This problem will be solved once Alik pushes his
            temporary table refactoring patch and we can start
            pre-acquiring metadata locks at the beginning of
            open_tables() call.
    */
    if (table_list->mdl_request.is_write_lock_request() &&
        !(flags &
          (MYSQL_OPEN_IGNORE_GLOBAL_READ_LOCK | MYSQL_OPEN_FORCE_SHARED_MDL |
           MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL |
           MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK)) &&
        !ot_ctx->has_protection_against_grl()) {
      MDL_request protection_request;
      MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);

      if (thd->global_read_lock.can_acquire_protection()) return true;

      MDL_REQUEST_INIT(&protection_request, MDL_key::GLOBAL, "", "",
                       MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);

      /*
        Install error handler which if possible will convert deadlock error
        into request to back-off and restart process of opening tables.

        Prefer this context as a victim in a deadlock when such a deadlock
        can be easily handled by back-off and retry.
      */
      thd->push_internal_handler(&mdl_deadlock_handler);
      thd->mdl_context.set_force_dml_deadlock_weight(ot_ctx->can_back_off());

      bool result = thd->mdl_context.acquire_lock(&protection_request,
                                                  ot_ctx->get_timeout());

      /*
        Unlike in other places where we acquire protection against global read
        lock, the read_only state is not checked here since we check its state
        later in mysql_lock_tables()
      */

      thd->mdl_context.set_force_dml_deadlock_weight(false);
      thd->pop_internal_handler();

      if (result) return true;

      ot_ctx->set_has_protection_against_grl();
    }

    if (open_table_get_mdl_lock(thd, ot_ctx, table_list, flags, &mdl_ticket) ||
        mdl_ticket == nullptr) {
      DEBUG_SYNC(thd, "before_open_table_wait_refresh");
      return true;
    }
    DEBUG_SYNC(thd, "after_open_table_mdl_shared");
  } else {
    /*
      Grab reference to the MDL lock ticket that was acquired
      by the caller.
    */
    mdl_ticket = table_list->mdl_request.ticket;
  }

  if (table_list->open_strategy == Table_ref::OPEN_IF_EXISTS ||
      table_list->open_strategy == Table_ref::OPEN_FOR_CREATE) {
    bool exists;

    if (check_if_table_exists(thd, table_list, &exists)) return true;

    /*
      If the table does not exist then upgrade the lock to the EXCLUSIVE MDL
      lock.
    */
    if (!exists) {
      if (table_list->open_strategy == Table_ref::OPEN_FOR_CREATE &&
          !(flags & (MYSQL_OPEN_FORCE_SHARED_MDL |
                     MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL))) {
        MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);

        thd->push_internal_handler(&mdl_deadlock_handler);

        DEBUG_SYNC(thd, "before_upgrading_lock_from_S_to_X_for_create_table");
        bool wait_result = thd->mdl_context.upgrade_shared_lock(
            table_list->mdl_request.ticket, MDL_EXCLUSIVE,
            thd->variables.lock_wait_timeout);

        thd->pop_internal_handler();
        DEBUG_SYNC(thd, "after_upgrading_lock_from_S_to_X_for_create_table");

        /* Deadlock or timeout occurred while upgrading the lock. */
        if (wait_result) return true;
      }

      return false;
    }

    /* Table exists. Let us try to open it. */
  } else if (table_list->open_strategy == Table_ref::OPEN_STUB)
    return false;

retry_share : {
  Table_cache *tc = table_cache_manager.get_cache(thd);

  tc->lock();

  /*
    Try to get unused TABLE object or at least pointer to
    TABLE_SHARE from the table cache.
  */
  if (!table_list->is_view())
    table = tc->get_table(thd, key, key_length, &share);

  if (table) {
    /* We have found an unused TABLE object. */

    if (!(flags & MYSQL_OPEN_IGNORE_FLUSH)) {
      /*
        TABLE_SHARE::version can only be initialised while holding the
        LOCK_open and in this case no one has a reference to the share
        object, if a reference exists to the share object it is necessary
        to lock both LOCK_open AND all table caches in order to update
        TABLE_SHARE::version. The same locks are required to increment
        refresh_version global variable.

        As result it is safe to compare TABLE_SHARE::version and
        refresh_version values while having only lock on the table
        cache for this thread.

        Table cache should not contain any unused TABLE objects with
        old versions.
      */
      assert(!share->has_old_version());

      /*
        Still some of already opened might become outdated (e.g. due to
        concurrent table flush). So we need to compare version of opened
        tables with version of TABLE object we just have got.
      */
      if (thd->open_tables &&
          thd->open_tables->s->version() != share->version()) {
        tc->release_table(thd, table);
        tc->unlock();
        (void)ot_ctx->request_backoff_action(
            Open_table_context::OT_REOPEN_TABLES, nullptr);
        return true;
      }
    }
    tc->unlock();

    /* Call rebind_psi outside of the critical section. */
    assert(table->file != nullptr);
    table->file->rebind_psi();
    table->file->ha_extra(HA_EXTRA_RESET_STATE);

    thd->status_var.table_open_cache_hits++;
    goto table_found;
  } else if (share) {
    /*
      We weren't able to get an unused TABLE object. Still we have
      found TABLE_SHARE for it. So let us try to create new TABLE
      for it. We start by incrementing share's reference count and
      checking its version.
    */
    mysql_mutex_lock(&LOCK_open);
    tc->unlock();
    share->increment_ref_count();
    goto share_found;
  } else {
    /*
      We have not found neither TABLE nor TABLE_SHARE object in
      table cache (this means that there are no TABLE objects for
      it in it).
      Let us try to get TABLE_SHARE from table definition cache or
      from disk and then to create TABLE object for it.
    */
    tc->unlock();
  }
}

  mysql_mutex_lock(&LOCK_open);

  if (!(share = get_table_share_with_discover(
            thd, table_list, key, key_length,
            flags & MYSQL_OPEN_SECONDARY_ENGINE, &error))) {
    mysql_mutex_unlock(&LOCK_open);
    /*
      If thd->is_error() is not set, we either need discover
      (error == 7), or the error was silenced by the prelocking
      handler (error == 0), in which case we should skip this
      table.
    */
    if (error == 7 && !thd->is_error()) {
      (void)ot_ctx->request_backoff_action(Open_table_context::OT_DISCOVER,
                                           table_list);
    }
    return true;
  }

  /*
    If a view is anticipated or the TABLE_SHARE object is a view, perform
    a version check for it without creating a TABLE object.

    Note that there is no need to call TABLE_SHARE::has_old_version() as we
    do for regular tables, because view shares are always up to date.
  */
  if (table_list->is_view() || share->is_view) {
    bool view_open_result = true;
    /*
      If parent_l of the table_list is non null then a merge table
      has this view as child table, which is not supported.
    */
    if (table_list->parent_l) my_error(ER_WRONG_MRG_TABLE, MYF(0));
    /*
      Validate metadata version: in particular, that a view is opened when
      it is expected, or that a table is opened when it is expected.
    */
    else if (check_and_update_table_version(thd, table_list, share))
      ;
    else if (table_list->open_strategy == Table_ref::OPEN_FOR_CREATE) {
      /*
        Skip reading the view definition if the open is for a table to be
        created. This scenario will happen only when there exists a view and
        the current CREATE TABLE request is with the same name.
      */
      release_table_share(share);
      mysql_mutex_unlock(&LOCK_open);

      /*
        The LEX object is used by the executor and other parts of the
        code to detect the presence of a view. As this is
        OPEN_FOR_CREATE we skip the call to open_and_read_view(),
        which creates the LEX object, and create a dummy LEX object.

        For SP and PS, LEX objects are created at the time of
        statement prepare and open_table() is called for every execute
        after that. Skip creation of LEX objects if it is already
        present.
      */
      if (!table_list->is_view()) return add_view_place_holder(thd, table_list);
      return false;
    } else {
      /*
        Read definition of existing view.
      */
      view_open_result = open_and_read_view(thd, share, table_list);
    }

    /* TODO: Don't free this */
    release_table_share(share);
    mysql_mutex_unlock(&LOCK_open);

    if (view_open_result) return true;

    if (parse_view_definition(thd, table_list)) return true;

    assert(table_list->is_view());

    return false;
  }

share_found:
  if (!(flags & MYSQL_OPEN_IGNORE_FLUSH)) {
    if (share->has_old_version()) {
      /*
        We already have an MDL lock. But we have encountered an old
        version of table in the table definition cache which is possible
        when someone changes the table version directly in the cache
        without acquiring a metadata lock (e.g. this can happen during
        "rolling" FLUSH TABLE(S)).
        Release our reference to share, wait until old version of
        share goes away and then try to get new version of table share.
      */
      release_table_share(share);
      mysql_mutex_unlock(&LOCK_open);

      MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);
      bool wait_result;

      thd->push_internal_handler(&mdl_deadlock_handler);

      /*
        In case of deadlock we would like this thread to be preferred as
        a deadlock victim when this deadlock can be nicely handled by
        back-off and retry. We still have a few weird cases, like
        FLUSH TABLES <table-list> WITH READ LOCK, where we use strong
        metadata locks and open_tables() is called with some metadata
        locks pre-acquired. In these cases we still want to use DDL
        deadlock weight.
      */
      uint deadlock_weight = ot_ctx->can_back_off()
                                 ? MDL_wait_for_subgraph::DEADLOCK_WEIGHT_DML
                                 : mdl_ticket->get_deadlock_weight();

      wait_result =
          tdc_wait_for_old_version(thd, table_list->db, table_list->table_name,
                                   ot_ctx->get_timeout(), deadlock_weight);

      thd->pop_internal_handler();

      if (wait_result) return true;

      DEBUG_SYNC(thd, "open_table_before_retry");
      goto retry_share;
    }

    if (thd->open_tables &&
        thd->open_tables->s->version() != share->version()) {
      /*
        If the version changes while we're opening the tables,
        we have to back off, close all the tables opened-so-far,
        and try to reopen them. Note: refresh_version is currently
        changed only during FLUSH TABLES.
      */
      release_table_share(share);
      mysql_mutex_unlock(&LOCK_open);
      (void)ot_ctx->request_backoff_action(Open_table_context::OT_REOPEN_TABLES,
                                           nullptr);
      return true;
    }
  }

  mysql_mutex_unlock(&LOCK_open);

  DEBUG_SYNC(thd, "open_table_found_share");

  {
    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
    const dd::Table *table_def = nullptr;
    if (!(flags & MYSQL_OPEN_NO_NEW_TABLE_IN_SE) &&
        thd->dd_client()->acquire(share->db.str, share->table_name.str,
                                  &table_def)) {
      // Error is reported by the dictionary subsystem.
      goto err_lock;
    }

    if (table_def && table_def->hidden() == dd::Abstract_table::HT_HIDDEN_SE) {
      my_error(ER_NO_SUCH_TABLE, MYF(0), table_list->db,
               table_list->table_name);
      goto err_lock;
    }

    /* make a new table */
    if (!(table = (TABLE *)my_malloc(key_memory_TABLE, sizeof(*table),
                                     MYF(MY_WME))))
      goto err_lock;

    error = open_table_from_share(
        thd, share, alias,
        ((flags & MYSQL_OPEN_NO_NEW_TABLE_IN_SE)
             ? 0
             : ((uint)(HA_OPEN_KEYFILE | HA_OPEN_RNDFILE | HA_GET_INDEX |
                       HA_TRY_READ_ONLY))),
        EXTRA_RECORD, thd->open_options, table, false, table_def);

    if (error) {
      destroy(table);
      my_free(table);

      if (error == 7)
        (void)ot_ctx->request_backoff_action(Open_table_context::OT_DISCOVER,
                                             table_list);
      else if (error == 8)
        (void)ot_ctx->request_backoff_action(
            Open_table_context::OT_FIX_ROW_TYPE, table_list);
      else if (share->crashed)
        (void)ot_ctx->request_backoff_action(Open_table_context::OT_REPAIR,
                                             table_list);
      goto err_lock;
    } else if (share->crashed) {
      switch (thd->lex->sql_command) {
        case SQLCOM_ALTER_TABLE:
        case SQLCOM_REPAIR:
        case SQLCOM_CHECK:
        case SQLCOM_SHOW_CREATE:
          break;
        default:
          closefrm(table, false);
          destroy(table);
          my_free(table);
          my_error(ER_CRASHED_ON_USAGE, MYF(0), share->table_name.str);
          goto err_lock;
      }
    }

    if (open_table_entry_fini(thd, share, table_def, table)) {
      closefrm(table, false);
      destroy(table);
      my_free(table);
      goto err_lock;
    }
  }
  {
    /* Add new TABLE object to table cache for this connection. */
    Table_cache *tc = table_cache_manager.get_cache(thd);

    tc->lock();

    if (tc->add_used_table(thd, table)) {
      tc->unlock();
      goto err_lock;
    }
    tc->unlock();
  }
  thd->status_var.table_open_cache_misses++;

table_found:
  table->mdl_ticket = mdl_ticket;

  table->next = thd->open_tables; /* Link into simple list */
  thd->set_open_tables(table);

  table->reginfo.lock_type = TL_READ; /* Assume read */

reset:
  table->reset();
  table->set_created();
  /*
    Check that there is no reference to a condition from an earlier query
    (cf. Bug#58553).
  */
  assert(table->file->pushed_cond == nullptr);

  // Table is not a derived table and not a non-updatable view:
  table_list->set_updatable();
  table_list->set_insertable();

  table_list->table = table;

  /*
    Position for each partition in the bitmap is read from the Handler_share
    instance of the table. In MYSQL_OPEN_NO_NEW_TABLE_IN_SE mode, table is not
    opened in the SE and Handler_share instance for it is not created. Hence
    skipping partitions bitmap setting in the MYSQL_OPEN_NO_NEW_TABLE_IN_SE
    mode.
  */
  if (!(flags & MYSQL_OPEN_NO_NEW_TABLE_IN_SE)) {
    if (table->part_info) {
      /* Set all [named] partitions as used. */
      if (table->part_info->set_partition_bitmaps(table_list)) return true;
    } else if (table_list->partition_names) {
      /* Don't allow PARTITION () clause on a nonpartitioned table */
      my_error(ER_PARTITION_CLAUSE_ON_NONPARTITIONED, MYF(0));
      return true;
    }
  }

  table->init(thd, table_list);

  /* Request a read lock for implicitly opened P_S tables. */
  if (in_LTM(thd) && table_list->table->file->get_lock_type() == F_UNLCK &&
      belongs_to_p_s(table_list)) {
    table_list->table->file->ha_external_lock(thd, F_RDLCK);
  }

  return false;

err_lock:
  mysql_mutex_lock(&LOCK_open);
  release_table_share(share);
  mysql_mutex_unlock(&LOCK_open);

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: Open_table_context::Open_table_context
Open_table_context::Open_table_context(THD *thd, uint flags)
    : m_thd(thd),
      m_failed_table(nullptr),
      m_start_of_statement_svp(thd->mdl_context.mdl_savepoint()),
      m_timeout(flags & MYSQL_LOCK_IGNORE_TIMEOUT
                    ? LONG_TIMEOUT
                    : thd->variables.lock_wait_timeout),
      m_flags(flags),
      m_action(OT_NO_ACTION),
      m_has_locks(thd->mdl_context.has_locks()),
      m_has_protection_against_grl(false) {} 

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: Open_table_context::recover_from_failed_open
bool Open_table_context::recover_from_failed_open() {
  if (m_action == OT_REPAIR) {
    DEBUG_SYNC(m_thd, "recover_ot_repair");
  }

  /*
    Skip repair and discovery in IS-queries as they require X lock
    which could lead to delays or deadlock. Instead set
    ER_WARN_I_S_SKIPPED_TABLE which will be converted to a warning
    later.
   */
  if ((m_action == OT_REPAIR || m_action == OT_DISCOVER ||
       m_action == OT_FIX_ROW_TYPE) &&
      (m_flags & MYSQL_OPEN_FAIL_ON_MDL_CONFLICT)) {
    my_error(ER_WARN_I_S_SKIPPED_TABLE, MYF(0),
             m_failed_table->mdl_request.key.db_name(),
             m_failed_table->mdl_request.key.name());
    return true;
  }

  bool result = false;
  MDL_deadlock_discovery_repair_handler handler;
  /*
    Install error handler to mark transaction to rollback on DEADLOCK error.
  */
  m_thd->push_internal_handler(&handler);

  /* Execute the action. */
  switch (m_action) {
    case OT_BACKOFF_AND_RETRY:
      break;
    case OT_REOPEN_TABLES:
      break;
    case OT_DISCOVER: {
      if ((result = lock_table_names(m_thd, m_failed_table, nullptr,
                                     get_timeout(), 0)))
        break;

      tdc_remove_table(m_thd, TDC_RT_REMOVE_ALL, m_failed_table->db,
                       m_failed_table->table_name, false);
      if (ha_create_table_from_engine(m_thd, m_failed_table->db,
                                      m_failed_table->table_name)) {
        result = true;
        break;
      }

      m_thd->get_stmt_da()->reset_condition_info(m_thd);
      m_thd->clear_error();  // Clear error message
      /*
        Rollback to start of the current statement to release exclusive lock
        on table which was discovered but preserve locks from previous
        statements in current transaction.
      */
      m_thd->mdl_context.rollback_to_savepoint(start_of_statement_svp());
      break;
    }
    case OT_REPAIR: {
      if ((result = lock_table_names(m_thd, m_failed_table, nullptr,
                                     get_timeout(), 0)))
        break;

      tdc_remove_table(m_thd, TDC_RT_REMOVE_ALL, m_failed_table->db,
                       m_failed_table->table_name, false);

      result = auto_repair_table(m_thd, m_failed_table);
      /*
        Rollback to start of the current statement to release exclusive lock
        on table which was discovered but preserve locks from previous
        statements in current transaction.
      */
      m_thd->mdl_context.rollback_to_savepoint(start_of_statement_svp());
      break;
    }
    case OT_FIX_ROW_TYPE: {
      /*
        Since we are going to commit changes to the data-dictionary there
        should not be any ongoing transaction.
        We already have checked that the connection holds no metadata locks
        earlier.
        Still there can be transaction started by START TRANSACTION, which
        we don't have right to implicitly finish (even more interesting case
        is START TRANSACTION WITH CONSISTENT SNAPSHOT). Hence explicit check
        for active transaction.
      */
      assert(!m_thd->mdl_context.has_locks());

      if (m_thd->in_active_multi_stmt_transaction()) {
        my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
        result = true;
        break;
      }

      if ((result = lock_table_names(m_thd, m_failed_table, nullptr,
                                     get_timeout(), 0)))
        break;

      result = fix_row_type(m_thd, m_failed_table);

      m_thd->mdl_context.release_transactional_locks();
      break;
    }
    default:
      assert(0);
  }
  m_thd->pop_internal_handler();
  /*
    Reset the pointers to conflicting MDL request and the
    Table_ref element, set when we need auto-discovery or repair,
    for safety.
  */
  m_failed_table = nullptr;
  /*
    Reset flag indicating that we have already acquired protection
    against GRL. It is no longer valid as the corresponding lock was
    released by close_tables_for_reopen().
  */
  m_has_protection_against_grl = false;
  /* Prepare for possible another back-off. */
  m_action = OT_NO_ACTION;
  return result;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_tables
bool open_tables(THD *thd, Table_ref **start, uint *counter, uint flags,
                 Prelocking_strategy *prelocking_strategy) {
  /*
    We use pointers to "next_global" member in the last processed
    Table_ref element and to the "next" member in the last processed
    Sroutine_hash_entry element as iterators over, correspondingly, the table
    list and stored routines list which stay valid and allow to continue
    iteration when new elements are added to the tail of the lists.
  */
  Table_ref **table_to_open;
  TABLE *old_table;
  Sroutine_hash_entry **sroutine_to_open;
  Table_ref *tables;
  Open_table_context ot_ctx(thd, flags);
  bool error = false;
  bool some_routine_modifies_data = false;
  bool has_prelocking_list;
  DBUG_TRACE;
  bool audit_notified = false;

restart:
  /*
    Close HANDLER tables which are marked for flush or against which there
    are pending exclusive metadata locks. This is needed both in order to
    avoid deadlocks and to have a point during statement execution at
    which such HANDLERs are closed even if they don't create problems for
    the current session (i.e. to avoid having a DDL blocked by HANDLERs
    opened for a long time).
  */
  if (!thd->handler_tables_hash.empty()) mysql_ha_flush(thd);

  has_prelocking_list = thd->lex->requires_prelocking();
  table_to_open = start;
  old_table = *table_to_open ? (*table_to_open)->table : nullptr;
  sroutine_to_open = &thd->lex->sroutines_list.first;
  *counter = 0;

  if (!(thd->state_flags & Open_tables_state::SYSTEM_TABLES))
    THD_STAGE_INFO(thd, stage_opening_tables);

  /*
    If we are executing LOCK TABLES statement or a DDL statement
    (in non-LOCK TABLES mode) we might have to acquire upgradable
    semi-exclusive metadata locks (SNW or SNRW) on some of the
    tables to be opened.
    When executing CREATE TABLE .. If NOT EXISTS .. SELECT, the
    table may not yet exist, in which case we acquire an exclusive
    lock.
    We acquire all such locks at once here as doing this in one
    by one fashion may lead to deadlocks or starvation. Later when
    we will be opening corresponding table pre-acquired metadata
    lock will be reused (thanks to the fact that in recursive case
    metadata locks are acquired without waiting).
  */
  if (!(flags & (MYSQL_OPEN_HAS_MDL_LOCK | MYSQL_OPEN_FORCE_SHARED_MDL |
                 MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL))) {
    if (thd->locked_tables_mode) {
      /*
        Under LOCK TABLES, we can't acquire new locks, so we instead
        need to check if appropriate locks were pre-acquired.
      */
      Table_ref *end_table = thd->lex->first_not_own_table();
      if (open_tables_check_upgradable_mdl(thd, *start, end_table) ||
          acquire_backup_lock_in_lock_tables_mode(thd, *start, end_table)) {
        error = true;
        goto err;
      }
    } else {
      Table_ref *table;
      if (lock_table_names(thd, *start, thd->lex->first_not_own_table(),
                           ot_ctx.get_timeout(), flags)) {
        error = true;
        goto err;
      }
      for (table = *start; table && table != thd->lex->first_not_own_table();
           table = table->next_global) {
        if (table->mdl_request.is_ddl_or_lock_tables_lock_request() ||
            table->open_strategy == Table_ref::OPEN_FOR_CREATE)
          table->mdl_request.ticket = nullptr;
      }
    }
  }

  /*
    Perform steps of prelocking algorithm until there are unprocessed
    elements in prelocking list/set.
  */
  while (*table_to_open ||
         (thd->locked_tables_mode <= LTM_LOCK_TABLES && *sroutine_to_open)) {
    /*
      For every table in the list of tables to open, try to find or open
      a table.
    */
    for (tables = *table_to_open; tables;
         table_to_open = &tables->next_global, tables = tables->next_global) {
      old_table = (*table_to_open)->table;
      error = open_and_process_table(thd, thd->lex, tables, counter,
                                     prelocking_strategy, has_prelocking_list,
                                     &ot_ctx);

      if (error) {
        if (ot_ctx.can_recover_from_failed_open()) {
          /*
            We have met exclusive metadata lock or old version of table.
            Now we have to close all tables and release metadata locks.
            We also have to throw away set of prelocked tables (and thus
            close tables from this set that were open by now) since it
            is possible that one of tables which determined its content
            was changed.

            Instead of implementing complex/non-robust logic mentioned
            above we simply close and then reopen all tables.

            We have to save pointer to table list element for table which we
            have failed to open since closing tables can trigger removal of
            elements from the table list (if MERGE tables are involved),
          */
          close_tables_for_reopen(thd, start, ot_ctx.start_of_statement_svp());

          /*
            Here we rely on the fact that 'tables' still points to the valid
            Table_ref element. Although currently this assumption is valid
            it may change in future.
          */
          if (ot_ctx.recover_from_failed_open()) goto err;

          /* Re-open temporary tables after close_tables_for_reopen(). */
          if (open_temporary_tables(thd, *start)) goto err;

          error = false;
          goto restart;
        }
        goto err;
      }

      DEBUG_SYNC(thd, "open_tables_after_open_and_process_table");
    }

    /*
      Iterate through set of tables and generate table access audit events.
    */
    if (!audit_notified && mysql_audit_table_access_notify(thd, *start)) {
      error = true;
      goto err;
    }

    /*
      Event is not generated in the next loop. It may contain duplicated
      table entries as well as new tables discovered for stored procedures.
      Events for these tables will be generated during the queries of these
      stored procedures.
    */
    audit_notified = true;

    /*
      If we are not already in prelocked mode and extended table list is
      not yet built for our statement we need to cache routines it uses
      and build the prelocking list for it.
      If we are not in prelocked mode but have built the extended table
      list, we still need to call open_and_process_routine() to take
      MDL locks on the routines.
    */
    if (thd->locked_tables_mode <= LTM_LOCK_TABLES) {
      bool routine_modifies_data;
      /*
        Process elements of the prelocking set which are present there
        since parsing stage or were added to it by invocations of
        Prelocking_strategy methods in the above loop over tables.

        For example, if element is a routine, cache it and then,
        if prelocking strategy prescribes so, add tables it uses to the
        table list and routines it might invoke to the prelocking set.
      */
      for (Sroutine_hash_entry *rt = *sroutine_to_open; rt;
           sroutine_to_open = &rt->next, rt = rt->next) {
        bool need_prelocking = false;
        Table_ref **save_query_tables_last = thd->lex->query_tables_last;

        error = open_and_process_routine(
            thd, thd->lex, rt, prelocking_strategy, has_prelocking_list,
            &ot_ctx, &need_prelocking, &routine_modifies_data);

        if (need_prelocking && !thd->lex->requires_prelocking())
          thd->lex->mark_as_requiring_prelocking(save_query_tables_last);

        if (need_prelocking && !*start) *start = thd->lex->query_tables;

        if (error) {
          if (ot_ctx.can_recover_from_failed_open()) {
            close_tables_for_reopen(thd, start,
                                    ot_ctx.start_of_statement_svp());
            if (ot_ctx.recover_from_failed_open()) goto err;

            /* Re-open temporary tables after close_tables_for_reopen(). */
            if (open_temporary_tables(thd, *start)) goto err;

            error = false;
            goto restart;
          }
          /*
            Serious error during reading stored routines from mysql.proc table.
            Something is wrong with the table or its contents, and an error has
            been emitted; we must abort.
          */
          goto err;
        }

        // Remember if any of SF modifies data.
        some_routine_modifies_data |= routine_modifies_data;
      }
    }
  }

  /* Accessing data in XA_IDLE or XA_PREPARED is not allowed. */
  if (*start &&
      (thd->get_transaction()->xid_state()->check_xa_idle_or_prepared(true) ||
       thd->get_transaction()->xid_state()->xa_trans_rolled_back()))
    return true;

  /*
   If some routine is modifying the table then the statement is not read only.
   If timer is enabled then resetting the timer in this case.
  */
  if (thd->timer && some_routine_modifies_data) {
    reset_statement_timer(thd);
    push_warning(thd, Sql_condition::SL_NOTE, ER_NON_RO_SELECT_DISABLE_TIMER,
                 ER_THD(thd, ER_NON_RO_SELECT_DISABLE_TIMER));
  }

  /*
    After successful open of all tables, including MERGE parents and
    children, attach the children to their parents. At end of statement,
    the children are detached. Attaching and detaching are always done,
    even under LOCK TABLES.

    We also convert all TL_WRITE_DEFAULT and TL_READ_DEFAULT locks to
    appropriate "real" lock types to be used for locking and to be passed
    to storage engine.
  */
  for (tables = *start; tables; tables = tables->next_global) {
    TABLE *tbl = tables->table;

    /*
      NOTE: temporary merge tables should be processed here too, because
      a temporary merge table can be based on non-temporary tables.
    */

    /* Schema tables may not have a TABLE object here. */
    if (tbl && tbl->file && tbl->file->ht->db_type == DB_TYPE_MRG_MYISAM) {
      /* MERGE tables need to access parent and child TABLE_LISTs. */
      assert(tbl->pos_in_table_list == tables);
      if (tbl->db_stat && tbl->file->ha_extra(HA_EXTRA_ATTACH_CHILDREN)) {
        error = true;
        goto err;
      }
    }

    /*
      Access to ACL table in a SELECT ... LOCK IN SHARE MODE are required
      to skip acquiring row locks. So, we use TL_READ_DEFAULT lock on ACL
      tables. This allows concurrent ACL DDL's.

      Do not request SE to skip row lock if 'flags' has
      MYSQL_OPEN_FORCE_SHARED_MDL, which indicates that this is PREPARE
      phase. It is OK to do so since during this phase no rows will be read
      anyway. And by doing this we avoid generation of extra warnings.
      EXECUTION phase will request SE to skip row locks if necessary.
    */
    bool issue_warning_on_skipping_row_lock = false;
    if (tables->lock_descriptor().type == TL_READ_WITH_SHARED_LOCKS &&
        !(flags & MYSQL_OPEN_FORCE_SHARED_MDL) &&
        is_acl_table_in_non_LTM(tables, thd->locked_tables_mode)) {
      tables->set_lock({TL_READ_DEFAULT, THR_DEFAULT});
      issue_warning_on_skipping_row_lock = true;
    }

    /* Set appropriate TABLE::lock_type. */
    if (tbl && tables->lock_descriptor().type != TL_UNLOCK &&
        !thd->locked_tables_mode) {
      if (tables->lock_descriptor().type == TL_WRITE_DEFAULT)
        tbl->reginfo.lock_type = thd->update_lock_default;
      else if (tables->lock_descriptor().type == TL_WRITE_CONCURRENT_DEFAULT)
        tables->table->reginfo.lock_type = thd->insert_lock_default;
      else if (tables->lock_descriptor().type == TL_READ_DEFAULT)
        tbl->reginfo.lock_type = read_lock_type_for_table(
            thd, thd->lex, tables, some_routine_modifies_data);
      else
        tbl->reginfo.lock_type = tables->lock_descriptor().type;
    }

    /*
      SELECT using a I_S system view with 'FOR UPDATE' and
      'LOCK IN SHARED MODE' clause is not allowed.
    */
    if (tables->is_system_view &&
        tables->lock_descriptor().type == TL_READ_WITH_SHARED_LOCKS) {
      my_error(ER_IS_QUERY_INVALID_CLAUSE, MYF(0), "LOCK IN SHARE MODE");
      error = true;
      goto err;
    }

    // Setup lock type for DD tables used under I_S view.
    if (set_non_locking_read_for_IS_view(thd, tables)) {
      error = true;
      goto err;
    }

    /**
      Setup lock type for read requests for ACL table in SQL statements.

      Do not request SE to skip row lock if 'flags' has
      MYSQL_OPEN_FORCE_SHARED_MDL, which indicates that this is PREPARE
      phase. It is OK to do so since during this phase no rows will be read
      anyway. And by doing this we avoid generation of extra warnings.
      EXECUTION phase will request SE to skip row locks if necessary.
    */
    if (!(flags & MYSQL_OPEN_FORCE_SHARED_MDL) &&
        set_non_locking_read_for_ACL_table(
            thd, tables, issue_warning_on_skipping_row_lock)) {
      error = true;
      goto err;
    }

  }  // End of for(;;)

err:
  // If a new TABLE was introduced, it's garbage, don't link to it:
  if (error && *table_to_open && old_table != (*table_to_open)->table) {
    (*table_to_open)->table = nullptr;
  }
  DBUG_PRINT("open_tables", ("returning: %d", (int)error));
  return error;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_table_get_mdl_lock
static bool open_table_get_mdl_lock(THD *thd, Open_table_context *ot_ctx,
                                    Table_ref *table_list, uint flags,
                                    MDL_ticket **mdl_ticket) {
  MDL_request *mdl_request = &table_list->mdl_request;
  MDL_request new_mdl_request;

  if (flags &
      (MYSQL_OPEN_FORCE_SHARED_MDL | MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL)) {
    /*
      MYSQL_OPEN_FORCE_SHARED_MDL flag means that we are executing
      PREPARE for a prepared statement and want to override
      the type-of-operation aware metadata lock which was set
      in the parser/during view opening with a simple shared
      metadata lock.
      This is necessary to allow concurrent execution of PREPARE
      and LOCK TABLES WRITE statement against the same table.

      MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL flag means that we open
      the table in order to get information about it for one of I_S
      queries and also want to override the type-of-operation aware
      shared metadata lock which was set earlier (e.g. during view
      opening) with a high-priority shared metadata lock.
      This is necessary to avoid unnecessary waiting and extra
      ER_WARN_I_S_SKIPPED_TABLE warnings when accessing I_S tables.

      These two flags are mutually exclusive.
    */
    assert(!(flags & MYSQL_OPEN_FORCE_SHARED_MDL) ||
           !(flags & MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL));

    MDL_REQUEST_INIT_BY_KEY(&new_mdl_request, &mdl_request->key,
                            (flags & MYSQL_OPEN_FORCE_SHARED_MDL)
                                ? MDL_SHARED
                                : MDL_SHARED_HIGH_PRIO,
                            MDL_TRANSACTION);
    mdl_request = &new_mdl_request;
  } else if (thd->variables.low_priority_updates &&
             mdl_request->type == MDL_SHARED_WRITE &&
             (table_list->lock_descriptor().type == TL_WRITE_DEFAULT ||
              table_list->lock_descriptor().type ==
                  TL_WRITE_CONCURRENT_DEFAULT)) {
    /*
      We are in @@low_priority_updates=1 mode and are going to acquire
      SW metadata lock on a table which for which neither LOW_PRIORITY nor
      HIGH_PRIORITY clauses were used explicitly.
      To keep compatibility with THR_LOCK locks and to avoid starving out
      concurrent LOCK TABLES READ statements, we need to acquire the low-prio
      version of SW lock instead of a normal SW lock in this case.
    */
    MDL_REQUEST_INIT_BY_KEY(&new_mdl_request, &mdl_request->key,
                            MDL_SHARED_WRITE_LOW_PRIO, MDL_TRANSACTION);
    mdl_request = &new_mdl_request;
  }

  if (flags & MYSQL_OPEN_FAIL_ON_MDL_CONFLICT) {
    /*
      When table is being open in order to get data for I_S table,
      we might have some tables not only open but also locked (e.g. when
      this happens under LOCK TABLES or in a stored function).
      As a result by waiting on a conflicting metadata lock to go away
      we may create a deadlock which won't entirely belong to the
      MDL subsystem and thus won't be detectable by this subsystem's
      deadlock detector.
      To avoid such situation we skip the trouble-making table if
      there is a conflicting lock.
    */
    if (thd->mdl_context.try_acquire_lock(mdl_request)) return true;
    if (mdl_request->ticket == nullptr) {
      my_error(ER_WARN_I_S_SKIPPED_TABLE, MYF(0), mdl_request->key.db_name(),
               mdl_request->key.name());
      return true;
    }
  } else {
    /*
      We are doing a normal table open. Let us try to acquire a metadata
      lock on the table. If there is a conflicting lock, acquire_lock()
      will wait for it to go away. Sometimes this waiting may lead to a
      deadlock, with the following results:
      1) If a deadlock is entirely within MDL subsystem, it is
         detected by the deadlock detector of this subsystem.
         ER_LOCK_DEADLOCK error is produced. Then, the error handler
         that is installed prior to the call to acquire_lock() attempts
         to request a back-off and retry. Upon success, ER_LOCK_DEADLOCK
         error is suppressed, otherwise propagated up the calling stack.
      2) Otherwise, a deadlock may occur when the wait-for graph
         includes edges not visible to the MDL deadlock detector.
         One such example is a wait on an InnoDB row lock, e.g. when:
         conn C1 gets SR MDL lock on t1 with SELECT * FROM t1
         conn C2 gets a row lock on t2 with  SELECT * FROM t2 FOR UPDATE
         conn C3 gets in and waits on C1 with DROP TABLE t0, t1
         conn C2 continues and blocks on C3 with SELECT * FROM t0
         conn C1 deadlocks by waiting on C2 by issuing SELECT * FROM
         t2 LOCK IN SHARE MODE.
         Such circular waits are currently only resolved by timeouts,
         e.g. @@innodb_lock_wait_timeout or @@lock_wait_timeout.

      Note that we want to force DML deadlock weight for our context
      when acquiring locks in this place. This is done to avoid situation
      when LOCK TABLES statement, which acquires strong SNRW and SRO locks
      on implicitly used tables, deadlocks with a concurrent DDL statement
      and the DDL statement is aborted since it is chosen as a deadlock
      victim. It is better to choose LOCK TABLES as a victim in this case
      as a deadlock can be easily caught here and handled by back-off and retry,
      without reporting any error to the user.
      We still have a few weird cases, like FLUSH TABLES <table-list> WITH
      READ LOCK, where we use "strong" metadata locks and open_tables() is
      called with some metadata locks pre-acquired. In these cases we still
      want to use DDL deadlock weight as back-off is not possible.
    */
    MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);

    thd->push_internal_handler(&mdl_deadlock_handler);
    thd->mdl_context.set_force_dml_deadlock_weight(ot_ctx->can_back_off());

    bool result =
        thd->mdl_context.acquire_lock(mdl_request, ot_ctx->get_timeout());

    thd->mdl_context.set_force_dml_deadlock_weight(false);
    thd->pop_internal_handler();

    if (result && !ot_ctx->can_recover_from_failed_open()) return true;
  }
  *mdl_ticket = mdl_request->ticket;
  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_and_process_routine
static bool open_and_process_routine(
    THD *thd, Query_tables_list *prelocking_ctx, Sroutine_hash_entry *rt,
    Prelocking_strategy *prelocking_strategy, bool has_prelocking_list,
    Open_table_context *ot_ctx, bool *need_prelocking,
    bool *routine_modifies_data) {
  *routine_modifies_data = false;
  DBUG_TRACE;

  switch (rt->type()) {
    case Sroutine_hash_entry::FUNCTION:
    case Sroutine_hash_entry::PROCEDURE: {
      sp_head *sp;
      /*
        Try to get MDL lock on the routine.
        Note that we do not take locks on top-level CALLs as this can
        lead to a deadlock. Not locking top-level CALLs does not break
        the binlog as only the statements in the called procedure show
        up there, not the CALL itself.
      */
      if (rt != prelocking_ctx->sroutines_list.first ||
          rt->type() != Sroutine_hash_entry::PROCEDURE) {
        MDL_request mdl_request;
        MDL_key mdl_key;

        if (rt->type() == Sroutine_hash_entry::FUNCTION)
          dd::Function::create_mdl_key(rt->db(), rt->name(), &mdl_key);
        else
          dd::Procedure::create_mdl_key(rt->db(), rt->name(), &mdl_key);

        MDL_REQUEST_INIT_BY_KEY(&mdl_request, &mdl_key, MDL_SHARED,
                                MDL_TRANSACTION);

        /*
          Waiting for a conflicting metadata lock to go away may
          lead to a deadlock, detected by MDL subsystem.
          If possible, we try to resolve such deadlocks by releasing all
          metadata locks and restarting the pre-locking process.
          To prevent the error from polluting the Diagnostics Area
          in case of successful resolution, install a special error
          handler for ER_LOCK_DEADLOCK error.
        */
        MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);

        thd->push_internal_handler(&mdl_deadlock_handler);
        bool result =
            thd->mdl_context.acquire_lock(&mdl_request, ot_ctx->get_timeout());
        thd->pop_internal_handler();

        if (result) return true;

        DEBUG_SYNC(thd, "after_shared_lock_pname");

        /* Ensures the routine is up-to-date and cached, if exists. */
        if (sp_cache_routine(thd, rt, has_prelocking_list, &sp)) return true;

        /* Remember the version of the routine in the parse tree. */
        if (check_and_update_routine_version(thd, rt, sp)) return true;

        /* 'sp' is NULL when there is no such routine. */
        if (sp) {
          *routine_modifies_data = sp->modifies_data();

          if (!has_prelocking_list)
            prelocking_strategy->handle_routine(thd, prelocking_ctx, rt, sp,
                                                need_prelocking);
        }
      } else {
        /*
          If it's a top level call, just make sure we have a recent
          version of the routine, if it exists.
          Validating routine version is unnecessary, since CALL
          does not affect the prepared statement prelocked list.
        */
        if (sp_cache_routine(thd, rt, false, &sp)) return true;
      }
    } break;
    case Sroutine_hash_entry::TRIGGER:
      /**
        We add trigger entries to lex->sroutines_list, but we don't
        load them here. The trigger entry is only used when building
        a transitive closure of objects used in a statement, to avoid
        adding to this closure objects that are used in the trigger more
        than once.
        E.g. if a trigger trg refers to table t2, and the trigger table t1
        is used multiple times in the statement (say, because it's used in
        function f1() twice), we will only add t2 once to the list of
        tables to prelock.

        We don't take metadata locks on triggers either: they are protected
        by a respective lock on the table, on which the trigger is defined.

        The only two cases which give "trouble" are SHOW CREATE TRIGGER
        and DROP TRIGGER statements. For these, statement syntax doesn't
        specify the table on which this trigger is defined, so we have
        to make a "dirty" read in the data dictionary to find out the
        table name. Once we discover the table name, we take a metadata
        lock on it, and this protects all trigger operations.
        Of course the table, in theory, may disappear between the dirty
        read and metadata lock acquisition, but in that case we just return
        a run-time error.

        Grammar of other trigger DDL statements (CREATE, DROP) requires
        the table to be specified explicitly, so we use the table metadata
        lock to protect trigger metadata in these statements. Similarly, in
        DML we always use triggers together with their tables, and thus don't
        need to take separate metadata locks on them.
      */
      break;
    case Sroutine_hash_entry::FK_TABLE_ROLE_PARENT_CHECK:
    case Sroutine_hash_entry::FK_TABLE_ROLE_CHILD_CHECK:
    case Sroutine_hash_entry::FK_TABLE_ROLE_CHILD_UPDATE:
    case Sroutine_hash_entry::FK_TABLE_ROLE_CHILD_DELETE: {
      if (thd->locked_tables_mode == LTM_NONE) {
        MDL_request mdl_request;

        /*
          Adjust metadata lock type according to the table's role in the
          FK relationship. Also acquire stronger locks when we are locking
          on behalf of LOCK TABLES.
        */
        enum_mdl_type mdl_lock_type;
        bool executing_LT = (prelocking_ctx->sql_command == SQLCOM_LOCK_TABLES);

        if (rt->type() == Sroutine_hash_entry::FK_TABLE_ROLE_PARENT_CHECK ||
            rt->type() == Sroutine_hash_entry::FK_TABLE_ROLE_CHILD_CHECK) {
          mdl_lock_type =
              (executing_LT ? MDL_SHARED_READ_ONLY : MDL_SHARED_READ);
        } else {
          mdl_lock_type =
              (executing_LT ? MDL_SHARED_NO_READ_WRITE : MDL_SHARED_WRITE);
        }

        MDL_REQUEST_INIT_BY_PART_KEY(&mdl_request, MDL_key::TABLE,
                                     rt->part_mdl_key(),
                                     rt->part_mdl_key_length(), rt->db_length(),
                                     mdl_lock_type, MDL_TRANSACTION);

        MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);

        thd->push_internal_handler(&mdl_deadlock_handler);
        bool result =
            thd->mdl_context.acquire_lock(&mdl_request, ot_ctx->get_timeout());
        thd->pop_internal_handler();

        if (result) return true;
      } else {
        /*
          This function is called only if we are not in prelocked mode
          already. So we must be handling statement executed under
          LOCK TABLES in this case.
        */
        assert(thd->locked_tables_mode == LTM_LOCK_TABLES);

        /*
          Even though LOCK TABLES tries to automatically lock parent and child
          tables which might be necessary for foreign key checks/actions, there
          are some cases when we might miss them. So it is better to check that
          we have appropriate metadata lock explicitly and error out if not.

          Some examples of problematic cases are:

          *) We are executing DELETE FROM t1 under LOCK TABLES t1 READ
             and table t1 is a parent in a foreign key.
             In this case error about inappropriate lock on t1 will be
             reported at later stage than prelocking set is built.
             So we can't assume/assert that we have proper lock on the
             corresponding child table here.

         *)  Table t1 has a trigger, which contains DELETE FROM t2 and
             t2 is participating in FK as parent. In such situation
             LOCK TABLE t1 WRITE will lock t2 for write implicitly
             so both updates and delete on t2 will be allowed. However,
             t3 will be locked only in a way as if only deletes from
             t2 were allowed.

          *) Prelocking list has been built earlier. Both child and parent
             definitions might have changed since this time so at LOCK TABLES
             time FK which corresponds to this element of prelocked set
             might be no longer around. In theory, we might be processing
         statement which is not marked as requiring prelocked set invalidation
         (and thus ignoring table version mismatches) or tables might be missing
         and this error can be suppressed. In such case we might not have
         appropriate metadata lock on our child/parent table.
        */
        if (rt->type() == Sroutine_hash_entry::FK_TABLE_ROLE_PARENT_CHECK ||
            rt->type() == Sroutine_hash_entry::FK_TABLE_ROLE_CHILD_CHECK) {
          if (!thd->mdl_context.owns_equal_or_stronger_lock(
                  MDL_key::TABLE, rt->db(), rt->name(), MDL_SHARED_READ_ONLY)) {
            my_error(ER_TABLE_NOT_LOCKED, MYF(0), rt->name());
            return true;
          }
        } else {
          if (!thd->mdl_context.owns_equal_or_stronger_lock(
                  MDL_key::TABLE, rt->db(), rt->name(),
                  MDL_SHARED_NO_READ_WRITE)) {
            my_error(ER_TABLE_NOT_LOCKED_FOR_WRITE, MYF(0), rt->name());
            return true;
          }
        }
      }

      if (rt->type() == Sroutine_hash_entry::FK_TABLE_ROLE_CHILD_UPDATE ||
          rt->type() == Sroutine_hash_entry::FK_TABLE_ROLE_CHILD_DELETE) {
        /*
          In order to continue building prelocked set or validating
          prelocked set which already has been built we need to get
          access to table's TABLE_SHARE.

          Getting unused TABLE object is more scalable that going
          directly for the TABLE_SHARE. If there are no unused TABLE
          object we might get at least pointer to the TABLE_SHARE
          from the table cache.

          Note that under LOCK TABLES we can't rely on that table is
          going to be in THD::open_tables list, as LOCK TABLES only
          pre-acquires metadata locks on FK tables but doesn't
          pre-open them.

          TODO: Perhaps we should give it a try as it can be more
                scalability friendly.
        */
        Table_cache *tc = table_cache_manager.get_cache(thd);
        TABLE *table;
        TABLE_SHARE *share;

        tc->lock();

        table = tc->get_table(thd, rt->part_mdl_key(),
                              rt->part_mdl_key_length(), &share);

        if (table) {
          assert(table->s == share);
          /*
            Don't check if TABLE_SHARE::version matches version of tables
            previously opened by this statement. It might be problematic
            under LOCK TABLES and possible version difference can't affect
            FK-related part of prelocking set.
          */
          tc->unlock();
        } else if (share) {
          /*
            TODO: If we constantly hit this case it would harm scalability...
                  Perhaps we need to create new unused TABLE instance in this
                  case.
          */
          mysql_mutex_lock(&LOCK_open);
          tc->unlock();
          share->increment_ref_count();
          mysql_mutex_unlock(&LOCK_open);

          /*
            Again, when building part of prelocking set related to foreign keys
            we can ignore fact that TABLE_SHARE::version is old.
          */
        } else {
          tc->unlock();

          /*
            If we are validating existing prelocking set then the table
            might have been dropped. We suppress this error in this case.
            Prelocking set will be either invalidated, or error will be
            reported the parent table is accessed.

            TODO: Perhaps we need to use get_table_share_with_discover()
                  here but it gets complicated under LOCK TABLES.
          */
          No_such_table_error_handler no_such_table_handler;
          thd->push_internal_handler(&no_such_table_handler);

          mysql_mutex_lock(&LOCK_open);
          share = get_table_share(thd, rt->db(), rt->name(), rt->part_mdl_key(),
                                  rt->part_mdl_key_length(), true);
          mysql_mutex_unlock(&LOCK_open);

          thd->pop_internal_handler();

          if (!share && no_such_table_handler.safely_trapped_errors()) {
            break;  // Jump out switch without error.
          }

          if (!share) {
            return true;
          }

          if (share->is_view) {
            /*
              Eeek! Somebody replaced the child table with a view. This can
              happen only when we are validating existing prelocked set.
              Parent either have been dropped or its definition has been
              changed. In either case our child table won't be accessed
              through the foreign key.
            */
            assert(has_prelocking_list);

            mysql_mutex_lock(&LOCK_open);
            release_table_share(share);
            mysql_mutex_unlock(&LOCK_open);

            if (ask_to_reprepare(thd)) return true;

            break;  // Jump out switch without error.
          }
        }

        auto release_table_lambda = [thd](TABLE *tab) {
          release_or_close_table(thd, tab);
        };
        std::unique_ptr<TABLE, decltype(release_table_lambda)>
            release_table_guard(table, release_table_lambda);

        /*
          We need to explicitly release TABLE_SHARE only if we don't
          have TABLE object.
        */
        auto release_share_lambda = [](TABLE_SHARE *tsh) {
          mysql_mutex_lock(&LOCK_open);
          release_table_share(tsh);
          mysql_mutex_unlock(&LOCK_open);
        };
        std::unique_ptr<TABLE_SHARE, decltype(release_share_lambda)>
            release_share_guard((table ? nullptr : share),
                                release_share_lambda);

        /*
          We need to maintain versioning of the prelocked tables since this
          is needed for correct handling of prepared statements to catch
          situations where a prelocked table (which is added to the prelocked
          set during PREPARE) is changed between repeated executions of the
          prepared statement.
         */
        int64 share_version = share->get_table_ref_version();

        if (rt->m_cache_version != share_version) {
          /*
            Version of the cached table share is different from the
            previous execution of the prepared statement, and it is
            unacceptable for this SQLCOM.
          */
          if (ask_to_reprepare(thd)) return true;
          /* Always maintain the latest cache version. */
          rt->m_cache_version = share_version;
        }

        /*
          If the child may be affected by update/delete and is in a read only
          schema, we must reject the statement.
        */
        if (check_schema_readonly(thd, rt->db())) {
          my_error(ER_SCHEMA_READ_ONLY, MYF(0), rt->db());
          return true;
        }

        if (!has_prelocking_list) {
          bool is_update =
              (rt->type() == Sroutine_hash_entry::FK_TABLE_ROLE_CHILD_UPDATE);
          bool is_delete =
              (rt->type() == Sroutine_hash_entry::FK_TABLE_ROLE_CHILD_DELETE);

          process_table_fks(thd, prelocking_ctx, share, false, is_update,
                            is_delete, rt->belong_to_view, need_prelocking);
        }
      }
    } break;
    default:
      /* Impossible type value. */
      assert(0);
  }
  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: acquire_backup_lock_in_lock_tables_mode
static bool acquire_backup_lock_in_lock_tables_mode(THD *thd,
                                                    Table_ref *tables_start,
                                                    Table_ref *tables_end) {
  Table_ref *table;
  assert(thd->locked_tables_mode);

  for (table = tables_start; table && table != tables_end;
       table = table->next_global) {
    if (is_temporary_table_being_opened(table)) continue;

    if (table->mdl_request.is_ddl_or_lock_tables_lock_request() &&
        table->mdl_request.type != MDL_SHARED_READ_ONLY)
      return acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout);
  }

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.h
Function: Open_table_context::get_timeout
  inline ulong get_timeout() const { return m_timeout; }

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_component.cc
Function: Sql_cmd_install_component::execute
bool Sql_cmd_install_component::execute(THD *thd) {
  my_service<SERVICE_TYPE(persistent_dynamic_loader)> persisted_loader(
      "persistent_dynamic_loader", srv_registry);
  if (persisted_loader) {
    my_error(ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION, MYF(0),
             "persistent_dynamic_loader");
    return true;
  }

  if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard autocommit_guard(thd);
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  DBUG_EXECUTE_IF("disable_rg_pfs_notifications", {
    auto name = "file://component_test_pfs_notification";
    if (m_urns.size() == 1 && strcmp(name, m_urns[0].str) == 0)
      resourcegroups::Resource_group_mgr::instance()
          ->disable_pfs_notification();
  });

  m_arg_list_size = m_set_exprs->size() * 2 + 1;
  m_arg_list = thd->mem_root->ArrayAlloc<char *>(m_arg_list_size + 1);
  m_arg_list[m_arg_list_size] = nullptr;
  char **arg = m_arg_list;

  *arg++ = nullptr;  // no program name

  for (auto &set : *m_set_exprs) {
    if (!set.expr->fixed && set.expr->fix_fields(thd, &set.expr)) return true;

    char buff[STRING_BUFFER_USUAL_SIZE];
    String value(buff, sizeof(buff), system_charset_info), *val;
    val = set.expr->val_str(&value);

    if (!val || set.expr->is_null()) {
      String x;
      if (set.name.prefix.length > 0) {
        x.append(set.name.prefix);
        x.append('.');
      }
      x.append(set.name.name);
      my_error(ER_INSTALL_COMPONENT_SET_NULL_VALUE, MYF(0), x.c_ptr());
      return true;
    }

    String argument(STRING_WITH_LEN("--"), system_charset_info);
    if (set.name.prefix.length > 0) {
      argument.append(set.name.prefix);
      argument.append('.');
    }
    argument.append(set.name.name);
    char *arg_name = thd->strmake(argument.c_ptr(), argument.length());
    convert_underscore_to_dash(arg_name, argument.length());

    *arg++ = arg_name;
    *arg++ = thd->strmake(val->c_ptr_safe(), val->length());
  }

  std::vector<const char *> urns(m_urns.size());
  for (size_t i = 0; i < m_urns.size(); ++i) {
    urns[i] = m_urns[i].str;
  }
  if (persisted_loader->load(thd, urns.data(), m_urns.size())) {
    return (end_transaction(thd, true));
  }

  bool set_var_failed = false;

  if (m_arg_list_size > 1) {
    std::stringstream str;
    str << m_arg_list[1] + 2;
    for (int idx = 3; idx < m_arg_list_size; idx += 2)
      str << ((idx + 2 < m_arg_list_size) ? ", " : " and ")
          << (m_arg_list[idx] + 2);
    my_error(ER_INSTALL_COMPONENT_SET_UNUSED_VALUE, MYF(0), str.str().c_str());
    set_var_failed = true;
  }
  /* persist the values that need persisting */
  if (!set_var_failed && m_set_exprs->elements > 0) {
    Set_variables_helper hlp(thd);
    for (auto &set_var : *m_set_exprs) {
      enum_var_type type = set_var.type;
      /* we already did the SET GLOBAL part, convert to PERSIST */
      if (type == enum_var_type::OPT_PERSIST)
        type = enum_var_type::OPT_PERSIST_ONLY;

      if (type == enum_var_type::OPT_PERSIST ||
          type == enum_var_type::OPT_PERSIST_ONLY) {
        if (hlp.add_variable(set_var.name.prefix.str,
                             set_var.name.prefix.length, set_var.name.name.str,
                             set_var.name.name.length, set_var.expr, type)) {
          set_var_failed = true;
          break;
        }
      } else if (hlp.check_variable_update_type(
                     set_var.name.prefix.str, set_var.name.prefix.length,
                     set_var.name.name.str, set_var.name.name.length,
                     set_var.expr)) {
        set_var_failed = true;
        break;
      }
    }
    if (set_var_failed || hlp.execute()) {
      set_var_failed = true;
    }
  }
  if (set_var_failed) {
    if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout) ||
        acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout))
      return true;
    if (dynamic_loader_srv->unload(urns.data(), m_urns.size()) ||
        mysql_persistent_dynamic_loader_imp::remove_from_cache(
            urns.data(), urns.size()) != (int)urns.size()) {
      assert(0);
    }
    return (end_transaction(thd, true));
  }

  my_ok(thd);
  return (end_transaction(thd, false));
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_component.cc
Function: Sql_cmd_uninstall_component::execute
bool Sql_cmd_uninstall_component::execute(THD *thd) {
  my_service<SERVICE_TYPE(persistent_dynamic_loader)> service_dynamic_loader(
      "persistent_dynamic_loader", srv_registry);
  if (service_dynamic_loader) {
    my_error(ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION, MYF(0),
             "persistent_dynamic_loader");
    return true;
  }

  if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard autocommit_guard(thd);
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  std::vector<const char *> urns(m_urns.size());
  for (size_t i = 0; i < m_urns.size(); ++i) {
    urns[i] = m_urns[i].str;
  }
  if (service_dynamic_loader->unload(thd, urns.data(), m_urns.size())) {
    return (end_transaction(thd, true));
  }
  my_ok(thd);
  return (end_transaction(thd, false));
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_db.cc
Function: mysql_alter_db
bool mysql_alter_db(THD *thd, const char *db, HA_CREATE_INFO *create_info) {
  DBUG_TRACE;

  // Reject altering the system schema except for system threads.
  if (!thd->is_dd_system_thread() &&
      dd::get_dictionary()->is_dd_schema_name(db)) {
    my_error(ER_NO_SYSTEM_SCHEMA_ACCESS, MYF(0), db);
    return true;
  }

  /*
    Check if user has permission to alter database, if encryption type
    provided differ from global 'default_table_encryption' setting.
  */
  if (create_info->encrypt_type.str && opt_table_encryption_privilege_check &&
      dd::is_encrypted(create_info->encrypt_type) !=
          thd->variables.default_table_encryption &&
      check_table_encryption_admin_access(thd)) {
    my_error(ER_CANNOT_SET_DATABASE_ENCRYPTION, MYF(0));
    return true;
  }

  if (lock_schema_name(thd, db)) return true;

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  dd::Schema *schema = nullptr;
  if (thd->dd_client()->acquire_for_modification(db, &schema)) return true;

  if (schema == nullptr) {
    my_error(ER_NO_SUCH_DB, MYF(0), db);
    return true;
  }

  /*
    If the schema is in read_only state, then the only change allowed is to:

    - Turn off read_only, possibly along with other option changes.
    - Keep read_only turned on, i.e., a no-op. In this case, other options may
      not be changed in the same statement.

     This means we fail if:

     - HA_CREATE_USED_READ_ONLY is not set.
     - Or if we set other fields as well and set READ ONLY to true.

     We check this before locking tables to avoid unnecessary lock acquisition.
  */
  bool schema_read_only = false;
  schema_read_only = schema->read_only();
  if (!thread_can_ignore_schema_read_only(thd) && schema_read_only) {
    if (!(create_info->used_fields & HA_CREATE_USED_READ_ONLY) ||
        ((create_info->used_fields & ~HA_CREATE_USED_READ_ONLY) &&
         create_info->schema_read_only)) {
      my_error(ER_SCHEMA_READ_ONLY, MYF(0), db);
      return true;
    }
  }

  /*
    Lock all tables while under schema lock so that we block all transactions
    from touching these tables until the ALTER is done. Because the schema read
    only check and the COMMIT are not done atomically, we use the table MDL
    to serialize ALTER SCHEMA and any write statements.
  */
  Table_ref *tables = nullptr;
  if (find_db_tables(thd, *schema, db, &tables) ||
      lock_table_names(thd, tables, nullptr, thd->variables.lock_wait_timeout,
                       0))
    return true;

  // Set new collation ID if submitted in the statement.
  if (create_info->used_fields & HA_CREATE_USED_DEFAULT_CHARSET) {
    set_db_default_charset(thd, create_info);
    schema->set_default_collation_id(
        create_info->default_table_charset->number);
  }

  // Set encryption type.
  if (create_info->used_fields & HA_CREATE_USED_DEFAULT_ENCRYPTION) {
    assert(create_info->encrypt_type.length > 0);
    schema->set_default_encryption(dd::is_encrypted(create_info->encrypt_type));
  }

  // Set read_only option.
  if (create_info->used_fields & HA_CREATE_USED_READ_ONLY) {
    schema->set_read_only(create_info->schema_read_only);
  }

  // Update schema.
  if (thd->dd_client()->update(schema)) return true;

  /*
    The original query is submitted to the engine's log handler
    because e.g. NDB needs to propagate the read only option to
    other mysqld servers in the cluster.
  */
  ha_binlog_log_query(thd, nullptr, LOGCOM_ALTER_DB, thd->query().str,
                      thd->query().length, db, "");

  /*
    The original query is written to the binlog and hence replicated.
    Binlogging must be switched off while executing ALTER SCHEMA if
    this is not desired.
  */
  if (write_db_cmd_to_binlog(thd, db, true)) return true;

  /*
    Commit the statement locally instead of relying on caller,
    in order to be sure that it is successful, before changing
    options of current database.
  */
  if (trans_commit_stmt(thd) || trans_commit(thd)) return true;

  /*
    Change collation options if the current database is being
    altered and the clause is explicitly submitted in the ALTER
    statement.
  */
  if (create_info->used_fields & HA_CREATE_USED_DEFAULT_CHARSET &&
      thd->db().str && !my_strcasecmp(table_alias_charset, thd->db().str, db)) {
    thd->db_charset = create_info->default_table_charset
                          ? create_info->default_table_charset
                          : thd->variables.collation_server;
    thd->variables.collation_database = thd->db_charset;
  }

  /*
    If the schema read only option was changed, then we must also evict the
    tables belonging to the schema from the TDC since the option is cached
    in the table shares. This is safe since we have already acquired
    exclusive MDL for each table.
  */
  if (create_info->used_fields & HA_CREATE_USED_READ_ONLY) {
    mysql_ha_flush_tables(thd, tables);
    for (Table_ref *table = tables; table != nullptr;
         table = table->next_global) {
      tdc_remove_table(thd, TDC_RT_REMOVE_ALL, table->db, table->table_name,
                       false);
    }
  }

  my_ok(thd, 1);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_db.cc
Function: mysql_rm_db
bool mysql_rm_db(THD *thd, const LEX_CSTRING &db, bool if_exists) {
  ulong deleted_tables = 0;
  bool error = false;
  char path[2 * FN_REFLEN + 16];
  Table_ref *tables = nullptr;
  Table_ref *table;
  Drop_table_error_handler err_handler;
  bool dropped_non_atomic = false;
  std::set<handlerton *> post_ddl_htons;
  Foreign_key_parents_invalidator fk_invalidator;

  DBUG_TRACE;

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  // Reject dropping the system schema except for system threads.
  if (!thd->is_dd_system_thread() &&
      dd::get_dictionary()->is_dd_schema_name(dd::String_type(db.str))) {
    my_error(ER_NO_SYSTEM_SCHEMA_ACCESS, MYF(0), db.str);
    return true;
  }

  if (lock_schema_name(thd, db.str)) return true;

  build_table_filename(path, sizeof(path) - 1, db.str, "", "", 0);

  DEBUG_SYNC(thd, "before_acquire_in_drop_schema");
  const dd::Schema *schema = nullptr;
  if (thd->dd_client()->acquire(db.str, &schema)) return true;

  DBUG_EXECUTE_IF("pretend_no_schema_in_drop_schema", { schema = nullptr; });

  /* See if the directory exists */
  MY_DIR *schema_dirp = my_dir(path, MYF(MY_DONT_SORT));

  auto dirender = [](MY_DIR *dirp) { my_dirend(dirp); };
  std::unique_ptr<MY_DIR, decltype(dirender)> grd{schema_dirp, dirender};

  if (schema == nullptr)  // Schema not found in DD
  {
    if (schema_dirp != nullptr)  // Schema directory exists
    {
      // This is always an error, even when if_exists is true
      my_error(ER_SCHEMA_DIR_UNKNOWN, MYF(0), db.str, path);
      return true;
    }

    if (!if_exists)  // IF EXISTS not given
    {
      my_error(ER_DB_DROP_EXISTS, MYF(0), db.str);
      return true;
    }
    push_warning_printf(thd, Sql_condition::SL_NOTE, ER_DB_DROP_EXISTS,
                        ER_THD(thd, ER_DB_DROP_EXISTS), db.str);

    /*
      We don't have active transaction at this point so we can't use
      binlog's trx cache, which requires transaction with valid XID.
    */
    if (write_db_cmd_to_binlog(thd, db.str, false)) return true;

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd)) return true;

    /* Fall-through to resetting current database in connection. */
  } else  // Schema found in DD
  {
    /* Database directory does not exist. */
    if (schema_dirp == nullptr) {
      if (!if_exists) {
        my_error(ER_SCHEMA_DIR_MISSING, MYF(0), path);
        return true;
      }
      push_warning_printf(thd, Sql_condition::SL_NOTE, ER_SCHEMA_DIR_MISSING,
                          ER_THD(thd, ER_SCHEMA_DIR_MISSING), path);
    } else {
      if (find_unknown_and_remove_deletable_files(thd, schema_dirp, path)) {
        return true;
      }
    }

    if (find_db_tables(thd, *schema, db.str, &tables)) {
      return true;
    }

    /* Lock all tables and stored routines about to be dropped. */
    if (lock_table_names(thd, tables, nullptr, thd->variables.lock_wait_timeout,
                         0) ||
        rm_table_do_discovery_and_lock_fk_tables(thd, tables) ||
        lock_check_constraint_names(thd, tables) ||
        Events::lock_schema_events(thd, *schema) ||
        lock_db_routines(thd, *schema) || lock_trigger_names(thd, tables))
      return true;

    /* mysql_ha_rm_tables() requires a non-null Table_ref. */
    if (tables) mysql_ha_rm_tables(thd, tables);

    for (table = tables; table; table = table->next_local) {
      deleted_tables++;
    }

    if (thd->killed) return true;

    thd->push_internal_handler(&err_handler);
    if (tables)
      error = mysql_rm_table_no_locks(thd, tables, true, false, true,
                                      &dropped_non_atomic, &post_ddl_htons,
                                      &fk_invalidator, nullptr);

    DBUG_EXECUTE_IF("rm_db_fail_after_dropping_tables", {
      my_error(ER_UNKNOWN_ERROR, MYF(0));
      error = true;
    });

    if (!error) {
      /*
        We temporarily disable the binary log while dropping SPs
        in the database. Since the DROP DATABASE statement is always
        replicated as a statement, execution of it will drop all objects
        in the database on the slave as well, so there is no need to
        replicate the removal of the individual objects in the database
        as well.

        This is more of a safety precaution, since normally no objects
        should be dropped while the database is being cleaned, but in
        the event that a change in the code to remove other objects is
        made, these drops should still not be logged.

        Notice that the binary log have to be enabled over the call to
        ha_drop_database(), since NDB otherwise detects the binary log
        as disabled and will not log the drop database statement on any
        other connected server.
      */

      ha_drop_database(path);
      thd->clear_error(); /* @todo Do not ignore errors */
      Disable_binlog_guard binlog_guard(thd);
      error = Events::drop_schema_events(thd, *schema);
      error = (error || sp_drop_db_routines(thd, *schema));
    }
    thd->pop_internal_handler();

    if (!error) error = thd->dd_client()->drop(schema);

    /*
      If database exists and there was no error we should
      write statement to binary log and remove DD entry.
    */
    if (!error) error = write_db_cmd_to_binlog(thd, db.str, true);

    if (!error) error = trans_commit_stmt(thd) || trans_commit(thd);

    /*
      In case of error rollback the transaction in order to revert
      changes which are possible to rollback (e.g. removal of tables
      in SEs supporting atomic DDL, events and routines).
    */
    if (error) {
      trans_rollback_stmt(thd);
      /*
        Play safe to be sure that THD::transaction_rollback_request is
        cleared before work-around code below is run. This also necessary
        to synchronize state of data-dicitionary on disk and in cache (to
        clear cache of uncommitted objects).
      */
      trans_rollback_implicit(thd);
    }

    /*
      Call post-DDL handlerton hook. For engines supporting atomic DDL
      tables' files are removed from disk on this step.
    */
    for (handlerton *hton : post_ddl_htons) hton->post_ddl(thd);

    fk_invalidator.invalidate(thd);

    /*
      Now we can try removing database directory.

      If the directory is a symbolic link, remove the link first, then
      remove the directory the symbolic link pointed at.

      This can happen only after post-DDL handlerton hook removes files
      from the directory.

      Since the statement is committed already, we do not report unlikely
      failure to remove the directory as an error. Instead we report it
      as a warning, which is sent to user and written to server error log.
    */
    if (!error && schema_dirp != nullptr) {
      Rmdir_error_handler rmdir_handler;
      thd->push_internal_handler(&rmdir_handler);
      (void)rm_dir_w_symlink(path, true);
      thd->pop_internal_handler();
    }

    if (error) {
      if (mysql_bin_log.is_open()) {
        /*
          If GTID_NEXT=='UUID:NUMBER', we must not log an incomplete
          statement.  However, the incomplete DROP has already 'committed'
          (some tables were removed).  So we generate an error and let
          user fix the situation.
        */
        if (thd->variables.gtid_next.type == ASSIGNED_GTID &&
            dropped_non_atomic) {
          char gtid_buf[Gtid::MAX_TEXT_LENGTH + 1];
          thd->variables.gtid_next.gtid.to_string(global_sid_map, gtid_buf,
                                                  true);
          my_error(ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID, MYF(0), path,
                   gtid_buf, db.str);
          return true;
        }
      }
      return true;
    }
  }

  /*
    If this database was the client's selected database, we silently
    change the client's selected database to nothing (to have an empty
    SELECT DATABASE() in the future). For this we free() thd->db and set
    it to 0.
  */
  if (thd->db().str && !strcmp(thd->db().str, db.str)) {
    mysql_change_db_impl(thd, NULL_CSTR, 0, thd->variables.collation_server);
    /*
      Check if current database tracker is enabled. If so, set the 'changed'
      flag.
    */
    if (thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)
            ->is_enabled()) {
      thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)
          ->mark_as_changed(thd, {});
    }
  }

  thd->server_status |= SERVER_STATUS_DB_DROPPED;
  my_ok(thd, deleted_tables);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_handler.cc
Function: Sql_cmd_handler_read::execute
bool Sql_cmd_handler_read::execute(THD *thd) {
  Table_ref *hash_tables = nullptr;
  TABLE *table, *backup_open_tables;
  MYSQL_LOCK *lock;
  Protocol *protocol = thd->get_protocol();
  char buff[MAX_FIELD_WIDTH];
  String buffer(buff, sizeof(buff), system_charset_info);
  int error, keyno = -1;
  uint num_rows;
  uchar *key = nullptr;
  uint key_len = 0;
  MDL_deadlock_and_lock_abort_error_handler sql_handler_lock_error;
  LEX *lex = thd->lex;
  Query_block *query_block = lex->query_block;
  Query_expression *unit = lex->unit;
  Table_ref *tables = query_block->get_table_list();
  enum_ha_read_modes mode = m_read_mode;
  Item *cond = query_block->where_cond();
  ha_rows select_limit_cnt, offset_limit_cnt;
  MDL_savepoint mdl_savepoint;
  bool res;
  DBUG_TRACE;
  DBUG_PRINT("enter", ("'%s'.'%s' as '%s'", tables->db, tables->table_name,
                       tables->alias));

  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  /* Accessing data in XA_IDLE or XA_PREPARED is not allowed. */
  if (thd->get_transaction()->xid_state()->check_xa_idle_or_prepared(true))
    return true;

  /*
    There is no need to check for table permissions here, because
    if a user has no permissions to read a table, he won't be
    able to open it (with SQLCOM_HA_OPEN) in the first place.
  */

  /* Get limit counters from Query_block. */
  query_block->resolve_limits(thd);
  unit->set_limit(thd, query_block);
  select_limit_cnt = unit->select_limit_cnt;
  offset_limit_cnt = unit->offset_limit_cnt;

  query_block->context.resolve_in_table_list_only(tables);
  mem_root_deque<Item *> list(thd->mem_root);
  list.push_back(new Item_field(&query_block->context, nullptr, nullptr, "*"));

retry:
  const auto hash_it = thd->handler_tables_hash.find(tables->alias);
  if (hash_it != thd->handler_tables_hash.end()) {
    hash_tables = hash_it->second.get();
    /*
      Handler interface sometimes uses "tables", sometimes it uses "hash_tables"
      thus we need grant information in both objects.
    */
    tables->grant = hash_tables->grant;
    table = hash_tables->table;

    DBUG_PRINT("info-in-hash",
               ("'%s'.'%s' as '%s' table: %p", hash_tables->db,
                hash_tables->table_name, hash_tables->alias, table));
    if (!table) {
      /*
        The handler table has been closed. Re-open it.
      */
      if (mysql_ha_open_table(thd, hash_tables)) {
        DBUG_PRINT("exit", ("reopen failed"));
        goto err0;
      }

      table = hash_tables->table;
      DBUG_PRINT("info", ("re-opened '%s'.'%s' as '%s' tab %p", hash_tables->db,
                          hash_tables->table_name, hash_tables->alias, table));
    }
  } else
    table = nullptr;

  if (!table) {
    my_error(ER_UNKNOWN_TABLE, MYF(0), tables->alias, "HANDLER");
    goto err0;
  }

  sql_handler_lock_error.init();

  /*
    For non-temporary tables we need to acquire SR lock in order to ensure
    that HANDLER READ is blocked by LOCK TABLES WRITE in other connections
    for storage engines which don't use THR_LOCK locks (e.g. InnoDB).

    To simplify clean-up code we take MDL_savepoint even for temporary tables.
  */
  mdl_savepoint = thd->mdl_context.mdl_savepoint();

  if (hash_tables->table->s->tmp_table == NO_TMP_TABLE) {
    MDL_request read_request;

    MDL_REQUEST_INIT_BY_KEY(&read_request, &hash_tables->mdl_request.key,
                            MDL_SHARED_READ, MDL_TRANSACTION);

    thd->push_internal_handler(&sql_handler_lock_error);

    error = thd->mdl_context.acquire_lock(&read_request,
                                          thd->variables.lock_wait_timeout);
    thd->pop_internal_handler();

    if (sql_handler_lock_error.need_reopen()) {
      /*
        HANDLER READ statement's attempt to upgrade lock on the subject table
        may get aborted if there is a pending DDL. In that case we close the
        table, reopen it, and try to read again.
        This is implicit and obscure, since HANDLER position is lost in the
        process, but it's the legacy server behaviour we should preserve.
      */
      assert(error && !thd->is_error());
      mysql_ha_close_table(thd, hash_tables);
      goto retry;
    }

    if (error) goto err0;
  }

  /* save open_tables state */
  backup_open_tables = thd->open_tables;
  /* Always a one-element list, see mysql_ha_open(). */
  assert(hash_tables->table->next == nullptr ||
         hash_tables->table->s->tmp_table);
  /*
    mysql_lock_tables() needs thd->open_tables to be set correctly to
    be able to handle aborts properly.
  */
  thd->set_open_tables(hash_tables->table);

  /* Re-use Sql_handler_lock_error instance which was initialized earlier. */
  assert(!sql_handler_lock_error.need_reopen());
  thd->push_internal_handler(&sql_handler_lock_error);

  lock = mysql_lock_tables(thd, &thd->open_tables, 1, 0);

  thd->pop_internal_handler();
  /*
    In 5.1 and earlier, mysql_lock_tables() could replace the TABLE
    object with another one (reopen it). This is no longer the case
    with new MDL.
  */
  assert(hash_tables->table == thd->open_tables);
  /* Restore previous context. */
  thd->set_open_tables(backup_open_tables);

  if (sql_handler_lock_error.need_reopen()) {
    assert(!lock && !thd->is_error());
    /*
      Always close statement transaction explicitly,
      so that the engine doesn't have to count locks.
      There should be no need to perform transaction
      rollback due to deadlock.
    */
    assert(!thd->transaction_rollback_request);
    trans_rollback_stmt(thd);
    thd->mdl_context.rollback_to_savepoint(mdl_savepoint);
    mysql_ha_close_table(thd, hash_tables);
    goto retry;
  }

  if (!lock) goto err1;  // mysql_lock_tables() printed error message already

  tables->table = hash_tables->table;
  tables->table->pos_in_table_list = tables;

  if (cond) {
    /*
      Privilege check not needed since all columns are selected and checked
      by insert_fields().
    */
    Column_privilege_tracker column_privilege(thd, 0);

    if (table->query_id != thd->query_id) cond->cleanup();  // File was reopened
    if ((!cond->fixed && cond->fix_fields(thd, &cond)) || cond->check_cols(1))
      goto err;
  }

  if (m_key_name) {
    keyno = find_type(m_key_name, &table->s->keynames, FIND_TYPE_NO_PREFIX) - 1;
    if (keyno < 0) {
      my_error(ER_KEY_DOES_NOT_EXITS, MYF(0), m_key_name, tables->alias);
      goto err;
    }
    /* Check if the same index involved. */
    if ((uint)keyno != table->file->get_index()) {
      if (mode == enum_ha_read_modes::RNEXT)
        mode = enum_ha_read_modes::RFIRST;
      else if (mode == enum_ha_read_modes::RPREV)
        mode = enum_ha_read_modes::RLAST;
    }
  }

  {
    // Mark all visible columns for read.
    const enum_mark_columns save_mark_columns = thd->mark_used_columns;
    thd->mark_used_columns = MARK_COLUMNS_READ;
    auto list_it = list.begin();
    if (insert_fields(thd, query_block, tables->db, tables->alias, &list,
                      &list_it, false))
      goto err;
    thd->mark_used_columns = save_mark_columns;
  }

  DBUG_EXECUTE_IF("simulate_handler_read_failure",
                  DBUG_SET("+d,simulate_net_write_failure"););
  res = thd->send_result_metadata(list,
                                  Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF);
  DBUG_EXECUTE_IF("simulate_handler_read_failure",
                  DBUG_SET("-d,simulate_net_write_failure"););
  if (res) goto err;

  if (mysql_audit_table_access_notify(thd, hash_tables)) goto err;

  /*
    In ::external_lock InnoDB resets the fields which tell it that
    the handle is used in the HANDLER interface. Tell it again that
    we are using it for HANDLER.
  */

  table->file->init_table_handle_for_HANDLER();

  /*
    Rebind the generated column expressions to current fields. They have to be
    cleaned up before returning, since the resolved expressions may point to
    memory allocated on the MEM_ROOT of the current HANDLER ... READ statement,
    which will be cleared when the statement has completed.
  */
  table->bind_value_generators_to_fields();

  for (num_rows = 0; num_rows < select_limit_cnt;) {
    switch (mode) {
      case enum_ha_read_modes::RNEXT:
        if (m_key_name) {
          if (table->file->inited == handler::INDEX) {
            /* Check if we read from the same index. */
            assert((uint)keyno == table->file->get_index());
            error = table->file->ha_index_next(table->record[0]);
            break;
          }
        } else if (table->file->inited == handler::RND) {
          error = table->file->ha_rnd_next(table->record[0]);
          break;
        }
        /*
          Fall through to HANDLER ... READ ... FIRST case if we are trying
          to read next row in index order after starting reading rows in
          natural order, or, vice versa, trying to read next row in natural
          order after reading previous rows in index order.
        */
        [[fallthrough]];
      case enum_ha_read_modes::RFIRST:
        if (m_key_name) {
          if (!(error = table->file->ha_index_or_rnd_end()) &&
              !(error = table->file->ha_index_init(keyno, true)))
            error = table->file->ha_index_first(table->record[0]);
        } else {
          if (!(error = table->file->ha_index_or_rnd_end()) &&
              !(error = table->file->ha_rnd_init(true)))
            error = table->file->ha_rnd_next(table->record[0]);
        }
        mode = enum_ha_read_modes::RNEXT;
        break;
      case enum_ha_read_modes::RPREV:
        assert(m_key_name != nullptr);
        /* Check if we read from the same index. */
        assert((uint)keyno == table->file->get_index());
        if (table->file->inited == handler::INDEX) {
          error = table->file->ha_index_prev(table->record[0]);
          break;
        }
        /* else fall through, for more info, see comment before 'case RFIRST'.
         */
        [[fallthrough]];
      case enum_ha_read_modes::RLAST:
        assert(m_key_name != nullptr);
        if (!(error = table->file->ha_index_or_rnd_end()) &&
            !(error = table->file->ha_index_init(keyno, true)))
          error = table->file->ha_index_last(table->record[0]);
        mode = enum_ha_read_modes::RPREV;
        break;
      case enum_ha_read_modes::RNEXT_SAME:
        /* Continue scan on "(keypart1,keypart2,...)=(c1, c2, ...)  */
        assert(table->file->inited == handler::INDEX);
        error = table->file->ha_index_next_same(table->record[0], key, key_len);
        break;
      case enum_ha_read_modes::RKEY: {
        assert(m_key_name != nullptr);
        KEY *keyinfo = table->key_info + keyno;
        KEY_PART_INFO *key_part = keyinfo->key_part;
        if (m_key_expr->size() > keyinfo->user_defined_key_parts) {
          my_error(ER_TOO_MANY_KEY_PARTS, MYF(0),
                   keyinfo->user_defined_key_parts);
          goto err;
        }
        /*
          Privilege check not needed since all columns are selected and checked
          by insert_fields().
        */
        Column_privilege_tracker column_privilege(thd, 0);

        auto it_ke = m_key_expr->begin();
        key_part_map keypart_map;
        for (keypart_map = key_len = 0; it_ke != m_key_expr->end();
             key_part++, ++it_ke) {
          Item *item = *it_ke;
          my_bitmap_map *old_map;
          // 'item' can be changed by fix_fields() call
          if ((!item->fixed && item->fix_fields(thd, &*it_ke)) ||
              (item = *it_ke)->check_cols(1))
            goto err;
          if (item->used_tables() & ~RAND_TABLE_BIT) {
            my_error(ER_WRONG_ARGUMENTS, MYF(0), "HANDLER ... READ");
            goto err;
          }
          old_map = dbug_tmp_use_all_columns(table, table->write_set);
          type_conversion_status conv_status =
              item->save_in_field(key_part->field, true);
          dbug_tmp_restore_column_map(table->write_set, old_map);
          /*
            If conversion status is TYPE_ERR_BAD_VALUE or
            TYPE_ERR_NULL_CONSTRAINT_VIOLATION, the target index value
            is not stored into record buffer, so we can't proceed with the
            index search.
          */
          if (conv_status == TYPE_ERR_BAD_VALUE) {
            my_error(ER_WRONG_ARGUMENTS, MYF(0), "HANDLER ... READ");
            goto err;
          }
          if (conv_status == TYPE_ERR_NULL_CONSTRAINT_VIOLATION) {
            my_error(ER_BAD_NULL_ERROR, MYF(0), m_key_name);
            goto err;
          }

          key_len += key_part->store_length;
          keypart_map = (keypart_map << 1) | 1;
        }

        if (!(key = (uchar *)thd->mem_calloc(ALIGN_SIZE(key_len)))) goto err;
        if ((error = table->file->ha_index_or_rnd_end())) break;
        key_copy(key, table->record[0], table->key_info + keyno, key_len);
        if (!(error = table->file->ha_index_init(keyno, true)))
          error = table->file->ha_index_read_map(table->record[0], key,
                                                 keypart_map, m_rkey_mode);
        mode = rkey_to_rnext[(int)m_rkey_mode];
        break;
      }
      default:
        my_error(ER_ILLEGAL_HA, MYF(0));
        goto err;
    }

    if (error) {
      if (error == HA_ERR_RECORD_DELETED) continue;
      if (error != HA_ERR_KEY_NOT_FOUND && error != HA_ERR_END_OF_FILE) {
        LogErr(ERROR_LEVEL, ER_SQL_HA_READ_FAILED, error, tables->table_name);
        table->file->print_error(error, MYF(0));
        goto err;
      }
      goto ok;
    }
    thd->inc_examined_row_count(1);
    if (cond && !cond->val_int()) {
      if (thd->is_error()) goto err;
      continue;
    }
    if (num_rows >= offset_limit_cnt) {
      protocol->start_row();
      if (thd->send_result_set_row(list)) goto err;

      if (protocol->end_row()) goto err;
    }
    num_rows++;
    thd->inc_sent_row_count(1);
  }
ok:
  /*
    Always close statement transaction explicitly,
    so that the engine doesn't have to count locks.
  */
  trans_commit_stmt(thd);
  hash_tables->table->pos_in_table_list = hash_tables;
  mysql_unlock_tables(thd, lock);
  thd->mdl_context.rollback_to_savepoint(mdl_savepoint);
  table->cleanup_value_generator_items();
  my_eof(thd);
  DBUG_PRINT("exit", ("OK"));
  return false;

err:
  trans_rollback_stmt(thd);
  mysql_unlock_tables(thd, lock);
  table->cleanup_value_generator_items();
err1:
  thd->mdl_context.rollback_to_savepoint(mdl_savepoint);
err0:
  if (hash_tables != nullptr && hash_tables->table != nullptr)
    hash_tables->table->pos_in_table_list = hash_tables;
  DBUG_PRINT("exit", ("ERROR"));
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_parse.cc
Function: lock_tables_open_and_lock_tables
static bool lock_tables_open_and_lock_tables(THD *thd, Table_ref *tables) {
  Lock_tables_prelocking_strategy lock_tables_prelocking_strategy;
  MDL_deadlock_and_lock_abort_error_handler deadlock_handler;
  MDL_savepoint mdl_savepoint = thd->mdl_context.mdl_savepoint();
  uint counter;
  Table_ref *table;

  thd->in_lock_tables = true;

retry:

  if (open_tables(thd, &tables, &counter, 0, &lock_tables_prelocking_strategy))
    goto err;

  deadlock_handler.init();
  thd->push_internal_handler(&deadlock_handler);

  for (table = tables; table; table = table->next_global) {
    if (!table->is_placeholder()) {
      if (table->table->s->tmp_table) {
        /*
          We allow to change temporary tables even if they were locked for read
          by LOCK TABLES. To avoid a discrepancy between lock acquired at LOCK
          TABLES time and by the statement which is later executed under LOCK
          TABLES we ensure that for temporary tables we always request a write
          lock (such discrepancy can cause problems for the storage engine).
          We don't set Table_ref::lock_type in this case as this might
          result in extra warnings from THD::decide_logging_format() even though
          binary logging is totally irrelevant for LOCK TABLES.
        */
        table->table->reginfo.lock_type = TL_WRITE;
      } else if (table->lock_descriptor().type == TL_READ &&
                 !table->prelocking_placeholder &&
                 table->table->file->ha_table_flags() & HA_NO_READ_LOCAL_LOCK) {
        /*
          In case when LOCK TABLE ... READ LOCAL was issued for table with
          storage engine which doesn't support READ LOCAL option and doesn't
          use THR_LOCK locks we need to upgrade weak SR metadata lock acquired
          in open_tables() to stronger SRO metadata lock.
          This is not needed for tables used through stored routines or
          triggers as we always acquire SRO (or even stronger SNRW) metadata
          lock for them.
        */
        bool result = thd->mdl_context.upgrade_shared_lock(
            table->table->mdl_ticket, MDL_SHARED_READ_ONLY,
            thd->variables.lock_wait_timeout);

        if (deadlock_handler.need_reopen()) {
          /*
            Deadlock occurred during upgrade of metadata lock.
            Let us restart acquiring and opening tables for LOCK TABLES.
          */
          thd->pop_internal_handler();
          close_tables_for_reopen(thd, &tables, mdl_savepoint);
          if (open_temporary_tables(thd, tables)) goto err;
          goto retry;
        }

        if (result) {
          thd->pop_internal_handler();
          goto err;
        }
      }
    }
  }

  thd->pop_internal_handler();

  if (lock_tables(thd, tables, counter, 0) ||
      thd->locked_tables_list.init_locked_tables(thd))
    goto err;

  thd->in_lock_tables = false;

  return false;

err:
  thd->in_lock_tables = false;

  trans_rollback_stmt(thd);
  /*
    Need to end the current transaction, so the storage engine (InnoDB)
    can free its locks if LOCK TABLES locked some tables before finding
    that it can't lock a table in its list
  */
  trans_rollback(thd);
  /* Close tables and release metadata locks. */
  close_thread_tables(thd);
  assert(!thd->locked_tables_mode);
  thd->mdl_context.release_transactional_locks();
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_install_plugin
static bool mysql_install_plugin(THD *thd, LEX_CSTRING name,
                                 const LEX_STRING *dl) {
  TABLE *table;
  bool error = true;
  int argc = orig_argc;
  char **argv = orig_argv;
  st_plugin_int *tmp = nullptr;
  bool store_infoschema_metadata = false;
  dd::Schema_MDL_locker mdl_handler(thd);
  Persisted_variables_cache *pv = Persisted_variables_cache::get_instance();

  DBUG_TRACE;

  Disable_autocommit_guard autocommit_guard(thd);
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  Table_ref tables("mysql", "plugin", TL_WRITE);

  if (!opt_noacl &&
      check_table_access(thd, INSERT_ACL, &tables, false, 1, false))
    return true;

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  /* need to open before acquiring LOCK_plugin or it will deadlock */
  if (!(table = open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))
    return true;

  /*
    System table mysql.plugin is supported by only InnoDB engine. Changing
    table's engine is not allowed. But to support logical upgrade creating
    system table is allowed in MyISAM engine. INSTALL PLUGIN operation is
    *not* allowed in this case.
  */
  if ((table->file->ht->is_supported_system_table != nullptr) &&
      !table->file->ht->is_supported_system_table(tables.db, tables.table_name,
                                                  true)) {
    my_error(ER_UNSUPPORTED_ENGINE, MYF(0),
             ha_resolve_storage_engine_name(table->file->ht), tables.db,
             tables.table_name);
    return end_transaction(thd, error);
  }

  // INSTALL PLUGIN operation is *not* allowed if table structure is changed.
  System_table_intact table_intact(thd);
  if (table_intact.check(thd, table, &mysql_plugin_table_def))
    return end_transaction(thd, error);

  /*
    Pre-acquire audit plugins for events that may potentially occur
    during [UN]INSTALL PLUGIN.

    When audit event is triggered, audit subsystem acquires interested
    plugins by walking through plugin list. Evidently plugin list
    iterator protects plugin list by acquiring LOCK_plugin, see
    plugin_foreach_with_mask().

    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin
    rather for a long time.

    When audit event is triggered during [UN]INSTALL PLUGIN, plugin
    list iterator acquires the same lock (within the same thread)
    second time.

    This hack should be removed when LOCK_plugin is fixed so it
    protects only what it supposed to protect.
    */
  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS,
                              MYSQL_AUDIT_GENERAL_ALL);

  mysql_mutex_lock(&LOCK_plugin_install);
  mysql_rwlock_wrlock(&LOCK_system_variables_hash);
  mysql_mutex_lock(&LOCK_plugin);

  {
    MEM_ROOT alloc{PSI_NOT_INSTRUMENTED, 512};
    my_getopt_use_args_separator = true;
    if (my_load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv,
                         &alloc, nullptr)) {
      mysql_mutex_unlock(&LOCK_plugin);
      mysql_rwlock_unlock(&LOCK_system_variables_hash);
      report_error(REPORT_TO_USER, ER_PLUGIN_IS_NOT_LOADED, name.str);
      goto err;
    }
    my_getopt_use_args_separator = false;
    /*
     Append parse early and static variables present in mysqld-auto.cnf file
     for the newly installed plugin to process those options which are specific
     to this plugin.
    */
    bool arg_separator_added = false;
    if (pv &&
        (pv->append_parse_early_variables(&argc, &argv, arg_separator_added) ||
         pv->append_read_only_variables(&argc, &argv, arg_separator_added,
                                        true))) {
      mysql_mutex_unlock(&LOCK_plugin);
      mysql_rwlock_unlock(&LOCK_system_variables_hash);
      report_error(REPORT_TO_USER, ER_PLUGIN_IS_NOT_LOADED, name.str);
      goto err;
    }
    error =
        plugin_add(thd->mem_root, name, dl, &argc, argv, REPORT_TO_USER, false);
  }

  /* LOCK_plugin and LOCK_system_variables_hash already unlocked by plugin_add()
     if error */
  if (error) goto err;

  if (!(tmp = plugin_find_internal(name, MYSQL_ANY_PLUGIN))) {
    mysql_mutex_unlock(&LOCK_plugin);
    mysql_rwlock_unlock(&LOCK_system_variables_hash);
    goto err;
  }

  error = false;
  if (tmp->state == PLUGIN_IS_DISABLED) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, ER_CANT_INITIALIZE_UDF,
                        ER_THD(thd, ER_CANT_INITIALIZE_UDF), name.str,
                        "Plugin is disabled");
  }

  // Check if we need to store I_S plugin metadata in DD.
  store_infoschema_metadata =
      (tmp->plugin->type == MYSQL_INFORMATION_SCHEMA_PLUGIN &&
       tmp->state != PLUGIN_IS_DISABLED);
  mysql_mutex_unlock(&LOCK_plugin);
  mysql_rwlock_unlock(&LOCK_system_variables_hash);

  // Acquire MDL lock if we are storing metadata in DD.
  if (store_infoschema_metadata) {
    if (!mdl_handler.ensure_locked(INFORMATION_SCHEMA_NAME.str)) {
      MDL_request mdl_request;
      MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE,
                       INFORMATION_SCHEMA_NAME.str, tmp->name.str,
                       MDL_EXCLUSIVE, MDL_TRANSACTION);
      if (thd->mdl_context.acquire_lock(&mdl_request,
                                        thd->variables.lock_wait_timeout))
        error = true;
    } else
      error = true;

    if (error) {
      report_error(REPORT_TO_USER, ER_DA_PLUGIN_INSTALL_ERROR, name.str,
                   "error acquiring metadata lock");
    }
  }

  /*
    We do not replicate the INSTALL PLUGIN statement. Disable binlogging
    of the insert into the plugin table, so that it is not replicated in
    row based mode.
  */
  if (!error) {
    Disable_binlog_guard binlog_guard(thd);
    table->use_all_columns();
    restore_record(table, s->default_values);
    table->field[0]->store(name.str, name.length, system_charset_info);
    table->field[1]->store(dl->str, dl->length, files_charset_info);
    error = table->file->ha_write_row(table->record[0]);
    if (error) {
      const char msg[] = "got '%s' writing to mysql.plugin";
      char buf[MYSQL_ERRMSG_SIZE + sizeof(msg) - 2];
      char errbuf[MYSQL_ERRMSG_SIZE];
      my_strerror(errbuf, sizeof(errbuf), error);
      snprintf(buf, sizeof(buf), msg, errbuf);
      report_error(REPORT_TO_USER, ER_DA_PLUGIN_INSTALL_ERROR, name.str, buf);
    } else {
      mysql_rwlock_wrlock(&LOCK_system_variables_hash);
      mysql_mutex_lock(&LOCK_plugin);

      if (tmp->state != PLUGIN_IS_DISABLED && plugin_initialize(tmp)) {
        my_error(ER_CANT_INITIALIZE_UDF, MYF(0), name.str,
                 "Plugin initialization function failed.");
        error = true;
      }

      /*
        Store plugin I_S table metadata into DD tables. The
        tables are closed before the function returns.
       */
      error = error || thd->transaction_rollback_request;
      if (!error && store_infoschema_metadata) {
        error = dd::info_schema::store_dynamic_plugin_I_S_metadata(thd, tmp);
        if (error) {
          report_error(REPORT_TO_USER, ER_DA_PLUGIN_INSTALL_ERROR, name.str,
                       "error storing metadata");
        }
      }

      /*
        Once server is started and plugin initialized and if there are persisted
        read-write plugin variables which need to be handled, we do it here.
      */
      if (!error && update_persisted_plugin_sysvars(name.str)) error = true;

      mysql_mutex_unlock(&LOCK_plugin);
      mysql_rwlock_unlock(&LOCK_system_variables_hash);

      if (!error && store_infoschema_metadata) {
        Uncommitted_tables_guard uncommitted_tables(thd);
        error = update_referencing_views_metadata(
            thd, INFORMATION_SCHEMA_NAME.str, tmp->name.str, false,
            &uncommitted_tables);
        if (error) {
          report_error(REPORT_TO_USER, ER_DA_PLUGIN_INSTALL_ERROR, name.str,
                       "error updating metadata");
        }
      }
    }
  }

  if (error) {
    mysql_mutex_lock(&LOCK_plugin);
    tmp->state = PLUGIN_IS_DELETED;
    reap_needed = true;
    reap_plugins();
    mysql_mutex_unlock(&LOCK_plugin);
  }

err:
  mysql_mutex_unlock(&LOCK_plugin_install);
  return end_transaction(thd, error);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_uninstall_plugin
static bool mysql_uninstall_plugin(THD *thd, LEX_CSTRING name) {
  TABLE *table;
  st_plugin_int *plugin;
  bool error = true;
  int rc = 0;
  bool remove_IS_metadata_from_dd = false;
  dd::Schema_MDL_locker mdl_handler(thd);
  dd::String_type orig_plugin_name;

  DBUG_TRACE;

  Table_ref tables("mysql", 5, "plugin", 6, "plugin", TL_WRITE);

  if (!opt_noacl &&
      check_table_access(thd, DELETE_ACL, &tables, false, 1, false)) {
    assert(thd->is_error());
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard autocommit_guard(thd);
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  /* need to open before acquiring LOCK_plugin or it will deadlock */
  if (!(table =
            open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT))) {
    assert(thd->is_error());
    return true;
  }

  /*
    System table mysql.plugin is supported by only InnoDB engine. Changing
    table's engine is not allowed. But to support logical upgrade creating
    system table is allowed in MyISAM engine. UNINSTALL PLUGIN operation is
    *not* allowed in this case.
  */
  if ((table->file->ht->is_supported_system_table != nullptr) &&
      !table->file->ht->is_supported_system_table(tables.db, tables.table_name,
                                                  true)) {
    my_error(ER_UNSUPPORTED_ENGINE, MYF(0),
             ha_resolve_storage_engine_name(table->file->ht), tables.db,
             tables.table_name);
    return end_transaction(thd, error);
  }

  // UNINSTALL PLUGIN operation is *not* allowed if table structure is changed.
  System_table_intact table_intact(thd);
  if (table_intact.check(thd, table, &mysql_plugin_table_def))
    return end_transaction(thd, error);

  mysql_mutex_lock(&LOCK_plugin_install);
  if (!table->key_info) {
    my_error(ER_MISSING_KEY, MYF(0), table->s->db.str,
             table->s->table_name.str);
    goto err;
  }

  /*
    Pre-acquire audit plugins for events that may potentially occur
    during [UN]INSTALL PLUGIN.

    When audit event is triggered, audit subsystem acquires interested
    plugins by walking through plugin list. Evidently plugin list
    iterator protects plugin list by acquiring LOCK_plugin, see
    plugin_foreach_with_mask().

    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin
    rather for a long time.

    When audit event is triggered during [UN]INSTALL PLUGIN, plugin
    list iterator acquires the same lock (within the same thread)
    second time.

    This hack should be removed when LOCK_plugin is fixed so it
    protects only what it supposed to protect.
  */
  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS,
                              MYSQL_AUDIT_GENERAL_ALL);

  mysql_mutex_lock(&LOCK_plugin);
  if (!(plugin = plugin_find_internal(name, MYSQL_ANY_PLUGIN)) ||
      plugin->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_DYING)) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), "PLUGIN", name.str);
    goto err;
  }
  if (!plugin->plugin_dl) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_PLUGIN_DELETE_BUILTIN, MYF(0));
    goto err;
  }
  if (plugin->load_option == PLUGIN_FORCE_PLUS_PERMANENT) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_PLUGIN_IS_PERMANENT, MYF(0), name.str);
    goto err;
  }
  /*
    Error message for ER_PLUGIN_IS_PERMANENT is not suitable for
    plugins marked as not dynamically uninstallable, so we have a
    separate one instead of changing the old one.
   */
  if (plugin->plugin->flags & PLUGIN_OPT_NO_UNINSTALL) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_PLUGIN_NO_UNINSTALL, MYF(0), plugin->plugin->name);
    goto err;
  }

  if ((plugin->plugin->check_uninstall) && (plugin->state == PLUGIN_IS_READY)) {
    int check;
    /*
      Prevent other threads to uninstall concurrently this plugin.
    */
    plugin->state = PLUGIN_IS_DYING;
    mysql_mutex_unlock(&LOCK_plugin);

    DEBUG_SYNC(current_thd, "in_plugin_check_uninstall");

    /*
      Check uninstall may perform complex operations,
      including acquiring MDL locks, which in turn may need LOCK_plugin.
    */
    DBUG_PRINT("info", ("check uninstall plugin: '%s'", plugin->name.str));
    check = plugin->plugin->check_uninstall(plugin);

    mysql_mutex_lock(&LOCK_plugin);
    assert(plugin->state == PLUGIN_IS_DYING);

    if (check) {
      DBUG_PRINT("warning",
                 ("Plugin '%s' blocked uninstall.", plugin->name.str));
      plugin->state = PLUGIN_IS_READY;
      mysql_mutex_unlock(&LOCK_plugin);
      my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name.str,
               "Plugin is still in use.");
      goto err;
    }
  }

  plugin->state = PLUGIN_IS_DELETED;
  if (plugin->ref_count)
    push_warning(thd, Sql_condition::SL_WARNING, WARN_PLUGIN_BUSY,
                 ER_THD(thd, WARN_PLUGIN_BUSY));
  else
    reap_needed = true;

  // Check if we need to remove I_S plugin metadata from DD.
  remove_IS_metadata_from_dd =
      (plugin->plugin->type == MYSQL_INFORMATION_SCHEMA_PLUGIN &&
       plugin->load_option != PLUGIN_OFF);

  orig_plugin_name = dd::String_type(plugin->name.str, plugin->name.length);
  reap_plugins();
  mysql_mutex_unlock(&LOCK_plugin);

  uchar user_key[MAX_KEY_LENGTH];
  table->use_all_columns();
  table->field[0]->store(name.str, name.length, system_charset_info);
  key_copy(user_key, table->record[0], table->key_info,
           table->key_info->key_length);

  if ((rc = table->file->ha_index_read_idx_map(
           table->record[0], 0, user_key, HA_WHOLE_KEY, HA_READ_KEY_EXACT)) ==
      0) {
    /*
      We do not replicate the UNINSTALL PLUGIN statement. Disable binlogging
      of the delete from the plugin table, so that it is not replicated in
      row based mode.
    */
    assert(!thd->is_error());
    Disable_binlog_guard binlog_guard(thd);
    rc = table->file->ha_delete_row(table->record[0]);
    if (rc) {
      assert(thd->is_error());
    } else
      error = false;
  } else if (rc != HA_ERR_KEY_NOT_FOUND && rc != HA_ERR_END_OF_FILE) {
    assert(thd->is_error());
  } else
    error = false;

  if (error) {
    const char msg[] = "got '%s' deleting from mysql.plugin";
    char buf[MYSQL_ERRMSG_SIZE + sizeof(msg) - 2];
    char errbuf[MYSQL_ERRMSG_SIZE];
    my_strerror(errbuf, sizeof(errbuf), error);
    snprintf(buf, sizeof(buf), msg, errbuf);
    report_error(REPORT_TO_USER, ER_PLUGIN_UNINSTALL_ERROR, name.str, buf);
  }

  if (!error && !thd->transaction_rollback_request &&
      remove_IS_metadata_from_dd) {
    error = dd::info_schema::remove_I_S_view_metadata(
        thd,
        dd::String_type(orig_plugin_name.c_str(), orig_plugin_name.length()));
    assert(!error || thd->is_error());

    if (!error) {
      Uncommitted_tables_guard uncommitted_tables(thd);
      error = update_referencing_views_metadata(
          thd, INFORMATION_SCHEMA_NAME.str, orig_plugin_name.c_str(), false,
          &uncommitted_tables);
    }

    if (error) {
      report_error(REPORT_TO_USER, ER_PLUGIN_UNINSTALL_ERROR, name.str,
                   "error updating metadata");
    }
  }

err:
  mysql_mutex_unlock(&LOCK_plugin_install);
  return end_transaction(thd, error || thd->transaction_rollback_request);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_reload.cc
Function: handle_reload_request 
bool handle_reload_request(THD *thd, unsigned long options, Table_ref *tables,
                           int *write_to_binlog) {
  bool result = false;
  select_errors = 0; /* Write if more errors */
  int tmp_write_to_binlog = *write_to_binlog = 1;

  assert(!thd || !thd->in_sub_stmt);

  if (options & REFRESH_GRANT) {
    THD *tmp_thd = nullptr;
    /*
      If handle_reload_request() is called from SIGHUP handler we have to
      allocate temporary THD for execution of acl_reload()/grant_reload().
    */
    if (!thd && (thd = (tmp_thd = new THD))) {
      thd->thread_stack = (char *)&tmp_thd;
      thd->store_globals();
    }

    if (thd) {
      bool reload_acl_failed = reload_acl_caches(thd, false);
      bool reload_servers_failed = servers_reload(thd);
      notify_flush_event(thd);
      if (reload_acl_failed || reload_servers_failed) {
        result = true;
        /*
          When an error is returned, my_message may have not been called and
          the client will hang waiting for a response.
        */
        my_error(ER_UNKNOWN_ERROR, MYF(0));
      }
    }

    reset_mqh(thd, (LEX_USER *)nullptr, true);
    if (tmp_thd) {
      delete tmp_thd;
      thd = nullptr;
    }
  }

  if (options & REFRESH_LOG) {
    /*
      Flush the normal query log, the update log, the binary log,
      the slow query log, the relay log (if it exists) and the log
      tables.
    */

    options |= REFRESH_BINARY_LOG;
    options |= REFRESH_RELAY_LOG;
    options |= REFRESH_SLOW_LOG;
    options |= REFRESH_GENERAL_LOG;
    options |= REFRESH_ENGINE_LOG;
    options |= REFRESH_ERROR_LOG;
  }

  if (options & REFRESH_ERROR_LOG) {
    if (reopen_error_log()) result = true;
  }

  if ((options & REFRESH_SLOW_LOG) && opt_slow_log &&
      (log_output_options & LOG_FILE))
    if (query_logger.reopen_log_file(QUERY_LOG_SLOW)) result = true;

  if ((options & REFRESH_GENERAL_LOG) && opt_general_log &&
      (log_output_options & LOG_FILE))
    if (query_logger.reopen_log_file(QUERY_LOG_GENERAL)) result = true;

  if (options & REFRESH_ENGINE_LOG) {
    if (ha_flush_logs()) {
      result = true;
    }
  }
  if ((options & REFRESH_BINARY_LOG) || (options & REFRESH_RELAY_LOG)) {
    /*
      If handle_reload_request() is called from SIGHUP handler we have to
      allocate temporary THD for execution of binlog/relay log rotation.
     */
    THD *tmp_thd = nullptr;
    if (!thd && (thd = (tmp_thd = new THD))) {
      thd->thread_stack = (char *)(&tmp_thd);
      thd->store_globals();
    }

    if (options & REFRESH_BINARY_LOG) {
      /*
        Writing this command to the binlog may result in infinite loops
        when doing mysqlbinlog|mysql, and anyway it does not really make
        sense to log it automatically (would cause more trouble to users
        than it would help them)
       */
      tmp_write_to_binlog = 0;
      if (mysql_bin_log.is_open()) {
        if (mysql_bin_log.rotate_and_purge(thd, true)) *write_to_binlog = -1;
      }
    }
    if (options & REFRESH_RELAY_LOG) {
      if (flush_relay_logs_cmd(thd)) *write_to_binlog = -1;
    }
    if (tmp_thd) {
      delete tmp_thd;
      /* Remember that we don't have a THD */
      current_thd = nullptr;
      thd = nullptr;
    }
  }

  assert(!thd || thd->locked_tables_mode || !thd->mdl_context.has_locks() ||
         !thd->handler_tables_hash.empty() ||
         thd->mdl_context.has_locks(MDL_key::USER_LEVEL_LOCK) ||
         thd->mdl_context.has_locks(MDL_key::LOCKING_SERVICE) ||
         thd->mdl_context.has_locks(MDL_key::BACKUP_LOCK) ||
         thd->global_read_lock.is_acquired());

  /*
    Note that if REFRESH_READ_LOCK bit is set then REFRESH_TABLES is set too
    (see sql_yacc.yy)
  */
  if (options & (REFRESH_TABLES | REFRESH_READ_LOCK)) {
    if ((options & REFRESH_READ_LOCK) && thd) {
      /*
        On the first hand we need write lock on the tables to be flushed,
        on the other hand we must not try to aspire a global read lock
        if we have a write locked table as this would lead to a deadlock
        when trying to reopen (and re-lock) the table after the flush.
      */
      if (thd->locked_tables_mode) {
        my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
        return true;
      }
      /*
        Writing to the binlog could cause deadlocks, as we don't log
        UNLOCK TABLES
      */
      tmp_write_to_binlog = 0;
      if (thd->global_read_lock.lock_global_read_lock(thd))
        return true;  // Killed
      if (close_cached_tables(thd, tables,
                              ((options & REFRESH_FAST) ? false : true),
                              thd->variables.lock_wait_timeout)) {
        /*
          NOTE: my_error() has been already called by reopen_tables() within
          close_cached_tables().
        */
        result = true;
      }

      if (thd->global_read_lock.make_global_read_lock_block_commit(
              thd))  // Killed
      {
        /* Don't leave things in a half-locked state */
        thd->global_read_lock.unlock_global_read_lock(thd);
        return true;
      }
    } else {
      if (thd && thd->locked_tables_mode) {
        /*
          If we are under LOCK TABLES we should have a write
          lock on tables which we are going to flush.
        */
        if (tables) {
          for (Table_ref *t = tables; t; t = t->next_local)
            if (!find_table_for_mdl_upgrade(thd, t->db, t->table_name, false))
              return true;
        } else {
          /*
            It is not safe to upgrade the metadata lock without GLOBAL IX lock.
            This can happen with FLUSH TABLES <list> WITH READ LOCK as we in
            these cases don't take a GLOBAL IX lock in order to be compatible
            with global read lock.
          */
          if (thd->open_tables &&
              !thd->mdl_context.owns_equal_or_stronger_lock(
                  MDL_key::GLOBAL, "", "", MDL_INTENTION_EXCLUSIVE)) {
            my_error(ER_TABLE_NOT_LOCKED_FOR_WRITE, MYF(0),
                     thd->open_tables->s->table_name.str);
            return true;
          }

          for (TABLE *tab = thd->open_tables; tab; tab = tab->next) {
            if (!tab->mdl_ticket->is_upgradable_or_exclusive()) {
              my_error(ER_TABLE_NOT_LOCKED_FOR_WRITE, MYF(0),
                       tab->s->table_name.str);
              return true;
            }
          }
        }
      }

      if (close_cached_tables(
              thd, tables, ((options & REFRESH_FAST) ? false : true),
              (thd ? thd->variables.lock_wait_timeout : LONG_TIMEOUT))) {
        /*
          NOTE: my_error() has been already called by reopen_tables() within
          close_cached_tables().
        */
        result = true;
      }
    }
  }
  if (options & REFRESH_HOSTS) hostname_cache_refresh();
  if (thd && (options & REFRESH_STATUS)) refresh_status();
  if (options & REFRESH_THREADS)
    Per_thread_connection_handler::kill_blocked_pthreads();
  if (options & REFRESH_MASTER) {
    assert(thd);
    tmp_write_to_binlog = 0;
    /*
      RESET MASTER acquired global read lock (if the thread is not acquired
      already) to make sure no transaction commits are getting executed
      while the operation is in process. If (and only if) it is
      acquired by RESET MASTER internal process (options will contain
      REFRESH_READ_LOCK flag in this case), unlock the global read lock
      in reset_master().
    */
    if (reset_master(thd, options & REFRESH_READ_LOCK)) {
      /* NOTE: my_error() has been already called by reset_master(). */
      result = true;
    }
  }
  if (options & REFRESH_OPTIMIZER_COSTS) reload_optimizer_cost_constants();
  if (options & REFRESH_REPLICA) {
    tmp_write_to_binlog = 0;
    if (reset_slave_cmd(thd)) {
      /*NOTE: my_error() has been already called by reset_slave() */
      result = true;
    }
  }
  if (options & REFRESH_USER_RESOURCES)
    reset_mqh(thd, nullptr, false); /* purecov: inspected */
  if (*write_to_binlog != -1) *write_to_binlog = tmp_write_to_binlog;
  /*
    If the query was killed then this function must fail.
  */
  return result || (thd ? thd->killed : 0);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_reload.cc
Function: flush_tables_with_read_lock
bool flush_tables_with_read_lock(THD *thd, Table_ref *all_tables) {
  Lock_tables_prelocking_strategy lock_tables_prelocking_strategy;
  Table_ref *table_list;

  /*
    This is called from SQLCOM_FLUSH, the transaction has
    been committed implicitly.
  */

  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    goto error;
  }

  /*
    Acquire SNW locks on tables to be flushed. Don't acquire global
    IX and database-scope IX locks on the tables as this will make
    this statement incompatible with FLUSH TABLES WITH READ LOCK.
  */
  if (lock_table_names(thd, all_tables, nullptr,
                       thd->variables.lock_wait_timeout,
                       MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK))
    goto error;

  DEBUG_SYNC(thd, "flush_tables_with_read_lock_after_acquire_locks");

  for (table_list = all_tables; table_list;
       table_list = table_list->next_global) {
    /* Request removal of table from cache. */
    tdc_remove_table(thd, TDC_RT_REMOVE_UNUSED, table_list->db,
                     table_list->table_name, false);
    /* Reset ticket to satisfy asserts in open_tables(). */
    table_list->mdl_request.ticket = nullptr;
  }

  /*
    Before opening and locking tables the below call also waits
    for old shares to go away, so the fact that we don't pass
    MYSQL_OPEN_IGNORE_FLUSH flag to it is important.
    Also we don't pass MYSQL_OPEN_HAS_MDL_LOCK flag as we want
    to open underlying tables if merge table is flushed.
    For underlying tables of the merge the below call has to
    acquire SNW locks to ensure that they can be locked for
    read without further waiting.
  */
  if (open_and_lock_tables(thd, all_tables, MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK,
                           &lock_tables_prelocking_strategy) ||
      thd->locked_tables_list.init_locked_tables(thd)) {
    goto error;
  }
  thd->variables.option_bits |= OPTION_TABLE_LOCK;

  /*
    We don't downgrade MDL_SHARED_NO_WRITE here as the intended
    post effect of this call is identical to LOCK TABLES <...> READ,
    and we didn't use thd->in_lock_talbes and
    thd->sql_command= SQLCOM_LOCK_TABLES hacks to enter the LTM.
  */

  return false;

error:
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_rename.cc
Function: mysql_rename_tables
bool mysql_rename_tables(THD *thd, Table_ref *table_list) {
  Table_ref *ren_table = nullptr;
  DBUG_TRACE;

  mysql_ha_rm_tables(thd, table_list);

  /*
    The below Auto_releaser allows to keep uncommitted versions of data-
    dictionary objects cached in the Dictionary_client for the whole duration
    of the statement.
  */
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  if (query_logger.is_log_table_enabled(QUERY_LOG_GENERAL) ||
      query_logger.is_log_table_enabled(QUERY_LOG_SLOW)) {
    int to_table;
    const char *rename_log_table[2] = {nullptr, nullptr};

    /*
      Rules for rename of a log table:

      IF   1. Log tables are enabled
      AND  2. Rename operates on the log table and nothing is being
              renamed to the log table.
      DO   3. Throw an error message.
      ELSE 4. Perform rename.
    */

    for (to_table = 0, ren_table = table_list; ren_table;
         to_table = 1 - to_table, ren_table = ren_table->next_local) {
      int log_table_rename = 0;

      if ((log_table_rename =
               query_logger.check_if_log_table(ren_table, true))) {
        /*
          as we use log_table_rename as an array index, we need it to start
          with 0, while QUERY_LOG_SLOW == 1 and QUERY_LOG_GENERAL == 2.
          So, we shift the value to start with 0;
        */
        log_table_rename--;
        if (rename_log_table[log_table_rename]) {
          if (to_table)
            rename_log_table[log_table_rename] = nullptr;
          else {
            /*
              Two renames of "log_table TO" w/o rename "TO log_table" in
              between.
            */
            my_error(ER_CANT_RENAME_LOG_TABLE, MYF(0), ren_table->table_name,
                     ren_table->table_name);
            return true;
          }
        } else {
          if (to_table) {
            /*
              Attempt to rename a table TO log_table w/o renaming
              log_table TO some table.
            */
            my_error(ER_CANT_RENAME_LOG_TABLE, MYF(0), ren_table->table_name,
                     ren_table->table_name);
            return true;
          } else {
            /* save the name of the log table to report an error */
            rename_log_table[log_table_rename] = ren_table->table_name;
          }
        }
      }
    }
    if (rename_log_table[0] || rename_log_table[1]) {
      if (rename_log_table[0])
        my_error(ER_CANT_RENAME_LOG_TABLE, MYF(0), rename_log_table[0],
                 rename_log_table[0]);
      else
        my_error(ER_CANT_RENAME_LOG_TABLE, MYF(0), rename_log_table[1],
                 rename_log_table[1]);
      return true;
    }
  }

  /*
    Array in which pointers to MDL requests for acquired schema locks are
    stored. Each schema can be present in this array only once.
  */
  Prealloced_array<MDL_request *, 1> schema_reqs(PSI_INSTRUMENT_ME);

  if (thd->locked_tables_mode) {
    /*
      LOCK TABLES case.

      Check that tables to be renamed are locked for WRITE. Take into
      account that name of table to be renamed might be result of some
      previous step in multi-step RENAME TABLES.

      In theory, we could disregard whether they locked or not and just try
      to acquire exclusive metadata locks on them, but this is too deadlock
      prone.

      Most probably, there is no tables which correspond to target table
      names, so similar check doesn't make sense for them.

      In theory, we can reduce chance of MDL deadlocks by also checking at
      this stage that all child and parent tables for FKs in which tables
      to be renamed participate are locked for WRITE (as we will have to
      acquire to exclusive MDLs on these tables later).
      But this is, probably, too severe restriction which will make
      RENAMES TABLES under LOCK TABLES hard to use in 3rd-party online
      ALTER TABLE tools.
    */
    malloc_unordered_set<Table_ref *, table_list_hash, table_list_equal>
        new_names(PSI_INSTRUMENT_ME);

    Table_ref *new_table;
    for (ren_table = table_list; ren_table; ren_table = new_table->next_local) {
      new_table = ren_table->next_local;

      auto new_name_it = new_names.find(ren_table);
      if (new_name_it == new_names.end()) {
        if (check_if_owns_upgradable_mdl(thd, ren_table->db,
                                         ren_table->table_name))
          return true;
      } else {
        new_names.erase(new_name_it);
      }
      new_names.insert(new_table);
    }

    /*
      Now proceed to acquiring exclusive metadata locks on both source and
      target table names as well as necessary schema, global and backup locks.
      Since we already have SNRW locks on source table names, we, in fact, are
      upgrading locks for them.
    */
  }

  if (lock_table_names(thd, table_list, nullptr,
                       thd->variables.lock_wait_timeout, 0, &schema_reqs) ||
      lock_trigger_names(thd, table_list))
    return true;

  const dd::Table *table_def = nullptr;
  for (Table_ref *table = table_list; table && table->next_local;
       table = table->next_local) {
    if (thd->dd_client()->acquire(table->db, table->table_name, &table_def)) {
      return true;
    }
    if (table_def && table_def->hidden() == dd::Abstract_table::HT_HIDDEN_SE) {
      my_error(ER_NO_SUCH_TABLE, MYF(0), table->db, table->table_name);
      return true;
    }
  }

  for (ren_table = table_list; ren_table; ren_table = ren_table->next_local) {
    if (thd->locked_tables_mode)
      close_all_tables_for_name(thd, ren_table->db, ren_table->table_name,
                                false);
    else
      tdc_remove_table(thd, TDC_RT_REMOVE_ALL, ren_table->db,
                       ren_table->table_name, false);
  }
  bool error = false;
  bool int_commit_done = false;
  /*
    Indicates whether we managed fully revert non-atomic RENAME TABLES
    after the failure.
  */
  bool int_commit_full_revert = false;
  std::set<handlerton *> post_ddl_htons;
  Foreign_key_parents_invalidator fk_invalidator;
  /*
    An exclusive lock on table names is satisfactory to ensure
    no other thread accesses this table.
  */
  if ((ren_table = rename_tables(thd, table_list, &int_commit_done,
                                 &post_ddl_htons, &fk_invalidator))) {
    /* Rename didn't succeed;  rename back the tables in reverse order */
    Table_ref *table;

    if (int_commit_done) {
      /* Reverse the table list */
      table_list = reverse_table_list(table_list);

      /* Find the last renamed table */
      for (table = table_list; table->next_local != ren_table;
           table = table->next_local->next_local)
        ;
      table = table->next_local->next_local;  // Skip error table

      /*
        Revert to old names. In 5.7 we have ignored most of errors occurring
        in the process. However, this looks like a risky idea -- by ignoring
        errors we are likely to end up in some awkward state and not going to
        restore status quo ante.

        So starting from 8.0 we chose to abort reversal on the first failure.
        We will still end up in some awkward case in this case but at least
        no additional damage will be done. Note that since InnoDB tables are
        new default and this engine supports atomic DDL, non-atomic RENAME
        TABLES, which this code deals with, is not the main use case anyway.
      */
      int_commit_full_revert = !rename_tables(thd, table, &int_commit_done,
                                              &post_ddl_htons, &fk_invalidator);

      /* Revert the table list (for prepared statements) */
      table_list = reverse_table_list(table_list);
    }

    error = true;
  }

  if (!error) {
    error = write_bin_log(thd, true, thd->query().str, thd->query().length,
                          !int_commit_done);
  }

  if (!error) {
    Uncommitted_tables_guard uncommitted_tables(thd);

    for (ren_table = table_list; ren_table;
         ren_table = ren_table->next_local->next_local) {
      Table_ref *new_table = ren_table->next_local;
      assert(new_table);

      uncommitted_tables.add_table(ren_table);
      uncommitted_tables.add_table(new_table);

      if ((error = update_referencing_views_metadata(
               thd, ren_table, new_table->db, new_table->table_name,
               int_commit_done, &uncommitted_tables)))
        break;
    }
  }

  if (!error && !int_commit_done) {
    error = (trans_commit_stmt(thd) || trans_commit_implicit(thd));

    if (!error) {
      /*
        Don't try to invalidate foreign key parents on error,
        as we might miss necessary locks on them.
      */
      fk_invalidator.invalidate(thd);
    }
  }

  if (error) {
    trans_rollback_stmt(thd);
    /*
      Full rollback in case we have THD::transaction_rollback_request
      and to synchronize DD state in cache and on disk (as statement
      rollback doesn't clear DD cache of modified uncommitted objects).
    */
    trans_rollback(thd);
  }

  for (handlerton *hton : post_ddl_htons) hton->post_ddl(thd);

  if (thd->locked_tables_mode) {
    if (!error) {
      /*
        Adjust locked tables list and reopen tables under new names.
        Also calculate sets of metadata locks to release (on old table
        names) and to keep until UNLOCK TABLES (on new table names).

        In addition to keeping locks on tables we also do the same for
        schemas in order to keep set of metadata locks consistent with
        one acquired by LOCK TABLES. We don't release locks on old table
        schemas as it is non-trivial to figure out which locks can be
        released.

        Tablespaces do not need special handling though, as metadata locks
        on them are acquired at LOCK TABLES time and are unaffected by
        RENAME TABLES.
      */
      malloc_unordered_set<Table_ref *, table_list_hash, table_list_equal>
          to_release(PSI_INSTRUMENT_ME), to_keep(PSI_INSTRUMENT_ME);
      Table_ref *new_table;
      for (ren_table = table_list; ren_table;
           ren_table = new_table->next_local) {
        new_table = ren_table->next_local;
        thd->locked_tables_list.rename_locked_table(
            ren_table, new_table->db, new_table->table_name,
            new_table->mdl_request.ticket);
        to_release.insert(ren_table);
        to_keep.erase(ren_table);
        to_keep.insert(new_table);
        to_release.erase(new_table);
      }

      error = thd->locked_tables_list.reopen_tables(thd);

      for (Table_ref *t : to_release) {
        // Also releases locks with EXPLICIT duration for the same name.
        thd->mdl_context.release_all_locks_for_name(t->mdl_request.ticket);
      }

      for (Table_ref *t : to_keep) {
        thd->mdl_context.set_lock_duration(t->mdl_request.ticket, MDL_EXPLICIT);
        t->mdl_request.ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
        find_and_set_explicit_duration_for_schema_mdl(thd, t, &schema_reqs);
      }
    } else if (!int_commit_done || int_commit_full_revert) {
      /*
        Error happened but all (actually not quite all, see below) changes
        were reverted. We just need to reopen tables.

        Since changes were reverted no additional metadata locks need to
        be kept after statement end. All additional locks acquired by
        this statement will be released automatically at its end, since
        they have transactional duration.

        In case of non-atomic RENAME TABLE previously orphan foreign keys
        which got new parents will keep these parents after reversal, but
        this is not important in this context.
      */
      thd->locked_tables_list.reopen_tables(thd);
    } else {
      /*
        Error happened and we failed to revert all changes. We simply close
        all tables involved.
      */
      thd->locked_tables_list.unlink_all_closed_tables(thd, nullptr, 0);
      /*
        We need to keep metadata locks on both old and new table names
        to avoid breaking foreign key invariants for LOCK TABLES.
        So we set duration of locks on new names to explicit and downgrade
        them from X to SNRW metadata locks. Also keep locks for new schemas.

        Prune list of duplicates first as setting explicit duration for the
        same MDL ticket twice is disallowed.
      */
      malloc_unordered_set<Table_ref *, table_list_hash, table_list_equal>
          to_keep(PSI_INSTRUMENT_ME);
      Table_ref *new_table;
      for (ren_table = table_list; ren_table;
           ren_table = new_table->next_local) {
        new_table = ren_table->next_local;
        to_keep.insert(new_table);
      }
      for (Table_ref *t : to_keep) {
        thd->mdl_context.set_lock_duration(t->mdl_request.ticket, MDL_EXPLICIT);
        t->mdl_request.ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
        find_and_set_explicit_duration_for_schema_mdl(thd, t, &schema_reqs);
      }
    }
  }

  if (!error) my_ok(thd);

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_servers.cc
Function: Sql_cmd_common_server::check_and_open_table
bool Sql_cmd_common_server::check_and_open_table(THD *thd) {
  if (check_global_access(thd, SUPER_ACL) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Table_ref tables("mysql", "servers", TL_WRITE);

  table = open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT);
  if (table == nullptr) return true;

  /*
    System table mysql.servers is supported by only InnoDB engine. Changing
    table's engine is not allowed. But to support logical upgrade creating
    system table is allowed in MyISAM engine. CREATE, ALTER and DROP SERVER
    operations are not allowed in this case.
  */
  if ((table->file->ht->is_supported_system_table != nullptr) &&
      !table->file->ht->is_supported_system_table(tables.db, tables.table_name,
                                                  true)) {
    my_error(ER_UNSUPPORTED_ENGINE, MYF(0),
             ha_resolve_storage_engine_name(table->file->ht), tables.db,
             tables.table_name);
    return true;
  }

  /*
    CREATE, ALTER and DROP SERVER operations are *not* allowed if table
    structure is changed.
  */
  System_table_intact table_intact(thd);
  if (table_intact.check(thd, table, &mysql_servers_table_def)) return true;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: Sql_cmd_show_schema_base::set_metadata_lock
bool Sql_cmd_show_schema_base::set_metadata_lock(THD *thd) {
  LEX_STRING lex_str_db;
  LEX *lex = thd->lex;
  if (lex_string_strmake(thd->mem_root, &lex_str_db, lex->query_block->db,
                         strlen(lex->query_block->db)))
    return true;

  // Acquire IX MDL lock on schema name.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::SCHEMA, lex_str_db.str, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: try_acquire_high_prio_shared_mdl_lock 
static bool try_acquire_high_prio_shared_mdl_lock(THD *thd, Table_ref *table,
                                                  bool can_deadlock) {
  bool error;
  MDL_REQUEST_INIT(&table->mdl_request, MDL_key::TABLE, table->db,
                   table->table_name, MDL_SHARED_HIGH_PRIO, MDL_TRANSACTION);

  if (can_deadlock) {
    /*
      When .FRM is being open in order to get data for an I_S table,
      we might have some tables not only open but also locked.
      E.g. this happens when a SHOW or I_S statement is run
      under LOCK TABLES or inside a stored function.
      By waiting for the conflicting metadata lock to go away we
      might create a deadlock which won't entirely belong to the
      MDL subsystem and thus won't be detectable by this subsystem's
      deadlock detector. To avoid such situation, when there are
      other locked tables, we prefer not to wait on a conflicting lock.
    */
    error = thd->mdl_context.try_acquire_lock(&table->mdl_request);
  } else {
    error = thd->mdl_context.acquire_lock(&table->mdl_request,
                                          thd->variables.lock_wait_timeout);
  }
  return error;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: acquire_mdl_for_table 
static bool acquire_mdl_for_table(THD *thd, const char *db_name,
                                  const char *table_name) {
  MDL_request table_request;
  MDL_REQUEST_INIT(&table_request, MDL_key::TABLE, db_name, table_name,
                   MDL_SHARED, MDL_TRANSACTION);

  if (thd->mdl_context.acquire_lock(&table_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: rm_table_do_discovery_and_lock_fk_tables
bool rm_table_do_discovery_and_lock_fk_tables(THD *thd, Table_ref *tables) {
  MEM_ROOT mdl_reqs_root(key_memory_rm_db_mdl_reqs_root, MEM_ROOT_BLOCK_SIZE);
  MDL_request_list mdl_requests;

  for (Table_ref *table = tables; table; table = table->next_local) {
    if (table->open_type != OT_BASE_ONLY && is_temporary_table(table)) continue;

    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    const dd::Abstract_table *abstract_table_def = nullptr;
    if (thd->dd_client()->acquire(table->db, table->table_name,
                                  &abstract_table_def))
      return true;

    if (!abstract_table_def) {
      /*
        If table is missing try to discover it from some storage engine
        as it might have foreign keys.
      */
      int result = ha_create_table_from_engine(
          thd, table->db,
          (lower_case_table_names == 2) ? table->alias : table->table_name);
      if (result > 0) {
        // Error during discovery, error should be reported already.
        return true;
      } else if (result == 0) {
        // Table was discovered. Re-try to retrieve its definition.
        if (thd->dd_client()->acquire(table->db, table->table_name,
                                      &abstract_table_def))
          return true;
      } else  // result < 0
      {
        // No table was found.
      }
    }

    if (!abstract_table_def ||
        abstract_table_def->type() != dd::enum_table_type::BASE_TABLE)
      continue;

    const dd::Table *table_def =
        dynamic_cast<const dd::Table *>(abstract_table_def);

    /*
      Ensure that we don't hold memory used by MDL_requests after locks
      have been acquired. This reduces memory usage in cases when we have
      DROP DATABASE that needs to drop lots of different objects.
    */
    MEM_ROOT *save_thd_mem_root = thd->mem_root;
    auto restore_thd_mem_root =
        create_scope_guard([&]() { thd->mem_root = save_thd_mem_root; });
    thd->mem_root = &mdl_reqs_root;

    if (collect_fk_parents_for_all_fks(thd, table_def, nullptr, MDL_EXCLUSIVE,
                                       &mdl_requests, nullptr))
      return true;

    if (collect_fk_children(thd, table_def, MDL_EXCLUSIVE, &mdl_requests))
      return true;

    if (collect_fk_names(thd, table->db, table_def, &mdl_requests)) return true;
  }

  if (!mdl_requests.is_empty() &&
      thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_rm_table
bool mysql_rm_table(THD *thd, Table_ref *tables, bool if_exists,
                    bool drop_temporary) {
  bool error;
  Drop_table_error_handler err_handler;
  Table_ref *table;
  uint have_non_tmp_table = 0;

  DBUG_TRACE;

  // DROP table is not allowed in the XA_IDLE or XA_PREPARED transaction states.
  if (thd->get_transaction()->xid_state()->check_xa_idle_or_prepared(true)) {
    return true;
  }

  /*
    DROP tables need to have their logging format determined if
    in MIXED mode and dropping a TEMP table.
  */
  if (thd->decide_logging_format(tables)) {
    return true;
  }

  /* Disable drop of enabled log tables, must be done before name locking */
  for (table = tables; table; table = table->next_local) {
    if (query_logger.check_if_log_table(table, true)) {
      my_error(ER_BAD_LOG_STATEMENT, MYF(0), "DROP");
      return true;
    }
  }

  if (!drop_temporary) {
    if (!thd->locked_tables_mode) {
      if (lock_table_names(thd, tables, nullptr,
                           thd->variables.lock_wait_timeout, 0) ||
          lock_trigger_names(thd, tables))
        return true;

      DEBUG_SYNC(thd, "mysql_rm_table_after_lock_table_names");

      for (table = tables; table; table = table->next_local) {
        if (is_temporary_table(table)) continue;

        /* Here we are sure that a non-tmp table exists */
        have_non_tmp_table = 1;
      }
    } else {
      bool acquire_backup_lock = false;

      for (table = tables; table; table = table->next_local)
        if (is_temporary_table(table)) {
          /*
            A temporary table.

            Don't try to find a corresponding MDL lock or assign it
            to table->mdl_request.ticket. There can't be metadata
            locks for temporary tables: they are local to the session.

            Later in this function we release the MDL lock only if
            table->mdl_requeset.ticket is not NULL. Thus here we
            ensure that we won't release the metadata lock on the base
            table locked with LOCK TABLES as a side effect of temporary
            table drop.
          */
          assert(table->mdl_request.ticket == nullptr);
        } else {
          /*
            Not a temporary table.

            Since 'tables' list can't contain duplicates (this is ensured
            by parser) it is safe to cache pointer to the TABLE instances
            in its elements.
          */
          table->table = find_table_for_mdl_upgrade(thd, table->db,
                                                    table->table_name, false);
          if (!table->table) return true;
          table->mdl_request.ticket = table->table->mdl_ticket;

          if (wait_while_table_is_used(thd, table->table,
                                       HA_EXTRA_FORCE_REOPEN))
            return true;

          /* Here we are sure that a non-tmp table exists */
          have_non_tmp_table = 1;

          if (!acquire_backup_lock) acquire_backup_lock = true;
        }

      if (acquire_backup_lock &&
          acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
        return true;
    }

    if (rm_table_do_discovery_and_lock_fk_tables(thd, tables)) return true;

    if (lock_check_constraint_names(thd, tables)) return true;
  }

  std::vector<MDL_ticket *> safe_to_release_mdl;

  {
    // This Auto_releaser needs to go out of scope before we start releasing
    // metadata locks below. Otherwise we end up having acquired objects for
    // which we no longer have any locks held.
    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    std::set<handlerton *> post_ddl_htons;
    Foreign_key_parents_invalidator fk_invalidator;
    bool not_used;

    /* mark for close and remove all cached entries */
    thd->push_internal_handler(&err_handler);
    error = mysql_rm_table_no_locks(thd, tables, if_exists, drop_temporary,
                                    false, &not_used, &post_ddl_htons,
                                    &fk_invalidator, &safe_to_release_mdl);
    thd->pop_internal_handler();
  }

  if (!drop_temporary) {
    /*
      Under LOCK TABLES we should release meta-data locks on the tables
      which were dropped.

      Leave LOCK TABLES mode if we managed to drop all tables which were
      locked. Additional check for 'non_temp_tables_count' is to avoid
      leaving LOCK TABLES mode if we have dropped only temporary tables.
    */
    if (thd->locked_tables_mode) {
      /*
        First we need to reopen tables which data-dictionary entries were
        updated/invalidated (and thus they were closed) due to fact that
        they participate in the same FKs as tables which were dropped.
      */
      if (thd->locked_tables_list.reopen_tables(thd)) error = true;

      if (thd->lock && thd->lock->table_count == 0 && have_non_tmp_table > 0) {
        thd->mdl_context.release_statement_locks();
        thd->locked_tables_list.unlock_locked_tables(thd);
      } else {
        for (MDL_ticket *mdl_ticket : safe_to_release_mdl) {
          /*
            Under LOCK TABLES we may have several instances of table open
            and locked and therefore have to remove several metadata lock
            requests associated with them.
          */
          thd->mdl_context.release_all_locks_for_name(mdl_ticket);
        }
      }
    }
  }

  if (error) return true;

  if (thd->lex->drop_temporary && thd->in_multi_stmt_transaction_mode()) {
    /*
      When autocommit is disabled, dropping temporary table sets this flag
      to start transaction in any case (regardless of binlog=on/off,
      binlog format and transactional/non-transactional engine) to make
      behavior consistent.
    */
    thd->server_status |= SERVER_STATUS_IN_TRANS;
  }

  if (thd->variables.binlog_format == BINLOG_FORMAT_STMT &&
      thd->lex->drop_temporary && (thd->in_sub_stmt & SUB_STMT_FUNCTION) &&
      thd->binlog_evt_union.do_union) {
    /*
      This does not write the query into binary log, it just sets
      thd->binlog_evt_union.unioned_events to true for writing
      its top function call to the binary log on function exit
      in mixed mode and statement mode. So this does not cause
      any error.
    */
    write_bin_log(thd, true, thd->query().str, thd->query().length, true);
  }

  my_ok(thd);
  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: lock_check_constraint_names
bool lock_check_constraint_names(THD *thd, Table_ref *tables) {
  DBUG_TRACE;
  MEM_ROOT mdl_reqs_root(key_memory_rm_db_mdl_reqs_root, MEM_ROOT_BLOCK_SIZE);
  MDL_request_list mdl_requests;

  for (Table_ref *table = tables; table != nullptr; table = table->next_local) {
    if (table->open_type != OT_BASE_ONLY && is_temporary_table(table)) continue;

    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    const dd::Abstract_table *abstract_table_def = nullptr;
    if (thd->dd_client()->acquire(table->db, table->table_name,
                                  &abstract_table_def))
      return true;

    if (abstract_table_def == nullptr ||
        abstract_table_def->type() != dd::enum_table_type::BASE_TABLE)
      continue;

    const dd::Table *table_def =
        dynamic_cast<const dd::Table *>(abstract_table_def);
    assert(table_def != nullptr);

    /*
      Ensure that we don't hold memory used by MDL_requests after locks
      have been acquired. This reduces memory usage in cases when we have
      DROP DATABASE that needs to drop lots of different objects.
    */
    MEM_ROOT *save_thd_mem_root = thd->mem_root;
    auto restore_thd_mem_root =
        create_scope_guard([&]() { thd->mem_root = save_thd_mem_root; });
    thd->mem_root = &mdl_reqs_root;

    for (auto &cc : table_def->check_constraints()) {
      if (push_check_constraint_mdl_request_to_list(
              thd, table->db, cc->name().c_str(), mdl_requests))
        return false;
    }
  }

  // Acquire MDL lock on all the check constraint names.
  if (!mdl_requests.is_empty() &&
      thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_create_table 
bool mysql_create_table(THD *thd, Table_ref *create_table,
                        HA_CREATE_INFO *create_info, Alter_info *alter_info) {
  bool result = false;
  bool is_trans = false;
  uint not_used;
  handlerton *post_ddl_ht = nullptr;
  bool is_pk_generated = false;
  Foreign_key_parents_invalidator fk_invalidator;
  DBUG_TRACE;

  handlerton *actual_hton = get_viable_handlerton_for_create(
      thd, create_table->table_name, *create_info);
  if (actual_hton == nullptr) return true;

  create_info->db_type = actual_hton;

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  if (create_info->m_transactional_ddl) {
    /*
      Stop if START TRANSACTION is requested on table with engine that
      does not support atomic DDL.
     */
    if (!(create_info->db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
      my_error(ER_NOT_ALLOWED_WITH_START_TRANSACTION, MYF(0),
               "with engine that does not support atomic DDL.");
      result = true;
      goto end;
    }

    // Stop if START TRANSACTION is requested when creating temporary table.
    if (create_info->options & HA_LEX_CREATE_TMP_TABLE) {
      my_error(ER_NOT_ALLOWED_WITH_START_TRANSACTION, MYF(0),
               "to create temporary tables.");
      result = true;
      goto end;
    }
  }

  /*
    Open or obtain "X" MDL lock on the table being created.
    To check the existence of table, lock of type "S" is obtained on the table
    and then it is upgraded to "X" if table does not exists.
  */
  if (open_tables(thd, &thd->lex->query_tables, &not_used, 0) ||
      thd->decide_logging_format(thd->lex->query_tables)) {
    result = true;
    goto end;
  }

  /* Got lock. */
  DEBUG_SYNC(thd, "locked_table_name");

  /*
    Do not acquire metadata locks on tables in FK relationships if
    table (or view with the same name) exists. They are not necessary
    as we won't perform any lookups on them or update of their metadata
    in this case.
  */
  if (!(create_table->table || create_table->is_view()) &&
      !(create_info->options & HA_LEX_CREATE_TMP_TABLE) &&
      (create_info->db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
    /*
      CREATE TABLE fails under LOCK TABLES at open_tables() time if target
      table doesn't exist already. So we don't need to handle LOCK TABLES
      case here by checking that parent tables for new FKs are properly
      locked and there are no orphan child tables for which table being
      created will become parent.
    */
    assert(thd->locked_tables_mode != LTM_LOCK_TABLES &&
           thd->locked_tables_mode != LTM_PRELOCKED_UNDER_LOCK_TABLES);

    MDL_request_list mdl_requests;

    if (collect_fk_parents_for_new_fks(thd, create_table->db,
                                       create_table->table_name, alter_info,
                                       MDL_EXCLUSIVE, create_info->db_type,
                                       &mdl_requests, &fk_invalidator) ||
        (!dd::get_dictionary()->is_dd_table_name(create_table->db,
                                                 create_table->table_name) &&
         collect_fk_children(thd, create_table->db, create_table->table_name,
                             create_info->db_type, MDL_EXCLUSIVE,
                             &mdl_requests)) ||
        collect_fk_names_for_new_fks(thd, create_table->db,
                                     create_table->table_name, alter_info,
                                     create_info->db_type,
                                     0,  // No pre-existing FKs
                                     &mdl_requests) ||
        (!mdl_requests.is_empty() &&
         thd->mdl_context.acquire_locks(&mdl_requests,
                                        thd->variables.lock_wait_timeout))) {
      result = true;
      goto end;
    }
  }

  // Prepare check constraints.
  if (prepare_check_constraints_for_create(
          thd, create_table->db, create_table->table_name, alter_info)) {
    result = true;
    goto end;
  }

  /*
    Promote first timestamp column, when explicit_defaults_for_timestamp
    is not set
  */
  if (!thd->variables.explicit_defaults_for_timestamp)
    promote_first_timestamp_column(&alter_info->create_list);

  /*
    If mode to generate invisible primary key is active then, generate primary
    key for the table.
  */
  if (is_generate_invisible_primary_key_mode_active(thd) &&
      is_candidate_table_for_invisible_primary_key_generation(create_info,
                                                              alter_info)) {
    if (validate_and_generate_invisible_primary_key(thd, alter_info)) {
      result = true;
      goto end;
    }
    is_pk_generated = true;
  }

  result = mysql_create_table_no_lock(
      thd, create_table->db, create_table->table_name, create_info, alter_info,
      0,
      /*
        We don't need to find parent keys for
        FK constraints if table exists.
      */
      !(create_table->table || create_table->is_view()), &is_trans,
      &post_ddl_ht);

  /*
    Don't write statement if:
    - Table creation has failed
    - Row-based logging is used and we are creating a temporary table
    Otherwise, the statement shall be binlogged.
  */
  if (!result) {
    /*
      CREATE TEMPORARY TABLE doesn't terminate a transaction. Calling
      stmt.mark_created_temp_table() guarantees the transaction can be binlogged
      correctly.
    */
    if (create_info->options & HA_LEX_CREATE_TMP_TABLE)
      thd->get_transaction()->mark_created_temp_table(Transaction_ctx::STMT);

    if (!thd->is_current_stmt_binlog_format_row() ||
        (thd->is_current_stmt_binlog_format_row() &&
         !(create_info->options & HA_LEX_CREATE_TMP_TABLE))) {
      thd->add_to_binlog_accessed_dbs(create_table->db);

      /*
        If primary key is generated for a table then we create version of CREATE
        TABLE statement which includes generated key and invisible column
        definitions in explicit form by calling store_create_info(). This is
        necessary to correctly binlog/replicate such statements, as we don't
        write to binary log value of @@sql_generate_invisible_primary_key
        variable, but rely on logging what really has been done instead.
      */
      if ((create_table->table == nullptr && !create_table->is_view()) &&
          is_pk_generated) {
        /*
          Open table to generate CREATE TABLE statement. For non-temporary
          table we already have exclusive lock here.
        */
        if (create_info->options & HA_LEX_CREATE_TMP_TABLE) {
          result = open_temporary_table(thd, create_table);
        } else {
          Open_table_context ot_ctx(thd, MYSQL_OPEN_REOPEN);
          result = open_table(thd, create_table, &ot_ctx);

          // Play safe, remove uncommitted table share from the cache.
          tdc_remove_table(thd, TDC_RT_REMOVE_NOT_OWN, create_table->db,
                           create_table->table_name, false);
        }

        if (!result) {
          char buf[2048];
          String query(buf, sizeof(buf), system_charset_info);
          query.length(0);
          result = store_create_info(thd, create_table, &query, create_info,
                                     true /* show_database */,
                                     false /* SHOW CREATE TABLE */);
          assert(result == 0);  // store_create_info() always return 0

          // Write generated CREATE TABLE statement to binlog.
          result =
              write_bin_log(thd, true, query.ptr(), query.length(), is_trans);

          /*
            Handle TABLE instance created for the non-temporary table here to
            avoid problems on transaction rollback. close_thread_table() at the
            end of statement will take care about the TABLE instance created
            for the temporary table.
          */
          if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE)) {
            /*
              close_thread_table() will take care about the TABLE instance we
              might have created for the non-temporary table, unless we are
              under LOCK TABLES. However, creation of non-temporary table is
              not allowed under LOCK TABLES. So we can't get here under LOCK
              TABLES.
            */
            assert(!thd->locked_tables_mode);
            close_thread_table(thd, &thd->open_tables);
            create_table->table = nullptr;
          }
        }
      } else {
        result = write_bin_log(thd, true, thd->query().str, thd->query().length,
                               is_trans);
      }
    }
  }

  if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE)) {
    if (!(create_table->table || create_table->is_view()) && !result &&
        (create_info->db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
      if (!dd::get_dictionary()->is_dd_table_name(create_table->db,
                                                  create_table->table_name)) {
        const dd::Table *new_table = nullptr;

        if (thd->dd_client()->acquire(create_table->db,
                                      create_table->table_name, &new_table))
          result = true;
        else {
          assert(new_table != nullptr);
          // Check for usage of prefix key index in PARTITION BY KEY() function.
          dd::warn_on_deprecated_prefix_key_partition(thd, create_table->db,
                                                      create_table->table_name,
                                                      new_table, false);
          /*
            If we are to support FKs for storage engines which don't support
            atomic DDL we need to decide what to do for such SEs in case of
            failure to update children definitions and adjust code accordingly.
          */
          assert(is_trans);

          if (adjust_fk_children_after_parent_def_change(
                  thd, create_table->db, create_table->table_name,
                  create_info->db_type, new_table, nullptr) ||
              adjust_fk_parents(thd, create_table->db, create_table->table_name,
                                true, nullptr))
            result = true;
        }
      }
    }

    // Update view metadata.
    if (!result) {
      Uncommitted_tables_guard uncommitted_tables(thd);

      if (!create_table->table && !create_table->is_view())
        uncommitted_tables.add_table(create_table);

      result = update_referencing_views_metadata(thd, create_table, !is_trans,
                                                 &uncommitted_tables);
    }

    /*
      Initialize the create select context with details required to perform
      rollback and commit operation after the INSERT's are executed. The
      context is freed once transaction is rolled back or committed.

      We do it just before transaction commit, so that if there is some
      error while creating a table, we can skip this initialization. One
      reason to do it this way is that the open_tables() acquires S mdl lock
      on table name and then later upgrade lock to X. If there is a error
      before the lock upgrade, we would have held S mdl lock, but then
      attempt to call tdc_remove_table() would assert during call to
      m_transactional_ddl.rollback().
    */
    if (!result && create_info->m_transactional_ddl) {
      thd->m_transactional_ddl.init(create_table->db, create_table->table_name,
                                    create_info->db_type);
    }

    /*
      Unless we are executing CREATE TEMPORARY TABLE we need to commit
      changes to the data-dictionary, SE and binary log and possibly run
      handlerton's post-DDL hook.

      Also, ignore implicit commit of transaction if we are processing
      transactional DDL.
    */
    if (!result && !thd->is_plugin_fake_ddl())
      result = trans_commit_stmt(thd) ||
               (create_info->m_transactional_ddl ? false
                                                 : trans_commit_implicit(thd));

    if (result && !thd->is_plugin_fake_ddl()) {
      trans_rollback_stmt(thd);
      /*
        Full rollback in case we have THD::transaction_rollback_request
        and to synchronize DD state in cache and on disk (as statement
        rollback doesn't clear DD cache of modified uncommitted objects).
      */
      trans_rollback(thd);
    }

    /*
      In case of CREATE TABLE post-DDL hook is mostly relevant for case
      when statement is rolled back. In such cases it is responsibility
      of this hook to cleanup files which might be left after failed
      table creation attempt. Ignore calling post-DDL hoot if we are
      processing transactional DDL.
    */
    if (!create_info->m_transactional_ddl && post_ddl_ht)
      post_ddl_ht->post_ddl(thd);

    if (!result) {
      /*
        Don't try to invalidate on error as it might be caused by
        failure to acquire locks needed for invalidation.
      */
      fk_invalidator.invalidate(thd);
    }
  }

end:
  return result;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: prepare_check_constraints_for_create
bool prepare_check_constraints_for_create(THD *thd, const char *db_name,
                                          const char *table_name,
                                          Alter_info *alter_info) {
  DBUG_TRACE;
  MDL_request_list cc_mdl_request_list;
  uint cc_max_generated_number = 0;

  /*
    Do not process check constraint specification list if master is on version
    not supporting check constraints feature.
  */
  if (is_slave_with_master_without_check_constraints_support(thd)) {
    alter_info->check_constraint_spec_list.clear();
    return false;
  }

  for (auto &cc_spec : alter_info->check_constraint_spec_list) {
    // If check constraint name is omitted then generate name.
    if (cc_spec->name.length == 0) {
      if (generate_check_constraint_name(
              thd, table_name, ++cc_max_generated_number, cc_spec->name, false))
        return true;
    }

    // Pre-validate check constraint.
    if (cc_spec->pre_validate()) return true;

    // Create MDL request for the check constraint.
    if (push_check_constraint_mdl_request_to_list(
            thd, db_name, cc_spec->name.str, cc_mdl_request_list))
      return true;
  }

  // Make sure fields used by the check constraint exists in the create list.
  mem_root_deque<Item_field *> fields(thd->mem_root);
  for (auto &cc_spec : alter_info->check_constraint_spec_list) {
    cc_spec->check_expr->walk(&Item::collect_item_field_processor,
                              enum_walk::POSTFIX, (uchar *)&fields);

    Create_field *cur_fld;
    List_iterator<Create_field> create_fields_it(alter_info->create_list);
    for (Item_field *cur_item_fld : fields) {
      if (cur_item_fld->type() != Item::FIELD_ITEM) continue;

      while ((cur_fld = create_fields_it++)) {
        if (!my_strcasecmp(system_charset_info, cur_item_fld->field_name,
                           cur_fld->field_name))
          break;
      }
      create_fields_it.rewind();

      if (cur_fld == nullptr) {
        my_error(ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN, MYF(0),
                 cc_spec->name.str, cur_item_fld->field_name);
        return true;
      }
    }
    fields.clear();
  }

  DEBUG_SYNC(thd, "before_acquiring_lock_on_check_constraints");
  if (thd->mdl_context.acquire_locks(&cc_mdl_request_list,
                                     thd->variables.lock_wait_timeout))
    return true;
  DEBUG_SYNC(thd, "after_acquiring_lock_on_check_constraints");

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_create_like_table 
bool mysql_create_like_table(THD *thd, Table_ref *table, Table_ref *src_table,
                             HA_CREATE_INFO *create_info) {
  Alter_info local_alter_info(thd->mem_root);
  Alter_table_ctx local_alter_ctx;  // Not used
  bool is_trans = false;
  uint not_used;
  Tablespace_hash_set tablespace_set(PSI_INSTRUMENT_ME);
  handlerton *post_ddl_ht = nullptr;
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  DBUG_TRACE;

  /*
    We the open source table to get its description in HA_CREATE_INFO
    and Alter_info objects. This also acquires a shared metadata lock
    on this table which ensures that no concurrent DDL operation will
    mess with it.
    Also in case when we create non-temporary table open_tables()
    call obtains an exclusive metadata lock on target table ensuring
    that we can safely perform table creation.
    Thus by holding both these locks we ensure that our statement is
    properly isolated from all concurrent operations which matter.

    CREATE LIKE needs to have the logging format determined if in
    MIXED mode and creating LIKE a TEMP table.
  */
  if (open_tables(thd, &thd->lex->query_tables, &not_used, 0) ||
      thd->decide_logging_format(thd->lex->query_tables))
    return true;
  src_table->table->use_all_columns();

  const dd::Table *src_table_obj = nullptr;
  if (!src_table->table->s->tmp_table) {
    if (thd->dd_client()->acquire(src_table->db, src_table->table_name,
                                  &src_table_obj)) {
      return true;
    }
    // Should not happen, we know the table exists and can be opened.
    assert(src_table_obj != nullptr);
  }

  DEBUG_SYNC(thd, "create_table_like_after_open");

  /* Fill HA_CREATE_INFO and Alter_info with description of source table. */
  HA_CREATE_INFO local_create_info;
  local_create_info.db_type = get_viable_handlerton_for_create_like(
      thd, table->table_name, *create_info, src_table->table->s->db_type());
  if (local_create_info.db_type == nullptr) return true;

  // This should be ok even if engine substitution has taken place since
  // row_type denontes the desired row_type, and a different row_type may be
  // assigned to real_row_type later.
  local_create_info.row_type = src_table->table->s->row_type;
  if (mysql_prepare_alter_table(thd, src_table_obj, src_table->table,
                                &local_create_info, &local_alter_info,
                                &local_alter_ctx))
    return true;

  if (prepare_check_constraints_for_create_like_table(thd, src_table, table,
                                                      &local_alter_info))
    return true;

  for (const Create_field &sql_field : local_alter_info.create_list) {
    warn_on_deprecated_float_precision(thd, sql_field);
    warn_on_deprecated_float_unsigned(thd, sql_field);
    warn_on_deprecated_zerofill(thd, sql_field);
  }

  /*
    During open_tables(), the target tablespace name(s) for a table being
    created or altered should be locked. However, for 'CREATE TABLE ... LIKE',
    the source table is not being created, yet its tablespace name should be
    locked since it is used as the target tablespace name for the table being
    created. The  target tablespace name cannot be set before open_tables()
    (which is how we handle this for e.g. CREATE TABLE ... TABLESPACE ...'),
    since before open_tables(), the source table itself is not locked, which
    means that a DDL operation may sneak in and change the tablespace of the
    source table *after* we retrieved it from the .FRM file of the source
    table, and *before* the source table itself is locked. Thus, we lock the
    target tablespace here in a separate mdl lock acquisition phase after
    open_tables(). Since the table is already opened (and locked), we retrieve
    the tablespace name from the table share instead of reading it from the
    .FRM file.
  */

  /* Partition info is not handled by mysql_prepare_alter_table() call. */
  if (src_table->table->part_info)
    thd->work_part_info = src_table->table->part_info->get_clone(thd);

  // Add the tablespace name, if used.
  if (src_table->table->s->tablespace &&
      strlen(src_table->table->s->tablespace) > 0) {
    assert(
        src_table->table->s->tmp_table ||
        thd->mdl_context.owns_equal_or_stronger_lock(
            MDL_key::TABLE, src_table->db, src_table->table_name, MDL_SHARED));

    tablespace_set.insert(src_table->table->s->tablespace);
  }

  // Add tablespace names used under partition/subpartition definitions.
  if (fill_partition_tablespace_names(src_table->table->part_info,
                                      &tablespace_set))
    return true;

  /*
    After we have identified the tablespace names, we iterate
    over the names and acquire MDL lock for each of them.
  */
  if (lock_tablespace_names(thd, &tablespace_set,
                            thd->variables.lock_wait_timeout, thd->mem_root)) {
    return true;
  }

  /*
    Adjust description of source table before using it for creation of
    target table.

    Similarly to SHOW CREATE TABLE we ignore MAX_ROWS attribute of
    temporary table which represents I_S table.
  */
  if (src_table->schema_table) local_create_info.max_rows = 0;
  /* Set IF NOT EXISTS option as in the CREATE TABLE LIKE statement. */
  local_create_info.options |=
      create_info->options & HA_LEX_CREATE_IF_NOT_EXISTS;
  /* Replace type of source table with one specified in the statement. */
  local_create_info.options &= ~HA_LEX_CREATE_TMP_TABLE;
  local_create_info.options |= create_info->options & HA_LEX_CREATE_TMP_TABLE;
  /* Reset auto-increment counter for the new table. */
  local_create_info.auto_increment_value = 0;
  /*
    Do not inherit values of DATA and INDEX DIRECTORY options from
    the original table. This is documented behavior.
  */
  local_create_info.data_file_name = local_create_info.index_file_name =
      nullptr;
  local_create_info.alias = create_info->alias;

  /*
    Keep tablespace, only if it was specified explicitly in CREATE
    TABLE when source table was created.
  */
  if (src_table_obj && !src_table_obj->is_explicit_tablespace()) {
    local_create_info.tablespace = nullptr;
  }

  /*
    Do not keep ENCRYPTION clause for unencrypted table.
    We raise error if we are creating encrypted temporary table later.
  */
  if (local_create_info.encrypt_type.str &&
      !dd::is_encrypted(local_create_info.encrypt_type)) {
    local_create_info.encrypt_type = {nullptr, 0};
  }

  /*
    Lock the FK children, in case the new table introduces a missing parent.
  */
  if (!(table->table || table->is_view()) &&
      !(create_info->options & HA_LEX_CREATE_TMP_TABLE) &&
      (local_create_info.db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
    /*
      CREATE TABLE LIKE fails under LOCK TABLES at open_tables() time if
      target table doesn't exist already. So we don't need to handle
      LOCK TABLES case here by checking that parent tables for new FKs
      are properly locked and there are no orphan child tables for which
      table being created will become parent.
    */
    assert(thd->locked_tables_mode != LTM_LOCK_TABLES &&
           thd->locked_tables_mode != LTM_PRELOCKED_UNDER_LOCK_TABLES);

    MDL_request_list mdl_requests;

    if ((!dd::get_dictionary()->is_dd_table_name(table->db,
                                                 table->table_name) &&
         collect_fk_children(thd, table->db, table->table_name,
                             local_create_info.db_type, MDL_EXCLUSIVE,
                             &mdl_requests)) ||
        (!mdl_requests.is_empty() &&
         thd->mdl_context.acquire_locks(&mdl_requests,
                                        thd->variables.lock_wait_timeout)))
      return true;
  }

  if (mysql_create_table_no_lock(
          thd, table->db, table->table_name, &local_create_info,
          &local_alter_info, 0,
          false,  // No FKs, no need to lookup parent keys
          &is_trans, &post_ddl_ht))
    goto err;

  /*
    Ensure that table or view does not exist and we have an exclusive lock on
    target table if we are creating non-temporary table. In LOCK TABLES mode
    the only way the table is locked, is if it already exists (since you cannot
    LOCK TABLE a non-existing table). And the only way we then can end up here
    is if IF EXISTS was used.
  */
  assert(
      table->table || table->is_view() ||
      (create_info->options & HA_LEX_CREATE_TMP_TABLE) ||
      (thd->locked_tables_mode != LTM_LOCK_TABLES &&
       thd->mdl_context.owns_equal_or_stronger_lock(
           MDL_key::TABLE, table->db, table->table_name, MDL_EXCLUSIVE)) ||
      (thd->locked_tables_mode == LTM_LOCK_TABLES &&
       (create_info->options & HA_LEX_CREATE_IF_NOT_EXISTS) &&
       thd->mdl_context.owns_equal_or_stronger_lock(
           MDL_key::TABLE, table->db, table->table_name, MDL_SHARED_NO_WRITE)));

  DEBUG_SYNC(thd, "create_table_like_before_binlog");

  /*
    CREATE TEMPORARY TABLE doesn't terminate a transaction. Calling
    stmt.mark_created_temp_table() guarantees the transaction can be binlogged
    correctly.
  */
  if (create_info->options & HA_LEX_CREATE_TMP_TABLE)
    thd->get_transaction()->mark_created_temp_table(Transaction_ctx::STMT);

  /*
    We have to write the query before we unlock the tables.
  */
  if (!thd->is_current_stmt_binlog_disabled() &&
      thd->is_current_stmt_binlog_format_row()) {
    /*
       Since temporary tables are not replicated under row-based
       replication, CREATE TABLE ... LIKE ... needs special
       treatment.  We have four cases to consider, according to the
       following decision table:

           ==== ========= ========= ==============================
           Case    Target    Source Write to binary log
           ==== ========= ========= ==============================
           1       normal    normal Original statement
           2       normal temporary Generated statement
           3    temporary    normal Nothing
           4    temporary temporary Nothing
           ==== ========= ========= ==============================
    */
    if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE)) {
      if (src_table->table->s->tmp_table)  // Case 2
      {
        char buf[2048];
        String query(buf, sizeof(buf), system_charset_info);
        query.length(0);  // Have to zero it since constructor doesn't
        Open_table_context ot_ctx(thd, MYSQL_OPEN_REOPEN);
        bool new_table = false;  // Whether newly created table is open.

        /*
          The condition avoids a crash as described in BUG#48506. Other
          binlogging problems related to CREATE TABLE IF NOT EXISTS LIKE
          when the existing object is a view will be solved by BUG 47442.
        */
        if (!table->is_view()) {
          if (!table->table) {
            /*
              In order for store_create_info() to work we need to open
              destination table if it is not already open (i.e. if it
              has not existed before). We don't need acquire metadata
              lock in order to do this as we already hold exclusive
              lock on this table. The table will be closed by
              close_thread_table() at the end of this branch.
            */
            bool result = open_table(thd, table, &ot_ctx);

            /*
              Play safe, ensure that we won't poison TDC/TC by storing
              not-yet-committed table definition there.
            */
            tdc_remove_table(thd, TDC_RT_REMOVE_NOT_OWN, table->db,
                             table->table_name, false);

            if (result) goto err;
            new_table = true;
          }

          /*
            After opening a MERGE table add the children to the query list of
            tables, so that children tables info can be used on "CREATE TABLE"
            statement generation by the binary log.
            Note that placeholders don't have the handler open.
          */
          if (table->table->file->ha_extra(HA_EXTRA_ADD_CHILDREN_LIST)) {
            if (new_table) {
              assert(thd->open_tables == table->table);
              close_thread_table(thd, &thd->open_tables);
              table->table = nullptr;
            }
            goto err;
          }

          /*
            As the reference table is temporary and may not exist on slave, we
            must force the ENGINE to be present into CREATE TABLE.
          */
          create_info->used_fields |= HA_CREATE_USED_ENGINE;

          bool result [[maybe_unused]] = store_create_info(
              thd, table, &query, create_info, true /* show_database */,
              false /* SHOW CREATE TABLE */);

          assert(result == 0);  // store_create_info() always return 0

          if (new_table) {
            assert(thd->open_tables == table->table);
            /*
              When opening the table, we ignored the locked tables
              (MYSQL_OPEN_GET_NEW_TABLE). Now we can close the table
              without risking to close some locked table.
            */
            close_thread_table(thd, &thd->open_tables);
            table->table = nullptr;
          }

          if (write_bin_log(thd, true, query.ptr(), query.length(), is_trans))
            goto err;
        }
      } else  // Case 1
          if (write_bin_log(thd, true, thd->query().str, thd->query().length,
                            is_trans))
        goto err;
    }
    /*
      Case 3 and 4 does nothing under RBR
    */
  } else if (write_bin_log(thd, true, thd->query().str, thd->query().length,
                           is_trans))
    goto err;

  if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE)) {
    /*
      Update the FK information for the children that were locked previously.
    */
    if (!(table->table || table->is_view()) &&
        !dd::get_dictionary()->is_dd_table_name(table->db, table->table_name) &&
        (local_create_info.db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
      const dd::Table *new_table = nullptr;
      if (thd->dd_client()->acquire(table->db, table->table_name, &new_table))
        goto err;
      else {
        assert(new_table != nullptr);
        /*
          If we are to support FKs for storage engines which don't support
          atomic DDL we need to decide what to do for such SEs in case of
          failure to update children definitions and adjust code accordingly.
        */
        assert(is_trans);

        if (adjust_fk_children_after_parent_def_change(
                thd, table->db, table->table_name, local_create_info.db_type,
                new_table, nullptr) ||
            adjust_fk_parents(thd, table->db, table->table_name, true, nullptr))
          goto err;
      }
    }

    /*
      Update view metadata. Use nested block to ensure that TDC
      invalidation happens before commit.
    */
    {
      Uncommitted_tables_guard uncommitted_tables(thd);

      if (!table->table && !table->is_view())
        uncommitted_tables.add_table(table);

      if (update_referencing_views_metadata(thd, table, !is_trans,
                                            &uncommitted_tables))
        goto err;
    }

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd)) goto err;

    if (post_ddl_ht) post_ddl_ht->post_ddl(thd);
  }
  return false;

err:
  if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE)) {
    trans_rollback_stmt(thd);
    /*
      Full rollback in case we have THD::transaction_rollback_request
      and to synchronize DD state in cache and on disk (as statement
      rollback doesn't clear DD cache of modified uncommitted objects).
    */
    trans_rollback(thd);

    if (post_ddl_ht) post_ddl_ht->post_ddl(thd);
  }
  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: prepare_check_constraints_for_create_like_table
static bool prepare_check_constraints_for_create_like_table(
    THD *thd, Table_ref *src_table, Table_ref *target_table,
    Alter_info *alter_info) {
  DBUG_TRACE;
  MDL_request_list cc_mdl_request_list;
  uint number = 0;

  if (src_table->table->table_check_constraint_list != nullptr) {
    for (auto &table_cc : *src_table->table->table_check_constraint_list) {
      Sql_check_constraint_spec *cc_spec =
          new (thd->mem_root) Sql_check_constraint_spec;
      if (cc_spec == nullptr) return true;  // OOM

      // For create like table, all the check constraint names are generated to
      // avoid name conflicts.
      if (generate_check_constraint_name(thd, target_table->table_name,
                                         ++number, cc_spec->name, true))
        return true;

      //  check constraint expression.
      cc_spec->check_expr = table_cc.value_generator()->expr_item;

      // Copy check constraint status.
      cc_spec->is_enforced = table_cc.is_enforced();

      alter_info->check_constraint_spec_list.push_back(cc_spec);

      /*
        Create MDL request for check constraint in source table and the
        generated check constraint name for target table.
      */
      if (push_check_constraint_mdl_request_to_list(
              thd, src_table->db, table_cc.name().str, cc_mdl_request_list) ||
          push_check_constraint_mdl_request_to_list(
              thd, target_table->db, cc_spec->name.str, cc_mdl_request_list))
        return true;
    }
  }

  DEBUG_SYNC(thd, "before_acquiring_lock_on_check_constraints");
  if (thd->mdl_context.acquire_locks(&cc_mdl_request_list,
                                     thd->variables.lock_wait_timeout))
    return true;
  DEBUG_SYNC(thd, "after_acquiring_lock_on_check_constraints");

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: Sql_cmd_discard_import_tablespace::mysql_discard_or_import_tablespace 
bool Sql_cmd_discard_import_tablespace::mysql_discard_or_import_tablespace(
    THD *thd, Table_ref *table_list) {
  Alter_table_prelocking_strategy alter_prelocking_strategy;
  int error;
  DBUG_TRACE;

  /*
    Note that DISCARD/IMPORT TABLESPACE always is the only operation in an
    ALTER TABLE
  */

  /*
    DISCARD/IMPORT TABLESPACE do not respect ALGORITHM and LOCK clauses.
  */
  if (m_alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_DEFAULT) {
    my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0),
             "LOCK=NONE/SHARED/EXCLUSIVE", "LOCK=DEFAULT");
    return true;
  } else if (m_alter_info->requested_algorithm !=
             Alter_info::ALTER_TABLE_ALGORITHM_DEFAULT) {
    my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0),
             "ALGORITHM=COPY/INPLACE/INSTANT", "ALGORITHM=DEFAULT");
    return true;
  }

  THD_STAGE_INFO(thd, stage_discard_or_import_tablespace);

  /*
    Adjust values of table-level and metadata which was set in parser
    for the case general ALTER TABLE.
  */
  table_list->mdl_request.set_type(MDL_EXCLUSIVE);
  table_list->set_lock({TL_WRITE, THR_DEFAULT});
  /* Do not open views. */
  table_list->required_type = dd::enum_table_type::BASE_TABLE;

  if (open_and_lock_tables(thd, table_list, 0, &alter_prelocking_strategy)) {
    /* purecov: begin inspected */
    return true;
    /* purecov: end */
  }

  if (table_list->table->part_info) {
    /*
      If not ALL is mentioned and there is at least one specified
      [sub]partition name, use the specified [sub]partitions only.
    */
    if (m_alter_info->partition_names.elements > 0 &&
        !(m_alter_info->flags & Alter_info::ALTER_ALL_PARTITION)) {
      table_list->partition_names = &m_alter_info->partition_names;
      /* Set all [named] partitions as used. */
      if (table_list->table->part_info->set_partition_bitmaps(table_list))
        return true;
    }
  } else {
    if (m_alter_info->partition_names.elements > 0 ||
        m_alter_info->flags & Alter_info::ALTER_ALL_PARTITION) {
      /* Don't allow DISCARD/IMPORT PARTITION on a nonpartitioned table */
      my_error(ER_PARTITION_MGMT_ON_NONPARTITIONED, MYF(0));
      return true;
    }
  }

  bool is_non_tmp_table = (table_list->table->s->tmp_table == NO_TMP_TABLE);
  handlerton *hton = table_list->table->s->db_type();

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  dd::Table *table_def = nullptr;

  if (is_non_tmp_table) {
    if (thd->dd_client()->acquire_for_modification(
            table_list->db, table_list->table_name, &table_def))
      return true;

    /* Table was successfully opened above. */
    assert(table_def != nullptr);
  } else
    table_def = table_list->table->s->tmp_table_def;

  /*
    Under LOCK TABLES we need to upgrade SNRW metadata lock to X lock
    before doing discard or import of tablespace.

    Skip this step for temporary tables as metadata locks are not
    applicable for them.

    Remember the ticket for the future downgrade.
  */
  MDL_ticket *mdl_ticket = nullptr;

  if (is_non_tmp_table &&
      (thd->locked_tables_mode == LTM_LOCK_TABLES ||
       thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES)) {
    mdl_ticket = table_list->table->mdl_ticket;
    if (thd->mdl_context.upgrade_shared_lock(mdl_ticket, MDL_EXCLUSIVE,
                                             thd->variables.lock_wait_timeout))
      return true;
  }

  /*
    The parser sets a flag in the Alter_info struct to indicate
    whether this is DISCARD or IMPORT. The flag is used for two purposes:

    1. To submit the appropriate parameter to the SE to indicate which
       operation is to be performed (see the source code below).
    2. To implement a callback function (the plugin API function
       'thd_tablespace_op()') allowing the SEs supporting these
       operations to check if we are doing a DISCARD or IMPORT, in order to
       suppress errors otherwise being thrown when opening tables with a
       missing tablespace.
  */

  bool discard = (m_alter_info->flags & Alter_info::ALTER_DISCARD_TABLESPACE);
  error = table_list->table->file->ha_discard_or_import_tablespace(discard,
                                                                   table_def);

  THD_STAGE_INFO(thd, stage_end);

  if (error) {
    table_list->table->file->print_error(error, MYF(0));
  } else {
    // When we have imported a tablespace we need to remove any old SDIs stored
    // in it because new SDIs need not have the same keys as those found in the
    // tablspace.
    if ((m_alter_info->flags & Alter_info::ALTER_IMPORT_TABLESPACE)) {
      // When we have imported tablespaces for individual partitions, we must
      // limit SDI removal to the tablespaces for the mentioned partitions.
      if (m_alter_info->partition_names.elements > 0) {
        DBUG_PRINT("ddsdi", ("Import partition tablespace for query:%s",
                             thd->query().str));
        const auto &pi = *table_list->table->part_info;
#ifndef NDEBUG
        for (const auto &pn : *table_list->partition_names) {
          DBUG_PRINT("ddsdi", ("Importing partition %s", pn.ptr()));
        }
        const auto &part_name_hash =
            *static_cast<Partition_share *>(table_list->table->s->ha_share)
                 ->partition_name_hash;
#endif /* NDEBUG */
        uint pa_id = 0;
        for (const auto &lp : *table_def->leaf_partitions()) {
#ifndef NDEBUG
          // Verify that part_id corresponds to index in leaf partition vector.
          auto part_def = find_or_nullptr(
              part_name_hash,
              std::string(lp->name().c_str(), lp->name().length()));
          assert(part_def != nullptr);
          assert(part_def->part_id == pa_id);
#endif /* NDEBUG */
          DBUG_PRINT("ddsdi",
                     ("Checking leaf partition %s, is_used(pa_id:%u):%s",
                      lp->name().c_str(), pa_id,
                      pi.is_partition_used(pa_id) ? "true" : "false"));
          if (pi.is_partition_used(pa_id) &&
              dd::sdi::drop_all_for_part(thd, lp)) {
            error = 1;
            break;
          }
          ++pa_id;
        }
      } else {
        assert(m_alter_info->partition_names.elements == 0);
        // We get here when we have imported a table tablespace, or all
        // partition tablespaces. In this case, we remove SDIs from all
        // tablespaces associated with the table.
        if (dd::sdi::drop_all_for_table(thd, table_def)) {
          error = 1;
        }
      }
    }

    /*
      Storage engine supporting atomic DDL can fully rollback discard/
      import if any problem occurs. This will happen during statement
      rollback.

      In case of success we need to save dd::Table object which might
      have been updated by SE. If this step or subsequent write to binary
      log fail then statement rollback will also restore status quo ante.
    */
    if (!error && is_non_tmp_table &&
        (hton->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        thd->dd_client()->update(table_def))
      error = 1;

    if (!error)
      error = write_bin_log(thd, false, thd->query().str, thd->query().length,
                            (hton->flags & HTON_SUPPORTS_ATOMIC_DDL));

      /*
        TODO: In theory since we have updated table definition in the
              data-dictionary above we need to remove its TABLE/TABLE_SHARE
              from TDC now. However this makes InnoDB to produce too many
              warnings about discarded tablespace which are not always well
              justified. So this code should be enabled after InnoDB is
              adjusted to be less verbose in these cases.
      */
#ifdef NEEDS_SUPPORT_FROM_INNODB
    if (is_non_tmp_table)
      close_all_tables_for_name(thd, table_list->table->s, false, nullptr);
    table_list->table = nullptr;  // Safety.
#endif
  }

  if (!error) error = trans_commit_stmt(thd) || trans_commit_implicit(thd);

  if (error) {
    trans_rollback_stmt(thd);
    trans_rollback_implicit(thd);
  }

  if (is_non_tmp_table && (hton->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
      hton->post_ddl)
    hton->post_ddl(thd);

  if (thd->locked_tables_mode && thd->locked_tables_list.reopen_tables(thd))
    error = 1;

  if (mdl_ticket) mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);

  if (error == 0) {
    my_ok(thd);
    return false;
  }

  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: Sql_cmd_secondary_load_unload::mysql_secondary_load_or_unload 
bool Sql_cmd_secondary_load_unload::mysql_secondary_load_or_unload(
    THD *thd, Table_ref *table_list) {
  Alter_table_prelocking_strategy alter_prelocking_strategy;

  // Because SECONDARY_LOAD and SECONDARY_UNLOAD are standalone alter table
  // actions, it should be impossible to set ALGORITHM and LOCK.
  assert(m_alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_DEFAULT);
  assert(m_alter_info->requested_algorithm ==
         Alter_info::ALTER_TABLE_ALGORITHM_DEFAULT);

  table_list->mdl_request.set_type(MDL_EXCLUSIVE);

  // Always use isolation level READ_COMMITTED to ensure consistent view of
  // table data during entire load operation. Higher isolation levels provide no
  // benefits for this operation and could impact performance, so it's fine to
  // downgrade from both REPEATABLE_READ and SERIALIZABLE.
  const enum_tx_isolation orig_tx_isolation = thd->tx_isolation;
  auto tx_isolation_guard = create_scope_guard(
      [thd, orig_tx_isolation] { thd->tx_isolation = orig_tx_isolation; });
  thd->tx_isolation = ISO_READ_COMMITTED;

  // Open base table.
  table_list->required_type = dd::enum_table_type::BASE_TABLE;
  if (open_and_lock_tables(thd, table_list, 0, &alter_prelocking_strategy))
    return true;

  // Omit hidden generated columns and columns marked as NOT SECONDARY from
  // read_set. It is the responsibility of the secondary engine handler to load
  // only the columns included in the read_set.
  bitmap_clear_all(table_list->table->read_set);
  for (Field **field = table_list->table->field; *field != nullptr; ++field) {
    // Skip hidden generated columns.
    if (bitmap_is_set(&table_list->table->fields_for_functional_indexes,
                      (*field)->field_index()))
      continue;

    // Skip columns marked as NOT SECONDARY.
    if ((*field)->is_flag_set(NOT_SECONDARY_FLAG)) continue;

    // Mark column as eligible for loading.
    table_list->table->mark_column_used(*field, MARK_COLUMNS_READ);
  }

  // SECONDARY_LOAD/SECONDARY_UNLOAD requires a secondary engine.
  if (!table_list->table->s->has_secondary_engine()) {
    my_error(ER_SECONDARY_ENGINE, MYF(0), "No secondary engine defined");
    return true;
  }

  // It should not have been possible to define a temporary table with a
  // secondary engine.
  assert(table_list->table->s->tmp_table == NO_TMP_TABLE);

  handlerton *hton = table_list->table->s->db_type();
  assert(hton->flags & HTON_SUPPORTS_ATOMIC_DDL &&
         hton->flags & HTON_SUPPORTS_SECONDARY_ENGINE &&
         hton->post_ddl != nullptr);

  // cache table name locally for future use
  const size_t name_len = table_list->db_length +
                          table_list->table_name_length +
                          5;  // for backticks, dot `db`.`tab`
  // allocated on thread, freed-up on thread exit
  char *full_tab_name = (char *)sql_calloc(name_len + 1);  // for \0 at the end
  sprintf(full_tab_name, "`%s`.`%s`", table_list->db, table_list->table_name);
  full_tab_name[name_len] = '\0';  // may not needed, since inited with 0

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  dd::Table *table_def = nullptr;
  if (thd->dd_client()->acquire_for_modification(
          table_list->db, table_list->table_name, &table_def))
    return true;

  MDL_ticket *mdl_ticket = table_list->table->mdl_ticket;

  auto downgrade_guard = create_scope_guard([mdl_ticket, thd] {
    // Under LOCK TABLES, downgrade to MDL_SHARED_NO_READ_WRITE after all
    // operations have completed.
    if (secondary_engine_lock_tables_mode(*thd)) {
      mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
    }
  });
  if (thd->mdl_context.upgrade_shared_lock(mdl_ticket, MDL_EXCLUSIVE,
                                           thd->variables.lock_wait_timeout))
    return true;

  // Cleanup that must be done regardless of commit or rollback.
  auto cleanup = [thd, hton]() {
    hton->post_ddl(thd);
    return thd->locked_tables_mode &&
           thd->locked_tables_list.reopen_tables(thd);
  };

  // This scope guard is responsible for rolling back the transaction in case of
  // any errors.
  auto rollback_guard = create_scope_guard([thd, cleanup] {
    trans_rollback_stmt(thd);
    trans_rollback_implicit(thd);
    cleanup();
  });

  /* Currently, if the DDL rolls back after completing the secondary engine
   * operation, then during undo only the secondary_flag update is undone, but
   * the secondary engine operation (load/unload) is not undone. This creates
   * a temporary inconsistency in the system where the secondary_load flag is
   * not in sync with the actual status of the table in the secondary engine. */

  // TODO: undo handling of secondary engine operation

  // Load if SECONDARY_LOAD, unload if SECONDARY_UNLOAD
  const bool is_load = m_alter_info->flags & Alter_info::ALTER_SECONDARY_LOAD;

  // Initiate loading into or unloading from secondary engine.
  if (is_load) {
    DEBUG_SYNC(thd, "before_secondary_engine_load_table");
    if (DBUG_EVALUATE_IF("sim_secload_fail",
                         (my_error(ER_SECONDARY_ENGINE, MYF(0),
                                   "Simulated failure of secondary_load()"),
                          true),
                         false) ||
        secondary_engine_load_table(thd, *table_list->table))
      return true;
  } else {
    if (DBUG_EVALUATE_IF("sim_secunload_fail",
                         (my_error(ER_SECONDARY_ENGINE, MYF(0),
                                   "Simulated failure of secondary_unload()"),
                          true),
                         false) ||
        secondary_engine_unload_table(thd, table_list->db,
                                      table_list->table_name, *table_def, true))
      return true;
  }
  DBUG_PRINT("sec_load_unload", ("secondary engine %s succeeded for table %s",
                                 (is_load ? "load" : "unload"), full_tab_name));

  DBUG_EXECUTE_IF("sim_fail_before_metadata_update", {
    DBUG_PRINT("sec_load_unload", ("Force exit before metadata update"));
    my_error(
        ER_SECONDARY_ENGINE, MYF(0),
        "Simulated failure of sec_{un}load before secondary_load flag update");
    return true;
  });

  // Update the secondary_load flag based on the current operation.
  if (DBUG_EVALUATE_IF("sim_fail_metadata_update",
                       (my_error(ER_SECONDARY_ENGINE, MYF(0),
                                 "Simulated failure during metadata update"),
                        true),
                       false) ||
      table_def->options().set("secondary_load", is_load) ||
      thd->dd_client()->update(table_def)) {
    LogErr(ERROR_LEVEL, ER_SECONDARY_ENGINE_DDL_FAILED, full_tab_name,
           (is_load ? "secondary_load" : "secondary_unload"),
           "metadata update failed");
    return true;
  }

  DBUG_PRINT("sec_load_unload", ("secondary_load flag %s for table %s",
                                 (is_load ? "set" : "reset"), full_tab_name));

  DBUG_EXECUTE_IF("sim_fail_before_write_bin_log", {
    DBUG_PRINT("sec_load_unload", ("Force exit before binlog write"));
    my_error(ER_SECONDARY_ENGINE, MYF(0),
             "Simulated failure of sec_{un}load before write_bin_log()");
    return true;
  });

  /* Write binlog to maintain replication consistency. Read-Replica's may not
   * have binlog enabled. write_bin_log API takes care of such cases. */
  if (DBUG_EVALUATE_IF("sim_fail_binlog_write",
                       (my_error(ER_SECONDARY_ENGINE, MYF(0),
                                 "Simulated failure during binlog write"),
                        true),
                       false) ||
      (write_bin_log(thd, true, thd->query().str, thd->query().length, true) !=
       0)) {
    LogErr(ERROR_LEVEL, ER_SECONDARY_ENGINE_DDL_FAILED, full_tab_name,
           (is_load ? "secondary_load" : "secondary_unload"),
           "binlog write failed");
    return true;
  }

  DBUG_PRINT("sec_load_unload",
             ("binlog entry added for alter table %s secondary_%s",
              full_tab_name, (is_load ? "load" : "unload")));

  DBUG_EXECUTE_IF("sim_fail_after_write_bin_log", {
    DBUG_PRINT("sec_load_unload", ("Force exit after binlog write"));
    my_error(ER_SECONDARY_ENGINE, MYF(0),
             "Simulated failure of sec_{un}load after write_bin_log()");
    return true;
  });

  // Close primary table.
  close_all_tables_for_name(thd, table_list->table->s, false, nullptr);
  table_list->table = nullptr;

  // Commit transaction if no errors.
  if (DBUG_EVALUATE_IF("sim_fail_transaction_commit",
                       (my_error(ER_SECONDARY_ENGINE, MYF(0),
                                 "Simulated failure during metadata update"),
                        true),
                       false) ||
      trans_commit_stmt(thd) || trans_commit_implicit(thd)) {
    LogErr(ERROR_LEVEL, ER_SECONDARY_ENGINE_DDL_FAILED, full_tab_name,
           (is_load ? "secondary_load" : "secondary_unload"),
           "transaction commit failed");
    return true;
  }

  DBUG_PRINT("sec_load_unload",
             ("commit succeeded for alter table %s secondary_%s", full_tab_name,
              (is_load ? "load" : "unload")));
  // Transaction committed successfully, no rollback will be necessary.
  rollback_guard.commit();

  if (cleanup()) return true;

  my_ok(thd);
  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: collect_and_lock_fk_tables_for_rename_table 
bool collect_and_lock_fk_tables_for_rename_table(
    THD *thd, const char *db, const char *table_name,
    const dd::Table *table_def, const char *new_db, const char *new_table_name,
    handlerton *hton, Foreign_key_parents_invalidator *fk_invalidator) {
  MDL_request_list mdl_requests;

  if (collect_fk_children(thd, db, table_name, hton, MDL_EXCLUSIVE,
                          &mdl_requests) ||
      collect_fk_children(thd, new_db, new_table_name, hton, MDL_EXCLUSIVE,
                          &mdl_requests) ||
      collect_fk_parents_for_all_fks(thd, table_def, hton, MDL_EXCLUSIVE,
                                     &mdl_requests, fk_invalidator) ||
      collect_fk_names_for_rename_table(thd, db, table_name, table_def, hton,
                                        new_db, new_table_name, &mdl_requests))
    return true;

  if (!mdl_requests.is_empty() &&
      thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_alter_table 
bool mysql_alter_table(THD *thd, const char *new_db, const char *new_name,
                       HA_CREATE_INFO *create_info, Table_ref *table_list,
                       Alter_info *alter_info) {
  DBUG_TRACE;

  /*
    Check if we attempt to alter mysql.slow_log or
    mysql.general_log table and return an error if
    it is the case.
    TODO: this design is obsolete and will be removed.
  */
  enum_log_table_type table_kind =
      query_logger.check_if_log_table(table_list, false);

  if (table_kind != QUERY_LOG_NONE) {
    /* Disable alter of enabled query log tables */
    if (query_logger.is_log_table_enabled(table_kind)) {
      my_error(ER_BAD_LOG_STATEMENT, MYF(0), "ALTER");
      return true;
    }

    /* Disable alter of log tables to unsupported engine */
    if ((create_info->used_fields & HA_CREATE_USED_ENGINE) &&
        (!create_info->db_type || /* unknown engine */
         !(create_info->db_type->flags & HTON_SUPPORT_LOG_TABLES))) {
      my_error(ER_UNSUPORTED_LOG_ENGINE, MYF(0));
      return true;
    }

    if (alter_info->flags & Alter_info::ALTER_PARTITION) {
      my_error(ER_WRONG_USAGE, MYF(0), "PARTITION", "log table");
      return true;
    }
  }

  // Reject request to ALTER TABLE with START TRANSACTION.
  if (create_info->m_transactional_ddl) {
    my_error(ER_NOT_ALLOWED_WITH_START_TRANSACTION, MYF(0),
             "with ALTER TABLE command.");
    return true;
  }

  if (alter_info->with_validation != Alter_info::ALTER_VALIDATION_DEFAULT &&
      !(alter_info->flags &
        (Alter_info::ALTER_ADD_COLUMN | Alter_info::ALTER_CHANGE_COLUMN))) {
    my_error(ER_WRONG_USAGE, MYF(0), "ALTER", "WITH VALIDATION");
    return true;
  }

  if ((alter_info->flags & Alter_info::ALTER_ADD_COLUMN) ==
      Alter_info::ALTER_ADD_COLUMN) {
    for (auto create_field : alter_info->create_list) {
      if (create_field.m_default_val_expr) {
        // ALTER TABLE .. DEFAULT (NDF function) should be rejected for mixed or
        // row binlog_format. For statement binlog_format it should be allowed
        // to continue and warning should be logged and/or pushed to the client
        if ((thd->variables.option_bits & OPTION_BIN_LOG) &&
            thd->lex->is_stmt_unsafe(
                Query_tables_list::BINLOG_STMT_UNSAFE_SYSTEM_FUNCTION)) {
          if (thd->variables.binlog_format == BINLOG_FORMAT_STMT) {
            LogErr(WARNING_LEVEL, ER_SERVER_BINLOG_UNSAFE_SYSTEM_FUNCTION,
                   "ALTER TABLE .. DEFAULT (NDF function)");
            push_warning(thd, Sql_condition::SL_WARNING,
                         ER_BINLOG_UNSAFE_SYSTEM_FUNCTION,
                         ER_THD(thd, ER_BINLOG_UNSAFE_SYSTEM_FUNCTION));
            break;
          } else {
            my_error(ER_BINLOG_UNSAFE_SYSTEM_FUNCTION, MYF(0));
            return true;
          }
        }
      }
    }
  }

  // LOCK clause doesn't make any sense for ALGORITHM=INSTANT.
  if (alter_info->requested_algorithm ==
          Alter_info::ALTER_TABLE_ALGORITHM_INSTANT &&
      alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_DEFAULT) {
    my_error(ER_WRONG_USAGE, MYF(0), "ALGORITHM=INSTANT",
             "LOCK=NONE/SHARED/EXCLUSIVE");
    return true;
  }

  THD_STAGE_INFO(thd, stage_init);

  // Reject invalid usage of the 'mysql' tablespace.
  if (dd::invalid_tablespace_usage(thd, table_list->db, table_list->table_name,
                                   create_info))
    return true;

  /*
    Assign target tablespace name to enable locking in lock_table_names().
    Reject invalid name lengths. Names will be validated after the table is
    opened and the SE (needed for SE specific validation) is identified.
  */
  if (create_info->tablespace) {
    if (validate_tablespace_name_length(create_info->tablespace)) return true;

    if (lex_string_strmake(thd->mem_root, &table_list->target_tablespace_name,
                           create_info->tablespace,
                           strlen(create_info->tablespace))) {
      my_error(ER_OUT_OF_RESOURCES, MYF(ME_FATALERROR));
      return true;
    }
  }

  /* Validate that AUTOEXTEND_SIZE option is not specified for
  temporary tables */
  if (is_temporary_table(table_list)) {
    if (create_info->m_implicit_tablespace_autoextend_size > 0) {
      my_error(ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE, MYF(0), "temporary");
      return true;
    }
  }

  /*
    Reject invalid tablespace name lengths specified for partitions.
    Names will be validated after the table has been opened.
  */
  if (validate_partition_tablespace_name_lengths(thd->lex->part_info))
    return true;

  /*
    Assign the partition info, so that the locks on tablespaces
    assigned for any new partitions added would be acquired during
    open_table.
  */
  thd->work_part_info = thd->lex->part_info;

  /*
    Code below can handle only base tables so ensure that we won't open a view.
    Note that RENAME TABLE the only ALTER clause which is supported for views
    has been already processed.
  */
  table_list->required_type = dd::enum_table_type::BASE_TABLE;

  /*
    If we are about to ALTER non-temporary table we need to get permission
    from/notify interested storage engines.
  */
  Table_ddl_hton_notification_guard notification_guard{
      thd, &table_list->mdl_request.key, HA_ALTER_DDL};

  if (!is_temporary_table(table_list) && notification_guard.notify())
    return true;

  Alter_table_prelocking_strategy alter_prelocking_strategy;

  DEBUG_SYNC(thd, "alter_table_before_open_tables");
  uint tables_opened;
  bool error = open_tables(thd, &table_list, &tables_opened, 0,
                           &alter_prelocking_strategy);

  DEBUG_SYNC(thd, "alter_opened_table");

  if (error) return true;

  // If we are removing a functional index, add any related hidden generated
  // columns to the drop list as well.
  if (handle_drop_functional_index(thd, alter_info, table_list)) {
    return true;
  }

  // If we are renaming a functional index, rename any related hidden generated
  // columns as well.
  if (alter_info->flags & Alter_info::ALTER_RENAME_INDEX) {
    if (handle_rename_functional_index(thd, alter_info, table_list)) {
      return true; /* purecov: deadcode */
    }
  }

  // Check tablespace name validity for the relevant engine.
  {
    // If there is no target handlerton, use the current.
    const handlerton *target_handlerton = create_info->db_type;
    if (target_handlerton == nullptr)
      target_handlerton = table_list->table->file->ht;

    /*
      Reject invalid tablespace names for the relevant engine, if the ALTER
      statement changes either tablespace or engine. We do this after the table
      has been opened because we need the handlerton and tablespace information.
      No need to validate if neither engine nor tablespace is changed, then the
      validation was done when the table was created.
    */
    if (create_info->tablespace || create_info->db_type) {
      // If there is no target table level tablespace, use the current.
      const char *target_tablespace = create_info->tablespace;
      if (target_tablespace == nullptr)
        target_tablespace = table_list->table->s->tablespace;

      // Check the tablespace/engine combination.
      assert(target_handlerton);
      if (target_tablespace != nullptr &&
          validate_tablespace_name(TS_CMD_NOT_DEFINED, target_tablespace,
                                   target_handlerton))
        return true;
    }

    // Reject invalid tablespace names specified for partitions.
    if (validate_partition_tablespace_names(thd->lex->part_info,
                                            target_handlerton))
      return true;
  }

  if (validate_secondary_engine_option(thd, *alter_info, *create_info,
                                       *table_list->table))
    return true;

  if (lock_trigger_names(thd, table_list)) return true;

  /*
    If we're in LOCK TABLE mode, we must lock the target tablespace name
    as well as the currently used tablesapces (since these may have been
    introduced by a previous ALTER while already in LOCK TABLE mode).
  */
  if (thd->locked_tables_mode &&
      get_and_lock_tablespace_names(thd, table_list, nullptr,
                                    thd->variables.lock_wait_timeout, MYF(0))) {
    return true;
  }

  if (table_list->table->s->db_type() != create_info->db_type &&
      (alter_info->flags & Alter_info::ALTER_OPTIONS) &&
      (create_info->used_fields & HA_CREATE_USED_ENGINE)) {
    handlerton *actual_hton = get_viable_handlerton_for_alter(
        thd, *create_info, table_list->table->s->db_type());
    if (actual_hton == nullptr) return true;

    create_info->db_type = actual_hton;
  }

  const handlerton *hton = create_info->db_type;
  if (hton == nullptr) {
    hton = table_list->table->s->db_type();
  }
  assert(hton != nullptr);
  if ((alter_info->flags & Alter_info::ANY_ENGINE_ATTRIBUTE) != 0 &&
      ((hton->flags & HTON_SUPPORTS_ENGINE_ATTRIBUTE) == 0 &&
       DBUG_EVALUATE_IF("simulate_engine_attribute_support", false, true))) {
    my_error(ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED, MYF(0),
             ha_resolve_storage_engine_name(hton));
    return true;
  }

  TABLE *table = table_list->table;
  table->use_all_columns();
  MDL_ticket *mdl_ticket = table->mdl_ticket;

  /*
    Prohibit changing of the UNION list of a non-temporary MERGE table
    under LOCK tables. It would be quite difficult to reuse a shrunk
    set of tables from the old table or to open a new TABLE object for
    an extended list and verify that they belong to locked tables.
  */
  if ((thd->locked_tables_mode == LTM_LOCK_TABLES ||
       thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) &&
      (create_info->used_fields & HA_CREATE_USED_UNION) &&
      (table->s->tmp_table == NO_TMP_TABLE)) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  Alter_table_ctx alter_ctx(thd, table_list, tables_opened, new_db, new_name);

  /*
    Acquire and keep schema locks until commit time, so the DD layer can
    safely assert that we have proper MDL on objects stored in the DD.
  */
  dd::Schema_MDL_locker mdl_locker_1(thd), mdl_locker_2(thd);
  const dd::Schema *schema = nullptr;
  const dd::Schema *new_schema = nullptr;
  const dd::Table *old_table_def = nullptr;
  /*
    This releaser allows us to keep uncommitted DD objects cached
    in the Dictionary_client until commit time.
  */
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  if (mdl_locker_1.ensure_locked(alter_ctx.db) ||
      mdl_locker_2.ensure_locked(alter_ctx.new_db) ||
      thd->dd_client()->acquire(alter_ctx.db, &schema) ||
      thd->dd_client()->acquire(alter_ctx.new_db, &new_schema))
    return true;

  if ((table->s->tmp_table == NO_TMP_TABLE) &&
      thd->dd_client()->acquire(alter_ctx.db, alter_ctx.table_name,
                                &old_table_def))
    return true;

  // If this is a temporary table, the schema might not exist even
  // if we have successfully opened the table
  if (schema == nullptr) {
    assert(table->s->tmp_table);
    my_error(ER_BAD_DB_ERROR, MYF(0), alter_ctx.db);
    return true;
  }

  assert((table->s->tmp_table != NO_TMP_TABLE) || old_table_def != nullptr);

  if (new_schema == nullptr) {
    my_error(ER_BAD_DB_ERROR, MYF(0), alter_ctx.new_db);
    return true;
  }

  /*
    Add old and new (if any) databases to the list of accessed databases
    for this statement. Needed for MTS.
  */
  thd->add_to_binlog_accessed_dbs(alter_ctx.db);
  if (alter_ctx.is_database_changed())
    thd->add_to_binlog_accessed_dbs(alter_ctx.new_db);

  // Ensure that triggers are in the same schema as their subject table.
  if (alter_ctx.is_database_changed() && old_table_def != nullptr &&
      old_table_def->has_trigger()) {
    my_error(ER_TRG_IN_WRONG_SCHEMA, MYF(0));
    return true;
  }

  /* Check that we are not trying to rename to an existing table */
  if (alter_ctx.is_table_renamed()) {
    if (table->s->tmp_table != NO_TMP_TABLE) {
      if (find_temporary_table(thd, alter_ctx.new_db, alter_ctx.new_name)) {
        my_error(ER_TABLE_EXISTS_ERROR, MYF(0), alter_ctx.new_alias);
        return true;
      }
    } else {
      MDL_request_list mdl_requests;

      mdl_requests.push_front(&alter_ctx.target_mdl_request);
      /*
        If we are moving the table to a different database, we also
        need IX lock on the database name so that the target database
        is protected by MDL while the table is moved.
      */
      if (alter_ctx.is_database_changed())
        mdl_requests.push_front(&alter_ctx.target_db_mdl_request);

      /*
        Global intention exclusive lock must have been already acquired when
        table to be altered was open, so there is no need to do it here.
      */
      assert(thd->mdl_context.owns_equal_or_stronger_lock(
          MDL_key::GLOBAL, "", "", MDL_INTENTION_EXCLUSIVE));

      if (thd->mdl_context.acquire_locks(&mdl_requests,
                                         thd->variables.lock_wait_timeout))
        return true;

      DEBUG_SYNC(thd, "locked_table_name");
      /*
        Table maybe does not exist, but we got an exclusive lock
        on the name, now we can safely try to find out for sure.
      */
      const dd::Abstract_table *at = nullptr;
      if (thd->dd_client()->acquire(alter_ctx.new_db, alter_ctx.new_name, &at))
        return true;

      if (at != nullptr) {
        /* Table will be closed in do_command() */
        my_error(ER_TABLE_EXISTS_ERROR, MYF(0), alter_ctx.new_alias);
        return true;
      }
    }
  }

  if (!create_info->db_type) {
    if (table->part_info && create_info->used_fields & HA_CREATE_USED_ENGINE) {
      /*
        This case happens when the user specified
        ENGINE = x where x is a non-existing storage engine
        We set create_info->db_type to default_engine_type
        to ensure we don't change underlying engine type
        due to a erroneously given engine name.
      */
      create_info->db_type = table->part_info->default_engine_type;
    } else
      create_info->db_type = table->s->db_type();
  }

  if (check_engine(alter_ctx.new_db, alter_ctx.new_name, create_info))
    return true;

  /*
    Do not allow change of storage engine if table participates in a foreign
    key. Even in cases when both source and target storage engines support
    foreign keys the fine details of what is supported might differ.
  */
  if (create_info->db_type != table->s->db_type() && old_table_def != nullptr &&
      (old_table_def->foreign_keys().size() ||
       old_table_def->foreign_key_parents().size())) {
    my_error(ER_FK_CANNOT_CHANGE_ENGINE, MYF(0));
    return true;
  }

  /*
   If foreign key is added then check permission to access parent table.

   In function "check_fk_parent_table_access", create_info->db_type is used
   to identify whether engine supports FK constraint or not. Since
   create_info->db_type is set here, check to parent table access is delayed
   till this point for the alter operation.
  */
  if ((alter_info->flags & Alter_info::ADD_FOREIGN_KEY) &&
      check_fk_parent_table_access(thd, create_info, alter_info))
    return true;

  Foreign_key_parents_invalidator fk_invalidator;

  if (table->s->tmp_table == NO_TMP_TABLE) {
    MDL_request_list mdl_requests;

    if (collect_fk_parents_for_new_fks(
            thd, table_list->db, table_list->table_name, alter_info,
            MDL_SHARED_UPGRADABLE, nullptr, &mdl_requests, nullptr))
      return true;

    /*
      Acquire SU locks on parent and child tables so we can access
      their definition while checking if this ALTER TABLE will break
      any FKs involving them.

      TODO: Refine set of ALTER TABLE commands for which we do this.
            This is obviously necessary for ADD/DROP KEY and COLUMN
            modifications. But are there any other operations which
            might affect indexes somehow?
    */
    if (!is_simple_rename_or_index_change(alter_info)) {
      if (collect_fk_parents_for_all_fks(thd, old_table_def, nullptr,
                                         MDL_SHARED_UPGRADABLE, &mdl_requests,
                                         nullptr))
        return true;

      if (create_info->db_type != table->s->db_type()) {
        /*
          By changing table's storage engine we might be introducing parent
          table for previously orphan foreign keys in the new SE. We need
          to lock child tables of such orphan foreign keys. OTOH it is safe
          to assume that if SE is changed table can't be parent in any
          foreign keys in old SE.

          Note that here and in other similar places we assume that ALTER
          TABLE which combines change of SE and renaming of table is executed
          by changing SE first and then performing rename (this is closer to
          ALTER TABLE real implementation). Because of this such ALTER TABLEs
          need to pick up orphan foreign keys associated with old table names
          as well. Thus we use old table name to get list of orphans.
        */
        assert(old_table_def->foreign_key_parents().size() == 0);

        if (collect_fk_children(thd, table_list->db, table_list->table_name,
                                create_info->db_type, MDL_SHARED_UPGRADABLE,
                                &mdl_requests))
          return true;
      } else {
        if (collect_fk_children(thd, old_table_def, MDL_SHARED_UPGRADABLE,
                                &mdl_requests))
          return true;
      }

      if (alter_ctx.is_table_renamed() &&
          collect_fk_children(thd, alter_ctx.new_db, alter_ctx.new_alias,
                              create_info->db_type, MDL_SHARED_UPGRADABLE,
                              &mdl_requests))
        return true;
    }

    /*
      Lock names of foreign keys to be dropped.

      Note that we can't lock names of foreign keys to be added yet
      because database in which they will be created depends on ALTER
      TABLE algorithm we are going to choose later.
    */
    if (collect_fk_names_for_dropped_fks(thd, table_list->db, alter_info,
                                         old_table_def, &mdl_requests))
      return true;

    /*
      Under LOCK TABLES all parent tables must be locked at least in READ
      mode. Otherwise, our ALTER TABLE will leave after itself child table
      locked for WRITE, without corresponding parent tables locked and thus
      without ability to perform FK checks when child table is modified.
    */
    if (thd->locked_tables_mode == LTM_LOCK_TABLES ||
        thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) {
      MDL_request_list::Iterator it(mdl_requests);
      MDL_request *mdl_request;

      while ((mdl_request = it++) != nullptr) {
        if (mdl_request->key.mdl_namespace() != MDL_key::TABLE) continue;

        if (!thd->mdl_context.owns_equal_or_stronger_lock(
                MDL_key::TABLE, mdl_request->key.db_name(),
                mdl_request->key.name(), MDL_SHARED_READ_ONLY)) {
          my_error(ER_TABLE_NOT_LOCKED, MYF(0), mdl_request->key.name());
          return true;
        }
      }
    }

    if (!mdl_requests.is_empty() &&
        thd->mdl_context.acquire_locks(&mdl_requests,
                                       thd->variables.lock_wait_timeout))
      return true;

    DEBUG_SYNC(thd, "alter_table_after_mdl_lock_fk");

    /*
      If we are executing ALTER TABLE RENAME under LOCK TABLES we also need
      to check that all previously orphan tables which reference new table
      name through foreign keys are locked for write. Otherwise this ALTER
      will leave after itself parent table locked for WRITE without child
      tables locked for WRITE. This will break FK LOCK TABLES invariants if
      some of previously orphan FKs have referential actions which update
      child table.

      The same should be done when we are going to add parent table to
      previously orphan foreign keys by changing table storage engine.

      In theory, we can reduce chance of MDL deadlocks by also checking at
      this stage that all child and parent tables for FKs in which this
      table participates are locked for WRITE (as we will have to acquire
      to exclusive MDLs on these tables later). But this is, probably, too
      severe restriction since many 3rd-party online ALTER tools use ALTER
      TABLE RENAME under LOCK TABLES and are unaware of it.
    */
    if (thd->locked_tables_mode == LTM_LOCK_TABLES ||
        thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) {
      MDL_request_list orphans_mdl_requests;

      if (create_info->db_type != table->s->db_type()) {
        assert(old_table_def->foreign_key_parents().size() == 0);
        if (collect_fk_children(thd, table_list->db, table_list->table_name,
                                create_info->db_type, MDL_EXCLUSIVE,
                                &orphans_mdl_requests))
          return true;
      }
      if (alter_ctx.is_table_renamed() &&
          collect_fk_children(thd, alter_ctx.new_db, alter_ctx.new_alias,
                              create_info->db_type, MDL_EXCLUSIVE,
                              &orphans_mdl_requests))
        return true;

      if (!orphans_mdl_requests.is_empty()) {
        MDL_request_list::Iterator it(orphans_mdl_requests);
        MDL_request *mdl_request;

        while ((mdl_request = it++) != nullptr) {
          if (mdl_request->key.mdl_namespace() != MDL_key::TABLE) continue;

          if (!thd->mdl_context.owns_equal_or_stronger_lock(
                  MDL_key::TABLE, mdl_request->key.db_name(),
                  mdl_request->key.name(), MDL_SHARED_NO_READ_WRITE)) {
            my_error(ER_TABLE_NOT_LOCKED_FOR_WRITE, MYF(0),
                     mdl_request->key.name());
            return true;
          }
        }
      }
    }
  }

  /*
   If this is an ALTER TABLE and no explicit row type specified reuse
   the table's row type.
   Note : this is the same as if the row type was specified explicitly.
  */
  if (create_info->row_type == ROW_TYPE_NOT_USED) {
    /* ALTER TABLE without explicit row type */
    create_info->row_type = table->s->row_type;
  } else {
    /* ALTER TABLE with specific row type */
    create_info->used_fields |= HA_CREATE_USED_ROW_FORMAT;
  }

  DBUG_PRINT("info", ("old type: %s  new type: %s",
                      ha_resolve_storage_engine_name(table->s->db_type()),
                      ha_resolve_storage_engine_name(create_info->db_type)));
  if (ha_check_storage_engine_flag(table->s->db_type(),
                                   HTON_ALTER_NOT_SUPPORTED) ||
      ha_check_storage_engine_flag(create_info->db_type,
                                   HTON_ALTER_NOT_SUPPORTED)) {
    DBUG_PRINT("info", ("doesn't support alter"));
    my_error(ER_ILLEGAL_HA, MYF(0), table_list->table_name);
    return true;
  }

  THD_STAGE_INFO(thd, stage_setup);

  if (is_simple_rename_or_index_change(alter_info) && !table->s->tmp_table) {
    // This requires X-lock, no other lock levels supported.
    if (alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_DEFAULT &&
        alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "LOCK=NONE/SHARED",
               "LOCK=EXCLUSIVE");
      return true;
    }
    return simple_rename_or_index_change(thd, *new_schema, table_list,
                                         alter_info->keys_onoff, &alter_ctx);
  }

  /* We have to do full alter table. */
  bool partition_changed = false;
  partition_info *new_part_info = nullptr;
  {
    if (prep_alter_part_table(thd, table, alter_info, create_info, &alter_ctx,
                              &partition_changed, &new_part_info)) {
      return true;
    }
  }

  /*
    Store all columns that are going to be dropped, since we need this list
    when removing column statistics later. The reason we need to store it here,
    is that 'mysql_prepare_alter_table' may remove some of the columns from
    the drop_list.
  */
  histograms::columns_set columns;
  for (const auto column : alter_info->drop_list) {
    if (column->type == Alter_drop::COLUMN) columns.emplace(column->name);
  }
  const Alter_column *alter = nullptr;
  uint i = 0;
  while (i < alter_info->alter_list.size()) {
    alter = alter_info->alter_list[i];
    if (alter->change_type() == Alter_column::Type::RENAME_COLUMN)
      columns.emplace(alter->name);
    i++;
  }

  Create_field *create_field;
  List_iterator<Create_field> list_it(alter_info->create_list);
  while ((create_field = list_it++)) {
    if (create_field->change != nullptr) columns.emplace(create_field->change);
  }

  /*
    Type of a constraint marked for DROP with DROP CONSTRAINT clause is unknown.
    Resolve type of a constraint by name.
  */
  Drop_constraint_type_resolver drop_constraint_type_resolver(alter_info);
  if (drop_constraint_type_resolver.is_type_resolution_needed() &&
      (drop_constraint_type_resolver.resolve_constraints_type(thd, table,
                                                              old_table_def)))
    return true;

  /*
    Type of a constraint marked for ALTER with ALTER CONSTRAINT clause is
    unknown. Resolve type of a constraint by name.
  */
  Enforce_constraint_type_resolver enforce_constraint_type_resolver(alter_info);
  if (enforce_constraint_type_resolver.is_type_resolution_needed() &&
      (enforce_constraint_type_resolver.resolve_constraints_type(
          thd, table, old_table_def)))
    return true;

  // Prepare check constraints for alter table operation.
  if (prepare_check_constraints_for_alter(thd, table, alter_info, &alter_ctx))
    return true;

  if (mysql_prepare_alter_table(thd, old_table_def, table, create_info,
                                alter_info, &alter_ctx)) {
    return true;
  }

  // Check restrictions on ALTER TABLE operations that affects GIPK and PK.
  if (check_primary_key_alter_restrictions(thd, create_info->db_type,
                                           alter_info, table))
    return true;

  /*
    Check if we are changing the SRID specification on a geometry column that
    has a spatial index. If that is the case, reject the change since allowing
    geometries with different SRIDs in a spatial index will make the index
    useless.
  */
  if (!is_alter_geometry_column_valid(alter_info)) return true;

  if (set_table_default_charset(thd, create_info, *schema)) return true;

  /*
    Use copy algorithm if:
    - old_alter_table system variable is set without in-place requested using
      the ALGORITHM clause.
    - Or if in-place is impossible for given operation.
    - Changes to partitioning needs to be handled using table copying
      algorithm unless the engine supports partitioning changes using
      in-place API (because it supports auto-partitioning or simply
      can do partitioning changes using in-place using mark-up in
      partition_info object).
  */
  if ((thd->variables.old_alter_table &&
       alter_info->requested_algorithm !=
           Alter_info::ALTER_TABLE_ALGORITHM_INPLACE &&
       alter_info->requested_algorithm !=
           Alter_info::ALTER_TABLE_ALGORITHM_INSTANT) ||
      is_inplace_alter_impossible(table, create_info, alter_info) ||
      (partition_changed &&
       !(table->s->db_type()->partition_flags() & HA_USE_AUTO_PARTITION) &&
       !new_part_info)) {
    if (alter_info->requested_algorithm ==
        Alter_info::ALTER_TABLE_ALGORITHM_INPLACE) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "ALGORITHM=INPLACE",
               "ALGORITHM=COPY");
      return true;
    }
    if (alter_info->requested_algorithm ==
        Alter_info::ALTER_TABLE_ALGORITHM_INSTANT) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "ALGORITHM=INSTANT",
               "ALGORITHM=COPY");
      return true;
    }
    alter_info->requested_algorithm = Alter_info::ALTER_TABLE_ALGORITHM_COPY;
  }

  /*
    If 'avoid_temporal_upgrade' mode is not enabled, then the
    pre MySQL 5.6.4 old temporal types if present is upgraded to the
    current format.
  */

  mysql_mutex_lock(&LOCK_global_system_variables);
  bool check_temporal_upgrade = !avoid_temporal_upgrade;
  mysql_mutex_unlock(&LOCK_global_system_variables);

  if (check_temporal_upgrade) {
    if (upgrade_old_temporal_types(thd, alter_info)) return true;
  }

  /*
    ALTER TABLE ... ENGINE to the same engine is a common way to
    request table rebuild. Set ALTER_RECREATE flag to force table
    rebuild.
  */
  if (create_info->db_type == table->s->db_type() &&
      create_info->used_fields & HA_CREATE_USED_ENGINE)
    alter_info->flags |= Alter_info::ALTER_RECREATE;

  /*
    If the old table had partitions and we are doing ALTER TABLE ...
    engine= <new_engine>, the new table must preserve the original
    partitioning. This means that the new engine is still the
    partitioning engine, not the engine specified in the parser.
    This is discovered in prep_alter_part_table, which in such case
    updates create_info->db_type.
    It's therefore important that the assignment below is done
    after prep_alter_part_table.
  */
  handlerton *new_db_type = create_info->db_type;
  handlerton *old_db_type = table->s->db_type();
  TABLE *new_table = nullptr;
  ha_rows copied = 0, deleted = 0;

  /*
    Handling of symlinked tables:
    If no rename:
      Create new data file and index file on the same disk as the
      old data and index files.
      Copy data.
      Rename new data file over old data file and new index file over
      old index file.
      Symlinks are not changed.

   If rename:
      Create new data file and index file on the same disk as the
      old data and index files.  Create also symlinks to point at
      the new tables.
      Copy data.
      At end, rename intermediate tables, and symlinks to intermediate
      table, to final table name.
      Remove old table and old symlinks

    If rename is made to another database:
      Create new tables in new database.
      Copy data.
      Remove old table and symlinks.
  */
  char index_file[FN_REFLEN], data_file[FN_REFLEN];

  if (!alter_ctx.is_database_changed()) {
    if (create_info->index_file_name) {
      /* Fix index_file_name to have 'tmp_name' as basename */
      my_stpcpy(index_file, alter_ctx.tmp_name);
      create_info->index_file_name =
          fn_same(index_file, create_info->index_file_name, 1);
    }
    if (create_info->data_file_name) {
      /* Fix data_file_name to have 'tmp_name' as basename */
      my_stpcpy(data_file, alter_ctx.tmp_name);
      create_info->data_file_name =
          fn_same(data_file, create_info->data_file_name, 1);
    }
  } else {
    /* Ignore symlink if db is changed. */
    create_info->data_file_name = create_info->index_file_name = nullptr;
  }

  DEBUG_SYNC(thd, "alter_table_before_create_table_no_lock");
  DBUG_EXECUTE_IF("sleep_before_create_table_no_lock", my_sleep(100000););
  /*
    Promote first timestamp column, when explicit_defaults_for_timestamp
    is not set
  */
  if (!thd->variables.explicit_defaults_for_timestamp)
    promote_first_timestamp_column(&alter_info->create_list);

  /*
    Create .FRM for new version of table with a temporary name.
    We don't log the statement, it will be logged later.

    Keep information about keys in newly created table as it
    will be used later to construct Alter_inplace_info object
    and by fill_alter_inplace_info() call.
  */
  KEY *key_info;
  uint key_count;
  FOREIGN_KEY *fk_key_info = nullptr;
  uint fk_key_count = 0;

  Alter_info::enum_enable_or_disable keys_onoff =
      ((alter_info->keys_onoff == Alter_info::LEAVE_AS_IS &&
        table->file->indexes_are_disabled())
           ? Alter_info::DISABLE
           : alter_info->keys_onoff);

  /*
    Take the X metadata lock on temporary name used for new version of
    the table. This ensures that concurrent I_S queries won't try to open it.
  */

  MDL_request tmp_name_mdl_request;
  bool is_tmp_table = (table->s->tmp_table != NO_TMP_TABLE);

  // Avoid these tables to be visible by I_S/SHOW queries.
  create_info->m_hidden = !is_tmp_table;

  if (!is_tmp_table) {
    MDL_REQUEST_INIT(&tmp_name_mdl_request, MDL_key::TABLE, alter_ctx.new_db,
                     alter_ctx.tmp_name, MDL_EXCLUSIVE, MDL_STATEMENT);
    if (thd->mdl_context.acquire_lock(&tmp_name_mdl_request,
                                      thd->variables.lock_wait_timeout))
      return true;
  }

  // Stop if we have invalid encryption clause.
  if (!is_tmp_table && validate_table_encryption(thd, create_info)) return true;

  /*
    For temporary tables or tables in SEs supporting atomic DDL dd::Table
    object describing new version of table. This object will be created in
    memory in create_table_impl() and will not be put into the on-disk DD
    and DD Object Cache.

    We become responsible for destroying this dd::Table object (for
    temporary tables until we pass its ownership to the TABLE_SHARE).
  */
  std::unique_ptr<dd::Table> non_dd_table_def;

  {
    Disable_binlog_guard binlog_guard(thd);
    /* Prevent intermediate commits to invoke commit order */
    Implicit_substatement_state_guard substatement_guard(
        thd, enum_implicit_substatement_guard_mode ::
                 DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);
    error = create_table_impl(
        thd, *new_schema, alter_ctx.new_db, alter_ctx.tmp_name,
        alter_ctx.table_name, alter_ctx.get_tmp_path(), create_info, alter_info,
        true, 0, true, true,
        /*
          If target SE supports atomic DDL do not store
          new table version in on-disk DD.
          It is not required to rollback statement in
          case of error and allows to keep correct names
          for pre-existing foreign keys in the dd::Table
          object for new table version.
         */
        (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL), nullptr, &key_info,
        &key_count, keys_onoff, &fk_key_info, &fk_key_count, alter_ctx.fk_info,
        alter_ctx.fk_count, old_table_def,
        alter_ctx.fk_max_generated_name_number, &non_dd_table_def, nullptr);
  }

  if (error) {
    /*
      Play it safe, rollback possible changes to the data-dictionary,
      so failed mysql_alter_table()/mysql_recreate_table() do not
      require rollback in the caller. Also do full rollback in unlikely
      case we have THD::transaction_rollback_request.
    */
    trans_rollback_stmt(thd);
    trans_rollback(thd);
    return true;
  }

  /*
    Atomic replacement of the table is possible only if both old and new
    storage engines support DDL atomicity.
  */
  bool atomic_replace = (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
                        (old_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL);

  /* Remember that we have not created table in storage engine yet. */
  bool no_ha_table = true;

  /* Indicates special case when we do ALTER TABLE which is really no-op. */
  bool is_noop = false;

  /*
    Indicates special case involving non-atomic ALTER TABLE which adds
    foreign keys and then fails at the late stage. Such ALTER TABLE still
    requires FK parent invalidation even despite of error.
  */
  bool invalidate_fk_parents_on_error = false;

  dd::Encrypt_result old_er{false, false};
  dd::Encrypt_result new_er{false, false};

  /*
    If we are ALTERing non-temporary table in SE not supporting atomic DDL
    we don't have dd::Table object describing new version of table yet.
    Retrieve it now.
  */
  dd::Table *table_def = non_dd_table_def.get();
  if (!table_def) {
    if (thd->dd_client()->acquire_for_modification(
            alter_ctx.new_db, alter_ctx.tmp_name, &table_def))
      goto err_new_table_cleanup;

    set_check_constraints_alter_mode(table_def, alter_info);

    assert(table_def);
  }

  if (!is_tmp_table) {
    // Check for usage of prefix key index in PARTITION BY KEY() function.
    dd::warn_on_deprecated_prefix_key_partition(
        thd, alter_ctx.db, alter_ctx.table_name, table_def, false);
  }

  if (remove_secondary_engine(thd, *table_list, *create_info, old_table_def))
    goto err_new_table_cleanup;

  // If we are changing the tablespace or the table encryption type.
  if (old_table_def &&
      (create_info->used_fields & HA_CREATE_USED_TABLESPACE ||
       create_info->used_fields & HA_CREATE_USED_ENCRYPT ||
       create_info->used_fields & HA_CREATE_USED_AUTOEXTEND_SIZE ||
       alter_ctx.is_database_changed())) {
    bool source_is_general_tablespace{false};
    bool source_encrytion_type{false};
    bool destination_is_general_tablespace{false};
    bool destination_encrytion_type{false};

    // Determine source tablespace type and encryption type.
    old_er = dd::is_tablespace_encrypted(thd, *old_table_def,
                                         &source_is_general_tablespace);
    if (old_er.error) {
      goto err_new_table_cleanup;
    }
    source_encrytion_type = old_er.value;
    if (!source_is_general_tablespace &&
        old_table_def->options().exists("encrypt_type")) {
      dd::String_type et;
      (void)old_table_def->options().get("encrypt_type", &et);
      assert(et.empty() == false);
      source_encrytion_type = is_encrypted(et);
    }

    // Determine destination tablespace type and encryption type.
    new_er = dd::is_tablespace_encrypted(thd, *table_def,
                                         &destination_is_general_tablespace);
    if (new_er.error) {
      goto err_new_table_cleanup;
    }
    destination_encrytion_type = new_er.value;
    if (!destination_is_general_tablespace &&
        table_def->options().exists("encrypt_type")) {
      dd::String_type et;
      (void)table_def->options().get("encrypt_type", &et);
      assert(et.empty() == false);
      destination_encrytion_type = is_encrypted(et);
    }

    /*
      Disallow converting a general tablespace to a file-per-table
      tablespace without a explicit ENCRYPTION clause.
    */
    if (source_is_general_tablespace && source_encrytion_type == true &&
        !destination_is_general_tablespace &&
        !(create_info->used_fields & HA_CREATE_USED_ENCRYPT)) {
      my_error(ER_TARGET_TABLESPACE_UNENCRYPTED, MYF(0));
      goto err_new_table_cleanup;
    }

    /*
      Disallow moving encrypted table (using general or file-per-table
      tablespace) to a unencrypted general tablespace.
    */
    if (source_encrytion_type && destination_is_general_tablespace &&
        !destination_encrytion_type) {
      my_error(ER_TARGET_TABLESPACE_UNENCRYPTED, MYF(0));
      goto err_new_table_cleanup;
    }

    /*
      Check table encryption privilege, if table encryption type differ
      from schema encryption type.
    */
    if (new_schema->default_encryption() != destination_encrytion_type) {
      // Ignore privilege check and show warning if database is same and
      // table encryption type is not changed.
      bool show_warning = !alter_ctx.is_database_changed() &&
                          source_encrytion_type == destination_encrytion_type;

      if (!show_warning && opt_table_encryption_privilege_check) {
        if (check_table_encryption_admin_access(thd)) {
          my_error(ER_CANNOT_SET_TABLE_ENCRYPTION, MYF(0));
          return true;
        }
      } else if (new_schema->default_encryption() &&
                 !destination_encrytion_type) {
        push_warning(thd, Sql_condition::SL_WARNING,
                     WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB,
                     ER_THD(thd, WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB));
      }
    }
  }

  if (old_table_def) {
    if (is_checked_for_upgrade(*old_table_def)) {
      DBUG_PRINT("admin", ("Transfering upgrade mark "
                           "from Table %s (%llu) to Table %s (%llu)",
                           old_table_def->name().c_str(), old_table_def->id(),
                           table_def->name().c_str(), table_def->id()));
      table_def->mark_as_checked_for_upgrade();
    }
  }

  /*
    Check if new table definition is compatible with foreign keys
    on other tales which reference this one. We want to do this
    before starting potentially expensive main phases of COPYing
    or INPLACE ALTER TABLE.
  */
  if (!is_tmp_table) {
    if (new_db_type != old_db_type) {
      /*
        By changing table's storage engine we might be introducing parent
        table for previously orphan foreign keys in the new SE. We need
        to lock child tables of such orphan foreign keys. OTOH it is safe
        to assume that if SE is changed table can't be parent in any
        foreign keys in old SE.

        We assume that ALTER TABLE which combines change of SE and renaming
        of table is executed by changing SE first and then performing rename
        (this is closer to ALTER TABLE real implementation). So such ALTER
        TABLEs  need to pick up orphan foreign keys associated with old table
        names as well. Thus we use old table name in the below check.
      */
      assert(old_table_def->foreign_key_parents().size() == 0);

      if (check_fk_children_after_parent_def_change(
              thd, table_list->db, table_list->table_name, nullptr, nullptr,
              new_db_type, table_def))
        goto err_new_table_cleanup;
    } else {
      if (check_fk_children_after_parent_def_change(
              thd, table_list->db, table_list->table_name, new_db_type,
              old_table_def, table_def, alter_info))
        goto err_new_table_cleanup;
    }

    if (alter_ctx.is_table_renamed() &&
        check_fk_children_after_parent_def_change(
            thd, alter_ctx.new_db, alter_ctx.new_alias, table_list->db,
            table_list->table_name, new_db_type, table_def))
      goto err_new_table_cleanup;
  }

  if (alter_info->requested_algorithm !=
      Alter_info::ALTER_TABLE_ALGORITHM_COPY) {
    Alter_inplace_info ha_alter_info(create_info, alter_info,
                                     alter_ctx.error_if_not_empty, key_info,
                                     key_count, thd->work_part_info);
    TABLE *altered_table = nullptr;
    bool use_inplace = true;

    /* Fill the Alter_inplace_info structure. */
    if (fill_alter_inplace_info(thd, table, &ha_alter_info))
      goto err_new_table_cleanup;

    DBUG_EXECUTE_IF("innodb_index_drop_count_zero", {
      if (ha_alter_info.index_drop_count) {
        my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "Index rebuild",
                 "Without rebuild");
        return true;
      }
    };);

    DBUG_EXECUTE_IF("innodb_index_drop_count_one", {
      if (ha_alter_info.index_drop_count != 1) {
        my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "Index change",
                 "Index rebuild");
        return true;
      }
    };);

    // We assume that the table is non-temporary.
    assert(!table->s->tmp_table);

    if (!(altered_table = open_table_uncached(
              thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
              alter_ctx.tmp_name, true, false, *table_def)))
      goto err_new_table_cleanup;

    /* Set markers for fields in TABLE object for altered table. */
    update_altered_table(ha_alter_info, altered_table);

    /*
      Mark all columns in 'altered_table' as used to allow usage
      of its record[0] buffer and Field objects during in-place
      ALTER TABLE.
    */
    altered_table->column_bitmaps_set_no_signal(&altered_table->s->all_set,
                                                &altered_table->s->all_set);

    set_column_static_defaults(altered_table, alter_info->create_list);

    if (ha_alter_info.handler_flags == 0) {
      /*
        No-op ALTER, no need to call handler API functions.

        If this code path is entered for an ALTER statement that
        should not be a real no-op, new handler flags should be added
        and fill_alter_inplace_info() adjusted.

        Note that we can end up here if an ALTER statement has clauses
        that cancel each other out (e.g. ADD/DROP identically index).

        Also note that we ignore the LOCK clause here.
      */
      close_temporary_table(thd, altered_table, true, false);

      if (!(create_info->db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
        // Delete temporary table object from data dictionary.
        bool result = dd::drop_table(thd, alter_ctx.new_db, alter_ctx.tmp_name,
                                     *table_def);
        (void)trans_intermediate_ddl_commit(thd, result);
      }

      is_noop = true;
      goto end_inplace_noop;
    }

    // Ask storage engine whether to use copy or in-place
    enum_alter_inplace_result inplace_supported =
        table->file->check_if_supported_inplace_alter(altered_table,
                                                      &ha_alter_info);

    // If INSTANT was requested but it is not supported, report error.
    if (alter_info->requested_algorithm ==
            Alter_info::ALTER_TABLE_ALGORITHM_INSTANT &&
        inplace_supported != HA_ALTER_INPLACE_INSTANT &&
        inplace_supported != HA_ALTER_ERROR) {
      ha_alter_info.report_unsupported_error("ALGORITHM=INSTANT",
                                             "ALGORITHM=COPY/INPLACE");
      close_temporary_table(thd, altered_table, true, false);
      goto err_new_table_cleanup;
    }

    switch (inplace_supported) {
      case HA_ALTER_INPLACE_EXCLUSIVE_LOCK:
        // If SHARED lock and no particular algorithm was requested, use COPY.
        if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_SHARED &&
            alter_info->requested_algorithm ==
                Alter_info::ALTER_TABLE_ALGORITHM_DEFAULT) {
          use_inplace = false;
        }
        // Otherwise, if weaker lock was requested, report error.
        else if (alter_info->requested_lock ==
                     Alter_info::ALTER_TABLE_LOCK_NONE ||
                 alter_info->requested_lock ==
                     Alter_info::ALTER_TABLE_LOCK_SHARED) {
          ha_alter_info.report_unsupported_error("LOCK=NONE/SHARED",
                                                 "LOCK=EXCLUSIVE");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        break;
      case HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE:
      case HA_ALTER_INPLACE_SHARED_LOCK:
        // If weaker lock was requested, report error.
        if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_NONE) {
          ha_alter_info.report_unsupported_error("LOCK=NONE", "LOCK=SHARED");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        break;
      case HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE:
      case HA_ALTER_INPLACE_NO_LOCK:
      case HA_ALTER_INPLACE_INSTANT:
        /*
          Note that any instant operation is also in fact in-place operation.

          It is totally safe to execute operation using instant algorithm if it
          has no drawbacks as compared to in-place algorithm even if user
          explicitly asked for ALGORITHM=INPLACE. Doing so, also allows to
          keep code in engines which support only limited subset of in-place
          ALTER TABLE operations as instant metadata only changes simple.

          If instant algorithm has some downsides to in-place algorithm and user
          explicitly asks for ALGORITHM=INPLACE it is responsibility of storage
          engine to fallback to in-place algorithm execution by returning
          HA_ALTER_INPLACE_NO_LOCK or HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE.
        */
        break;
      case HA_ALTER_INPLACE_NOT_SUPPORTED:
        // If INPLACE was requested, report error.
        if (alter_info->requested_algorithm ==
            Alter_info::ALTER_TABLE_ALGORITHM_INPLACE) {
          ha_alter_info.report_unsupported_error("ALGORITHM=INPLACE",
                                                 "ALGORITHM=COPY");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        // COPY with LOCK=NONE is not supported, no point in trying.
        if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_NONE) {
          ha_alter_info.report_unsupported_error("LOCK=NONE", "LOCK=SHARED");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        // Otherwise use COPY
        use_inplace = false;
        break;
      case HA_ALTER_ERROR:
      default:
        close_temporary_table(thd, altered_table, true, false);
        goto err_new_table_cleanup;
    }

    if (use_inplace) {
      if (mysql_inplace_alter_table(thd, *schema, *new_schema, old_table_def,
                                    table_def, table_list, table, altered_table,
                                    &ha_alter_info, inplace_supported,
                                    &alter_ctx, columns, fk_key_info,
                                    fk_key_count, &fk_invalidator)) {
        return true;
      }

      goto end_inplace;
    } else {
      close_temporary_table(thd, altered_table, true, false);
    }
  }

  /* ALTER TABLE using copy algorithm. */

  /* Check if ALTER TABLE is compatible with foreign key definitions. */
  if (fk_check_copy_alter_table(thd, table_list, old_table_def, alter_info))
    goto err_new_table_cleanup;

  if (!table->s->tmp_table) {
    MDL_request_list mdl_requests;

    // COPY algorithm doesn't work with concurrent writes.
    if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_NONE) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED_REASON, MYF(0), "LOCK=NONE",
               ER_THD(thd, ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY),
               "LOCK=SHARED");
      goto err_new_table_cleanup;
    }

    // If EXCLUSIVE lock is requested, upgrade already.
    if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE &&
        wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN))
      goto err_new_table_cleanup;

    /*
      Otherwise upgrade to SHARED_NO_WRITE.
      Note that under LOCK TABLES, we will already have SHARED_NO_READ_WRITE.
    */
    if (alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE &&
        thd->mdl_context.upgrade_shared_lock(mdl_ticket, MDL_SHARED_NO_WRITE,
                                             thd->variables.lock_wait_timeout))
      goto err_new_table_cleanup;

    DEBUG_SYNC(thd, "alter_table_copy_after_lock_upgrade");

    /*
      COPY algorithm creates new table version in the new database.
      So if new database differs from old one we need to lock all
      foreign key names in new table version. If it is the same as
      the old one we need to lock only names of foreign keys added.

      Also if table is renamed we need to acquire locks on all foreign
      key names involved (taking into account adjustment of auto-generated
      names).
    */
    if (alter_ctx.is_database_changed()) {
      if (collect_fk_names(thd, alter_ctx.new_db, table_def, &mdl_requests))
        goto err_new_table_cleanup;
    } else {
      if (collect_fk_names_for_new_fks(
              thd, alter_ctx.new_db, table_list->table_name, alter_info,
              new_db_type,
              get_fk_max_generated_name_number(table_list->table_name,
                                               old_table_def, new_db_type),
              &mdl_requests))
        goto err_new_table_cleanup;
    }

    if (alter_ctx.is_table_renamed() &&
        collect_fk_names_for_rename_table(
            thd, table_list->db, table_list->table_name, table_def, new_db_type,
            alter_ctx.new_db, alter_ctx.new_name, &mdl_requests))
      goto err_new_table_cleanup;

    /*
      Acquire SRO locks on parent tables for newly added foreign keys
      in order to prevent concurrent DML on them.

      This is temporary workaround to the problem caused by the fact that
      InnoDB makes such foreign keys visible in its internal dictionary
      cache before ALTER TABLE commit. So such DML can result in access
      to our temporary table without prior acquisition of metadata lock
      on it (which would have blocked such access normally). As result
      our ALTER TABLE can fail due to locks acquired by these accesses.

      Long-term the problem should be solved by adjusting InnoDB code
      to avoid making such uncommitted changes visible to other
      connections.
    */
    if (collect_fk_parents_for_new_fks(
            thd, table_list->db, table_list->table_name, alter_info,
            MDL_SHARED_READ_ONLY, nullptr, &mdl_requests, nullptr))
      goto err_new_table_cleanup;

    if (!mdl_requests.is_empty() &&
        thd->mdl_context.acquire_locks(&mdl_requests,
                                       thd->variables.lock_wait_timeout))
      goto err_new_table_cleanup;

    /*
      Check if ALTER TABLE results in any foreign key name conflicts
      before starting potentially expensive copying operation.
    */
    if (!dd::get_dictionary()->is_dd_table_name(table_list->db,
                                                table_list->table_name) &&
        (new_db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
      if (alter_ctx.is_database_changed()) {
        /*
          If new table version was created schema different from the old one
          we need to check names for both pre-existing and newly added foreign
          keys.
        */
        for (FOREIGN_KEY *fk = fk_key_info; fk < fk_key_info + fk_key_count;
             ++fk) {
          bool exists;
          if (thd->dd_client()->check_foreign_key_exists(*new_schema, fk->name,
                                                         &exists))
            goto err_new_table_cleanup;

          if (exists) {
            my_error(ER_FK_DUP_NAME, MYF(0), fk->name);
            goto err_new_table_cleanup;
          }
        }
      } else {
        /* Otherwise we can limit our check to newly added foreign keys only. */
        for (FOREIGN_KEY *fk = fk_key_info + alter_ctx.fk_count;
             fk < fk_key_info + fk_key_count; ++fk) {
          bool exists;
          if (thd->dd_client()->check_foreign_key_exists(*new_schema, fk->name,
                                                         &exists))
            goto err_new_table_cleanup;

          if (exists) {
            my_error(ER_FK_DUP_NAME, MYF(0), fk->name);
            goto err_new_table_cleanup;
          }
        }
      }

      if (alter_ctx.is_table_renamed() &&
          check_fk_names_before_rename(thd, table_list, *table_def, new_db_type,
                                       *new_schema, alter_ctx))
        goto err_new_table_cleanup;
    }
  }

  {
    if (ha_create_table(thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
                        alter_ctx.tmp_name, create_info, false, true,
                        table_def))
      goto err_new_table_cleanup;

    /* Mark that we have created table in storage engine. */
    no_ha_table = false;

    if (create_info->options & HA_LEX_CREATE_TMP_TABLE) {
      if (thd->decide_logging_format(table_list) ||
          !open_table_uncached(thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
                               alter_ctx.tmp_name, true, true, *table_def))
        goto err_new_table_cleanup;
      /* in case of alter temp table send the tracker in OK packet */
      if (thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
              ->is_enabled())
        thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
            ->mark_as_changed(thd, {});
    }

    /* Open the table since we need to copy the data. */
    if (table->s->tmp_table != NO_TMP_TABLE) {
      Table_ref tbl(alter_ctx.new_db, alter_ctx.tmp_name, TL_READ_NO_INSERT);
      /* Table is in thd->temporary_tables */
      (void)open_temporary_table(thd, &tbl);
      new_table = tbl.table;
      /* Transfer dd::Table ownership to temporary table's share. */
      new_table->s->tmp_table_def = non_dd_table_def.release();
    } else {
      /* table is a normal table: Create temporary table in same directory */
      /* Open our intermediate table. */
      new_table =
          open_table_uncached(thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
                              alter_ctx.tmp_name, true, true, *table_def);
    }
    if (!new_table) goto err_new_table_cleanup;
    /*
      Note: In case of MERGE table, we do not attach children. We do not
      copy data for MERGE tables. Only the children have data.
    */

    // It's now safe to take the table level lock.
    if (lock_tables(thd, table_list, alter_ctx.tables_opened, 0))
      goto err_new_table_cleanup;
  }

  /*
    We do not copy data for MERGE tables. Only the children have data.
    MERGE tables have HA_NO_COPY_ON_ALTER set.
  */
  if (!(new_table->file->ha_table_flags() & HA_NO_COPY_ON_ALTER)) {
    new_table->next_number_field = new_table->found_next_number_field;
    THD_STAGE_INFO(thd, stage_copy_to_tmp_table);
    DBUG_EXECUTE_IF("abort_copy_table", {
      my_error(ER_LOCK_WAIT_TIMEOUT, MYF(0));
      goto err_new_table_cleanup;
    });

    if (copy_data_between_tables(thd, thd->m_stage_progress_psi, table,
                                 new_table, alter_info->create_list, &copied,
                                 &deleted, alter_info->keys_onoff, &alter_ctx))
      goto err_new_table_cleanup;

    DEBUG_SYNC(thd, "alter_after_copy_table");
  } else {
    /* Should be MERGE only */
    assert(new_table->file->ht->db_type == DB_TYPE_MRG_MYISAM);
    if (!table->s->tmp_table &&
        wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN))
      goto err_new_table_cleanup;
    THD_STAGE_INFO(thd, stage_manage_keys);
    DEBUG_SYNC(thd, "alter_table_manage_keys");
    alter_table_manage_keys(thd, table, table->file->indexes_are_disabled(),
                            alter_info->keys_onoff);
    assert(!(new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL));

    /* Prevent intermediate commits to invoke commit order */
    Implicit_substatement_state_guard substatement_guard(
        thd, enum_implicit_substatement_guard_mode ::
                 DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd))
      goto err_new_table_cleanup;
  }

  if (table->s->tmp_table != NO_TMP_TABLE) {
    /* Close lock if this is a transactional table */
    if (thd->lock) {
      if (thd->locked_tables_mode != LTM_LOCK_TABLES &&
          thd->locked_tables_mode != LTM_PRELOCKED_UNDER_LOCK_TABLES) {
        mysql_unlock_tables(thd, thd->lock);
        thd->lock = nullptr;
      } else {
        /*
          If LOCK TABLES list is not empty and contains this table,
          unlock the table and remove the table from this list.
        */
        mysql_lock_remove(thd, thd->lock, table);
      }
    }
    /* Remove link to old table and rename the new one */
    close_temporary_table(thd, table, true, true);
    /* Should pass the 'new_name' as we store table name in the cache */
    if (rename_temporary_table(thd, new_table, alter_ctx.new_db,
                               alter_ctx.new_name))
      goto err_new_table_cleanup;
    /*
      We don't replicate alter table statement on temporary tables
      in RBR mode.
    */
    if (!thd->is_current_stmt_binlog_format_row() &&
        write_bin_log(thd, true, thd->query().str, thd->query().length)) {
      /*
        We can't revert replacement of old table version with a new one
        at this point. So, if possible, commit the statement to avoid
        new table version being emptied by statement rollback.
      */
      if (!thd->transaction_rollback_request) {
        (void)trans_commit_stmt(thd);
        (void)trans_commit_implicit(thd);
      }
      return true;
    }

    // Do implicit commit for consistency with non-temporary table case/
    if (trans_commit_stmt(thd) || trans_commit_implicit(thd)) return true;

    goto end_temporary;
  }

  /*
    Close the intermediate table that will be the new table, but do
    not delete it! Even though MERGE tables do not have their children
    attached here it is safe to call close_temporary_table().
  */
  close_temporary_table(thd, new_table, true, false);
  new_table = nullptr;

  DEBUG_SYNC(thd, "alter_table_before_rename_result_table");
  DBUG_EXECUTE_IF("exit_after_alter_table_before_rename", {
    my_error(ER_UNKNOWN_ERROR, MYF(0));
    return true;
  });

  /*
    Data is copied. Now we:
    1) Wait until all other threads will stop using old version of table
       by upgrading shared metadata lock to exclusive one.
    2) Close instances of table open by this thread and replace them
       with placeholders to simplify reopen process.
    3) Rename the old table to a temp name, rename the new one to the
       old name.
    4) If we are under LOCK TABLES and don't do ALTER TABLE ... RENAME
       we reopen new version of table.
    5) Write statement to the binary log.
    6) If we are under LOCK TABLES and do ALTER TABLE ... RENAME we
       remove placeholders and release metadata locks.
    7) If we are not not under LOCK TABLES we rely on the caller
      (mysql_execute_command()) to release metadata locks.
  */

  THD_STAGE_INFO(thd, stage_rename_result_table);

  if (wait_while_table_is_used(thd, table, HA_EXTRA_PREPARE_FOR_RENAME))
    goto err_new_table_cleanup;

  if (collect_and_lock_fk_tables_for_complex_alter_table(
          thd, table_list, old_table_def, &alter_ctx, alter_info, old_db_type,
          new_db_type, &fk_invalidator))
    goto err_new_table_cleanup;

  /*
    To ensure DDL atomicity after this point support from both old and
    new engines is necessary. If either of them lacks such support let
    us commit transaction so changes to data-dictionary are more closely
    reflect situations in SEs.

    Also if new SE supports atomic DDL then we have not stored new table
    definition in on-disk data-dictionary so far. It is time to do this
    now if ALTER TABLE as a whole won't be atomic.
  */
  if (!atomic_replace) {
    if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        thd->dd_client()->store(non_dd_table_def.get()))
      goto err_new_table_cleanup;

    /* Prevent intermediate commits to invoke commit order */
    Implicit_substatement_state_guard substatement_guard(thd);

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd))
      goto err_new_table_cleanup;

    // Safety, in-memory dd::Table is no longer totally correct.
    non_dd_table_def.reset();
  }

  char backup_name[32];
  assert(sizeof(my_thread_id) == 4);
  snprintf(backup_name, sizeof(backup_name), "%s2-%lx-%x", tmp_file_prefix,
           current_pid, thd->thread_id());
  if (lower_case_table_names) my_casedn_str(files_charset_info, backup_name);

  close_all_tables_for_name(thd, table->s, false, nullptr);
  table_list->table = table = nullptr; /* Safety */

  /*
    Rename the old version to temporary name to have a backup in case
    anything goes wrong while renaming the new table.

    Take the X metadata lock on this temporary name too. This ensures that
    concurrent I_S queries won't try to open it. Assert to ensure we do not
    come here when ALTERing temporary table.
  */
  {
    assert(!is_tmp_table);
    MDL_request backup_name_mdl_request;
    MDL_REQUEST_INIT(&backup_name_mdl_request, MDL_key::TABLE, alter_ctx.db,
                     backup_name, MDL_EXCLUSIVE, MDL_STATEMENT);
    dd::cache::Dictionary_client::Auto_releaser releaser_2(thd->dd_client());
    const dd::Table *backup_table = nullptr;

    if (thd->mdl_context.acquire_lock(&backup_name_mdl_request,
                                      thd->variables.lock_wait_timeout) ||
        thd->dd_client()->acquire(alter_ctx.db, backup_name, &backup_table)) {
      /* purecov: begin tested */
      /*
        We need to clear THD::transaction_rollback_request (which might
        be set due to MDL deadlock) before attempting to remove new version
        of table.
      */
      if (thd->transaction_rollback_request) {
        trans_rollback_stmt(thd);
        trans_rollback(thd);
      }

      if (!atomic_replace) {
        (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                             alter_ctx.tmp_name, FN_IS_TMP);
      }
      goto err_with_mdl;
      /* purecov: end */
    }

    if (backup_table != nullptr) {
      /* purecov: begin tested */
      my_error(ER_TABLE_EXISTS_ERROR, MYF(0), backup_name);

      if (!atomic_replace) {
        (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                             alter_ctx.tmp_name, FN_IS_TMP);
      }
      goto err_with_mdl;
      /* purecov: end */
    }
  }

  if (mysql_rename_table(thd, old_db_type, alter_ctx.db, alter_ctx.table_name,
                         alter_ctx.db, alter_ctx.table_name, *schema,
                         alter_ctx.db, backup_name,
                         FN_TO_IS_TMP | (atomic_replace ? NO_DD_COMMIT : 0) |
                             NO_FK_RENAME | NO_CC_RENAME)) {
    // Rename to temporary name failed, delete the new table, abort ALTER.
    if (!atomic_replace) {
      /*
        In non-atomic mode situations when the SE has requested rollback
        should be handled already, by executing rollback right inside
        mysql_rename_table() call.
      */
      assert(!thd->transaction_rollback_request);
      (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                           alter_ctx.tmp_name, FN_IS_TMP);
    }
    goto err_with_mdl;
  }

  /*
    The below code assumes that only SE capable of atomic DDL support FK.
    This is somewhat simplifies error handling below.

    Note that we need to handle FKs atomically with this rename in order
    to handle scenario when, for example, MyISAM table is altered to InnoDB
    SE and some FKs are added at the same time.
  */
  assert(!(new_db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS) ||
         (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL));

  /*
    We also assume that we can't have non-atomic ALTER TABLE which
    will preserve any foreign keys (i.e. such ALTER TABLE can only
    drop all foreign keys on the table, or add new foreign keys to
    table which previously didn't have any).
  */
  assert(atomic_replace || alter_ctx.fk_count == 0);

  /*
    If both old and new SEs support atomic DDL then we have not stored
    new table definition in on-disk data-dictionary so far. It is time
    to do this now. However, before doing this we need to rename foreign
    keys in old table definition to temporary names to avoid conflicts
    with duplicate names.
  */
  if (atomic_replace) {
    if (alter_ctx.fk_count > 0 &&
        adjust_foreign_key_names_for_old_table_version(thd, alter_ctx.db,
                                                       backup_name))
      goto err_with_mdl;

    if (thd->dd_client()->store(non_dd_table_def.get())) goto err_with_mdl;

    // Safety, in-memory dd::Table is no longer totally correct.
    non_dd_table_def.reset();
  }

  // Rename the new table to the correct name.
  if (mysql_rename_table(
          thd, new_db_type, alter_ctx.new_db, alter_ctx.tmp_name, alter_ctx.db,
          alter_ctx.table_name, *new_schema, alter_ctx.new_db,
          alter_ctx.new_alias,
          (FN_FROM_IS_TMP |
           ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) ? NO_DD_COMMIT
                                                            : 0) |
           (alter_ctx.is_table_renamed() ? 0 : NO_FK_RENAME | NO_CC_RENAME))) ||
      ((new_db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS) &&
       adjust_fks_for_complex_alter_table(thd, table_list, &alter_ctx,
                                          alter_info, new_db_type,
                                          &fk_invalidator)) ||
      /*
        Try commit changes if ALTER TABLE as whole is not atomic and we have
        not done this in the above mysql_rename_table() call.
      */
      (!atomic_replace && (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
       trans_intermediate_ddl_commit(thd, false))) {
    // Rename failed, delete the temporary table.
    if (!atomic_replace) {
      if (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) {
        /*
          If ALTER TABLE as whole is not atomic and the above rename or
          FK changes have failed without cleaning up after themselves,
          we need to do this now.
        */
        (void)trans_intermediate_ddl_commit(thd, true);
      }

      /*
        In non-atomic mode situations when the SE has requested rollback
        should be handled already.
      */
      assert(!thd->transaction_rollback_request);

      (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                           alter_ctx.tmp_name, FN_IS_TMP);

      // Restore the backup of the original table to its original name.
      // If the operation fails, we need to retry it to avoid leaving
      // the dictionary inconsistent.
      //
      // This hack might become unnecessary once InnoDB stops acquiring
      // gap locks on DD tables (which might cause deadlocks).
      uint retries = 20;
      while (retries-- &&
             mysql_rename_table(
                 thd, old_db_type, alter_ctx.db, backup_name, alter_ctx.db,
                 backup_name, *schema, alter_ctx.db, alter_ctx.alias,
                 FN_FROM_IS_TMP | NO_FK_CHECKS | NO_FK_RENAME | NO_CC_RENAME))
        ;
    }
    goto err_with_mdl;
  }

  /*
    If ALTER TABLE is non-atomic and fails after this point it can add
    foreign keys and such addition won't be reverted. So we need to
    invalidate table objects for foreign key parents even on error.
  */
  if (!atomic_replace) invalidate_fk_parents_on_error = true;

  // Handle trigger name, check constraint names and histograms statistics.
  {
    dd::Table *backup_table = nullptr;
    dd::Table *new_dd_table = nullptr;
    if (thd->dd_client()->acquire_for_modification(alter_ctx.db, backup_name,
                                                   &backup_table) ||
        thd->dd_client()->acquire_for_modification(
            alter_ctx.new_db, alter_ctx.new_alias, &new_dd_table))
      goto err_with_mdl;
    assert(backup_table != nullptr && new_dd_table != nullptr);

    /*
      Check if this is an ALTER command that will cause histogram statistics to
      become invalid. If that is the case; remove the histogram statistics.

      This will take care of scenarios when COPY alter is used, but not INPLACE.
      Do this before the commit for non-transactional tables, because the
      new_dd_table is invalidated on commit.
    */
    if (alter_table_drop_histograms(thd, table_list, alter_info, create_info,
                                    columns, backup_table, new_dd_table))
      goto err_with_mdl; /* purecov: deadcode */

    bool update = (new_dd_table->check_constraints()->size() > 0);
    // Set mode for new_dd_table's check constraints.
    set_check_constraints_alter_mode(new_dd_table, alter_info);

    /*
      Check constraint names are unique per schema, we cannot create them while
      both table version exists. Adjust check constraint names in old table
      version.
    */
    if (adjust_check_constraint_names_for_old_table_version(thd, alter_ctx.db,
                                                            backup_table))
      goto err_with_mdl;

    // Reset check constraint's mode.
    reset_check_constraints_alter_mode(new_dd_table);

    /*
      Since trigger names have to be unique per schema, we cannot
      create them while both the old and the tmp version of the
      table exist.
    */
    if (backup_table->has_trigger()) {
      new_dd_table->copy_triggers(backup_table);
      backup_table->drop_all_triggers();
      update = true;
    }
    if (!is_checked_for_upgrade(*new_dd_table) &&
        is_checked_for_upgrade(*backup_table)) {
      new_dd_table->mark_as_checked_for_upgrade();
      update = true;
    }
    if (update) {
      if (thd->dd_client()->update(backup_table) ||
          thd->dd_client()->update(new_dd_table))
        goto err_with_mdl;

      /* Prevent intermediate commits to invoke commit order */
      Implicit_substatement_state_guard substatement_guard(thd);
      if (!atomic_replace && (trans_commit_stmt(thd) || trans_commit(thd)))
        goto err_with_mdl;
    }
  }

  // If the ALTER command was a rename, rename any existing histograms.
  if (alter_ctx.is_table_renamed() &&
      rename_histograms(thd, table_list->db, table_list->table_name, new_db,
                        new_name)) {
    goto err_with_mdl; /* purecov: deadcode */
  }

  // ALTER TABLE succeeded, delete the backup of the old table.
  if (quick_rm_table(thd, old_db_type, alter_ctx.db, backup_name,
                     FN_IS_TMP | (atomic_replace ? NO_DD_COMMIT : 0))) {
    /*
      The fact that deletion of the backup failed is not critical
      error, but still worth reporting as it might indicate serious
      problem with server.

      TODO: In !atomic_replace case we might need to do FK parents
            invalidation here. However currently our FKs are not
            even named correctly at this point, so we postpone
            fixing this issue until we solve FK naming problem.
    */
    goto err_with_mdl;
  }

end_inplace_noop:

  THD_STAGE_INFO(thd, stage_end);

  DBUG_EXECUTE_IF("sleep_alter_before_main_binlog", my_sleep(6000000););
  DEBUG_SYNC(thd, "alter_table_before_main_binlog");

  ha_binlog_log_query(thd, create_info->db_type, LOGCOM_ALTER_TABLE,
                      thd->query().str, thd->query().length, alter_ctx.db,
                      alter_ctx.table_name);

  assert(!(mysql_bin_log.is_open() &&
           thd->is_current_stmt_binlog_format_row() &&
           (create_info->options & HA_LEX_CREATE_TMP_TABLE)));

  /*
    If this is no-op ALTER TABLE we don't have transaction started.
    We can't use binlog's trx cache in this case as it requires active
    transaction with valid XID.
  */
  if (write_bin_log(thd, true, thd->query().str, thd->query().length,
                    atomic_replace && !is_noop))
    goto err_with_mdl;

  if (!is_noop) {
    Uncommitted_tables_guard uncommitted_tables(thd);

    uncommitted_tables.add_table(table_list);

    if (update_referencing_views_metadata(thd, table_list, new_db, new_name,
                                          !atomic_replace, &uncommitted_tables))
      goto err_with_mdl;

    if (alter_ctx.is_table_renamed())
      tdc_remove_table(thd, TDC_RT_REMOVE_ALL, alter_ctx.new_db,
                       alter_ctx.new_name, false);
  }

  // Commit if it was not done before in order to be able to reopen tables.
  if (atomic_replace && (trans_commit_stmt(thd) || trans_commit_implicit(thd)))
    goto err_with_mdl;

  if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && new_db_type->post_ddl)
    new_db_type->post_ddl(thd);
  if ((old_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && old_db_type->post_ddl)
    old_db_type->post_ddl(thd);

#ifndef WORKAROUND_TO_BE_REMOVED_BY_WL6049
  {
    Table_ref table_list_reopen(alter_ctx.new_db, alter_ctx.new_name,
                                alter_ctx.new_alias, TL_READ);
    table_list_reopen.mdl_request.ticket =
        alter_ctx.is_table_renamed() ? alter_ctx.target_mdl_request.ticket
                                     : mdl_ticket;

    Open_table_context ot_ctx(thd, MYSQL_OPEN_REOPEN);

    if (open_table(thd, &table_list_reopen, &ot_ctx)) return true;

    assert(table_list_reopen.table == thd->open_tables);
    close_thread_table(thd, &thd->open_tables);
  }
#endif

end_inplace:

  fk_invalidator.invalidate(thd);

  if (alter_ctx.is_table_renamed())
    thd->locked_tables_list.rename_locked_table(
        table_list, alter_ctx.new_db, alter_ctx.new_name,
        alter_ctx.target_mdl_request.ticket);

  {
    bool reopen_error = thd->locked_tables_list.reopen_tables(thd);

    if (thd->locked_tables_mode == LTM_LOCK_TABLES ||
        thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) {
      if (alter_ctx.is_table_renamed()) {
        /*
          Release metadata lock on old table name and keep the lock
          on the new one. We have to ignore reopen_error in this case
          as we will mess up FK invariants for LOCK TABLES otherwise.
        */
        thd->mdl_context.release_all_locks_for_name(mdl_ticket);
        thd->mdl_context.set_lock_duration(alter_ctx.target_mdl_request.ticket,
                                           MDL_EXPLICIT);
        alter_ctx.target_mdl_request.ticket->downgrade_lock(
            MDL_SHARED_NO_READ_WRITE);
        if (alter_ctx.is_database_changed())
          thd->mdl_context.set_lock_duration(
              alter_ctx.target_db_mdl_request.ticket, MDL_EXPLICIT);
      } else
        mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
    }

    if (reopen_error) return true;
  }

end_temporary:
  snprintf(alter_ctx.tmp_name, sizeof(alter_ctx.tmp_name),
           ER_THD(thd, ER_INSERT_INFO), (long)(copied + deleted), (long)deleted,
           (long)thd->get_stmt_da()->current_statement_cond_count());
  my_ok(thd, copied + deleted, 0L, alter_ctx.tmp_name);
  return false;

err_new_table_cleanup:
  if (create_info->options & HA_LEX_CREATE_TMP_TABLE) {
    if (new_table)
      close_temporary_table(thd, new_table, true, true);
    else if (!no_ha_table)
      rm_temporary_table(thd, new_db_type, alter_ctx.get_tmp_path(),
                         non_dd_table_def.get());
  } else {
    /* close_temporary_table() frees the new_table pointer. */
    if (new_table) close_temporary_table(thd, new_table, true, false);

    if (!(new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
      if (no_ha_table)  // Only remove from DD.
      {
        dd::cache::Dictionary_client::Auto_releaser releaser_3(
            thd->dd_client());
        const dd::Table *drop_table_def = nullptr;
        if (!thd->dd_client()->acquire(alter_ctx.new_db, alter_ctx.tmp_name,
                                       &drop_table_def)) {
          assert(drop_table_def != nullptr);
          bool result = dd::drop_table(thd, alter_ctx.new_db,
                                       alter_ctx.tmp_name, *drop_table_def);
          (void)trans_intermediate_ddl_commit(thd, result);
        }
      } else  // Remove from both DD and SE.
        (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                             alter_ctx.tmp_name, FN_IS_TMP);
    } else {
      trans_rollback_stmt(thd);
      /*
        Full rollback in case we have THD::transaction_rollback_request
        and to synchronize DD state in cache and on disk (as statement
        rollback doesn't clear DD cache of modified uncommitted objects).
      */
      trans_rollback(thd);
    }
    if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        new_db_type->post_ddl)
      new_db_type->post_ddl(thd);
  }

  if (alter_ctx.error_if_not_empty &
      Alter_table_ctx::GEOMETRY_WITHOUT_DEFAULT) {
    my_error(ER_INVALID_USE_OF_NULL, MYF(0));
  }

  /*
    No default value was provided for a DATE/DATETIME field, the
    current sql_mode doesn't allow the '0000-00-00' value and
    the table to be altered isn't empty.
    Report error here. Ignore error checkin for push_zero_date_warning()
    as we return true right below.
  */
  if ((alter_ctx.error_if_not_empty &
       Alter_table_ctx::DATETIME_WITHOUT_DEFAULT) &&
      (thd->variables.sql_mode & MODE_NO_ZERO_DATE) &&
      thd->get_stmt_da()->current_row_for_condition()) {
    (void)push_zero_date_warning(thd, alter_ctx.datetime_field);
  }
  return true;

err_with_mdl:
  /*
    An error happened while we were holding exclusive name metadata lock
    on table being altered. Before releasing locks we need to rollback
    changes to the data-dictionary, storage angine and binary log (if
    they were not committed earlier) and execute post DDL hooks.
    We also try to reopen old version of the table under LOCK TABLES
    if possible.
  */

  trans_rollback_stmt(thd);
  /*
    Full rollback in case we have THD::transaction_rollback_request
    and to synchronize DD state in cache and on disk (as statement
    rollback doesn't clear DD cache of modified uncommitted objects).
  */
  trans_rollback(thd);
  if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && new_db_type->post_ddl)
    new_db_type->post_ddl(thd);
  if ((old_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && old_db_type->post_ddl)
    old_db_type->post_ddl(thd);

  if (atomic_replace) {
    /*
      If both old and new storage engines support atomic DDL all changes
      were reverted at this point. So we can safely try to reopen table
      under old name.
    */
  } else {
    /*
      If ALTER TABLE ... RENAME ... ALGORITHM=COPY is non-atomic we can't
      be sure that rename step was reverted, so we simply remove table
      from the list of locked tables.
    */
    if (alter_ctx.is_table_renamed())
      thd->locked_tables_list.unlink_all_closed_tables(thd, nullptr, 0);
  }

  /*
    ALTER TABLE which changes table storage engine from MyISAM to InnoDB
    and adds foreign keys at the same time can fail after installing
    new table version. In this case we still need to invalidate table
    objects for parent tables to avoid creating discrepancy between
    data-dictionary and cache contents.
  */
  if (invalidate_fk_parents_on_error) fk_invalidator.invalidate(thd);

  (void)thd->locked_tables_list.reopen_tables(thd);

  if ((thd->locked_tables_mode == LTM_LOCK_TABLES ||
       thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES)) {
    /*
      Non-atomic ALTER TABLE ... RENAME ... ALGORITHM=COPY can add
      foreign keys if at the same time SE is changed from, e.g.,
      MyISAM to InnoDB. Since releasing metadata locks on old or new
      table name can break FK invariants for LOCK TABLES in various
      scenarios we keep both of them.
    */
    if (!atomic_replace && alter_ctx.is_table_renamed()) {
      thd->mdl_context.set_lock_duration(alter_ctx.target_mdl_request.ticket,
                                         MDL_EXPLICIT);
      alter_ctx.target_mdl_request.ticket->downgrade_lock(
          MDL_SHARED_NO_READ_WRITE);
      if (alter_ctx.is_database_changed())
        thd->mdl_context.set_lock_duration(
            alter_ctx.target_db_mdl_request.ticket, MDL_EXPLICIT);
    }
    mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
  }

  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: prepare_check_constraints_for_alter 
static bool prepare_check_constraints_for_alter(
    THD *thd, const TABLE *table, Alter_info *alter_info,
    Alter_table_ctx *alter_tbl_ctx) {
  DBUG_TRACE;
  MDL_request_list cc_mdl_request_list;
  Sql_check_constraint_spec_list new_check_cons_list(thd->mem_root);
  uint cc_max_generated_number = 0;
  uint table_name_len = strlen(alter_tbl_ctx->table_name);

  /*
    Do not process check constraint specification list if master is on version
    not supporting check constraints feature.
  */
  if (is_slave_with_master_without_check_constraints_support(thd)) {
    alter_info->check_constraint_spec_list.clear();
    return false;
  }

  auto find_cc_name = [](std::vector<const char *> &names, const char *s) {
    auto name = find_if(names.begin(), names.end(), [s](const char *cc_name) {
      return !my_strcasecmp(system_charset_info, s, cc_name);
    });
    return (name != names.end()) ? *name : nullptr;
  };

  /*
    List of check constraint names. Used after acquiring MDL locks on final list
    of check constraints to verify if check constraint names conflict with
    existing check constraint names.
  */
  std::vector<const char *> new_cc_names;

  /*
     Handle check constraint specifications marked for drop.

     Prepare list of check constraint names (Pointer to the constraint name in
     Alter_drop instances) marked for drop. List is used to skip constraints
     while preparing specification list from existing check constraints and
     while adding new check constraints with the same name.
  */
  std::vector<const char *> dropped_cc_names;
  for (const Alter_drop *drop : alter_info->drop_list) {
    if (drop->type != Alter_drop::CHECK_CONSTRAINT) continue;

    bool cc_found = false;
    if (table->table_check_constraint_list != nullptr) {
      for (Sql_table_check_constraint &table_cc :
           *table->table_check_constraint_list) {
        if (!my_strcasecmp(system_charset_info, table_cc.name().str,
                           drop->name)) {
          dropped_cc_names.push_back(drop->name);
          cc_found = true;
          break;
        }
      }
    }

    if (!cc_found) {
      my_error(ER_CHECK_CONSTRAINT_NOT_FOUND, MYF(0), drop->name);
      return true;
    }
  }

  /*
    Auto-drop check constraint: If check constraint refers to only one column
                                and that column is marked for drop then drop
                                check constraint too.
    Check constraints marked for auto-drop are added to list of check constraint
    (dropped_cc_names) to be dropped.
  */
  if (table->table_check_constraint_list != nullptr) {
    for (const Alter_drop *drop : alter_info->drop_list) {
      if (drop->type == Alter_drop::COLUMN) {
        for (Sql_table_check_constraint &table_cc :
             *table->table_check_constraint_list) {
          if (check_constraint_expr_refers_to_only_column(
                  table_cc.value_generator()->expr_item, drop->name))
            dropped_cc_names.push_back(table_cc.name().str);
        }
      }
    }
  }

  /*
    Prepare check constraint specification for the existing check constraints on
    the table.

    * Skip check constraint specification marked for drop.

    * Get max sequence number for generated names. This is required when
      handling new check constraints added to the table.

    * If table is renamed, adjust generated check constraint names to use new
      table name.

    * Create MDL request on all check constraints.
      - Also on adjusted check constraint names if table is renamed.
      - If database changed then on all check constraints with the new database.
  */
  if (table->table_check_constraint_list != nullptr) {
    for (auto &table_cc : *table->table_check_constraint_list) {
      /*
        Push MDL_request for the existing check constraint name.
        Note: Notice that this also handles case of dropped constraints.
      */
      if (push_check_constraint_mdl_request_to_list(
              thd, alter_tbl_ctx->db, table_cc.name().str, cc_mdl_request_list))
        return true;

      // Skip if constraint is marked for drop.
      if (find_cc_name(dropped_cc_names, table_cc.name().str) != nullptr)
        continue;

      Sql_check_constraint_spec *cc_spec =
          new (thd->mem_root) Sql_check_constraint_spec;
      if (cc_spec == nullptr) return true;  // OOM

      bool is_generated_name = dd::is_generated_check_constraint_name(
          alter_tbl_ctx->table_name, table_name_len, table_cc.name().str,
          table_cc.name().length);
      /*
        Get number from generated name and update max generated number if
        needed.
      */
      if (is_generated_name) {
        char *end;
        uint number =
            my_strtoull(table_cc.name().str + table_name_len +
                            sizeof(dd::CHECK_CONSTRAINT_NAME_SUBSTR) - 1,
                        &end, 10);
        if (number > cc_max_generated_number) cc_max_generated_number = number;
      }

      // If generated name and table is renamed then update generated name.
      if (is_generated_name && alter_tbl_ctx->is_table_name_changed()) {
        char *end;
        uint number =
            my_strtoull(table_cc.name().str + table_name_len +
                            sizeof(dd::CHECK_CONSTRAINT_NAME_SUBSTR) - 1,
                        &end, 10);
        if (number > cc_max_generated_number) cc_max_generated_number = number;

        // Generate new check constraint name.
        if (generate_check_constraint_name(thd, alter_tbl_ctx->new_name, number,
                                           cc_spec->name, true))
          return true;
      } else {
        lex_string_strmake(thd->mem_root, &cc_spec->name, table_cc.name().str,
                           table_cc.name().length);
        if (cc_spec->name.str == nullptr) return true;  // OOM
      }

      //  check constraint expression.
      cc_spec->check_expr = table_cc.value_generator()->expr_item;

      // Copy check constraint status.
      cc_spec->is_enforced = table_cc.is_enforced();

      // Push check constraint to new list.
      new_check_cons_list.push_back(cc_spec);

      /*
        If db is changed then push MDL_request on check constraint with new db
        name or if table name is changed then push MDL_request on generated
        check constraint name.
      */
      if ((alter_tbl_ctx->is_database_changed() ||
           (alter_tbl_ctx->is_table_name_changed() && is_generated_name))) {
        if (push_check_constraint_mdl_request_to_list(
                thd, alter_tbl_ctx->new_db, cc_spec->name.str,
                cc_mdl_request_list))
          return true;

        new_cc_names.push_back(cc_spec->name.str);
      }
    }

    /*
      Check if any check constraint refers to column(s) being dropped or
      renamed.
    */
    if (!new_check_cons_list.empty()) {
      // Check if any check constraint refers column(s) being dropped.
      if (std::any_of(
              alter_info->drop_list.begin(), alter_info->drop_list.end(),
              Check_constraint_column_dependency_checker(new_check_cons_list)))
        return true;

      /*
        Check if any check constraint refers column(s) being renamed using
        RENAME COLUMN clause.
      */
      if (std::any_of(
              alter_info->alter_list.begin(), alter_info->alter_list.end(),
              Check_constraint_column_dependency_checker(new_check_cons_list)))
        return true;

      /*
        Check if any check constraint refers column(s) being renamed using
        CHANGE [COLUMN] clause.
      */
      if (std::any_of(
              alter_info->create_list.begin(), alter_info->create_list.end(),
              Check_constraint_column_dependency_checker(new_check_cons_list)))
        return true;
    }
  }

  // Update check constraint enforcement state (i.e. enforced or not enforced).
  for (auto *alter_constraint : alter_info->alter_constraint_enforcement_list) {
    if (alter_constraint->type !=
        Alter_constraint_enforcement::Type::CHECK_CONSTRAINT)
      continue;

    bool cc_found = false;
    for (auto &cc_spec : new_check_cons_list) {
      if (!my_strcasecmp(system_charset_info, cc_spec->name.str,
                         alter_constraint->name)) {
        cc_found = true;
        // Update status.
        cc_spec->is_enforced = alter_constraint->is_enforced;
        break;
      }
    }
    if (!cc_found) {
      my_error(ER_CHECK_CONSTRAINT_NOT_FOUND, MYF(0), alter_constraint->name);
      return true;
    }
  }

  /*
    Handle new check constraints added to the table.

    * Generate name if name is not specified.
      If table already has check constraints with generated name then use
      sequence number generated when handling existing check constraint names.

    * pre-validate check constraint.

    * Prepare MDL request for new check constraints.
  */
  for (auto &cc_spec : alter_info->check_constraint_spec_list) {
    // If check constraint name is omitted then generate name.
    if (cc_spec->name.length == 0) {
      if (generate_check_constraint_name(thd, alter_tbl_ctx->new_name,
                                         ++cc_max_generated_number,
                                         cc_spec->name, false))
        return true;
    }

    if (cc_spec->pre_validate()) return true;

    // Push check constraint to new list.
    new_check_cons_list.push_back(cc_spec);

    // Create MDL request for the check constraint.
    if (push_check_constraint_mdl_request_to_list(
            thd, alter_tbl_ctx->new_db, cc_spec->name.str, cc_mdl_request_list))
      return true;

    /*
      We need to check if conflicting constraint name exists for all newly added
      constraints. However, we don't need (and it is inconvenient) to do this
      if constraint with the same name was dropped by the same ALTER TABLE,
      unless old and new constraints belong to different databases (i.e. this
      ALTER TABLE also moves table between databases).
    */
    if (alter_tbl_ctx->is_database_changed() ||
        find_cc_name(dropped_cc_names, cc_spec->name.str) == nullptr)
      new_cc_names.push_back(cc_spec->name.str);
  }

  /*
    Adjust Alter_info::flags.

    * Check if final list has any check constraint whose state is changed from
      NOT ENFORCED to ENFORCED.

    * Check if list has any new check constraints added with ENFORCED state.

    * Update Alter_info::flags accordingly.
  */
  bool final_enforced_state = false;
  for (auto &cc : new_check_cons_list) {
    // Check if any of existing constraint is enforced.
    if (table->table_check_constraint_list != nullptr) {
      for (auto &table_cc : *table->table_check_constraint_list) {
        if (!my_strcasecmp(system_charset_info, cc->name.str,
                           table_cc.name().str) &&
            !table_cc.is_enforced() && cc->is_enforced) {
          final_enforced_state = true;
          break;
        }
      }
    }
    if (final_enforced_state) break;

    // Check if new constraint is added in enforced state.
    for (auto &new_cc : alter_info->check_constraint_spec_list) {
      if (!my_strcasecmp(system_charset_info, cc->name.str, new_cc->name.str) &&
          cc->is_enforced) {
        final_enforced_state = true;
        break;
      }
    }
    if (final_enforced_state) break;
  }
  if (final_enforced_state)
    alter_info->flags |= Alter_info::ENFORCE_CHECK_CONSTRAINT;
  else
    alter_info->flags &= ~Alter_info::ENFORCE_CHECK_CONSTRAINT;

  /*
    Set alter mode for each check constraint specification instance.

    For non-temporary table prepare temporary check constraint names. During
    ALTER TABLE operation, two versions of table exists and to avoid check
    constraint name conflicts temporary(adjusted) names stored for newer
    version and alter mode is set. Check constraint names are restored
    later in ALTER TABLE operation. MDL request to temporary name is also
    created to avoid creation of table with same name by concurrent operation.

    * Prepare temporary(adjusted) name for each check constraint specification.

    * Set alter mode for each check constraint specification.

    * Prepare MDL request for each temporary name.
  */
  if (table->s->tmp_table == NO_TMP_TABLE) {
    ulong id = 1;
    for (Sql_check_constraint_spec *cc : new_check_cons_list) {
      const int prefix_len = 3;  // #cc
      const int process_id_len = 20;
      const int thread_id_len = 10;
      const int id_len = 20;
      const int separator_len = 1;
      char temp_name_buf[prefix_len + process_id_len + thread_id_len + id_len +
                         (separator_len * 3) + 1];
      snprintf(temp_name_buf, sizeof(temp_name_buf), "#cc_%lu_%u_%lu",
               current_pid, thd->thread_id(), id++);

      // Create MDL request for the temp check constraint name.
      if (push_check_constraint_mdl_request_to_list(
              thd, alter_tbl_ctx->new_db, temp_name_buf, cc_mdl_request_list))
        return true;

      cc->is_alter_mode = true;
      cc->alias_name.length = strlen(temp_name_buf);
      cc->alias_name.str =
          strmake_root(thd->mem_root, temp_name_buf, cc->alias_name.length);
    }
  }

  // Acquire MDL lock on all the MDL_request prepared in this method.
  DEBUG_SYNC(thd, "before_acquiring_lock_on_check_constraints");
  if (thd->mdl_context.acquire_locks(&cc_mdl_request_list,
                                     thd->variables.lock_wait_timeout))
    return true;
  DEBUG_SYNC(thd, "after_acquiring_lock_on_check_constraints");

  /*
    Make sure new check constraint names do not conflict with any existing check
    constraint names before starting expensive ALTER operation.
  */
  dd::Schema_MDL_locker mdl_locker(thd);
  const dd::Schema *new_schema = nullptr;
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  if (mdl_locker.ensure_locked(alter_tbl_ctx->new_db) ||
      thd->dd_client()->acquire(alter_tbl_ctx->new_db, &new_schema))
    return true;
  bool exists = false;
  for (auto cc_name : new_cc_names) {
    if (thd->dd_client()->check_constraint_exists(*new_schema, cc_name,
                                                  &exists))
      return true;
    if (exists) {
      my_error(ER_CHECK_CONSTRAINT_DUP_NAME, MYF(0), cc_name);
      return true;
    }
  }

  alter_info->check_constraint_spec_list.clear();
  alter_info->check_constraint_spec_list.resize(new_check_cons_list.size());
  std::move(new_check_cons_list.begin(), new_check_cons_list.end(),
            alter_info->check_constraint_spec_list.begin());

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: remove_secondary_engine 
static bool remove_secondary_engine(THD *thd, const Table_ref &table,
                                    const HA_CREATE_INFO &create_info,
                                    const dd::Table *old_table_def) {
  // Nothing to do if no secondary engine defined for the table.
  if (table.table->s->secondary_engine.str == nullptr) return false;

  // Check if SECONDARY_ENGINE = NULL has been set in ALTER TABLE.
  const bool is_null =
      create_info.used_fields & HA_CREATE_USED_SECONDARY_ENGINE &&
      create_info.secondary_engine.str == nullptr;

  if (!is_null) return false;

  if (thd->mdl_context.upgrade_shared_lock(table.table->mdl_ticket,
                                           MDL_EXCLUSIVE,
                                           thd->variables.lock_wait_timeout))
    return true;

  return secondary_engine_unload_table(thd, table.db, table.table_name,
                                       *old_table_def, false);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table 
static bool mysql_inplace_alter_table(
    THD *thd, const dd::Schema &schema, const dd::Schema &new_schema,
    const dd::Table *table_def, dd::Table *altered_table_def,
    Table_ref *table_list, TABLE *table, TABLE *altered_table,
    Alter_inplace_info *ha_alter_info,
    enum_alter_inplace_result inplace_supported, Alter_table_ctx *alter_ctx,
    histograms::columns_set &columns, FOREIGN_KEY *fk_key_info,
    uint fk_key_count, Foreign_key_parents_invalidator *fk_invalidator) {
  handlerton *db_type = table->s->db_type();
  MDL_ticket *mdl_ticket = table->mdl_ticket;
  Alter_info *alter_info = ha_alter_info->alter_info;
  bool reopen_tables = false;
  bool rollback_needs_dict_cache_reset = false;
  MDL_request_list mdl_requests;

  DBUG_TRACE;

  /*
    Upgrade to EXCLUSIVE lock if:
    - This is requested by the storage engine
    - Or the storage engine needs exclusive lock for just the prepare
      phase
    - Or requested by the user

    Note that we handle situation when storage engine needs exclusive
    lock for prepare phase under LOCK TABLES in the same way as when
    exclusive lock is required for duration of the whole statement.
  */
  if (inplace_supported == HA_ALTER_INPLACE_EXCLUSIVE_LOCK ||
      ((inplace_supported == HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE ||
        inplace_supported == HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE) &&
       (thd->locked_tables_mode == LTM_LOCK_TABLES ||
        thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES)) ||
      alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE) {
    if (wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN))
      goto cleanup;
    /*
      Get rid of all TABLE instances belonging to this thread
      except one to be used for in-place ALTER TABLE.

      This is mostly needed to satisfy InnoDB assumptions/asserts.
    */
    close_all_tables_for_name(thd, table->s, false, table);
    /*
      If we are under LOCK TABLES we will need to reopen tables which we
      just have closed in case of error.
    */
    reopen_tables = true;
  } else if (inplace_supported == HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE ||
             inplace_supported == HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE) {
    /*
      Storage engine has requested exclusive lock only for prepare phase
      and we are not under LOCK TABLES.
      Don't mark TABLE_SHARE as old in this case, as this won't allow opening
      of table by other threads during main phase of in-place ALTER TABLE.
    */
    if (thd->mdl_context.upgrade_shared_lock(table->mdl_ticket, MDL_EXCLUSIVE,
                                             thd->variables.lock_wait_timeout))
      goto cleanup;

    tdc_remove_table(thd, TDC_RT_REMOVE_NOT_OWN_KEEP_SHARE, table->s->db.str,
                     table->s->table_name.str, false);
  }

  /*
    Upgrade to SHARED_NO_WRITE lock if:
    - The storage engine needs writes blocked for the whole duration
    - Or this is requested by the user
    Note that under LOCK TABLES, we will already have SHARED_NO_READ_WRITE.
  */
  if ((inplace_supported == HA_ALTER_INPLACE_SHARED_LOCK ||
       alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_SHARED) &&
      thd->mdl_context.upgrade_shared_lock(table->mdl_ticket,
                                           MDL_SHARED_NO_WRITE,
                                           thd->variables.lock_wait_timeout)) {
    goto cleanup;
  }

  /*
    Acquire locks on names of new foreign keys. INPLACE algorithm creates
    the new table definition in the original table's database.
  */
  if (collect_fk_names_for_new_fks(
          thd, table_list->db, table_list->table_name, alter_info, db_type,
          get_fk_max_generated_name_number(table_list->table_name, table_def,
                                           db_type),
          &mdl_requests) ||
      (alter_ctx->is_table_renamed() &&
       collect_fk_names_for_rename_table(
           thd, table_list->db, table_list->table_name, altered_table_def,
           db_type, alter_ctx->new_db, alter_ctx->new_name, &mdl_requests)))
    goto cleanup;

  if (!mdl_requests.is_empty() &&
      thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    goto cleanup;

  /*
    Check if ALTER TABLE results in any foreign key name conflicts
    before starting potentially expensive phases of INPLACE ALTER.
  */
  if (!dd::get_dictionary()->is_dd_table_name(table_list->db,
                                              table_list->table_name) &&
      (db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
    for (FOREIGN_KEY *fk = fk_key_info + alter_ctx->fk_count;
         fk < fk_key_info + fk_key_count; ++fk) {
      bool exists;
      if (thd->dd_client()->check_foreign_key_exists(schema, fk->name, &exists))
        goto cleanup;

      if (exists) {
        my_error(ER_FK_DUP_NAME, MYF(0), fk->name);
        goto cleanup;
      }
    }

    if (alter_ctx->is_table_renamed() &&
        check_fk_names_before_rename(thd, table_list, *altered_table_def,
                                     db_type, new_schema, *alter_ctx))
      goto cleanup;
  }

  // It's now safe to take the table level lock.
  if (lock_tables(thd, table_list, alter_ctx->tables_opened, 0)) goto cleanup;

  if (alter_ctx->error_if_not_empty) {
    /*
      Storage engines should not suggest/support INSTANT algorithm if
      error_if_not_empty flag is set.
      The problem is that the below check if table is empty is not "instant",
      as it might have to traverse through deleted versions of rows on SQL-layer
      (e.g. MyISAM) or in SE (e.g. InnoDB).

      OTOH for cases when table is empty difference between INSTANT and INPLACE
      or COPY algorithms should be negligible.

      This limitation might be raised in the future if we will implement support
      for quick (i.e. non-traversing) check for table emptiness.
    */
    assert(inplace_supported != HA_ALTER_INPLACE_INSTANT);
    /*
      Operations which set error_if_not_empty flag typically request exclusive
      lock during prepare phase, so we don't have to upgrade lock to prevent
      concurrent table modifications here.
    */
    assert(table->mdl_ticket->get_type() == MDL_EXCLUSIVE);
    bool empty_table = false;
    if (table_is_empty(table_list->table, &empty_table)) goto cleanup;
    if (!empty_table) {
      if (alter_ctx->error_if_not_empty &
          Alter_table_ctx::GEOMETRY_WITHOUT_DEFAULT) {
        my_error(ER_INVALID_USE_OF_NULL, MYF(0));
      } else if ((alter_ctx->error_if_not_empty &
                  Alter_table_ctx::DATETIME_WITHOUT_DEFAULT) &&
                 (thd->variables.sql_mode & MODE_NO_ZERO_DATE)) {
        /*
          Report a warning if the NO ZERO DATE MODE is enabled. The
          warning will be promoted to an error if strict mode is
          also enabled. Do not check for errors here as we check
          thd->is_error() just below.
        */
        (void)push_zero_date_warning(thd, alter_ctx->datetime_field);
      }

      if (thd->is_error()) goto cleanup;
    }

    // Empty table, so don't allow inserts during inplace operation.
    if (inplace_supported == HA_ALTER_INPLACE_NO_LOCK ||
        inplace_supported == HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE)
      inplace_supported = HA_ALTER_INPLACE_SHARED_LOCK;
  }

  DEBUG_SYNC(thd, "alter_table_inplace_after_lock_upgrade");
  THD_STAGE_INFO(thd, stage_alter_inplace_prepare);

  switch (inplace_supported) {
    case HA_ALTER_ERROR:
    case HA_ALTER_INPLACE_NOT_SUPPORTED:
      assert(0);
      [[fallthrough]];
    case HA_ALTER_INPLACE_NO_LOCK:
    case HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE:
      switch (alter_info->requested_lock) {
        case Alter_info::ALTER_TABLE_LOCK_DEFAULT:
        case Alter_info::ALTER_TABLE_LOCK_NONE:
          ha_alter_info->online = true;
          break;
        case Alter_info::ALTER_TABLE_LOCK_SHARED:
        case Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE:
          break;
      }
      break;
    case HA_ALTER_INPLACE_EXCLUSIVE_LOCK:
    case HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE:
    case HA_ALTER_INPLACE_SHARED_LOCK:
    case HA_ALTER_INPLACE_INSTANT:
      break;
  }

  {
    /*
      We want warnings/errors about data truncation emitted when
      values of virtual columns are evaluated in INPLACE algorithm.
    */
    thd->check_for_truncated_fields = CHECK_FIELD_WARN;
    thd->num_truncated_fields = 0L;

    if (table->file->ha_prepare_inplace_alter_table(
            altered_table, ha_alter_info, table_def, altered_table_def)) {
      goto rollback;
    }

    /*
      Downgrade the lock if storage engine has told us that exclusive lock was
      necessary only for prepare phase (unless we are not under LOCK TABLES) and
      user has not explicitly requested exclusive lock.
    */
    if ((inplace_supported == HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE ||
         inplace_supported == HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE) &&
        !(thd->locked_tables_mode == LTM_LOCK_TABLES ||
          thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) &&
        (alter_info->requested_lock !=
         Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE)) {
      /* If storage engine or user requested shared lock downgrade to SNW. */
      if (inplace_supported == HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE ||
          alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_SHARED)
        table->mdl_ticket->downgrade_lock(MDL_SHARED_NO_WRITE);
      else {
        assert(inplace_supported == HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE);
        table->mdl_ticket->downgrade_lock(MDL_SHARED_UPGRADABLE);
      }
    }

    DEBUG_SYNC(thd, "alter_table_inplace_after_lock_downgrade");
    THD_STAGE_INFO(thd, stage_alter_inplace);

    if (table->file->ha_inplace_alter_table(altered_table, ha_alter_info,
                                            table_def, altered_table_def)) {
      goto rollback;
    }

    // Upgrade to EXCLUSIVE before commit.
    if (wait_while_table_is_used(thd, table, HA_EXTRA_PREPARE_FOR_RENAME))
      goto rollback;

    if (collect_and_lock_fk_tables_for_complex_alter_table(
            thd, table_list, table_def, alter_ctx, alter_info, db_type, db_type,
            fk_invalidator))
      goto rollback;

    /*
      Check if this is an ALTER command that will cause histogram statistics to
      become invalid. If that is the case; remove the histogram statistics.

      This will take care of scenarios when INPLACE alter is used, but not COPY.
    */
    if (alter_table_drop_histograms(thd, table_list, ha_alter_info->alter_info,
                                    ha_alter_info->create_info, columns,
                                    table_def, altered_table_def))
      goto rollback;

    /*
      If we are killed after this point, we should ignore and continue.
      We have mostly completed the operation at this point, there should
      be no long waits left.
    */

    DBUG_EXECUTE_IF("alter_table_rollback_new_index", {
      table->file->ha_commit_inplace_alter_table(
          altered_table, ha_alter_info, false, table_def, altered_table_def);
      my_error(ER_UNKNOWN_ERROR, MYF(0));
      thd->check_for_truncated_fields = CHECK_FIELD_IGNORE;
      goto cleanup;
    });

    DEBUG_SYNC(thd, "alter_table_inplace_before_commit");
    THD_STAGE_INFO(thd, stage_alter_inplace_commit);

    if (table->file->ha_commit_inplace_alter_table(
            altered_table, ha_alter_info, true, table_def, altered_table_def)) {
      goto rollback;
    }

    thd->check_for_truncated_fields = CHECK_FIELD_IGNORE;

    close_all_tables_for_name(thd, table->s, false, nullptr);
    table_list->table = table = nullptr;
    reopen_tables = true;
    close_temporary_table(thd, altered_table, true, false);
    rollback_needs_dict_cache_reset = true;

    /*
      Replace table definition in the data-dictionary.

      Note that any error after this point is really awkward for storage engines
      which don't support atomic DDL. Changes to table in SE are already
      committed and can't be rolled back. Failure to update data-dictionary or
      binary log will create inconsistency between them and SE. Since we can't
      do much in this situation we simply return error and hope that old table
      definition is compatible enough with a new one.

      For engines supporting atomic DDL error is business-as-usual situation.
      Rollback of statement which happens on error should revert changes to
      table in SE as well.
    */
    altered_table_def->set_schema_id(table_def->schema_id());
    altered_table_def->set_name(alter_ctx->alias);
    altered_table_def->set_hidden(dd::Abstract_table::HT_VISIBLE);

    /*
      Copy pre-existing triggers to the new table definition.
      Since trigger names have to be unique per schema, we cannot
      create them while both the old and the new version of the
      table definition exist. Note that we drop the old table before
      we call update on the new table definition.
    */
    altered_table_def->copy_triggers(table_def);

    if (thd->dd_client()->drop(table_def)) goto cleanup2;
    table_def = nullptr;

    DEBUG_SYNC_C("alter_table_after_dd_client_drop");

    // Reset check constraint's mode.
    reset_check_constraints_alter_mode(altered_table_def);

    if ((db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
      /*
        For engines supporting atomic DDL we have delayed storing new
        table definition in the data-dictionary so far in order to avoid
        conflicts between old and new definitions on foreign key names.
        Since the old table definition is gone we can safely store new
        definition now.
      */
      if (thd->dd_client()->store(altered_table_def)) goto cleanup2;
    } else {
      if (thd->dd_client()->update(altered_table_def)) goto cleanup2;

      /*
        Persist changes to data-dictionary for storage engines which don't
        support atomic DDL. Such SEs can't rollback in-place changes if error
        or crash happens after this point, so we are better to have
        data-dictionary in sync with SE.

        Prevent intermediate commits to invoke commit order
      */
      Implicit_substatement_state_guard substatement_guard(thd);

      if (trans_commit_stmt(thd) || trans_commit_implicit(thd)) goto cleanup2;
    }
  }

#ifdef HAVE_PSI_TABLE_INTERFACE
  PSI_TABLE_CALL(drop_table_share)
  (true, alter_ctx->new_db, static_cast<int>(strlen(alter_ctx->new_db)),
   alter_ctx->tmp_name, static_cast<int>(strlen(alter_ctx->tmp_name)));
#endif

  DBUG_EXECUTE_IF("crash_after_index_create",
                  DBUG_SET("-d,crash_after_index_create");
                  DBUG_SUICIDE(););

  /*
    Tell the SE that the changed table in the data-dictionary.
    For engines which don't support atomic DDL this needs to be
    done before trying to rename the table.
  */
  if (!(db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
    Open_table_context ot_ctx(thd, MYSQL_OPEN_REOPEN);

    table_list->mdl_request.ticket = mdl_ticket;
    if (open_table(thd, table_list, &ot_ctx)) goto cleanup2;

    table_list->table->file->ha_notify_table_changed(ha_alter_info);

    /*
      We might be going to reopen table down on the road, so we have to
      restore state of the TABLE object which we used for obtaining of
      handler object to make it usable for later reopening.
    */
    assert(table_list->table == thd->open_tables);
    close_thread_table(thd, &thd->open_tables);
    table_list->table = nullptr;

    /*
      Remove TABLE and TABLE_SHARE for from the TDC as we might have to
      rename table later.
    */
    tdc_remove_table(thd, TDC_RT_REMOVE_ALL, alter_ctx->db,
                     alter_ctx->table_name, false);
  }

  // Rename altered table if requested.
  if (alter_ctx->is_table_renamed()) {
    if (mysql_rename_table(
            thd, db_type, alter_ctx->db, alter_ctx->table_name, alter_ctx->db,
            alter_ctx->table_name, new_schema, alter_ctx->new_db,
            alter_ctx->new_alias,
            ((db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) ? NO_DD_COMMIT : 0))) {
      /*
        If the rename fails we will still have a working table
        with the old name, but with other changes applied.
      */
      goto cleanup2;
    }
  }

  /*
    We don't have SEs which support FKs and don't support atomic DDL.
    If we ever to support such engines we need to decide how to handle
    errors in the below code for them.
  */
  assert(!(db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS) ||
         (db_type->flags & HTON_SUPPORTS_ATOMIC_DDL));

  if (adjust_fks_for_complex_alter_table(thd, table_list, alter_ctx, alter_info,
                                         db_type, fk_invalidator))
    goto cleanup2;

  THD_STAGE_INFO(thd, stage_end);

  DBUG_EXECUTE_IF("sleep_alter_before_main_binlog", my_sleep(6000000););
  DEBUG_SYNC(thd, "alter_table_before_main_binlog");

  ha_binlog_log_query(thd, ha_alter_info->create_info->db_type,
                      LOGCOM_ALTER_TABLE, thd->query().str, thd->query().length,
                      alter_ctx->db, alter_ctx->table_name);

  assert(!(mysql_bin_log.is_open() &&
           thd->is_current_stmt_binlog_format_row() &&
           (ha_alter_info->create_info->options & HA_LEX_CREATE_TMP_TABLE)));

  if (write_bin_log(thd, true, thd->query().str, thd->query().length,
                    (db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)))
    goto cleanup2;

  {
    Uncommitted_tables_guard uncommitted_tables(thd);

    uncommitted_tables.add_table(table_list);

    bool views_err =
        (alter_ctx->is_table_renamed()
             ? update_referencing_views_metadata(
                   thd, table_list, alter_ctx->new_db, alter_ctx->new_name,
                   !(db_type->flags & HTON_SUPPORTS_ATOMIC_DDL),
                   &uncommitted_tables)
             : update_referencing_views_metadata(
                   thd, table_list,
                   !(db_type->flags & HTON_SUPPORTS_ATOMIC_DDL),
                   &uncommitted_tables));

    if (alter_ctx->is_table_renamed())
      tdc_remove_table(thd, TDC_RT_REMOVE_ALL, alter_ctx->new_db,
                       alter_ctx->new_name, false);

    if (views_err) goto cleanup2;
  }

  DEBUG_SYNC(thd, "action_after_write_bin_log");

  if (db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) {
    enum_implicit_substatement_guard_mode mode =
        enum_implicit_substatement_guard_mode ::
            ENABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE;

    /* Disable GTID and SPCO for OPTIMIZE TABLE to avoid deadlock. */
    if (thd->lex->sql_command == SQLCOM_OPTIMIZE)
      mode = enum_implicit_substatement_guard_mode ::
          DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE;

    /*
      It allows saving GTID and invoking commit order, except when
      replica-preserve-commit-order is enabled and OPTIMIZE TABLE command
      is getting executed. The exception for OPTIMIZE TABLE command is
      because if it does enter commit order here and at the same time
      any operation on the table which is getting optimized is done,
      it results in deadlock.
    */
    Implicit_substatement_state_guard guard(thd, mode);

    /*
      Commit ALTER TABLE. Needs to be done here and not in the callers
      (which do it anyway) to be able notify SE about changed table.
    */
    if (trans_commit_stmt(thd) || trans_commit_implicit(thd)) goto cleanup2;

    /* Call SE DDL post-commit hook. */
    if (db_type->post_ddl) db_type->post_ddl(thd);

    /*
      Finally we can tell SE supporting atomic DDL that the changed table
      in the data-dictionary.
    */
    Table_ref new_table_list(alter_ctx->new_db, alter_ctx->new_name,
                             alter_ctx->new_alias, TL_READ);
    new_table_list.mdl_request.ticket =
        alter_ctx->is_table_renamed() ? alter_ctx->target_mdl_request.ticket
                                      : mdl_ticket;

    Open_table_context ot_ctx(thd, MYSQL_OPEN_REOPEN);

    if (open_table(thd, &new_table_list, &ot_ctx)) return true;

    new_table_list.table->file->ha_notify_table_changed(ha_alter_info);

    assert(new_table_list.table == thd->open_tables);
    close_thread_table(thd, &thd->open_tables);
  }

  // TODO: May move the opening of the table and the call to
  //       ha_notify_table_changed() here to make sure we don't
  //       notify the handler until all meta data is complete.

  return false;

rollback:
  table->file->ha_commit_inplace_alter_table(
      altered_table, ha_alter_info, false, table_def, altered_table_def);
  thd->check_for_truncated_fields = CHECK_FIELD_IGNORE;

cleanup:
  close_temporary_table(thd, altered_table, true, false);

cleanup2:

  (void)trans_rollback_stmt(thd);
  /*
    Full rollback in case we have THD::transaction_rollback_request
    and to synchronize DD state in cache and on disk (as statement
    rollback doesn't clear DD cache of modified uncommitted objects).
  */
  (void)trans_rollback(thd);

  if ((db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && db_type->post_ddl)
    db_type->post_ddl(thd);

  /*
    InnoDB requires additional SE dictionary cache invalidation if we roll back
    after successful call to handler::ha_commit_inplace_alter_table().
  */
  if (rollback_needs_dict_cache_reset) {
    if (db_type->dict_cache_reset != nullptr)
      db_type->dict_cache_reset(alter_ctx->db, alter_ctx->table_name);
  }

  /*
    Re-opening of table needs to be done after rolling back the failed
    statement/transaction and clearing THD::transaction_rollback_request
    flag.
  */
  if (reopen_tables) {
    /* Close the only table instance which might be still around. */
    if (table) close_all_tables_for_name(thd, table->s, false, nullptr);

    /*
      For engines which support atomic DDL all changes were reverted
      by this point, so we can safely reopen them using old name.

      For engines which do not support atomic DDL we can't be sure
      that rename step was reverted, so we simply remove table from
      the list of locked tables. We also downgrade/release metadata
      locks later. This  won't mess up FK-related invariants for LOCK
      TABLES as such engines do not support FKs.
    */
    if (!(db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        alter_ctx->is_table_renamed()) {
      assert(!(db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS));
      thd->locked_tables_list.unlink_all_closed_tables(thd, nullptr, 0);
    }

    (void)thd->locked_tables_list.reopen_tables(thd);
  }

  if (!(db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
    const dd::Table *drop_table_def = nullptr;
    if (!thd->dd_client()->acquire(alter_ctx->new_db, alter_ctx->tmp_name,
                                   &drop_table_def) &&
        (drop_table_def != nullptr)) {
      bool result = dd::drop_table(thd, alter_ctx->new_db, alter_ctx->tmp_name,
                                   *drop_table_def);
      (void)trans_intermediate_ddl_commit(thd, result);
    }
  }

  if (thd->locked_tables_mode == LTM_LOCK_TABLES ||
      thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES)
    mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);

  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: collect_and_lock_fk_tables_for_complex_alter_table 
static bool collect_and_lock_fk_tables_for_complex_alter_table(
    THD *thd, Table_ref *table_list, const dd::Table *old_table_def,
    const Alter_table_ctx *alter_ctx, const Alter_info *alter_info,
    handlerton *old_hton, handlerton *new_hton,
    Foreign_key_parents_invalidator *fk_invalidator) {
  MDL_request_list mdl_requests;

  if (collect_fk_parents_for_new_fks(
          thd, table_list->db, table_list->table_name, alter_info,
          MDL_EXCLUSIVE, new_hton, &mdl_requests, fk_invalidator))
    return true;

  if (alter_ctx->is_table_renamed()) {
    if (collect_fk_parents_for_all_fks(thd, old_table_def, old_hton,
                                       MDL_EXCLUSIVE, &mdl_requests,
                                       fk_invalidator))
      return true;
  } else {
    if (collect_fk_parents_for_dropped_fks(thd, alter_info, old_table_def,
                                           old_hton, &mdl_requests,
                                           fk_invalidator))
      return true;
  }

  if (new_hton != old_hton) {
    /*
      By changing table's storage engine we might be introducing parent
      table for previously orphan foreign keys in the new SE. We need
      to lock child tables of such orphan foreign keys. OTOH it is safe
      to assume that if SE is changed table can't be parent in any
      foreign keys in old SE.
    */
    assert(old_table_def->foreign_key_parents().size() == 0);

    if (collect_fk_children(thd, table_list->db, table_list->table_name,
                            new_hton, MDL_EXCLUSIVE, &mdl_requests))
      return true;
  } else {
    if (collect_fk_children(thd, old_table_def, MDL_EXCLUSIVE, &mdl_requests))
      return true;
  }

  if (alter_ctx->is_table_renamed()) {
    if (collect_fk_children(thd, alter_ctx->new_db, alter_ctx->new_alias,
                            new_hton, MDL_EXCLUSIVE, &mdl_requests))
      return true;
  }

  if (!mdl_requests.is_empty() &&
      thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: adjust_foreign_key_names_for_old_table_version 
static bool adjust_foreign_key_names_for_old_table_version(
    THD *thd, const char *db_name, const char *backup_name) {
  dd::Table *table_def = nullptr;
  MDL_request_list mdl_requests;

  if (thd->dd_client()->acquire_for_modification(db_name, backup_name,
                                                 &table_def))
    return true;
  assert(table_def != nullptr);

  for (dd::Foreign_key *fk : *table_def->foreign_keys()) {
    char temp_fk_name[4 + 20 + 1];

    snprintf(temp_fk_name, sizeof(temp_fk_name), "#fk_%llu",
             (ulonglong)fk->id());

    /*
      Acquire metadata locks on temporary names before updating data-dictionary
      just in case somebody tries to create foreign keys with names like
      #fk_<number> concurrently.
    */
    MDL_request *mdl_request = new (thd->mem_root) MDL_request;
    if (mdl_request == nullptr) return true;
    MDL_REQUEST_INIT(mdl_request, MDL_key::FOREIGN_KEY, db_name, temp_fk_name,
                     MDL_EXCLUSIVE, MDL_STATEMENT);
    mdl_requests.push_front(mdl_request);

    // Update dd::Foreign_key object but do not store it in data-dictionary yet.
    fk->set_name(temp_fk_name);
  }

  assert(!mdl_requests.is_empty());

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  return thd->dd_client()->update(table_def);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: adjust_check_constraint_names_for_old_table_version 
static bool adjust_check_constraint_names_for_old_table_version(
    THD *thd, const char *old_table_db, dd::Table *old_table) {
  MDL_request_list mdl_requests;
  for (dd::Check_constraint *cc : *old_table->check_constraints()) {
    const int prefix_len = 4;  // #cc_
    const int id_len = 20;
    char temp_cc_name[prefix_len + id_len + 1];
    snprintf(temp_cc_name, sizeof(temp_cc_name), "#cc_%llu",
             (ulonglong)cc->id());

    /*
      Acquire lock on temporary names before updating data-dictionary just in
      case somebody tries to create check constraints with same name.
    */
    if (push_check_constraint_mdl_request_to_list(thd, old_table_db,
                                                  temp_cc_name, mdl_requests))
      return true;

    // Set adjusted name.
    cc->set_name(temp_cc_name);
  }

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: lock_check_constraint_names_for_rename 
bool lock_check_constraint_names_for_rename(THD *thd, const char *db,
                                            const char *table_name,
                                            const dd::Table *table_def,
                                            const char *target_db,
                                            const char *target_table_name) {
  DBUG_TRACE;
  MDL_request_list mdl_requests;
  size_t table_name_len = strlen(table_name);

  // Push lock requests for the check constraints defined on db.table_name.
  for (auto &cc : table_def->check_constraints()) {
    if (push_check_constraint_mdl_request_to_list(thd, db, cc->name().c_str(),
                                                  mdl_requests))
      return true;
  }

  // Push lock request for the check constraints in target table.
  for (auto &cc : table_def->check_constraints()) {
    const char *cc_name = cc->name().c_str();
    /*
      If check constraint name is a generated name in the source table then
      generate name with the target table to create mdl_request with it.
    */
    bool is_generated_name = dd::is_generated_check_constraint_name(
        table_name, table_name_len, cc->name().c_str(), cc->name().length());
    if (is_generated_name) {
      char *end;
      uint number =
          my_strtoull(cc->name().c_str() + table_name_len +
                          sizeof(dd::CHECK_CONSTRAINT_NAME_SUBSTR) - 1,
                      &end, 10);
      LEX_STRING name;
      if (generate_check_constraint_name(thd, target_table_name, number, name,
                                         true))
        return true;
      cc_name = name.str;
    }

    /*
      If check constraint name is generated or table moved different database
      then create mdl_request with target_db.cc_name.
    */
    if ((is_generated_name ||
         my_strcasecmp(table_alias_charset, db, target_db)) &&
        push_check_constraint_mdl_request_to_list(thd, target_db, cc_name,
                                                  mdl_requests))
      return true;
  }

  // Acquire locks on all the collected check constraint names.
  if (!mdl_requests.is_empty() &&
      thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  DEBUG_SYNC(thd, "after_acquiring_lock_on_check_constraints_for_rename");

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_tablespace.cc
Function: set_table_encryption_type 
static bool set_table_encryption_type(THD *thd, const dd::Tablespace &ts,
                                      dd::Tablespace_table_ref_vec *trefs,
                                      Table_pair_list *tpl,
                                      const LEX_STRING &requested_encryption,
                                      MDL_request_list *table_mdl_reqs) {
  bool is_request_to_encrypt = dd::is_encrypted(requested_encryption);

  // If the source tablespace encryption type is same as request type.
  dd::String_type source_tablespace_encryption;
  if (ts.options().exists("encryption"))
    (void)ts.options().get("encryption", &source_tablespace_encryption);
  else
    source_tablespace_encryption = "N";
  if (dd::is_encrypted(source_tablespace_encryption) == is_request_to_encrypt)
    return false;

  // Retrieve table references that use tablespaces.
  if (dd::fetch_tablespace_table_refs(thd, ts, trefs)) {
    return true;
  }

  // Nothing to update, if there are no tables in it.
  if (trefs->empty()) return false;

  // Acquire MDL lock on objects.
  std::vector<dd::String_type> schemaset;
  for (auto &tref : *trefs) {
    table_mdl_reqs->push_front(dd::mdl_req(thd, tref, MDL_SHARED_UPGRADABLE));
    schemaset.push_back(tref.m_schema_name);
  }
  for (auto &sname : schemaset) {
    table_mdl_reqs->push_front(dd::mdl_schema_req(thd, sname));
  }
  if (thd->mdl_context.acquire_locks(table_mdl_reqs,
                                     thd->variables.lock_wait_timeout)) {
    return true;
  }

  // Acquire DD objects to update.
  auto &dc = *thd->dd_client();
  for (auto &tref : *trefs) {
    // Acquire table object pair
    auto tblp = get_mod_pair<dd::Table>(&dc, tref.m_schema_name, tref.m_name);
    if (tblp.first == nullptr) {
      my_error(ER_UNKNOWN_TABLE, MYF(0), tref.m_name.c_str());
      tpl->clear();
      return true;
    }
    tpl->push_back(tblp);
  }

  /*
    Check if any table's schema has default encryption is conflicting with
    the requested encryption type.
  */
  bool is_schema_encryption_conflicting = false;
  for (auto &tref : *trefs) {
    if (tref.m_schema_encryption != is_request_to_encrypt) {
      is_schema_encryption_conflicting = true;
      break;
    }
  }
  if (is_schema_encryption_conflicting) {
    if (opt_table_encryption_privilege_check &&
        check_table_encryption_admin_access(thd)) {
      my_error(is_request_to_encrypt ? ER_TABLESPACE_CANNOT_BE_ENCRYPTED
                                     : ER_TABLESPACE_CANNOT_BE_DECRYPTED,
               MYF(0));
      return true;
    }
    // We throw warning only when creating a unencrypted table in a schema
    // which has default encryption enabled.
    if (is_request_to_encrypt == false)
      push_warning(thd, Sql_condition::SL_WARNING,
                   WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB,
                   ER_THD(thd, WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB));
  }

  // Update encryption as 'Y/N' for all tables in this tablespace.
  for (auto &tp : *tpl) {
    dd::Properties *table_options = &tp.second->options();
    table_options->set("encrypt_type", (is_request_to_encrypt ? "Y" : "N"));
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_tablespace.cc
Function: Sql_cmd_alter_tablespace_rename::execute
bool Sql_cmd_alter_tablespace_rename::execute(THD *thd) {
  Rollback_guard rollback_on_return{thd};

  if (check_global_access(thd, CREATE_TABLESPACE_ACL)) {
    return true;
  }

  // Can't check the name in SE, yet. Need to acquire Tablespace
  // object first, so that we can get the engine name.

  // Lock both tablespace names in one go
  if (lock_tablespace_names(thd, m_tablespace_name, m_new_name)) {
    return true;
  }
  dd::cache::Dictionary_client *dc = thd->dd_client();
  dd::cache::Dictionary_client::Auto_releaser releaser(dc);

  dd::String_type old_name = dd::make_string_type(m_tablespace_name);
  dd::String_type new_name = dd::make_string_type(m_new_name);

  auto tsmp = get_mod_pair<dd::Tablespace>(dc, m_tablespace_name.str);
  if (tsmp.first == nullptr) {
    my_error(ER_TABLESPACE_MISSING_WITH_NAME, MYF(0), m_tablespace_name.str);
    return true;
  }
  tsmp.second->set_name(new_name);

  const dd::Tablespace *existing_new_ts_def = nullptr;
  if (dc->acquire(new_name, &existing_new_ts_def)) {
    return true;
  }
  if (existing_new_ts_def != nullptr) {
    my_error(ER_TABLESPACE_EXISTS, MYF(0), new_name.c_str());
    return true;
  }

  handlerton *hton = nullptr;
  if (get_dd_hton(thd, tsmp.first->engine(), {nullptr, 0},
                  m_tablespace_name.str, "ALTER TABLESPACE ... RENAME TO",
                  &hton)) {
    return true;
  }
  if (ha_is_storage_engine_disabled(hton)) {
    my_error(ER_DISABLED_STORAGE_ENGINE, MYF(0),
             ha_resolve_storage_engine_name(hton));
    return true;
  }
  rollback_on_return.m_hton = hton;

  /*
    Now with the hton, we need to validate BOTH the old and the new
    name - since we are not allowed to rename reserved names
    FUTURE - Could be a property/attribute of dd::Tablespace
  */
  if (validate_tablespace_name(DROP_TABLESPACE, m_tablespace_name.str, hton)) {
    return true;
  }

  // Also validate the new tablespace name in the SE
  if (validate_tablespace_name(CREATE_TABLESPACE, m_new_name.str, hton)) {
    return true;
  }

  dd::Tablespace_table_ref_vec trefs;
  if (dd::fetch_tablespace_table_refs(thd, *tsmp.first, &trefs)) {
    return true;
  }
  MDL_request_list table_reqs;
  for (auto &tref : trefs) {
    table_reqs.push_front(dd::mdl_req(thd, tref, MDL_EXCLUSIVE));
  }

  if (thd->mdl_context.acquire_locks(&table_reqs,
                                     thd->variables.lock_wait_timeout)) {
    return true;
  }

  for (auto &tref : trefs) {
    // Lock and release the mutex each time to allow others to access the tdc.
    // Rename tablespace can afford to wait for mutex repeatedly.
    tdc_remove_table(thd, TDC_RT_REMOVE_ALL, tref.m_schema_name.c_str(),
                     tref.m_name.c_str(), false /*has_lock*/);
  }
  st_alter_tablespace ts_info{
      m_tablespace_name.str,   nullptr, ALTER_TABLESPACE,
      ALTER_TABLESPACE_RENAME, nullptr, nullptr,
      Tablespace_options{}};
  if (map_errors(
          hton->alter_tablespace(hton, thd, &ts_info, tsmp.first, tsmp.second),
          "ALTER TABLESPACE ... RENAME TO", &ts_info)) {
    return true;
  }

  // TODO WL#9536: Until crash-safe ddl is implemented we need to do
  // manual compensation in case of rollback
  auto compensate_grd = dd::sdi_utils::make_guard(hton, [&](handlerton *ht) {
    std::unique_ptr<dd::Tablespace> comp{tsmp.first->clone()};
    (void)ht->alter_tablespace(ht, thd, &ts_info, tsmp.second, comp.get());
  });

  DBUG_EXECUTE_IF("tspr_post_se", {
    my_error(ER_UNKNOWN_ERROR, MYF(0));
    return true;
  });

  if (dc->update(tsmp.second)) {
    return true;
  }

  DBUG_EXECUTE_IF("tspr_post_update", {
    my_error(ER_UNKNOWN_ERROR, MYF(0));
    return true;
  });

  /*
    ALTER TABLESPACE for engines which don't support atomic
    DDL still needs to be handled by doing commit right after updating
    data-dictionary.
  */
  if (intermediate_commit_unless_atomic_ddl(thd, hton)) {
    return true;
  }

  if (!ddl_is_atomic(hton)) {
    compensate_grd.release();
  }

  DBUG_EXECUTE_IF("tspr_post_intcmt", {
    my_error(ER_UNKNOWN_ERROR, MYF(0));
    return true;
  });

  if (complete_stmt(thd, hton, [&]() {
        rollback_on_return.disable();
        compensate_grd.release();
      })) {
    return true;
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_trigger.cc
Function: Sql_cmd_ddl_trigger_common::open_and_lock_subj_table 
TABLE *Sql_cmd_ddl_trigger_common::open_and_lock_subj_table(
    THD *thd, Table_ref *tables, MDL_ticket **mdl_ticket) const {
  /* We should have only one table in table list. */
  assert(tables->next_global == nullptr);

  /* We also don't allow creation of triggers on views. */
  tables->required_type = dd::enum_table_type::BASE_TABLE;
  /*
    Also prevent DROP TRIGGER from opening temporary table which might
    shadow the subject table on which trigger to be dropped is defined.
  */
  tables->open_type = OT_BASE_ONLY;

  /* Keep consistent with respect to other DDL statements */
  mysql_ha_rm_tables(thd, tables);

  if (thd->locked_tables_mode) {
    /* Under LOCK TABLES we must only accept write locked tables. */
    tables->table =
        find_table_for_mdl_upgrade(thd, tables->db, tables->table_name, false);
    if (tables->table == nullptr) return nullptr;

    if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
      return nullptr;
  } else {
    tables->table = open_n_lock_single_table(thd, tables, TL_READ_NO_INSERT, 0);
    if (tables->table == nullptr) return nullptr;
    tables->table->use_all_columns();
  }

  TABLE *table = tables->table;
  table->pos_in_table_list = tables;

  /* Later on we will need it to downgrade the lock */
  *mdl_ticket = table->mdl_ticket;

  if (wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN))
    return nullptr;

  return table;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_trigger.cc
Function: acquire_mdl_for_trigger 
bool acquire_mdl_for_trigger(THD *thd, const char *db, const char *trg_name,
                             enum_mdl_type trigger_name_mdl_type) {
  DBUG_TRACE;
  assert(trg_name != nullptr);
  assert(trigger_name_mdl_type == MDL_EXCLUSIVE ||
         trigger_name_mdl_type == MDL_SHARED_HIGH_PRIO);

  MDL_key mdl_key;
  dd::Trigger::create_mdl_key(dd::String_type(db), dd::String_type(trg_name),
                              &mdl_key);

  MDL_request mdl_request;
  MDL_REQUEST_INIT_BY_KEY(&mdl_request, &mdl_key, trigger_name_mdl_type,
                          MDL_TRANSACTION);
  /*
    It isn't required to create MDL request for MDL_key::GLOBAL,
    MDL_key::SCHEMA since it was already done before while
    calling the method open_and_lock_subj_table().
  */
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  DEBUG_SYNC(thd, "after_acquiring_mdl_lock_on_trigger");

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_view.cc
Function: mysql_drop_view
bool mysql_drop_view(THD *thd, Table_ref *views) {
  bool some_views_deleted = false;

  DBUG_TRACE;

  /*
    We can't allow dropping of unlocked view under LOCK TABLES since this
    might lead to deadlock. But since we can't really lock view with LOCK
    TABLES we have to simply prohibit dropping of views.
  */
  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  if (lock_table_names(thd, views, nullptr, thd->variables.lock_wait_timeout,
                       0))
    return true;

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  Security_context *sctx = thd->security_context();

  // First check which views exist
  String non_existant_views;
  for (Table_ref *view = views; view; view = view->next_local) {
    /*
      Either, the entity does not exist, in which case we will
      issue a warning (if running with DROP ... IF EXISTS), or
      we will fail with an error later due to views not existing.

      Otherwise, the entity does indeed exist, and we must take
      different actions depending on the table type.
    */
    const dd::Abstract_table *at = nullptr;
    if (thd->dd_client()->acquire(view->db, view->table_name, &at)) return true;

    if (at == nullptr) {
      String tbl_name(view->db, system_charset_info);
      tbl_name.append('.');
      tbl_name.append(String(view->table_name, system_charset_info));

      if (thd->lex->drop_if_exists)
        push_warning_printf(thd, Sql_condition::SL_NOTE, ER_BAD_TABLE_ERROR,
                            ER_THD(thd, ER_BAD_TABLE_ERROR), tbl_name.c_ptr());
      else {
        if (non_existant_views.length()) non_existant_views.append(',');
        non_existant_views.append(tbl_name);
      }
    } else if (at->type() == dd::enum_table_type::BASE_TABLE) {
      my_error(ER_WRONG_OBJECT, MYF(0), view->db, view->table_name, "VIEW");
      return true;
    }
  }
  if (non_existant_views.length()) {
    my_error(ER_BAD_TABLE_ERROR, MYF(0), non_existant_views.c_ptr());
    return true;
  }

  // Then actually start dropping views.
  for (Table_ref *view = views; view; view = view->next_local) {
    DBUG_EXECUTE_IF("fail_while_acquiring_view_obj",
                    DBUG_SET("+d,fail_while_acquiring_dd_object"););
    /*
      Either, the entity does not exist, in which case we will
      issue a warning (if running with DROP ... IF EXISTS), or
      we will fail with an error later due to views not existing.

      Otherwise, the entity does indeed exist, and we must take
      different actions depending on the table type.
    */
    const dd::Abstract_table *at = nullptr;
    if (thd->dd_client()->acquire(view->db, view->table_name, &at)) {
      DBUG_EXECUTE_IF("fail_while_acquiring_view_obj",
                      DBUG_SET("-d,fail_while_acquiring_dd_object"););
      trans_rollback_stmt(thd);
      // Full rollback in case we have THD::transaction_rollback_request.
      trans_rollback(thd);
      return true;
    }

    if (at == nullptr) {
      assert(thd->lex->drop_if_exists);
      continue;  // Warning reported above.
    }

    assert(at->type() == dd::enum_table_type::SYSTEM_VIEW ||
           at->type() == dd::enum_table_type::USER_VIEW);

    const dd::View *vw = dynamic_cast<const dd::View *>(at);
    assert(vw);
    /*
      If definer has the SYSTEM_USER privilege then invoker can drop view
      only if latter also has same privilege.
    */
    Auth_id definer(vw->definer_user().c_str(), vw->definer_host().c_str());
    if (sctx->can_operate_with(definer, consts::system_user, true)) return true;

    Uncommitted_tables_guard uncommitted_tables(thd);
    /*
      For a view, there is a TABLE_SHARE object, but its
      ref_count never goes above 1. Remove it from the table
      definition cache, in case the view was cached.
    */
    uncommitted_tables.add_table(view);

    /*
      Remove view from DD tables and update metadata of other views
      referecing view being dropped.
    */
    if (thd->dd_client()->drop(at) ||
        update_referencing_views_metadata(thd, view, false,
                                          &uncommitted_tables)) {
      trans_rollback_stmt(thd);
      /*
        Full rollback in case we have THD::transaction_rollback_request
        and to synchronize DD state in cache and on disk (as statement
        rollback doesn't clear DD cache of modified uncommitted objects).
      */
      trans_rollback(thd);
      return true;
    }

    thd->add_to_binlog_accessed_dbs(view->db);
    some_views_deleted = true;
  }

  if (some_views_deleted) sp_cache_invalidate();

  if (write_bin_log(thd, false, thd->query().str, thd->query().length,
                    some_views_deleted) ||
      DBUG_EVALUATE_IF("simulate_drop_view_failure", true, false)) {
    DBUG_EXECUTE_IF("simulate_drop_view_failure",
                    my_error(ER_UNKNOWN_ERROR, MYF(0)););
    trans_rollback_stmt(thd);
    /*
      Full rollback in case we have THD::transaction_rollback_request
      and to synchronize DD state in cache and on disk (as statement
      rollback doesn't clear DD cache of modified uncommitted objects).
    */
    trans_rollback(thd);
    return true;
  }

  if (trans_commit_stmt(thd) || trans_commit(thd)) return true;

  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/xa.cc
Function: acquire_mandatory_metadata_locks
bool acquire_mandatory_metadata_locks(THD *thd, xid_t *detached_xid) {
  /*
    Acquire metadata lock which will ensure that XA ROLLBACK is blocked
    by active FLUSH TABLES WITH READ LOCK (and vice versa ROLLBACK in
    progress blocks FTWRL). This is to avoid binlog and redo entries
    while a backup is in progress.
  */
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    return true;
  }

  /*
    Like in the commit case a failure to store gtid is regarded
    as the resource manager issue.
  */

  if (MDL_context_backup_manager::instance().restore_backup(
          &thd->mdl_context, detached_xid->key(), detached_xid->key_length())) {
    return true;
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/xa/sql_xa_commit.cc
Function: Sql_cmd_xa_commit::process_attached_xa_commit 
bool Sql_cmd_xa_commit::process_attached_xa_commit(THD *thd) const {
  DBUG_TRACE;
  bool res = false;
  bool gtid_error = false, need_clear_owned_gtid = false;
  auto xid_state = thd->get_transaction()->xid_state();

  if (xid_state->xa_trans_rolled_back()) {
    xa_trans_force_rollback(thd);
    res = thd->is_error();
  } else if (xid_state->has_state(XID_STATE::XA_IDLE) &&
             m_xa_opt == XA_ONE_PHASE) {
    int r = ha_commit_trans(thd, true);
    if ((res = r)) my_error(r == 1 ? ER_XA_RBROLLBACK : ER_XAER_RMERR, MYF(0));
  } else if (xid_state->has_state(XID_STATE::XA_PREPARED) &&
             m_xa_opt == XA_NONE) {
    MDL_request mdl_request;

    /*
      Acquire metadata lock which will ensure that COMMIT is blocked
      by active FLUSH TABLES WITH READ LOCK (and vice versa COMMIT in
      progress blocks FTWRL).

      We allow FLUSHer to COMMIT; we assume FLUSHer knows what it does.
    */
    MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "",
                     MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
    if (thd->mdl_context.acquire_lock(&mdl_request,
                                      thd->variables.lock_wait_timeout)) {
      /*
        We can't rollback an XA transaction on lock failure due to
        Innodb redo log and bin log update are involved in rollback.
        Return error to user for a retry.
      */
      my_error(ER_XA_RETRY, MYF(0));
      return true;
    }

    std::tie(gtid_error, need_clear_owned_gtid) = commit_owned_gtids(thd, true);
    if (gtid_error) {
      res = true;
      /*
        Failure to store gtid is regarded as a unilateral one of the
        resource manager therefore the transaction is to be rolled back.
        The specified error is the same as @c xa_trans_force_rollback.
        The prepared XA will be rolled back along and so will do Gtid state,
        see ha_rollback_trans().

        Todo/fixme: fix binlogging, "XA rollback" event could be missed out.
        Todo/fixme: as to XAER_RMERR, should not it be XA_RBROLLBACK?
                    Rationale: there's no consistency concern after rollback,
                    unlike what XAER_RMERR suggests.
      */
      ha_rollback_trans(thd, true);
      my_error(ER_XAER_RMERR, MYF(0));
    } else {
      CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP("before_commit_xa_trx");
      DEBUG_SYNC(thd, "trans_xa_commit_after_acquire_commit_lock");

      if (tc_log != nullptr)
        res = tc_log->commit(thd, /* all */ true);
      else
        res = ha_commit_low(thd, /* all */ true);

      DBUG_EXECUTE_IF("simulate_xa_commit_log_failure", { res = true; });

      if (res)
        my_error(ER_XAER_RMERR, MYF(0));  // todo/fixme: consider to rollback it
#ifdef HAVE_PSI_TRANSACTION_INTERFACE
      else {
        /*
          Since we don't call ha_commit_trans() for prepared transactions,
          we need to explicitly mark the transaction as committed.
        */
        MYSQL_COMMIT_TRANSACTION(thd->m_transaction_psi);
      }

      thd->m_transaction_psi = nullptr;
#endif
    }
  } else {
    my_error(ER_XAER_RMFAIL, MYF(0), xid_state->state_name());
    return true;
  }

  gtid_state_commit_or_rollback(thd, need_clear_owned_gtid, !gtid_error);
  cleanup_trans_state(thd);

  xid_state->set_state(XID_STATE::XA_NOTR);
  xid_state->unset_binlogged();
  trans_track_end_trx(thd);
  /* The transaction should be marked as complete in P_S. */
  assert(thd->m_transaction_psi == nullptr || res);
  return res;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/events.cc
Function: Events::lock_schema_events
bool Events::lock_schema_events(THD *thd, const dd::Schema &schema) {
  DBUG_TRACE;

  std::vector<dd::String_type> event_names;
  if (thd->dd_client()->fetch_schema_component_names<dd::Event>(&schema,
                                                                &event_names))
    return true;

  /*
    If lower_case_table_names == 2 then schema names should be lower cased for
    proper hash key comparisons.
  */
  const char *schema_name = schema.name().c_str();
  char schema_name_buf[NAME_LEN + 1];
  if (lower_case_table_names == 2) {
    my_stpcpy(schema_name_buf, schema_name);
    my_casedn_str(system_charset_info, schema_name_buf);
    schema_name = schema_name_buf;
  }

  /*
    Ensure that we don't hold memory used by MDL_requests after locks have
    been acquired. This reduces memory usage in cases when we have DROP
    DATABASE that needs to drop lots of different objects.
  */
  MEM_ROOT mdl_reqs_root(key_memory_rm_db_mdl_reqs_root, MEM_ROOT_BLOCK_SIZE);

  MDL_request_list mdl_requests;
  for (std::vector<dd::String_type>::const_iterator name = event_names.begin();
       name != event_names.end(); ++name) {
    MDL_key mdl_key;
    dd::Event::create_mdl_key(dd::String_type(schema_name), *name, &mdl_key);

    // Add MDL_request for routine to mdl_requests list.
    MDL_request *mdl_request = new (&mdl_reqs_root) MDL_request;
    MDL_REQUEST_INIT_BY_KEY(mdl_request, &mdl_key, MDL_EXCLUSIVE,
                            MDL_TRANSACTION);
    mdl_requests.push_front(mdl_request);
  }

  return thd->mdl_context.acquire_locks(&mdl_requests,
                                        thd->variables.lock_wait_timeout);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/events.cc
Function: Events::show_create_event
bool Events::show_create_event(THD *thd, LEX_CSTRING dbname, LEX_CSTRING name) {
  Event_timed et;
  bool ret;

  DBUG_TRACE;
  DBUG_PRINT("enter", ("name: %s@%s", dbname.str, name.str));

  if (check_access(thd, EVENT_ACL, dbname.str, nullptr, nullptr, false, false))
    return true;

  // We must make sure the schema is released and unlocked in the right
  // order. Fail if we are unable to get a meta data lock on the schema
  // name.
  dd::Schema_MDL_locker mdl_handler(thd);
  if (mdl_handler.ensure_locked(dbname.str)) return true;

  // Grab MDL lock on object in shared mode.
  MDL_key mdl_key;
  dd::Event::create_mdl_key(dbname.str, name.str, &mdl_key);
  MDL_request event_mdl_request;
  MDL_REQUEST_INIT_BY_KEY(&event_mdl_request, &mdl_key, MDL_SHARED_HIGH_PRIO,
                          MDL_TRANSACTION);
  if (thd->mdl_context.acquire_lock(&event_mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  DEBUG_SYNC(thd, "after_acquiring_shared_lock_on_the_event");

  /*
    We would like to allow SHOW CREATE EVENT under LOCK TABLES and
    in pre-locked mode. mysql.event table is marked as a system table.
    This flag reduces the set of its participation scenarios in LOCK TABLES
    operation, and therefore an out-of-bound open of this table
    for reading like the one below (sic, only for reading) is
    more or less deadlock-free. For additional information about when a
    deadlock can occur please refer to the description of 'system table'
    flag.
  */
  ret = Event_db_repository::load_named_event(thd, dbname, name, &et);
  if (!ret) ret = send_show_create_event(thd, &et, thd->get_protocol());

  return ret;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_authorization.cc
Function: mysql_table_grant 

int mysql_table_grant(THD *thd, Table_ref *table_list,
                      List<LEX_USER> &user_list, List<LEX_COLUMN> &columns,
                      ulong rights, bool revoke_grant) {
  ulong column_priv = 0;
  List_iterator<LEX_USER> str_list(user_list);
  LEX_USER *Str, *tmp_Str;
  Table_ref tables[ACL_TABLES::LAST_ENTRY];
  const char *db_name, *table_name;
  bool transactional_tables;
  acl_table::Pod_user_what_to_update what_to_set;
  bool result = false;
  int ret = 0;
  std::set<LEX_USER *> existing_users;

  DBUG_TRACE;

  assert(initialized);

  if (rights & ~TABLE_ACLS) {
    my_error(ER_ILLEGAL_GRANT_FOR_TABLE, MYF(0));
    return true;
  }

  if (!revoke_grant) {
    if (columns.elements) {
      class LEX_COLUMN *column;
      List_iterator<LEX_COLUMN> column_iter(columns);

      if (open_tables_for_query(thd, table_list, 0)) return true;

      if (table_list->is_view() &&
          !table_list->derived_query_expression()->is_prepared()) {
        Prepared_stmt_arena_holder ps_arena_holder(thd);

        if (table_list->resolve_derived(thd, false))
          return true; /* purecov: inspected */

        // Prepare a readonly (materialized) view for access to columns
        if (table_list->setup_materialized_derived(thd))
          return true; /* purecov: inspected */
      }
      while ((column = column_iter++)) {
        uint unused_field_idx = NO_FIELD_INDEX;
        Table_ref *dummy;
        Field *f = find_field_in_table_ref(
            thd, table_list, column->column.ptr(), column->column.length(),
            column->column.ptr(), nullptr, nullptr, nullptr,
            // check that we have the
            // to-be-granted privilege:
            column->rights, false, &unused_field_idx, false, &dummy);
        if (f == (Field *)nullptr) {
          my_error(ER_BAD_FIELD_ERROR, MYF(0), column->column.c_ptr(),
                   table_list->alias);
          return true;
        }
        if (f == (Field *)-1) return true;
        column_priv |= column->rights;
      }
      close_mysql_tables(thd);
    } else {
      if (!(rights & CREATE_ACL)) {
        // We need at least a shared MDL lock on the table to be allowed
        // to safely check its existence.
        MDL_request mdl_request;
        MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, table_list->db,
                         table_list->table_name, MDL_SHARED, MDL_TRANSACTION);
        if (thd->mdl_context.acquire_lock(&mdl_request,
                                          thd->variables.lock_wait_timeout))
          return true;

        bool exists;
        if (dd::table_exists(thd->dd_client(), table_list->db,
                             table_list->table_name, &exists))
          return true;

        if (!exists) {
          my_error(ER_NO_SUCH_TABLE, MYF(0), table_list->db, table_list->alias);
          return true;
        }
      }
      ulong missing_privilege = rights & ~table_list->grant.privilege;
      if (missing_privilege) {
        char command[128];
        get_privilege_desc(command, sizeof(command), missing_privilege);
        my_error(ER_TABLEACCESS_DENIED_ERROR, MYF(0), command,
                 thd->security_context()->priv_user().str,
                 thd->security_context()->host_or_ip().str, table_list->alias);
        return true;
      }
    }
  }

  /*
    This statement will be replicated as a statement, even when using
    row-based replication.  The binlog state will be cleared here to
    statement based replication and will be reset to the originals
    values when we are out of this function scope
  */
  Save_and_Restore_binlog_format_state binlog_format_state(thd);

  /*
    The lock api is depending on the thd->lex variable which needs to be
    re-initialized.
  */
  Query_tables_list backup;
  thd->lex->reset_n_backup_query_tables_list(&backup);
  /*
    Restore Query_tables_list::sql_command value, which was reset
    above, as the code writing query to the binary log assumes that
    this value corresponds to the statement being executed.
  */
  thd->lex->sql_command = backup.sql_command;

  { /* Critical Section */
    Acl_cache_lock_guard acl_cache_lock(thd, Acl_cache_lock_mode::WRITE_MODE);

    if ((ret = open_grant_tables(thd, tables, &transactional_tables))) {
      thd->lex->restore_backup_query_tables_list(&backup);
      return ret != 1; /* purecov: deadcode */
    }

    if (!acl_cache_lock.lock()) {
      commit_and_close_mysql_tables(thd);
      return true;
    }

    if (check_system_user_privilege(thd, user_list)) {
      commit_and_close_mysql_tables(thd);
      return true;
    }

    MEM_ROOT *old_root = thd->mem_root;
    thd->mem_root = &memex;
    grant_version++;

    while ((tmp_Str = str_list++)) {
      int error;
      GRANT_TABLE *grant_table;

      if (!(Str = get_current_user(thd, tmp_Str))) {
        result = true;
        continue;
      }

      Userhostpassword_list password_list;
      if (set_and_validate_user_attributes(
              thd, Str, what_to_set, false, false,
              &tables[ACL_TABLES::TABLE_PASSWORD_HISTORY], nullptr,
              revoke_grant ? "REVOKE" : "GRANT", password_list)) {
        result = true;
        continue;
      }

      ACL_USER *this_user = find_acl_user(Str->host.str, Str->user.str, true);
      if (this_user && (what_to_set.m_what & PLUGIN_ATTR))
        existing_users.insert(tmp_Str);

      db_name = table_list->get_db_name();
      thd->add_to_binlog_accessed_dbs(db_name);  // collecting db:s for MTS
      table_name = table_list->get_table_name();

      /* Find/create cached table grant */
      grant_table = table_hash_search(Str->host.str, NullS, db_name,
                                      Str->user.str, table_name, true);
      if (!grant_table) {
        if (revoke_grant) {
          result = report_missing_user_grant_message(
              thd, (this_user ? true : false), Str->user.str, Str->host.str,
              table_list->table_name, ER_NONEXISTING_TABLE_GRANT);
          continue;
        }

        DBUG_EXECUTE_IF("mysql_table_grant_out_of_memory",
                        DBUG_SET("+d,simulate_out_of_memory"););
        grant_table = new (thd->mem_root)
            GRANT_TABLE(Str->host.str, db_name, Str->user.str, table_name,
                        rights, column_priv);
        DBUG_EXECUTE_IF("mysql_table_grant_out_of_memory",
                        DBUG_SET("-d,simulate_out_of_memory"););

        if (!grant_table) {
          result = true; /* purecov: deadcode */
          break;         /* purecov: deadcode */
        }
        column_priv_hash->emplace(
            grant_table->hash_key,
            unique_ptr_destroy_only<GRANT_TABLE>(grant_table));
      }

      /* If revoke_grant, calculate the new column privilege for tables_priv */
      if (revoke_grant) {
        class LEX_COLUMN *column;
        List_iterator<LEX_COLUMN> column_iter(columns);
        GRANT_COLUMN *grant_column;

        /* Fix old grants */
        while ((column = column_iter++)) {
          grant_column = column_hash_search(grant_table, column->column.ptr(),
                                            column->column.length());
          if (grant_column) grant_column->rights &= ~(column->rights | rights);
        }
        /* scan through all columns to get new column grant */
        column_priv = 0;
        for (const auto &key_and_value : grant_table->hash_columns) {
          grant_column = key_and_value.second.get();
          grant_column->rights &= ~rights;  // Fix other columns
          column_priv |= grant_column->rights;
        }
      } else {
        column_priv |= grant_table->cols;
      }

      /* update table and columns */

      // Hold on to grant_table if it gets deleted, since we use it below.
      std::unique_ptr<GRANT_TABLE, Destroy_only<GRANT_TABLE>>
          deleted_grant_table;

      if ((error = replace_table_table(
               thd, grant_table, &deleted_grant_table,
               tables[ACL_TABLES::TABLE_TABLES_PRIV].table, *Str, db_name,
               table_name, rights, column_priv, revoke_grant))) {
        result = true;
        if (error < 0) break;

        continue;
      }

      if (tables[3].table) {
        if ((error = replace_column_table(
                 thd, grant_table, tables[ACL_TABLES::TABLE_COLUMNS_PRIV].table,
                 *Str, columns, db_name, table_name, rights, revoke_grant))) {
          result = true;
          if (error < 0) break;

          continue;
        }
      }
    }
    thd->mem_root = old_root;

    assert(!result || thd->is_error());

    result = log_and_commit_acl_ddl(thd, transactional_tables);

    {
      /* Notify audit plugin. We will ignore the return value. */
      LEX_USER *existing_user;
      for (LEX_USER *one_user : existing_users) {
        if ((existing_user = get_current_user(thd, one_user)))
          mysql_audit_notify(
              thd, AUDIT_EVENT(MYSQL_AUDIT_AUTHENTICATION_CREDENTIAL_CHANGE),
              thd->is_error(), existing_user->user.str, existing_user->host.str,
              existing_user->first_factor_auth_info.plugin.str,
              is_role_id(existing_user), nullptr, nullptr);
      }
    }
    get_global_acl_cache()->increase_version();
  } /* Critical section */

  if (!result) {
    my_ok(thd);
    /* Notify storage engines */
    acl_notify_htons(thd, revoke_grant ? SQLCOM_REVOKE : SQLCOM_GRANT,
                     &user_list);
  }

  thd->lex->restore_backup_query_tables_list(&backup);
  DEBUG_SYNC(thd, "after_table_grant_revoke");
  return result;
}
-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user_table.cc
Function: acl_tables_setup_for_write_and_acquire_mdl 
static bool acl_tables_setup_for_write_and_acquire_mdl(THD *thd,
                                                       Table_ref *tables) {
  /*
    This function is called perform an ACL DDL operation

    Operation MUST be able to run concurrently with a simple SELECT queries

    The operation:
    a. Modifies one or more tables specified below
    b. Updates one or more in-memory caches used for
       authentication/authorization

    Thus, operation MUST not be able to run concurrently with:
    a. A INSERT/UPDATE/DELETE operation on tables used by ACL DDls
    b. FLUSH TABLES WITH READ LOCKS
    c. FLUSH PRIVILEGES

    Following describes which all MDLs are taken and why.

    - MDL_INTENTION_EXCLUSIVE for MDL_key::GLOBAL at global level. This
    - MDL_INTENTION_EXCLUSIVE for MDL_Key::BACKUP_LOCK at global level
    - MDL_SHARED_READ_ONLY for MDL_key::TABLE for each ACL table
    - MDL_SHARED_WRITE for MDL_key::TABLE for each ACL table

    Collectively, these locks prevent following operations from other
    connections:
    - DMLs that may modify ACL tables
    - DDLs that may modify ACL tables (ALTER/DROP etc)
    - ACL DDLs
    - FLUSH PRIVILEGES
    - FLUSH TABLES WITH READ LOCK
    - LOCK TABLE
  */

  /* MDL does not matter because we are setting flag to ignore it */
  acl_tables_setup(tables, TL_WRITE, MDL_SHARED_WRITE);

  MDL_request_list mdl_requests;

  if (thd->global_read_lock.can_acquire_protection()) return true;
  MDL_request *global_ix_request = new (thd->mem_root) MDL_request;
  if (global_ix_request == nullptr) {
    my_error(ER_OUTOFMEMORY, MYF(ME_FATALERROR), sizeof(MDL_request));
    return true;
  }

  MDL_REQUEST_INIT(global_ix_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  mdl_requests.push_front(global_ix_request);

  MDL_request *backup_request = new (thd->mem_root) MDL_request;
  if (backup_request == nullptr) {
    my_error(ER_OUTOFMEMORY, MYF(ME_FATALERROR), sizeof(MDL_request));
    return true;
  }

  MDL_REQUEST_INIT(backup_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  mdl_requests.push_front(backup_request);

  for (int idx = 0; idx < ACL_TABLES::LAST_ENTRY; ++idx) {
    MDL_request *sro_request = new (thd->mem_root) MDL_request;
    if (sro_request == nullptr) {
      my_error(ER_OUTOFMEMORY, MYF(ME_FATALERROR), sizeof(MDL_request));
      return true;
    }
    MDL_REQUEST_INIT(sro_request, MDL_key::TABLE, (tables + idx)->db,
                     (tables + idx)->table_name, MDL_SHARED_READ_ONLY,
                     MDL_TRANSACTION);
    mdl_requests.push_front(sro_request);

    MDL_request *sw_request = new (thd->mem_root) MDL_request;
    if (sw_request == nullptr) {
      my_error(ER_OUTOFMEMORY, MYF(ME_FATALERROR), sizeof(MDL_request));
      return true;
    }
    MDL_REQUEST_INIT(sw_request, MDL_key::TABLE, (tables + idx)->db,
                     (tables + idx)->table_name, MDL_SHARED_WRITE,
                     MDL_TRANSACTION);
    mdl_requests.push_front(sw_request);
  }

  acl_tables_setup_for_write_and_acquire_mdl_error_handler handler;
  thd->push_internal_handler(&handler);
  bool mdl_acquire_error = false;
  for (;;) {
    handler.reset_hit_deadlock();
    /*
      MDL_context::acquire_locks sorts all lock requests.
      Due to this, a situation may arise that two or more
      competing threads will acquire:
      - IX lock at global level
      - Backup lock
      - SRO on first table according to sorting done

      Next, they will all compete for SW on the same table.

      At this point, MDL's deadlock detection would kick in
      and evict all but one thread.

      In a standalone server, this may result into victim
      threads receiving ER_DEADLOCK_ERROR. This may not be
      a big problem because user can always retry. However,
      in a secondary node, applier threads can not
      tolerate such error.

      Thus, we run a infinite loop here. Essentially - do not
      give up in case a deadlock is encountered. Repeat until
      all required locks are obtained. We do this by crafting
      a special handler and pushing it on top for the duration
      of the loop. This error handler will suppress
      ER_DEADLOCK_ERROR.

      MDL_context::acquire_locks() will make sure that lock
      acquisition is atomic. So we don't have to worry about
      cleanup in case the function fails.

      Note that even with custom error handlers,
      MDL_context::acquire_locks() will return failure in case
      of ER_DEADLOCK_ERROR. However, there won't be any error
      set in THD thatnks to custom error handler.
    */
    mdl_acquire_error = thd->mdl_context.acquire_locks(
        &mdl_requests, thd->variables.lock_wait_timeout);
    /* Retry acquire_locks only if there was a deadlock */
    if (mdl_acquire_error && handler.hit_deadlock())
      continue;
    else
      break;
  }
  thd->pop_internal_handler();

  return mdl_acquire_error;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: open_views_and_update_metadata 
static bool open_views_and_update_metadata(
    THD *thd, const std::vector<Table_ref *> *views, bool commit_dd_changes,
    Uncommitted_tables_guard *uncommitted_tables) {
  DBUG_TRACE;

  if (!commit_dd_changes) {
    /*
      If we don't plan to commit changes to the data-dictionary in this
      function we need to keep locks on views to be updated until the
      statement end. Because of this we need to acquire them before
      View_metadata_updater_context takes effect.
    */
    for (auto view : *views) {
      MDL_request view_request, schema_request;

      MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, view->db, "",
                       MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
      if (thd->mdl_context.acquire_lock(&schema_request,
                                        thd->variables.lock_wait_timeout))
        return true;

      MDL_REQUEST_INIT_BY_KEY(&view_request, &view->mdl_request.key,
                              MDL_EXCLUSIVE, MDL_STATEMENT);
      if (thd->mdl_context.acquire_lock(&view_request,
                                        thd->variables.lock_wait_timeout))
        return true;
    }
  }

  // Check schema read only for all views.
  for (auto view : *views) {
    if (check_schema_readonly(thd, view->db)) return true;
  }

  for (auto view : *views) {
    View_metadata_updater_context vw_metadata_update_context(thd);

    View_metadata_updater_error_handler error_handler;
    thd->push_internal_handler(&error_handler);

    DBUG_EXECUTE_IF("enable_stack_overrun_simulation",
                    { DBUG_SET("+d,simulate_stack_overrun"); });

    // This needs to be after View_metadata_updater_context so that
    // objects are released before metadata locks are dropped.
    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    /*
      Open view.

      Do not open tables which are not already in Table Cache in SE,
      as this might mean that, for example, this table is in the
      process of being ALTERed (by the thread which called our
      function), so its definition which we are going to use for
      opening is not committed/usable with SE.
    */
    uint counter = 0;
    DML_prelocking_strategy prelocking_strategy;
    view->query_block = thd->lex->query_block;
    /*
      open_tables() will normally switch the current memory allocation context
      from the execution context to the prepared statement context, if
      such context is active. However, open_views_and_update_metadata() should
      be done only as part of a single execution, and will be fully cleaned up
      as part of that execution.
      The following code forces the preparation code in open_tables() to
      be performed on the execution mem_root, regardless of the current
      embedding memory allocation context.
    */
    MEM_ROOT *saved_arena_mem_root = thd->stmt_arena->mem_root;
    thd->stmt_arena->mem_root = thd->mem_root;
    if (open_tables(thd, &view, &counter, MYSQL_OPEN_NO_NEW_TABLE_IN_SE,
                    &prelocking_strategy)) {
      thd->stmt_arena->mem_root = saved_arena_mem_root;
      thd->pop_internal_handler();

      if (error_handler.is_view_invalid()) {
        if (view->mdl_request.ticket != nullptr) {
          // Update view status in tables.options.view_valid.
          if (dd::update_view_status(thd, view->get_db_name(),
                                     view->get_table_name(), false,
                                     commit_dd_changes))
            return true;
        }
      } else if (error_handler.is_view_error_handled() == false) {
        // ER_STACK_OVERRUN_NEED_MORE, ER_LOCK_DEADLOCK or
        // ER_LOCK_WAIT_TIMEOUT.
        DBUG_EXECUTE_IF("enable_stack_overrun_simulation",
                        { DBUG_SET("-d,simulate_stack_overrun"); });
        return true;
      }
      continue;
    }
    thd->stmt_arena->mem_root = saved_arena_mem_root;
    if (view->is_view() == false) {
      // In between listing views and locking(opening), if view is dropped and
      // created as table then skip it.
      thd->pop_internal_handler();
      continue;
    }

    /* Prepare select to resolve all fields */
    LEX *view_lex = view->view_query();
    LEX *org_lex = thd->lex;
    thd->lex = view_lex;
    view_lex->context_analysis_only |= CONTEXT_ANALYSIS_ONLY_VIEW;
    if (view_lex->unit->prepare(thd, nullptr, nullptr, 0, 0)) {
      thd->lex = org_lex;
      thd->pop_internal_handler();
      // Please refer comments in the view open error handling block above.
      if (error_handler.is_view_invalid()) {
        // Update view status in tables.options.view_valid.
        if (dd::update_view_status(thd, view->get_db_name(),
                                   view->get_table_name(), false,
                                   commit_dd_changes))
          return true;
      } else if (error_handler.is_view_error_handled() == false) {
        // ER_STACK_OVERRUN_NEED_MORE, ER_LOCK_DEADLOCK or
        // ER_LOCK_WAIT_TIMEOUT.
        return true;
      }
      continue;
    }
    thd->pop_internal_handler();

    /*
      If we are not going commit changes immediately we need to ensure
      that entries for uncommitted views are removed from TDC on error/
      rollback. Add view which we about to update to the helper class
      for TDC invalidation.
    */
    if (!commit_dd_changes) uncommitted_tables->add_table(view);

    // Prepare view query from the Item-tree built using original query.
    const CHARSET_INFO *view_client_cs;
    resolve_charset(view->view_client_cs_name.str, system_charset_info,
                    &view_client_cs);
    char view_query_buff[4096];
    String view_query(view_query_buff, sizeof(view_query_buff), view_client_cs);
    view_query.length(0);

    if (thd->lex->unit->is_mergeable() &&
        view->algorithm != VIEW_ALGORITHM_TEMPTABLE) {
      for (ORDER *order = thd->lex->query_block->order_list.first; order;
           order = order->next)
        order->used_alias = false;  /// @see Item::print_for_order()
    }
    Sql_mode_parse_guard parse_guard(thd);
    thd->lex->unit->print(
        thd, &view_query,
        static_cast<enum_query_type>(QT_TO_ARGUMENT_CHARSET |
                                     QT_HIDE_ROLLUP_FUNCTIONS));
    if (lex_string_strmake(thd->mem_root, &view->select_stmt, view_query.ptr(),
                           view_query.length()))
      return true;

    // Update view metadata in the data-dictionary tables.
    view->updatable_view = is_updatable_view(thd, view);
    dd::View *new_view = nullptr;
    if (thd->dd_client()->acquire_for_modification(view->db, view->table_name,
                                                   &new_view))
      return true;
    assert(new_view != nullptr);
    bool res = dd::update_view(thd, new_view, view);

    if (commit_dd_changes) {
      Implicit_substatement_state_guard substatement_guard(thd);
      if (res) {
        trans_rollback_stmt(thd);
        // Full rollback in case we have THD::transaction_rollback_request.
        trans_rollback(thd);
      } else
        res = trans_commit_stmt(thd) || trans_commit(thd);
    }
    if (res) {
      thd->lex = org_lex;
      return true;
    }
    tdc_remove_table(thd, TDC_RT_REMOVE_ALL, view->get_db_name(),
                     view->get_table_name(), false);

    thd->lex = org_lex;
  }
  DEBUG_SYNC(thd, "after_updating_view_metadata");

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: mark_all_views_invalid
template <typename T>
static bool mark_all_views_invalid(THD *thd, const char *db,
                                   const char *tbl_or_sf_name,
                                   const std::vector<Table_ref *> *views_list,
                                   bool skip_same_db, bool commit_dd_changes,
                                   MEM_ROOT *mem_root) {
  DBUG_TRACE;
  assert(!views_list->empty());

  // Acquire lock on all the views.
  MDL_request_list mdl_requests;
  for (auto view : *views_list) {
    MDL_request *schema_request = new (mem_root) MDL_request;
    ;
    MDL_REQUEST_INIT(schema_request, MDL_key::SCHEMA, view->db, "",
                     MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
    mdl_requests.push_front(schema_request);
    mdl_requests.push_front(&view->mdl_request);
  }
  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  // Check schema read only for all views.
  for (auto view : *views_list) {
    if (check_schema_readonly(thd, view->db)) return true;
  }

  /*
    In the time gap of listing referencing views and acquiring MDL lock on them
    if any view definition is updated or dropped then it should not be
    considered for state update.
    Hence preparing updated list of view tables after acquiring the lock.
  */
  std::vector<Table_ref *> updated_views_list;
  if (prepare_view_tables_list<T>(thd, db, tbl_or_sf_name, skip_same_db,
                                  mem_root, &updated_views_list))
    return true;
  if (updated_views_list.empty()) return false;

  // Update state of the views as invalid.
  for (auto view : *views_list) {
    // Update status of the view if it is listed in the updated_views_list.
    bool update_status = false;
    for (auto vw : updated_views_list) {
      if (!strcmp(view->get_db_name(), vw->get_db_name()) &&
          !strcmp(view->get_table_name(), vw->get_table_name())) {
        update_status = true;
        break;
      }
    }

    // Update Table.options.view_valid as false(invalid).
    if (update_status &&
        dd::update_view_status(thd, view->get_db_name(), view->get_table_name(),
                               false, commit_dd_changes))
      return true;
  }

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/handler.cc
Function: ha_commit_trans
int ha_commit_trans(THD *thd, bool all, bool ignore_global_read_lock) {
  int error = 0;
  THD_STAGE_INFO(thd, stage_waiting_for_handler_commit);
  bool run_slave_post_commit = false;
  bool need_clear_owned_gtid = false;
  /*
    Save transaction owned gtid into table before transaction prepare
    if binlog is disabled, or binlog is enabled and log_replica_updates
    is disabled with slave SQL thread or slave worker thread.
  */
  std::tie(error, need_clear_owned_gtid) = commit_owned_gtids(thd, all);

  /*
    'all' means that this is either an explicit commit issued by
    user, or an implicit commit issued by a DDL.
  */
  Transaction_ctx *trn_ctx = thd->get_transaction();
  Transaction_ctx::enum_trx_scope trx_scope =
      all ? Transaction_ctx::SESSION : Transaction_ctx::STMT;

  /*
    "real" is a nick name for a transaction for which a commit will
    make persistent changes. E.g. a 'stmt' transaction inside a 'all'
    transaction is not 'real': even though it's possible to commit it,
    the changes are not durable as they might be rolled back if the
    enclosing 'all' transaction is rolled back.
  */
  bool is_real_trans = all || !trn_ctx->is_active(Transaction_ctx::SESSION);
#ifndef NDEBUG
  bool transaction_to_skip = false;
  DBUG_EXECUTE_IF("replica_crash_after_commit", {
    transaction_to_skip = is_already_logged_transaction(thd);
  });
#endif  // NDEBUG
  auto ha_info = trn_ctx->ha_trx_info(trx_scope);
  XID_STATE *xid_state = trn_ctx->xid_state();

  DBUG_TRACE;

  DBUG_PRINT("info", ("all=%d thd->in_sub_stmt=%d ha_info=%p is_real_trans=%d",
                      all, thd->in_sub_stmt, ha_info.head(), is_real_trans));
  /*
    We must not commit the normal transaction if a statement
    transaction is pending. Otherwise statement transaction
    flags will not get propagated to its normal transaction's
    counterpart.
  */
  assert(!trn_ctx->is_active(Transaction_ctx::STMT) || !all);

  DBUG_EXECUTE_IF("pre_commit_error", {
    error = true;
    my_error(ER_UNKNOWN_ERROR, MYF(0));
  });

  /*
    When atomic DDL is executed on the slave, we would like to
    to update slave applier state as part of DDL's transaction.
    Call Relay_log_info::pre_commit() hook to do this before DDL
    gets committed in the following block.
    Failed atomic DDL statements should've been marked as executed/committed
    during statement rollback, though some like GRANT may continue until
    this point.
    When applying a DDL statement on a slave and the statement is filtered
    out by a table filter, we report an error "ER_REPLICA_IGNORED_TABLE" to
    warn slave applier thread. We need to save the DDL statement's gtid
    into mysql.gtid_executed system table if the binary log is disabled
    on the slave and gtids are enabled.
  */
  if (is_real_trans && is_atomic_ddl_commit_on_slave(thd) &&
      (!thd->is_error() ||
       (thd->is_operating_gtid_table_implicitly &&
        thd->get_stmt_da()->mysql_errno() == ER_REPLICA_IGNORED_TABLE))) {
    run_slave_post_commit = true;
    error = error || thd->rli_slave->pre_commit();

    DBUG_EXECUTE_IF("rli_pre_commit_error", {
      error = true;
      my_error(ER_UNKNOWN_ERROR, MYF(0));
    });
    DBUG_EXECUTE_IF("replica_crash_before_commit", {
      /* This pre-commit crash aims solely at atomic DDL */
      DBUG_SUICIDE();
    });
  }

  if (thd->in_sub_stmt) {
    assert(0);
    /*
      Since we don't support nested statement transactions in 5.0,
      we can't commit or rollback stmt transactions while we are inside
      stored functions or triggers. So we simply do nothing now.
      TODO: This should be fixed in later ( >= 5.1) releases.
    */
    if (!all) return 0;
    /*
      We assume that all statements which commit or rollback main transaction
      are prohibited inside of stored functions or triggers. So they should
      bail out with error even before ha_commit_trans() call. To be 100% safe
      let us throw error in non-debug builds.
    */
    my_error(ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG, MYF(0));
    return 2;
  }

  MDL_request mdl_request;
  bool release_mdl = false;
  if (ha_info && !error) {
    uint rw_ha_count = 0;
    bool rw_trans;

    DBUG_EXECUTE_IF("crash_commit_before", DBUG_SUICIDE(););

    /*
     skip 2PC if the transaction is empty and it is not marked as started (which
     can happen when the slave's binlog is disabled)
    */
    if (ha_info->is_started())
      rw_ha_count = ha_check_and_coalesce_trx_read_only(thd, ha_info, all);
    trn_ctx->set_rw_ha_count(trx_scope, rw_ha_count);
    /* rw_trans is true when we in a transaction changing data */
    rw_trans = is_real_trans && (rw_ha_count > 0);

    DBUG_EXECUTE_IF("dbug.enabled_commit", {
      const char act[] = "now signal Reached wait_for signal.commit_continue";
      assert(!debug_sync_set_action(thd, STRING_WITH_LEN(act)));
    };);
    DEBUG_SYNC(thd, "ha_commit_trans_before_acquire_commit_lock");
    if (rw_trans && !ignore_global_read_lock) {
      /*
        Acquire a metadata lock which will ensure that COMMIT is blocked
        by an active FLUSH TABLES WITH READ LOCK (and vice versa:
        COMMIT in progress blocks FTWRL).

        We allow the owner of FTWRL to COMMIT; we assume that it knows
        what it does.
      */
      MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "",
                       MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);

      DBUG_PRINT("debug", ("Acquire MDL commit lock"));
      if (thd->mdl_context.acquire_lock(&mdl_request,
                                        thd->variables.lock_wait_timeout)) {
        ha_rollback_trans(thd, all);
        return 1;
      }
      release_mdl = true;

      DEBUG_SYNC(thd, "ha_commit_trans_after_acquire_commit_lock");
    }

    if (rw_trans && stmt_has_updated_trans_table(ha_info) &&
        check_readonly(thd, true)) {
      ha_rollback_trans(thd, all);
      error = 1;
      goto end;
    }

    if (!trn_ctx->no_2pc(trx_scope) && (trn_ctx->rw_ha_count(trx_scope) > 1))
      error = tc_log->prepare(thd, all);
  }
  /*
    The state of XA transaction is changed to Prepared, intermediately.
    It's going to change to the regular NOTR at the end.
    The fact of the Prepared state is of interest to binary logger.
  */
  if (!error && all && xid_state->has_state(XID_STATE::XA_IDLE)) {
    assert(
        thd->lex->sql_command == SQLCOM_XA_COMMIT &&
        static_cast<Sql_cmd_xa_commit *>(thd->lex->m_sql_cmd)->get_xa_opt() ==
            XA_ONE_PHASE);

    xid_state->set_state(XID_STATE::XA_PREPARED);
  }
  if (error || (error = tc_log->commit(thd, all))) {
    ha_rollback_trans(thd, all);
    error = 1;
    goto end;
  }
/*
        Mark multi-statement (any autocommit mode) or single-statement
        (autocommit=1) transaction as rolled back
*/
#ifdef HAVE_PSI_TRANSACTION_INTERFACE
  if (is_real_trans && thd->m_transaction_psi != nullptr) {
    MYSQL_COMMIT_TRANSACTION(thd->m_transaction_psi);
    thd->m_transaction_psi = nullptr;
  }
#endif
  DBUG_EXECUTE_IF("crash_commit_after",
                  if (!thd->is_operating_gtid_table_implicitly)
                      DBUG_SUICIDE(););
end:
  if (release_mdl && mdl_request.ticket) {
    /*
      We do not always immediately release transactional locks
      after ha_commit_trans() (see uses of ha_enable_transaction()),
      thus we release the commit blocker lock as soon as it's
      not needed.
    */
    DBUG_PRINT("debug", ("Releasing MDL commit lock"));
    thd->mdl_context.release_lock(mdl_request.ticket);
  }
  /* Free resources and perform other cleanup even for 'empty' transactions. */
  if (is_real_trans) {
    trn_ctx->cleanup();
    thd->tx_priority = 0;
  }

  if (need_clear_owned_gtid) {
    thd->server_status &= ~SERVER_STATUS_IN_TRANS;
    /*
      Release the owned GTID when binlog is disabled, or binlog is
      enabled and log_replica_updates is disabled with slave SQL thread
      or slave worker thread.
    */
    if (error)
      gtid_state->update_on_rollback(thd);
    else
      gtid_state->update_on_commit(thd);
  } else {
    if (has_commit_order_manager(thd) && error) {
      gtid_state->update_on_rollback(thd);
    }
  }
  if (run_slave_post_commit) {
    DBUG_EXECUTE_IF("replica_crash_after_commit", DBUG_SUICIDE(););

    thd->rli_slave->post_commit(error != 0);
    /*
      SERVER_STATUS_IN_TRANS may've been gained by pre_commit alone
      when the main DDL transaction is filtered out of execution.
      In such case the status has to be reset now.

      TODO: move/refactor this handling onto trans_commit/commit_implicit()
            the caller level.
    */
    thd->server_status &= ~SERVER_STATUS_IN_TRANS;
  } else {
    DBUG_EXECUTE_IF("replica_crash_after_commit", {
      if (thd->slave_thread && thd->rli_slave &&
          thd->rli_slave->current_event &&
          thd->rli_slave->current_event->get_type_code() ==
              binary_log::XID_EVENT &&
          !thd->is_operating_substatement_implicitly &&
          !thd->is_operating_gtid_table_implicitly && !transaction_to_skip)
        DBUG_SUICIDE();
    });
  }

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/handler.cc
Function: Temp_table_handle::open 
TABLE *Temp_table_handle::open(THD *thd, const char *db_name,
                               const char *table_name) {
  char path[FN_REFLEN + 1];
  bool was_truncated;
  build_table_filename(path, sizeof(path) - 1 - reg_ext_length, db_name,
                       table_name, "", 0, &was_truncated);
  assert(!was_truncated);

  MDL_request table_request;
  MDL_REQUEST_INIT(&table_request, MDL_key::TABLE, db_name, table_name,
                   MDL_SHARED, MDL_TRANSACTION);

  if (thd->mdl_context.acquire_lock(&table_request,
                                    thd->variables.lock_wait_timeout)) {
    return nullptr;
  }

  {
    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
    const dd::Table *tab_obj = nullptr;
    if (thd->dd_client()->acquire(db_name, table_name, &tab_obj))
      return nullptr;
    assert(tab_obj);
    table = open_table_uncached(thd, path, db_name, table_name, false, false,
                                *tab_obj);
  }
  return table;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/histograms/histogram.cc
Function: histograms::lock_for_write 
static bool lock_for_write(THD *thd, const MDL_key &mdl_key) {
  DBUG_EXECUTE_IF("histogram_fail_during_lock_for_write", { return true; });

  MDL_request mdl_request;
  MDL_REQUEST_INIT_BY_KEY(&mdl_request, &mdl_key, MDL_EXCLUSIVE,
                          MDL_TRANSACTION);

  // If locking fails, an error has already been flagged.
  return thd->mdl_context.acquire_lock(&mdl_request,
                                       thd->variables.lock_wait_timeout);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/histograms/histogram.cc
Function: histograms::drop_histograms 
bool drop_histograms(THD *thd, Table_ref &table, const columns_set &columns,
                     bool needs_lock, results_map &results) {
  dd::cache::Dictionary_client *client = thd->dd_client();
  dd::cache::Dictionary_client::Auto_releaser auto_releaser(client);

  if (needs_lock) {
    /*
      At this point ANALYZE TABLE DROP HISTOGRAM is the only caller of this
      function that requires it to acquire lock on table and individual
      column statistics.

      Error out on temporary table for consistency with update histograms case.
    */
    if (table.table != nullptr && table.table->s->tmp_table != NO_TMP_TABLE) {
      results.emplace("", Message::TEMPORARY_TABLE);
      return true;
    }
    /*
      Acquire shared metadata lock on the table (or check that it is locked
      under LOCK TABLES) so this table and all column statistics for it are
      not dropped under our feet.
    */
    if (thd->locked_tables_mode) {
      if (!find_locked_table(thd->open_tables, table.db, table.table_name)) {
        my_error(ER_TABLE_NOT_LOCKED, MYF(0), table.table_name);
        return true;
      }
    } else {
      if (thd->mdl_context.acquire_lock(&table.mdl_request,
                                        thd->variables.lock_wait_timeout))
        return true;  // error is already reported.
    }
  } else {
    /*
      In this case we assume that caller has acquired exclusive metadata
      lock on table so there is no need to lock individual column statistics.
      It is also caller's responsibility to ensure that table is non-temporary.
    */
    assert(thd->mdl_context.owns_equal_or_stronger_lock(
        MDL_key::TABLE, table.db, table.table_name, MDL_EXCLUSIVE));
  }

  for (const std::string &column_name : columns) {
    if (needs_lock) {
      MDL_key mdl_key;
      dd::Column_statistics::create_mdl_key(
          {table.db, table.db_length},
          {table.table_name, table.table_name_length}, column_name.c_str(),
          &mdl_key);

      if (lock_for_write(thd, mdl_key))
        return true;  // error is already reported.
    }

    dd::String_type dd_name = dd::Column_statistics::create_name(
        {table.db, table.db_length},
        {table.table_name, table.table_name_length}, column_name.c_str());

    // Do we have an existing histogram for this column?
    const dd::Column_statistics *column_statistics = nullptr;
    if (client->acquire(dd_name, &column_statistics)) {
      // error is already reported.
      return true; /* purecov: deadcode */
    }

    if (column_statistics == nullptr) {
      results.emplace(column_name, Message::NO_HISTOGRAM_FOUND);
      continue;
    }

    if (client->drop(column_statistics)) {
      /* purecov: begin inspected */
      my_error(ER_UNABLE_TO_DROP_COLUMN_STATISTICS, MYF(0), column_name.c_str(),
               table.db, table.table_name);
      return true;
      /* purecov: end */
    }

    results.emplace(column_name, Message::HISTOGRAM_DELETED);
  }

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/histograms/histogram.cc
Function: histograms::rename_histograms 
bool rename_histograms(THD *thd, const char *old_schema_name,
                       const char *old_table_name, const char *new_schema_name,
                       const char *new_table_name, results_map &results) {
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, old_schema_name,
                   old_table_name, MDL_SHARED_READ_ONLY, MDL_TRANSACTION);

  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    // error has already been reported
    return true; /* purecov: deadcode */
  }

  /*
    We have to look up the new table since it already will be renamed at this
    point.
  */
  const dd::Table *table_def = nullptr;
  if (thd->dd_client()->acquire(new_schema_name, new_table_name, &table_def)) {
    // error has already been reported
    return false; /* purecov: deadcode */
  }

  if (table_def == nullptr) {
    assert(false); /* purecov: deadcode */
    return false;
  }

  for (const auto &col : table_def->columns()) {
    if (rename_histogram(thd, old_schema_name, old_table_name, new_schema_name,
                         new_table_name, col->name().c_str(), results))
      return true; /* purecov: deadcode */
  }

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/lock.cc
Function: mysql_lock_tables 
MYSQL_LOCK *mysql_lock_tables(THD *thd, TABLE **tables, size_t count,
                              uint flags) {
  int rc;
  MYSQL_LOCK *sql_lock;
  ulong timeout = (flags & MYSQL_LOCK_IGNORE_TIMEOUT)
                      ? LONG_TIMEOUT
                      : thd->variables.lock_wait_timeout;

  DBUG_TRACE;

  if (lock_tables_check(thd, tables, count, flags)) return nullptr;

  if (!(sql_lock = get_lock_data(thd, tables, count, GET_LOCK_STORE_LOCKS)))
    return nullptr;

  if (!(thd->state_flags & Open_tables_state::SYSTEM_TABLES))
    THD_STAGE_INFO(thd, stage_system_lock);

  ulonglong lock_start_usec = my_micro_time();

  DBUG_PRINT("info", ("thd->proc_info %s", thd->proc_info()));
  if (sql_lock->table_count &&
      lock_external(thd, sql_lock->table, sql_lock->table_count)) {
    /* Clear the lock type of all lock data to avoid reusage. */
    reset_lock_data_and_free(&sql_lock);
    goto end;
  }

  /* Copy the lock data array. thr_multi_lock() reorders its contents. */
  memcpy(sql_lock->locks + sql_lock->lock_count, sql_lock->locks,
         sql_lock->lock_count * sizeof(*sql_lock->locks));
  /* Lock on the copied half of the lock data array. */
  rc = thr_lock_errno_to_mysql[(int)thr_multi_lock(
      sql_lock->locks + sql_lock->lock_count, sql_lock->lock_count,
      &thd->lock_info, timeout)];

  DBUG_EXECUTE_IF("mysql_lock_tables_kill_query",
                  thd->killed = THD::KILL_QUERY;);

  if (rc) {
    if (sql_lock->table_count)
      (void)unlock_external(thd, sql_lock->table, sql_lock->table_count);
    reset_lock_data_and_free(&sql_lock);
    if (!thd->killed) my_error(rc, MYF(0));
  }

end:
  if (!(flags & MYSQL_OPEN_IGNORE_KILLED) && thd->killed) {
    thd->send_kill_message();
    if (sql_lock) {
      mysql_unlock_tables(thd, sql_lock);
      sql_lock = nullptr;
    }
  }

  if (thd->variables.session_track_transaction_info > TX_TRACK_NONE)
    track_table_access(thd, tables, count);

  ulonglong lock_end_usec = my_micro_time();
  thd->inc_lock_usec(lock_end_usec - lock_start_usec);

  return sql_lock;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/lock.cc
Function: lock_schema_name
bool lock_schema_name(THD *thd, const char *db) {
  MDL_request_list mdl_requests;
  MDL_request global_request;
  MDL_request mdl_request;
  MDL_request backup_lock_request;

  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  if (thd->global_read_lock.can_acquire_protection()) return true;
  MDL_REQUEST_INIT(&global_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  MDL_REQUEST_INIT(&mdl_request, MDL_key::SCHEMA, db, "", MDL_EXCLUSIVE,
                   MDL_TRANSACTION);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);

  mdl_requests.push_front(&mdl_request);
  mdl_requests.push_front(&global_request);
  mdl_requests.push_front(&backup_lock_request);

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(thd, true)) return true;

  /*
    We have an IX lock on the schema name, so we can check the read
    only option of the schema without worrying about a concurrent
    ALTER SCHEMA.
  */
  if (check_schema_readonly(thd, db)) return true;

  DEBUG_SYNC(thd, "after_wait_locked_schema_name");
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/lock.cc
Function: lock_object_name 
bool lock_object_name(THD *thd, MDL_key::enum_mdl_namespace mdl_type,
                      const char *db, const char *name) {
  MDL_request_list mdl_requests;
  MDL_request global_request;
  MDL_request schema_request;
  MDL_request mdl_request;
  MDL_request backup_lock_request;
  MDL_key mdl_key;

  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  assert(name);

  switch (mdl_type) {
    case MDL_key::FUNCTION:
      dd::Function::create_mdl_key(db, name, &mdl_key);
      break;
    case MDL_key::PROCEDURE:
      dd::Procedure::create_mdl_key(db, name, &mdl_key);
      break;
    case MDL_key::EVENT:
      dd::Event::create_mdl_key(db, name, &mdl_key);
      break;
    case MDL_key::RESOURCE_GROUPS:
      dd::Resource_group::create_mdl_key(name, &mdl_key);
      break;
    default:
      assert(false);
      return true;
  }

  DEBUG_SYNC(thd, "before_wait_locked_pname");

  if (thd->global_read_lock.can_acquire_protection()) return true;
  MDL_REQUEST_INIT(&global_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, db, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  MDL_REQUEST_INIT_BY_KEY(&mdl_request, &mdl_key, MDL_EXCLUSIVE,
                          MDL_TRANSACTION);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);

  mdl_requests.push_front(&mdl_request);
  mdl_requests.push_front(&schema_request);
  mdl_requests.push_front(&global_request);
  mdl_requests.push_front(&backup_lock_request);

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(thd, true)) return true;

  /*
    We have an IX lock on the schema name, so we can check the read
    only option of the schema without worrying about a concurrent
    ALTER SCHEMA.
  */
  if (check_schema_readonly(thd, db)) return true;

  DEBUG_SYNC(thd, "after_wait_locked_pname");
  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/lock.cc
Function: Global_read_lock::lock_global_read_lock
bool Global_read_lock::lock_global_read_lock(THD *thd) {
  DBUG_TRACE;

  if (!m_state) {
    MDL_request mdl_request;

    assert(!thd->mdl_context.owns_equal_or_stronger_lock(MDL_key::GLOBAL, "",
                                                         "", MDL_SHARED));
    MDL_REQUEST_INIT(&mdl_request, MDL_key::GLOBAL, "", "", MDL_SHARED,
                     MDL_EXPLICIT);

    /* Increment static variable first to signal innodb memcached server
       to release mdl locks held by it */
    Global_read_lock::m_atomic_active_requests++;
    if (thd->mdl_context.acquire_lock(&mdl_request,
                                      thd->variables.lock_wait_timeout)) {
      Global_read_lock::m_atomic_active_requests--;
      return true;
    }

    m_mdl_global_shared_lock = mdl_request.ticket;
    m_state = GRL_ACQUIRED;
  }
  /*
    We DON'T set global_read_lock_blocks_commit now, it will be set after
    tables are flushed (as the present function serves for FLUSH TABLES WITH
    READ LOCK only). Doing things in this order is necessary to avoid
    deadlocks (we must allow COMMIT until all tables are closed; we should not
    forbid it before, or we can have a 3-thread deadlock if 2 do SELECT FOR
    UPDATE and one does FLUSH TABLES WITH READ LOCK).
  */
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/lock.cc
Function: Global_read_lock::make_global_read_lock_block_commit
bool Global_read_lock::make_global_read_lock_block_commit(THD *thd) {
  MDL_request mdl_request;
  DBUG_TRACE;
  /*
    If we didn't succeed lock_global_read_lock(), or if we already succeeded
    make_global_read_lock_block_commit(), do nothing.
  */
  if (m_state != GRL_ACQUIRED) return false;

  MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "", MDL_SHARED,
                   MDL_EXPLICIT);

  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  m_mdl_blocks_commits_lock = mdl_request.ticket;
  m_state = GRL_ACQUIRED_AND_BLOCKS_COMMIT;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_create_resource_group::execute
bool resourcegroups::Sql_cmd_create_resource_group::execute(THD *thd) {
  DBUG_TRACE;

  if (check_readonly(thd, true)) return true;

  Security_context *sctx = thd->security_context();
  if (!sctx->has_global_grant(STRING_WITH_LEN("RESOURCE_GROUP_ADMIN")).first) {
    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "RESOURCE_GROUP_ADMIN");
    return true;
  }

  // Resource group name validation.
  if (is_invalid_string(m_name, system_charset_info)) return true;

  // VCPU IDs list validation.
  uint32_t num_vcpus =
      resourcegroups::Resource_group_mgr::instance()->num_vcpus();
  DBUG_PRINT("info", ("Number of VCPUS: %u", num_vcpus));

  auto vcpu_range_vector = std::unique_ptr<std::vector<Range>>(
      new (std::nothrow) std::vector<Range>);
  if (vcpu_range_vector == nullptr) {
    my_error(ER_OUTOFMEMORY, MYF(ME_FATALERROR), 0);
    return true;
  }

  if (validate_vcpu_range_vector(vcpu_range_vector.get(), m_cpu_list,
                                 num_vcpus))
    return true;

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  // Acquire exclusive lock on the resource group name.
  if (acquire_exclusive_mdl_for_resource_group(thd, m_name.str)) return true;

  auto res_grp_mgr = Resource_group_mgr::instance();
  // Check whether resource group exists in-memory.
  if (res_grp_mgr->get_resource_group(m_name.str) != nullptr) {
    my_error(ER_RESOURCE_GROUP_EXISTS, MYF(0), m_name.str);
    return true;
  }

  bool resource_group_exists;
  // Check the disk also for existence of resource group.
  if (dd::resource_group_exists(thd->dd_client(), dd::String_type(m_name.str),
                                &resource_group_exists))
    return true;

  if (resource_group_exists) {
    my_error(ER_RESOURCE_GROUP_EXISTS, MYF(0), m_name.str);
    return true;
  }

  auto resource_group_ptr = res_grp_mgr->create_and_add_in_resource_group_hash(
      m_name, m_type, m_enabled, std::move(vcpu_range_vector), m_priority);

  if (resource_group_ptr == nullptr) return true;

  Disable_autocommit_guard autocommit_guard(thd);
  if (dd::create_resource_group(thd, *resource_group_ptr)) {
    Resource_group_mgr::instance()->remove_resource_group(
        std::string(m_name.str));
    return true;
  }

  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_alter_resource_group::execute
bool resourcegroups::Sql_cmd_alter_resource_group::execute(THD *thd) {
  DBUG_TRACE;

  if (check_readonly(thd, true)) return true;

  Security_context *sctx = thd->security_context();
  if (!sctx->has_global_grant(STRING_WITH_LEN("RESOURCE_GROUP_ADMIN")).first) {
    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "RESOURCE_GROUP_ADMIN");
    return true;
  }

  // Resource group name validation.
  if (is_invalid_string(m_name, system_charset_info)) return true;

  // Disallow altering USR_default & SYS_default resource group.
  if (is_default_resource_group(m_name.str)) {
    my_error(ER_DISALLOWED_OPERATION, MYF(0), "Alter",
             "default resource groups.");
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  // Acquire exclusive lock on the resource group name.
  if (acquire_exclusive_mdl_for_resource_group(thd, m_name.str)) return true;

  auto resource_group = check_and_load_resource_group(thd, m_name);

  if (resource_group == nullptr) return true;

  // VCPU IDs list validation.
  uint32_t num_vcpus = Resource_group_mgr::instance()->num_vcpus();
  DBUG_PRINT("info", ("Number of VCPUS: %u", num_vcpus));

  auto vcpu_range_vector = std::unique_ptr<std::vector<Range>>(
      new (std::nothrow) std::vector<Range>);
  if (vcpu_range_vector == nullptr) {
    my_error(ER_OUTOFMEMORY, MYF(ME_FATALERROR), 0);
    return true;
  }

  if (validate_vcpu_range_vector(vcpu_range_vector.get(), m_cpu_list,
                                 num_vcpus))
    return true;

  if (validate_resource_group_priority(thd, &m_priority, m_name,
                                       resource_group->type()))
    return true;

  // FORCE option is not paired with DISABLE option.
  if (m_force && (!m_use_enable || m_enable)) {
    my_error(ER_INVALID_USE_OF_FORCE_OPTION, MYF(0));
    return true;
  }

  Thread_resource_control *thr_res_ctrl = resource_group->controller();
  bool thr_res_ctrl_change = false;
  if (m_priority != thr_res_ctrl->priority()) {
    thr_res_ctrl->set_priority(m_priority);
    thr_res_ctrl_change = true;
  }

  if (!vcpu_range_vector->empty()) {
    thr_res_ctrl->set_vcpu_vector(*vcpu_range_vector);
    thr_res_ctrl_change = true;
  }

  if (m_use_enable && m_enable != resource_group->enabled()) {
    resource_group->set_enabled(m_enable);
    thr_res_ctrl_change = m_enable;
  } else
    thr_res_ctrl_change = resource_group->enabled();

  // Update on-disk resource group.
  Disable_autocommit_guard autocommit_guard(thd);
  dd::String_type name(m_name.str);
  if (update_resource_group(thd, name, *resource_group)) return true;

  /*
    Reapply controls on threads if there was some change in
    the thread resource controls and the resource group is enabled.
  */
  if (thr_res_ctrl_change) {
    resource_group->apply_control_func(
        [resource_group](ulonglong pfs_thread_id) {
          auto res_grp_mgr_ptr = Resource_group_mgr::instance();
          PSI_thread_attrs pfs_thread_attr;
          memset(&pfs_thread_attr, 0, sizeof(pfs_thread_attr));
          if (!res_grp_mgr_ptr->get_thread_attributes(&pfs_thread_attr,
                                                      pfs_thread_id))
            resource_group->controller()->apply_control(
                pfs_thread_attr.m_thread_os_id);
        });
  }

  /*
    If some threads are bound with resource group, then
    (i) If FORCE option is specified, move the threads bound with this
        resource group to respective default resource groups.
    (ii) If FORCE option is not specified, the resource group is just
         disabled.
  */
  if (resource_group->is_bound_to_threads()) {
    if (m_force) {
      // Move all threads associated with this to default resource groups.
      resource_group->apply_control_func(
          Move_thread_to_default_group(resource_group));
      resource_group->clear();
    }
  }
  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_drop_resource_group::execute
bool resourcegroups::Sql_cmd_drop_resource_group::execute(THD *thd) {
  DBUG_TRACE;

  if (check_readonly(thd, true)) return true;

  Security_context *sctx = thd->security_context();
  if (!sctx->has_global_grant(STRING_WITH_LEN("RESOURCE_GROUP_ADMIN")).first) {
    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "RESOURCE_GROUP_ADMIN");
    return true;
  }

  // Resource group name validation.
  if (is_invalid_string(m_name, system_charset_info)) return true;

  // Disallow dropping USR_default & SYS_default resource group.
  if (is_default_resource_group(m_name.str)) {
    my_error(ER_DISALLOWED_OPERATION, MYF(0), "Drop operation ",
             "default resource groups.");
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  // Acquire exclusive lock on the resource group name.
  if (acquire_exclusive_mdl_for_resource_group(thd, m_name.str)) return true;

  auto resource_group = check_and_load_resource_group(thd, m_name);

  if (resource_group == nullptr) return true;

  if (resource_group->is_bound_to_threads()) {
    if (m_force)  // move all threads to the default resource group.
    {
      resource_group->apply_control_func(
          Move_thread_to_default_group(resource_group));
      resource_group->clear();
    } else {
      my_error(ER_RESOURCE_GROUP_BUSY, MYF(0), m_name.str);
      return true;
    }
  }

  // Remove from on-disk resource group.
  Disable_autocommit_guard autocommit_guard(thd);
  if (dd::drop_resource_group(thd, m_name.str)) return true;

  // Remove from in-memory hash the resource group.
  if (resource_group != nullptr)
    Resource_group_mgr::instance()->remove_resource_group(m_name.str);

  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: lock_db_routines
bool lock_db_routines(THD *thd, const dd::Schema &schema) {
  DBUG_TRACE;

  // Vectors for names of stored functions and procedures of the schema.
  std::vector<dd::String_type> func_names, proc_names;

  // Fetch names of stored functions and procedures of the schema.
  if (thd->dd_client()->fetch_schema_component_names<dd::Function>(
          &schema, &func_names) ||
      thd->dd_client()->fetch_schema_component_names<dd::Procedure>(
          &schema, &proc_names))
    return true;

  /*
    If lower_case_table_names == 2 then schema names should be lower cased for
    proper hash key comparisons.
  */
  const char *schema_name = schema.name().c_str();
  char schema_name_buf[NAME_LEN + 1];
  if (lower_case_table_names == 2) {
    my_stpcpy(schema_name_buf, schema_name);
    my_casedn_str(system_charset_info, schema_name_buf);
    schema_name = schema_name_buf;
  }
  const dd::String_type schema_name_str(schema_name);

  /*
    Ensure that we don't hold memory used by MDL_requests after locks have
    been acquired. This reduces memory usage in cases when we have DROP
    DATABASE that needs to drop lots of different objects.
  */
  MEM_ROOT mdl_reqs_root(key_memory_rm_db_mdl_reqs_root, MEM_ROOT_BLOCK_SIZE);

  MDL_request_list mdl_requests;

  auto add_requests_for_names = [&](dd::Routine::enum_routine_type type,
                                    const std::vector<dd::String_type> &names) {
    for (const dd::String_type &name : names) {
      MDL_key mdl_key;
      dd::Routine::create_mdl_key(type, schema_name_str, name, &mdl_key);
      MDL_request *mdl_request = new (&mdl_reqs_root) MDL_request;
      MDL_REQUEST_INIT_BY_KEY(mdl_request, &mdl_key, MDL_EXCLUSIVE,
                              MDL_TRANSACTION);
      mdl_requests.push_front(mdl_request);
    }
  };

  add_requests_for_names(dd::Routine::RT_FUNCTION, func_names);
  add_requests_for_names(dd::Routine::RT_PROCEDURE, proc_names);

  return thd->mdl_context.acquire_locks(&mdl_requests,
                                        thd->variables.lock_wait_timeout);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: lock_routine_name 
static bool lock_routine_name(THD *thd, enum_sp_type type, const sp_name *name,
                              enum_mdl_type mdl_lock_type) {
  DBUG_TRACE;

  assert(mdl_lock_type == MDL_SHARED_HIGH_PRIO || mdl_lock_type == MDL_SHARED);

  MDL_key mdl_key;
  if (type == enum_sp_type::FUNCTION)
    dd::Function::create_mdl_key(name->m_db.str, name->m_name.str, &mdl_key);
  else
    dd::Procedure::create_mdl_key(name->m_db.str, name->m_name.str, &mdl_key);

  // MDL Lock request on the routine.
  MDL_request routine_request;
  MDL_REQUEST_INIT_BY_KEY(&routine_request, &mdl_key, mdl_lock_type,
                          MDL_TRANSACTION);
  // Acquire MDL locks
  if (thd->mdl_context.acquire_lock(&routine_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_admin.cc
Function: Sql_cmd_analyze_table::handle_histogram_command 
bool Sql_cmd_analyze_table::handle_histogram_command(THD *thd,
                                                     Table_ref *table) {
  // This should not be empty here.
  assert(!get_histogram_fields().empty());

  histograms::results_map results;
  bool res = false;
  if (table->next_local != nullptr) {
    /*
      Only one table can be specified for
      ANALYZE TABLE ... UPDATE/DROP HISTOGRAM
    */
    results.emplace("", histograms::Message::MULTIPLE_TABLES_SPECIFIED);
    res = true;
  } else {
    if (read_only || thd->tx_read_only) {
      // Do not try to update histograms when in read_only mode.
      results.emplace("", histograms::Message::SERVER_READ_ONLY);
      res = false;
    } else {
      Disable_autocommit_guard autocommit_guard(thd);

      /* Prevent intermediate commits to invoke commit order */
      Implicit_substatement_state_guard substatement_guard(
          thd, enum_implicit_substatement_guard_mode ::
                   DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);

      /*
        This statement will be written to the binary log even if it fails. But a
        failing statement calls trans_rollback_stmt which calls
        gtid_state->update_on_rollback, which releases GTID ownership. And GTID
        ownership must be held when the statement is being written to the binary
        log. Therefore, we set this flag before executing the statement. The
        flag tells gtid_state->update_on_rollback to skip releasing ownership.
      */
      Variable_scope_guard<bool> skip_gtid_rollback_guard(
          thd->skip_gtid_rollback);
      if ((thd->variables.gtid_next.type == ASSIGNED_GTID ||
           thd->variables.gtid_next.type == ANONYMOUS_GTID) &&
          (!thd->skip_gtid_rollback))
        thd->skip_gtid_rollback = true;

      dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
      switch (get_histogram_command()) {
        case Histogram_command::UPDATE_HISTOGRAM:
          res = acquire_shared_backup_lock(thd,
                                           thd->variables.lock_wait_timeout) ||
                update_histogram(thd, table, results);
          break;
        case Histogram_command::DROP_HISTOGRAM:
          res = acquire_shared_backup_lock(thd,
                                           thd->variables.lock_wait_timeout) ||
                drop_histogram(thd, table, results);

          if (res) {
            /*
              Do a rollback. We can end up here if query was interrupted
              during drop_histogram.
            */
            trans_rollback_stmt(thd);
            trans_rollback(thd);
          } else {
            res = trans_commit_stmt(thd) || trans_commit(thd);
          }
          break;
        case Histogram_command::NONE:
          assert(false); /* purecov: deadcode */
          break;
      }

      if (!res) {
        /*
          If a histogram was added, updated or removed, we will request the old
          TABLE_SHARE to go away from the table definition cache. This is
          because histogram data is cached in the TABLE_SHARE, so we want new
          transactions to fetch the updated data into the TABLE_SHARE before
          using it again.
        */
        tdc_remove_table(thd, TDC_RT_REMOVE_UNUSED, table->db,
                         table->table_name, false);
      }
    }
  }

  thd->clear_error();
  res = send_histogram_results(thd, results, table);
  thd->get_stmt_da()->reset_condition_info(thd);
  my_eof(thd);
  return res;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_admin.cc
Function: mysql_admin_table 
static bool mysql_admin_table(
    THD *thd, Table_ref *tables, HA_CHECK_OPT *check_opt,
    const char *operator_name, thr_lock_type lock_type, bool open_for_modify,
    bool repair_table_use_frm, uint extra_open_options,
    int (*prepare_func)(THD *, Table_ref *, HA_CHECK_OPT *),
    int (handler::*operator_func)(THD *, HA_CHECK_OPT *), int check_view,
    Alter_info *alter_info, bool need_to_acquire_shared_backup_lock) {
  /*
    Prevent InnoDB from automatically committing InnoDB
    transaction each time data-dictionary tables are closed after
    being updated.
  */
  Disable_autocommit_guard autocommit_guard(thd);

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  Table_ref *table;
  Query_block *select = thd->lex->query_block;
  Item *item;
  Protocol *protocol = thd->get_protocol();
  LEX *lex = thd->lex;
  int result_code;
  bool gtid_rollback_must_be_skipped =
      ((thd->variables.gtid_next.type == ASSIGNED_GTID ||
        thd->variables.gtid_next.type == ANONYMOUS_GTID) &&
       (!thd->skip_gtid_rollback));
  bool ignore_grl_on_analyze = operator_func == &handler::ha_analyze;
  DBUG_TRACE;

  mem_root_deque<Item *> field_list(thd->mem_root);
  field_list.push_back(item =
                           new Item_empty_string("Table", NAME_CHAR_LEN * 2));
  item->set_nullable(true);
  field_list.push_back(item = new Item_empty_string("Op", 10));
  item->set_nullable(true);
  field_list.push_back(item = new Item_empty_string("Msg_type", 10));
  item->set_nullable(true);
  field_list.push_back(
      item = new Item_empty_string("Msg_text", SQL_ADMIN_MSG_TEXT_SIZE));
  item->set_nullable(true);
  if (thd->send_result_metadata(field_list,
                                Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))
    return true;

  /*
    Close all temporary tables which were pre-open to simplify
    privilege checking. Clear all references to closed tables.
  */
  close_thread_tables(thd);
  for (table = tables; table; table = table->next_local) table->table = nullptr;

  /*
    This statement will be written to the binary log even if it fails.
    But a failing statement calls trans_rollback_stmt which calls
    gtid_state->update_on_rollback, which releases GTID ownership.
    And GTID ownership must be held when the statement is being
    written to the binary log.  Therefore, we set this flag before
    executing the statement. The flag tells
    gtid_state->update_on_rollback to skip releasing ownership.
  */
  if (gtid_rollback_must_be_skipped) thd->skip_gtid_rollback = true;

  for (table = tables; table; table = table->next_local) {
    char table_name[NAME_LEN * 2 + 2];
    const char *db = table->db;
    bool fatal_error = false;
    bool open_error;

    DBUG_PRINT("admin", ("table: '%s'.'%s'", table->db, table->table_name));
    DBUG_PRINT("admin", ("extra_open_options: %u", extra_open_options));
    strxmov(table_name, db, ".", table->table_name, NullS);
    thd->open_options |= extra_open_options;
    table->set_lock({lock_type, THR_DEFAULT});
    /*
      To make code safe for re-execution we need to reset type of MDL
      request as code below may change it.
      To allow concurrent execution of read-only operations we acquire
      weak metadata lock for them.
    */
    table->mdl_request.set_type((lock_type >= TL_WRITE_ALLOW_WRITE)
                                    ? MDL_SHARED_NO_READ_WRITE
                                    : MDL_SHARED_READ);
    /* open only one table from local list of command */
    {
      Table_ref *save_next_global, *save_next_local;
      save_next_global = table->next_global;
      table->next_global = nullptr;
      save_next_local = table->next_local;
      table->next_local = nullptr;
      select->m_table_list.first = table;
      /*
        Time zone tables and SP tables can be add to lex->query_tables list,
        so it have to be prepared.
        TODO: Investigate if we can put extra tables into argument instead of
        using lex->query_tables
      */
      lex->query_tables = table;
      lex->query_tables_last = &table->next_global;
      lex->query_tables_own_last = nullptr;
      /*
        CHECK TABLE command is allowed for views as well. Check on alter flags
        to differentiate from ALTER TABLE...CHECK PARTITION on which view is not
        allowed.
      */
      if (alter_info->flags & Alter_info::ALTER_ADMIN_PARTITION ||
          check_view != 1)
        table->required_type = dd::enum_table_type::BASE_TABLE;

      if (!thd->locked_tables_mode && repair_table_use_frm) {
        /*
          If we're not under LOCK TABLES and we're executing REPAIR TABLE
          USE_FRM, we need to ignore errors from open_and_lock_tables().
          REPAIR TABLE USE_FRM is a heavy weapon used when a table is
          critically damaged, so open_and_lock_tables() will most likely
          report errors. Those errors are not interesting for the user
          because it's already known that the table is badly damaged.
        */

        Diagnostics_area tmp_da(false);
        thd->push_diagnostics_area(&tmp_da);

        open_error = open_temporary_tables(thd, table);

        if (!open_error) {
          open_error = open_and_lock_tables(thd, table, 0);

          if (!open_error && need_to_acquire_shared_backup_lock &&
              /*
                Acquire backup lock explicitly since lock types used by
                admin statements won't cause its automatic acquisition
                in open_and_lock_tables().
              */
              acquire_shared_backup_lock(thd,
                                         thd->variables.lock_wait_timeout)) {
            result_code = HA_ADMIN_FAILED;
            goto send_result;
          }
        }

        thd->pop_diagnostics_area();
        if (tmp_da.is_error()) {
          // Copy the exception condition information.
          thd->get_stmt_da()->set_error_status(tmp_da.mysql_errno(),
                                               tmp_da.message_text(),
                                               tmp_da.returned_sqlstate());
        }
      } else {
        /*
          It's assumed that even if it is REPAIR TABLE USE_FRM, the table
          can be opened if we're under LOCK TABLES (otherwise LOCK TABLES
          would fail). Thus, the only errors we could have from
          open_and_lock_tables() are logical ones, like incorrect locking
          mode. It does make sense for the user to see such errors.
        */

        open_error = open_temporary_tables(thd, table);

        if (!open_error) {
          open_error = open_and_lock_tables(thd, table, 0);

          if (!open_error && need_to_acquire_shared_backup_lock &&
              /*
                Acquire backup lock explicitly since lock types used by
                admin statements won't cause its automatic acquisition
                in open_and_lock_tables().
              */
              acquire_shared_backup_lock(thd,
                                         thd->variables.lock_wait_timeout)) {
            result_code = HA_ADMIN_FAILED;
            goto send_result;
          }
        }
      }

      /*
        Views are always treated as materialized views, including creation
        of temporary table descriptor.
      */
      if (!open_error && table->is_view()) {
        open_error = table->resolve_derived(thd, false);
        if (!open_error) open_error = table->setup_materialized_derived(thd);
      }
      table->next_global = save_next_global;
      table->next_local = save_next_local;
      thd->open_options &= ~extra_open_options;

      /*
        If open_and_lock_tables() failed, close_thread_tables() will close
        the table and table->table can therefore be invalid.
      */
      if (open_error) table->table = nullptr;

      /*
        Under locked tables, we know that the table can be opened,
        so any errors opening the table are logical errors.
        In these cases it does not make sense to try to repair.
      */
      if (open_error && thd->locked_tables_mode) {
        result_code = HA_ADMIN_FAILED;
        goto send_result;
      }
      if (table->table) {
        /*
          Set up which partitions that should be processed
          if ALTER TABLE t ANALYZE/CHECK/OPTIMIZE/REPAIR PARTITION ..
          CACHE INDEX/LOAD INDEX for specified partitions
        */
        if (alter_info->flags & Alter_info::ALTER_ADMIN_PARTITION) {
          if (!table->table->part_info) {
            my_error(ER_PARTITION_MGMT_ON_NONPARTITIONED, MYF(0));
            result_code = HA_ADMIN_FAILED;
            goto send_result;
          }

          if (set_part_state(alter_info, table->table->part_info, PART_ADMIN,
                             true)) {
            my_error(ER_DROP_PARTITION_NON_EXISTENT, MYF(0), table_name);
            result_code = HA_ADMIN_FAILED;
            goto send_result;
          }
        }
      }
    }
    DBUG_PRINT("admin", ("table: %p", table->table));

    if (prepare_func) {
      DBUG_PRINT("admin", ("calling prepare_func"));
      switch ((*prepare_func)(thd, table, check_opt)) {
        case 1:  // error, message written to net
          trans_rollback_stmt(thd);
          trans_rollback(thd);
          /* Make sure this table instance is not reused after the operation. */
          if (table->table) table->table->invalidate_dict();
          close_thread_tables(thd);
          thd->mdl_context.release_transactional_locks();
          DBUG_PRINT("admin", ("simple error, admin next table"));
          continue;
        case -1:  // error, message could be written to net
          /* purecov: begin inspected */
          DBUG_PRINT("admin", ("severe error, stop"));
          goto err;
          /* purecov: end */
        default:  // should be 0 otherwise
          DBUG_PRINT("admin", ("prepare_func succeeded"));
          ;
      }
    }

    /*
      CHECK TABLE command is only command where VIEW allowed here and this
      command use only temporary teble method for VIEWs resolving => there
      can't be VIEW tree substitition of join view => if opening table
      succeed then table->table will have real TABLE pointer as value (in
      case of join view substitution table->table can be 0, but here it is
      impossible)
    */
    if (!table->table) {
      DBUG_PRINT("admin", ("open table failed"));
      if (thd->get_stmt_da()->cond_count() == 0)
        push_warning(thd, Sql_condition::SL_WARNING, ER_CHECK_NO_SUCH_TABLE,
                     ER_THD(thd, ER_CHECK_NO_SUCH_TABLE));
      if (thd->get_stmt_da()->is_error() &&
          table_not_corrupt_error(thd->get_stmt_da()->mysql_errno()))
        result_code = HA_ADMIN_FAILED;
      else
        /* Default failure code is corrupt table */
        result_code = HA_ADMIN_CORRUPT;
      goto send_result;
    }

    if (table->is_view()) {
      result_code = HA_ADMIN_OK;
      goto send_result;
    }

    if (table->schema_table) {
      result_code = HA_ADMIN_NOT_IMPLEMENTED;
      goto send_result;
    }

    if ((table->table->db_stat & HA_READ_ONLY) && open_for_modify) {
      /* purecov: begin inspected */
      char buff[FN_REFLEN + MYSQL_ERRMSG_SIZE];
      size_t length;
      enum_sql_command save_sql_command = lex->sql_command;
      DBUG_PRINT("admin", ("sending error message"));
      protocol->start_row();
      protocol->store(table_name, system_charset_info);
      protocol->store(operator_name, system_charset_info);
      protocol->store_string(STRING_WITH_LEN("error"), system_charset_info);
      length = snprintf(buff, sizeof(buff), ER_THD(thd, ER_OPEN_AS_READONLY),
                        table_name);
      protocol->store_string(buff, length, system_charset_info);
      {
        /* Prevent intermediate commits to invoke commit order */
        Implicit_substatement_state_guard substatement_guard(
            thd, enum_implicit_substatement_guard_mode ::
                     DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);
        trans_commit_stmt(thd, ignore_grl_on_analyze);
        trans_commit(thd, ignore_grl_on_analyze);
      }
      /* Make sure this table instance is not reused after the operation. */
      if (table->table) table->table->invalidate_dict();
      close_thread_tables(thd);
      thd->mdl_context.release_transactional_locks();
      lex->reset_query_tables_list(false);
      /*
        Restore Query_tables_list::sql_command value to make statement
        safe for re-execution.
      */
      lex->sql_command = save_sql_command;
      if (protocol->end_row()) goto err;
      thd->get_stmt_da()->reset_diagnostics_area();
      continue;
      /* purecov: end */
    }

    /*
      Close all instances of the table to allow MyISAM "repair"
      to rename files.
      @todo: This code does not close all instances of the table.
      It only closes instances in other connections, but if this
      connection has LOCK TABLE t1 a READ, t1 b WRITE,
      both t1 instances will be kept open.
      There is no need to execute this branch for InnoDB, which does
      repair by recreate. There is no need to do it for OPTIMIZE,
      which doesn't move files around.
      Hence, this code should be moved to prepare_for_repair(),
      and executed only for MyISAM engine.
    */
    if (lock_type == TL_WRITE && !table->table->s->tmp_table) {
      if (wait_while_table_is_used(thd, table->table,
                                   HA_EXTRA_PREPARE_FOR_RENAME))
        goto err;
      DEBUG_SYNC(thd, "after_admin_flush");
      /*
        XXX: hack: switch off open_for_modify to skip the
        flush that is made later in the execution flow.
      */
      open_for_modify = false;
    }

    if (table->table->s->crashed && operator_func == &handler::ha_check) {
      /* purecov: begin inspected */
      DBUG_PRINT("admin", ("sending crashed warning"));
      protocol->start_row();
      protocol->store(table_name, system_charset_info);
      protocol->store(operator_name, system_charset_info);
      protocol->store_string(STRING_WITH_LEN("warning"), system_charset_info);
      protocol->store_string(STRING_WITH_LEN("Table is marked as crashed"),
                             system_charset_info);
      if (protocol->end_row()) goto err;
      /* purecov: end */
    }

    if (operator_func == &handler::ha_repair &&
        !(check_opt->sql_flags & TT_USEFRM)) {
      // Check for old temporal format if avoid_temporal_upgrade is disabled.
      mysql_mutex_lock(&LOCK_global_system_variables);
      const bool check_temporal_upgrade = !avoid_temporal_upgrade;
      mysql_mutex_unlock(&LOCK_global_system_variables);

      if ((check_table_for_old_types(table->table, check_temporal_upgrade) ==
           HA_ADMIN_NEEDS_ALTER) ||
          (table->table->file->ha_check_for_upgrade(check_opt) ==
           HA_ADMIN_NEEDS_ALTER)) {
        DBUG_PRINT("admin", ("recreating table"));
        /*
          Temporary table are always created by current server so they never
          require upgrade. So we don't need to pre-open them before calling
          mysql_recreate_table().
        */
        assert(!table->table->s->tmp_table);

        trans_rollback_stmt(thd);
        trans_rollback(thd);
        /* Make sure this table instance is not reused after the operation. */
        if (table->table) table->table->invalidate_dict();
        close_thread_tables(thd);
        thd->mdl_context.release_transactional_locks();

        /*
          table_list->table has been closed and freed. Do not reference
          uninitialized data. open_tables() could fail.
        */
        table->table = nullptr;
        /* Same applies to MDL ticket. */
        table->mdl_request.ticket = nullptr;

        {
          // binlogging is done by caller if wanted
          Disable_binlog_guard binlog_guard(thd);
          result_code = mysql_recreate_table(thd, table, false);
        }
        /*
          mysql_recreate_table() can push OK or ERROR.
          Clear 'OK' status. If there is an error, keep it:
          we will store the error message in a result set row
          and then clear.
        */
        if (thd->get_stmt_da()->is_ok())
          thd->get_stmt_da()->reset_diagnostics_area();
        table->table = nullptr;
        result_code = result_code ? HA_ADMIN_FAILED : HA_ADMIN_OK;
        goto send_result;
      }
    }

    if (check_opt && (check_opt->sql_flags & TT_FOR_UPGRADE) != 0) {
      if (table->table->s->tmp_table) {
        result_code = HA_ADMIN_OK;
      } else {
        dd::String_type snam = dd::make_string_type(table->table->s->db);
        dd::String_type tnam =
            dd::make_string_type(table->table->s->table_name);

        Check_result cr = check_for_upgrade(thd, snam, tnam, [&]() {
          DBUG_PRINT("admin", ("calling operator_func '%s'", operator_name));
          return (table->table->file->*operator_func)(thd, check_opt);
        });

        result_code = cr.second;
        if (cr.first) {
          goto err;
        }
      }
    }
    // Some other admin COMMAND
    else {
      DBUG_PRINT("admin", ("calling operator_func '%s'", operator_name));
      result_code = (table->table->file->*operator_func)(thd, check_opt);
    }
    DBUG_PRINT("admin", ("operator_func returned: %d", result_code));

    /*
      ANALYZE statement calculates values for dynamic fields of
      I_S.TABLES and I_S.STATISTICS table in table_stats and index_stats
      table. This table is joined with new dd table to provide results
      when I_S table is queried.
      To get latest statistics of table or index, user should use analyze
      table statement before querying I_S.TABLES or I_S.STATISTICS
    */

    if (!read_only && ignore_grl_on_analyze) {
      // Acquire the lock
      if (dd::info_schema::update_table_stats(thd, table) ||
          dd::info_schema::update_index_stats(thd, table)) {
        // Play safe, rollback possible changes to the data-dictionary.
        trans_rollback_stmt(thd);
        trans_rollback_implicit(thd);
        result_code = HA_ADMIN_STATS_UPD_ERR;
        goto send_result;
      }
    }

    /*
      push_warning() if the table version is lesser than current
      server version and there are triggers for this table.
    */
    if (operator_func == &handler::ha_check &&
        (check_opt->sql_flags & TT_FOR_UPGRADE) && table->table->triggers) {
      table->table->triggers->print_upgrade_warnings(thd);
    }

  send_result:

    lex->cleanup_after_one_table_open();
    thd->clear_error();  // these errors shouldn't get client
    if (send_analyze_table_errors(thd, operator_name, table_name)) goto err;
    protocol->start_row();
    protocol->store(table_name, system_charset_info);
    protocol->store(operator_name, system_charset_info);

  send_result_message:

    DBUG_PRINT("info", ("result_code: %d", result_code));
    switch (result_code) {
      case HA_ADMIN_NOT_IMPLEMENTED: {
        char buf[MYSQL_ERRMSG_SIZE];
        size_t length =
            snprintf(buf, sizeof(buf), ER_THD(thd, ER_CHECK_NOT_IMPLEMENTED),
                     operator_name);
        protocol->store_string(STRING_WITH_LEN("note"), system_charset_info);
        protocol->store_string(buf, length, system_charset_info);
      } break;

      case HA_ADMIN_NOT_BASE_TABLE: {
        char buf[MYSQL_ERRMSG_SIZE];

        String tbl_name;
        tbl_name.append(String(db, system_charset_info));
        tbl_name.append('.');
        tbl_name.append(String(table_name, system_charset_info));

        size_t length =
            snprintf(buf, sizeof(buf), ER_THD(thd, ER_BAD_TABLE_ERROR),
                     tbl_name.c_ptr());
        protocol->store_string(STRING_WITH_LEN("note"), system_charset_info);
        protocol->store_string(buf, length, system_charset_info);
      } break;

      case HA_ADMIN_OK:
        protocol->store_string(STRING_WITH_LEN("status"), system_charset_info);
        protocol->store_string(STRING_WITH_LEN("OK"), system_charset_info);
        break;

      case HA_ADMIN_FAILED:
        protocol->store_string(STRING_WITH_LEN("status"), system_charset_info);
        protocol->store_string(STRING_WITH_LEN("Operation failed"),
                               system_charset_info);
        break;

      case HA_ADMIN_REJECT:
        protocol->store_string(STRING_WITH_LEN("status"), system_charset_info);
        protocol->store_string(
            STRING_WITH_LEN("Operation need committed state"),
            system_charset_info);
        open_for_modify = false;
        break;

      case HA_ADMIN_ALREADY_DONE:
        protocol->store_string(STRING_WITH_LEN("status"), system_charset_info);
        protocol->store_string(STRING_WITH_LEN("Table is already up to date"),
                               system_charset_info);
        break;

      case HA_ADMIN_CORRUPT:
        protocol->store_string(STRING_WITH_LEN("error"), system_charset_info);
        protocol->store_string(STRING_WITH_LEN("Corrupt"), system_charset_info);
        fatal_error = true;
        break;

      case HA_ADMIN_INVALID:
        protocol->store_string(STRING_WITH_LEN("error"), system_charset_info);
        protocol->store_string(STRING_WITH_LEN("Invalid argument"),
                               system_charset_info);
        break;

      case HA_ADMIN_TRY_ALTER: {
        uint save_flags;

        /* Store the original value of alter_info->flags */
        save_flags = alter_info->flags;
        {
          /* Prevent intermediate commits to invoke commit order */
          Implicit_substatement_state_guard substatement_guard(
              thd, enum_implicit_substatement_guard_mode ::
                       DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);
          /*
            This is currently used only by InnoDB. ha_innobase::optimize()
            answers "try with alter", so here we close the table, do an ALTER
            TABLE, reopen the table and do ha_innobase::analyze() on it. We have
            to end the row, so analyze could return more rows.
          */
          trans_commit_stmt(thd, ignore_grl_on_analyze);
          trans_commit(thd, ignore_grl_on_analyze);
        }
        close_thread_tables(thd);
        thd->mdl_context.release_transactional_locks();

        /*
           table_list->table has been closed and freed. Do not reference
           uninitialized data. open_tables() could fail.
         */
        table->table = nullptr;
        /* Same applies to MDL ticket. */
        table->mdl_request.ticket = nullptr;

        DEBUG_SYNC(thd, "ha_admin_try_alter");
        protocol->store_string(STRING_WITH_LEN("note"), system_charset_info);
        if (alter_info->flags & Alter_info::ALTER_ADMIN_PARTITION) {
          protocol->store_string(
              STRING_WITH_LEN("Table does not support optimize on "
                              "partitions. All partitions "
                              "will be rebuilt and analyzed."),
              system_charset_info);
        } else {
          protocol->store_string(
              STRING_WITH_LEN("Table does not support optimize, "
                              "doing recreate + analyze instead"),
              system_charset_info);
        }
        if (protocol->end_row()) goto err;
        DBUG_PRINT("info", ("HA_ADMIN_TRY_ALTER, trying analyze..."));
        Table_ref *save_next_local = table->next_local,
                  *save_next_global = table->next_global;
        table->next_local = table->next_global = nullptr;
        {
          // binlogging is done by caller if wanted
          Disable_binlog_guard binlog_guard(thd);
          /* Don't forget to pre-open temporary tables. */
          result_code = (open_temporary_tables(thd, table) ||
                         mysql_recreate_table(thd, table, false));
        }
        /*
          mysql_recreate_table() can push OK or ERROR.
          Clear 'OK' status. If there is an error, keep it:
          we will store the error message in a result set row
          and then clear.
        */
        if (thd->get_stmt_da()->is_ok())
          thd->get_stmt_da()->reset_diagnostics_area();
        {
          /* Prevent intermediate commits to invoke commit order */
          Implicit_substatement_state_guard substatement_guard(
              thd, enum_implicit_substatement_guard_mode ::
                       DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);
          trans_commit_stmt(thd, ignore_grl_on_analyze);
          trans_commit(thd, ignore_grl_on_analyze);
        }
        close_thread_tables(thd);
        thd->mdl_context.release_transactional_locks();
        /* Clear references to TABLE and MDL_ticket after releasing them. */
        table->table = nullptr;
        table->mdl_request.ticket = nullptr;
        if (!result_code)  // recreation went ok
        {
          DEBUG_SYNC(thd, "ha_admin_open_ltable");
          if (acquire_shared_backup_lock(thd,
                                         thd->variables.lock_wait_timeout)) {
            result_code = HA_ADMIN_FAILED;
          } else {
            table->mdl_request.set_type(MDL_SHARED_READ);
            if (!open_temporary_tables(thd, table) &&
                (table->table = open_n_lock_single_table(
                     thd, table, TL_READ_NO_INSERT, 0))) {
              /*
                Reset the ALTER_ADMIN_PARTITION bit in alter_info->flags
                to force analyze on all partitions.
               */
              alter_info->flags &= ~(Alter_info::ALTER_ADMIN_PARTITION);
              result_code = table->table->file->ha_analyze(thd, check_opt);
              if (result_code == HA_ADMIN_ALREADY_DONE)
                result_code = HA_ADMIN_OK;
              else if (result_code)  // analyze failed
                table->table->file->print_error(result_code, MYF(0));
              alter_info->flags = save_flags;
            } else
              result_code = -1;  // open failed
          }
        }
        /* Start a new row for the final status row */
        protocol->start_row();
        protocol->store(table_name, system_charset_info);
        protocol->store(operator_name, system_charset_info);
        if (result_code)  // either mysql_recreate_table or analyze failed
        {
          assert(thd->is_error() || thd->killed);
          if (thd->is_error()) {
            Diagnostics_area *da = thd->get_stmt_da();
            if (!thd->get_protocol()->connection_alive()) {
              LogEvent()
                  .type(LOG_TYPE_ERROR)
                  .subsys(LOG_SUBSYSTEM_TAG)
                  .prio(ERROR_LEVEL)
                  .source_file(MY_BASENAME)
                  .lookup(ER_ERROR_INFO_FROM_DA, da->mysql_errno(),
                          da->message_text())
                  .sqlstate(da->returned_sqlstate());
            } else {
              /* Hijack the row already in-progress. */
              protocol->store_string(STRING_WITH_LEN("error"),
                                     system_charset_info);
              protocol->store(da->message_text(), system_charset_info);
              if (protocol->end_row()) goto err;
              /* Start off another row for HA_ADMIN_FAILED */
              protocol->start_row();
              protocol->store(table_name, system_charset_info);
              protocol->store(operator_name, system_charset_info);
            }
            thd->clear_error();
          }
          /* Make sure this table instance is not reused after the operation. */
          if (table->table) table->table->invalidate_dict();
        }
        result_code = result_code ? HA_ADMIN_FAILED : HA_ADMIN_OK;
        table->next_local = save_next_local;
        table->next_global = save_next_global;
        goto send_result_message;
      }
      case HA_ADMIN_WRONG_CHECKSUM: {
        protocol->store_string(STRING_WITH_LEN("note"), system_charset_info);
        protocol->store_string(ER_THD(thd, ER_VIEW_CHECKSUM),
                               strlen(ER_THD(thd, ER_VIEW_CHECKSUM)),
                               system_charset_info);
        break;
      }

      case HA_ADMIN_NEEDS_UPGRADE:
      case HA_ADMIN_NEEDS_ALTER: {
        char buf[MYSQL_ERRMSG_SIZE];
        size_t length;

        protocol->store_string(STRING_WITH_LEN("error"), system_charset_info);
        if (table->table->file->ha_table_flags() & HA_CAN_REPAIR)
          length =
              snprintf(buf, sizeof(buf), ER_THD(thd, ER_TABLE_NEEDS_UPGRADE),
                       table->table_name);
        else
          length =
              snprintf(buf, sizeof(buf), ER_THD(thd, ER_TABLE_NEEDS_REBUILD),
                       table->table_name);
        protocol->store_string(buf, length, system_charset_info);
        fatal_error = true;
        break;
      }

      case HA_ADMIN_STATS_UPD_ERR:
        protocol->store_string(STRING_WITH_LEN("status"), system_charset_info);
        protocol->store_string(
            STRING_WITH_LEN("Unable to write table statistics to DD tables"),
            system_charset_info);
        break;

      case HA_ADMIN_NEEDS_DUMP_UPGRADE: {
        /*
          In-place upgrade does not allow pre 5.0 decimal to 8.0. Recreation of
          tables will not create pre 5.0 decimal types. Hence, control should
          never reach here.
        */
        assert(false);

        char buf[MYSQL_ERRMSG_SIZE];
        size_t length;

        protocol->store_string(STRING_WITH_LEN("error"), system_charset_info);
        length = snprintf(buf, sizeof(buf),
                          "Table upgrade required for "
                          "`%-.64s`.`%-.64s`. Please dump/reload table to "
                          "fix it!",
                          table->db, table->table_name);
        protocol->store_string(buf, length, system_charset_info);
        fatal_error = true;
        break;
      }

      default:  // Probably HA_ADMIN_INTERNAL_ERROR
      {
        char buf[MYSQL_ERRMSG_SIZE];
        size_t length = snprintf(buf, sizeof(buf),
                                 "Unknown - internal error %d during operation",
                                 result_code);
        protocol->store_string(STRING_WITH_LEN("error"), system_charset_info);
        protocol->store_string(buf, length, system_charset_info);
        fatal_error = true;
        break;
      }
    }
    if (table->table) {
      if (table->table->s->tmp_table) {
        /*
          If the table was not opened successfully, do not try to get
          status information. (Bug#47633)
        */
        if (open_for_modify && !open_error)
          table->table->file->info(HA_STATUS_CONST);
      } else if (open_for_modify || fatal_error) {
        if (operator_func == &handler::ha_analyze)
          /*
            Force update of key distribution statistics in rec_per_key array and
            info in TABLE::file::stats by marking existing TABLE instances as
            needing reopening. Any subsequent statement that uses this table
            will have to call handler::open() which will cause this information
            to be updated. OTOH, such subsequent statements won't have to wait
            for already running statements to go away since we do not invalidate
            TABLE_SHARE.
          */
          tdc_remove_table(thd, TDC_RT_MARK_FOR_REOPEN, table->db,
                           table->table_name, false);
        else
          tdc_remove_table(thd, TDC_RT_REMOVE_UNUSED, table->db,
                           table->table_name, false);
      } else {
        /*
          Reset which partitions that should be processed
          if ALTER TABLE t ANALYZE/CHECK/.. PARTITION ..
          CACHE INDEX/LOAD INDEX for specified partitions
        */
        if (table->table->part_info &&
            alter_info->flags & Alter_info::ALTER_ADMIN_PARTITION) {
          set_all_part_state(table->table->part_info, PART_NORMAL);
        }
      }
    }
    /* Error path, a admin command failed. */
    if (thd->transaction_rollback_request) {
      /*
        Unlikely, but transaction rollback was requested by one of storage
        engines (e.g. due to deadlock). Perform it.
      */
      DBUG_PRINT("admin", ("rollback"));

      if (trans_rollback_stmt(thd) || trans_rollback_implicit(thd)) goto err;
    } else {
      enum_implicit_substatement_guard_mode mode =
          enum_implicit_substatement_guard_mode ::
              DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE;

      if (strcmp(operator_name, "optimize") == 0 ||
          strcmp(operator_name, "analyze") == 0 ||
          strcmp(operator_name, "repair") == 0) {
        mode = enum_implicit_substatement_guard_mode ::
            ENABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE;
      }

      /*
        It allows saving GTID and invoking commit order i.e. set
        thd->is_operating_substatement_implicitly = false, when
        replica-preserve-commit-order is enabled and any of OPTIMIZE TABLE,
        ANALYZE TABLE and REPAIR TABLE command is getting executed,
        otherwise saving GTID and invoking commit order is disabled.
      */
      Implicit_substatement_state_guard guard(thd, mode);

      if (trans_commit_stmt(thd, ignore_grl_on_analyze) ||
          trans_commit_implicit(thd, ignore_grl_on_analyze))
        goto err;
      DBUG_PRINT("admin", ("commit"));
    }
    close_thread_tables(thd);
    thd->mdl_context.release_transactional_locks();

    if (protocol->end_row()) goto err;
  }

  my_eof(thd);

  if (gtid_rollback_must_be_skipped) thd->skip_gtid_rollback = false;

  return false;

err:
  DBUG_PRINT("admin", ("err:"));
  if (gtid_rollback_must_be_skipped) thd->skip_gtid_rollback = false;

  trans_rollback_stmt(thd);
  trans_rollback(thd);

  if (thd->sp_runtime_ctx) thd->sp_runtime_ctx->end_partial_result_set = true;

  /* Make sure this table instance is not reused after the operation. */
  if (table->table) table->table->invalidate_dict();
  close_thread_tables(thd);  // Shouldn't be needed
  thd->mdl_context.release_transactional_locks();
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_admin.cc
Function: prepare_for_repair 
static int prepare_for_repair(THD *thd, Table_ref *table_list,
                              HA_CHECK_OPT *check_opt) {
  int error = 0;
  TABLE tmp_table, *table;
  TABLE_SHARE *share;
  bool has_mdl_lock = false;
  char from[FN_REFLEN], tmp[FN_REFLEN + 32];
  const char **ext;
  MY_STAT stat_info;
  Open_table_context ot_ctx(thd,
                            (MYSQL_OPEN_IGNORE_FLUSH | MYSQL_OPEN_HAS_MDL_LOCK |
                             MYSQL_LOCK_IGNORE_TIMEOUT));
  DBUG_TRACE;

  if (!(check_opt->sql_flags & TT_USEFRM)) return 0;

  if (!(table = table_list->table)) {
    const char *key;
    size_t key_length;
    /*
      If the table didn't exist, we have a shared metadata lock
      on it that is left from mysql_admin_table()'s attempt to
      open it. Release the shared metadata lock before trying to
      acquire the exclusive lock to satisfy MDL asserts and avoid
      deadlocks.
    */
    thd->mdl_context.release_transactional_locks();
    /*
      Attempt to do full-blown table open in mysql_admin_table() has failed.
      Let us try to open at least a .FRM for this table.
    */
    MDL_REQUEST_INIT(&table_list->mdl_request, MDL_key::TABLE, table_list->db,
                     table_list->table_name, MDL_EXCLUSIVE, MDL_TRANSACTION);

    if (lock_table_names(thd, table_list, table_list->next_global,
                         thd->variables.lock_wait_timeout, 0))
      return 0;
    has_mdl_lock = true;

    key_length = get_table_def_key(table_list, &key);

    mysql_mutex_lock(&LOCK_open);
    share = get_table_share(thd, table_list->db, table_list->table_name, key,
                            key_length, false);
    mysql_mutex_unlock(&LOCK_open);
    if (share == nullptr) return 0;  // Can't open frm file

    if (open_table_from_share(thd, share, "", 0, 0, 0, &tmp_table, false,
                              nullptr)) {
      mysql_mutex_lock(&LOCK_open);
      release_table_share(share);
      mysql_mutex_unlock(&LOCK_open);
      return 0;  // Out of memory
    }
    table = &tmp_table;
  }

  /*
    REPAIR TABLE ... USE_FRM for temporary tables makes little sense.
  */
  if (table->s->tmp_table) {
    error = send_check_errmsg(thd, table_list, "repair",
                              "Cannot repair temporary table from .frm file");
    goto end;
  }

  /*
    Check if this is a table type that stores index and data separately,
    like ISAM or MyISAM. We assume fixed order of engine file name
    extensions array. First element of engine file name extensions array
    is meta/index file extension. Second element - data file extension.
  */
  ext = table->file->ht->file_extensions;
  if (!ext || !ext[0] || !ext[1]) goto end;  // No data file

  /* A MERGE table must not come here. */
  assert(table->file->ht->db_type != DB_TYPE_MRG_MYISAM);

  /*
    Storage engines supporting atomic DDL do not come here either.

    If we are to have storage engine which supports atomic DDL on one
    hand and REPAIR ... USE_FRM on another then the below code related
    to table re-creation in SE needs to be adjusted to at least
    commit the transaction.
  */
  assert(!(table->file->ht->flags & HTON_SUPPORTS_ATOMIC_DDL));

  // Name of data file
  strxmov(from, table->s->normalized_path.str, ext[1], NullS);
  if (!mysql_file_stat(key_file_misc, from, &stat_info, MYF(0)))
    goto end;  // Can't use USE_FRM flag

  snprintf(tmp, sizeof(tmp), "%s-%lx_%x", from, current_pid, thd->thread_id());

  if (table_list->table) {
    /*
      Table was successfully open in mysql_admin_table(). Now we need
      to close it, but leave it protected by exclusive metadata lock.
    */
    if (wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN)) goto end;
    close_all_tables_for_name(thd, table_list->table->s, false, nullptr);
    table_list->table = nullptr;
  }
  /*
    After this point we have an exclusive metadata lock on our table
    in both cases when table was successfully open in mysql_admin_table()
    and when it was open in prepare_for_repair().
  */

  if (my_rename(from, tmp, MYF(MY_WME))) {
    error = send_check_errmsg(thd, table_list, "repair",
                              "Failed renaming data file");
    goto end;
  }
  if (dd::recreate_table(thd, table_list->db, table_list->table_name)) {
    error = send_check_errmsg(thd, table_list, "repair",
                              "Failed generating table from .frm file");
    goto end;
  }
  if (mysql_file_rename(key_file_misc, tmp, from, MYF(MY_WME))) {
    error = send_check_errmsg(thd, table_list, "repair",
                              "Failed restoring .MYD file");
    goto end;
  }

  if (thd->locked_tables_list.reopen_tables(thd)) goto end;

  /*
    Now we should be able to open the partially repaired table
    to finish the repair in the handler later on.
  */
  if (open_table(thd, table_list, &ot_ctx)) {
    error = send_check_errmsg(thd, table_list, "repair",
                              "Failed to open partially repaired table");
    goto end;
  }

end:
  thd->locked_tables_list.unlink_all_closed_tables(thd, nullptr, 0);
  if (table == &tmp_table) {
    mysql_mutex_lock(&LOCK_open);
    closefrm(table, true);  // Free allocated memory
    mysql_mutex_unlock(&LOCK_open);
  }
  /* In case of a temporary table there will be no metadata lock. */
  if (error && has_mdl_lock) thd->mdl_context.release_transactional_locks();

  return error;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/sdi_utils.h
Function: dd::sdi_utils::mdl_lock 
inline bool mdl_lock(THD *thd, MDL_key::enum_mdl_namespace ns,
                     const String_type &schema_name,
                     const String_type &object_name,
                     enum_mdl_type mt = MDL_EXCLUSIVE,
                     enum_mdl_duration md = MDL_TRANSACTION) {
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, ns, schema_name.c_str(), object_name.c_str(),
                   mt, md);
  return checked_return(thd->mdl_context.acquire_lock(
      &mdl_request, thd->variables.lock_wait_timeout));
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_alter_instance.cc
Function: Rotate_innodb_master_key::execute
bool Rotate_innodb_master_key::execute() {
  const LEX_CSTRING storage_engine = {STRING_WITH_LEN("innodb")};
  plugin_ref se_plugin;
  handlerton *hton;

  Security_context *sctx = m_thd->security_context();
  if (!sctx->check_access(SUPER_ACL) &&
      !sctx->has_global_grant(STRING_WITH_LEN("ENCRYPTION_KEY_ADMIN")).first) {
    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0),
             "SUPER or ENCRYPTION_KEY_ADMIN");
    return true;
  }

  if ((se_plugin = ha_resolve_by_name(m_thd, &storage_engine, false))) {
    hton = plugin_data<handlerton *>(se_plugin);
  } else {
    my_error(ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE, MYF(0));
    return true;
  }

  if (!hton->rotate_encryption_master_key) {
    my_error(ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE, MYF(0));
    return true;
  }

  /*
    Acquire protection against GRL and check for concurrent change of read_only
    value since encryption key rotation is not allowed in read_only/
    super_read_only mode.
  */
  if (acquire_shared_global_read_lock(m_thd,
                                      m_thd->variables.lock_wait_timeout)) {
    // MDL subsystem has to set an error in Diagnostics Area
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  /*
    Acquire shared backup lock to block concurrent backup. Acquire exclusive
    backup lock to block any concurrent DDL. The fact that we acquire both
    these locks also ensures that concurrent KEY rotation requests are blocked.
  */
  if (acquire_exclusive_backup_lock(m_thd, m_thd->variables.lock_wait_timeout,
                                    true) ||
      acquire_shared_backup_lock(m_thd, m_thd->variables.lock_wait_timeout)) {
    // MDL subsystem has to set an error in Diagnostics Area
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  if (hton->rotate_encryption_master_key()) {
    /* SE should have raised error */
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  if (log_to_binlog()) {
    /*
      Though we failed to write to binlog,
      there is no way we can undo this operation.
      So, convert error to a warning and let user
      know that something went wrong while trying
      to make entry in binlog.
    */
    m_thd->clear_error();
    m_thd->get_stmt_da()->reset_diagnostics_area();

    push_warning(m_thd, Sql_condition::SL_WARNING,
                 ER_MASTER_KEY_ROTATION_BINLOG_FAILED,
                 ER_THD(m_thd, ER_MASTER_KEY_ROTATION_BINLOG_FAILED));
  }

  my_ok(m_thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_alter_instance.cc
Function: Innodb_redo_log::execute
bool Innodb_redo_log::execute() {
  DBUG_TRACE;

  const LEX_CSTRING storage_engine = {STRING_WITH_LEN("innodb")};

  auto hton = plugin_data<handlerton *>(
      ha_resolve_by_name(m_thd, &storage_engine, false));

  if (hton == nullptr) {
    /* Innodb engine is not loaded. Should never happen. */
    my_error(ER_UNKNOWN_STORAGE_ENGINE, MYF(0), storage_engine.str);
  }

  Security_context *sctx = m_thd->security_context();
  if (!sctx->has_global_grant(STRING_WITH_LEN("INNODB_REDO_LOG_ENABLE"))
           .first) {
    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "INNODB_REDO_LOG_ENABLE");
    return true;
  }

  /*
    Acquire shared backup lock to block concurrent backup. Acquire exclusive
    backup lock to block any concurrent DDL. This would also serialize any
    concurrent key rotation and other redo log enable/disable calls.
  */
  if (acquire_exclusive_backup_lock(m_thd, m_thd->variables.lock_wait_timeout,
                                    true) ||
      acquire_shared_backup_lock(m_thd, m_thd->variables.lock_wait_timeout)) {
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  if (hton->redo_log_set_state(m_thd, m_enable)) {
    /* SE should have raised error */
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  /* Right now, we don't log this command to binary log as redo logging
  options are low level physical attribute which is not needed to replicate
  to other instances. */

  my_ok(m_thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_backup_lock.cc
Function: Sql_cmd_lock_instance::execute
bool Sql_cmd_lock_instance::execute(THD *thd) {
  if (check_backup_admin_privilege(thd) ||
      acquire_exclusive_backup_lock(
          thd,
          DBUG_EVALUATE_IF("stop_replica_dont_release_backup_lock", 5,
                           thd->variables.lock_wait_timeout),
          false))
    return true;

  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_srs.cc
Function: Sql_cmd_drop_srs::execute
bool Sql_cmd_drop_srs::execute(THD *thd) {
  if (!(thd->security_context()->check_access(SUPER_ACL))) {
    my_error(ER_CMD_NEED_SUPER, MYF(0), "DROP SPATIAL REFERENCE SYSTEM");
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard dag(thd);
  dd::cache::Dictionary_client *dd_client = thd->dd_client();
  dd::cache::Dictionary_client::Auto_releaser releaser(dd_client);
  auto rollback_guard = create_scope_guard([thd]() {
    if (rollback(thd)) assert(false); /* purecov: deadcode */
  });
  Srs_fetcher fetcher(thd);
  dd::Spatial_reference_system *srs = nullptr;
  if (fetcher.acquire_for_modification(m_srid, &srs))
    return true; /* purecov: inspected */

  if (srs == nullptr) {
    if (m_if_exists) {
      push_warning_printf(thd, Sql_condition::SL_WARNING, ER_WARN_SRS_NOT_FOUND,
                          ER_THD(thd, ER_SRS_NOT_FOUND), m_srid);
      my_ok(thd);
    } else {
      my_error(ER_SRS_NOT_FOUND, MYF(0), m_srid);
    }
    return !m_if_exists;
  }

  warn_if_in_reserved_range(m_srid, thd);

  if (srs_is_used(m_srid, thd)) {
    my_error(ER_CANT_MODIFY_SRS_USED_BY_COLUMN, MYF(0), m_srid);
    return true;
  }

  if (dd_client->drop(srs)) return true; /* purecov: inspected */
  rollback_guard.commit();
  if (commit(thd)) return true; /* purecov: inspected */
  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_srs.cc
Function: Sql_cmd_create_srs::execute
bool Sql_cmd_create_srs::execute(THD *thd) {
  if (!(thd->security_context()->check_access(SUPER_ACL))) {
    my_error(ER_CMD_NEED_SUPER, MYF(0),
             m_or_replace ? "CREATE OR REPLACE SPATIAL REFERENCE SYSTEM"
                          : "CREATE SPATIAL REFERENCE SYSTEM");
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard dag(thd);
  dd::cache::Dictionary_client *dd_client = thd->dd_client();
  dd::cache::Dictionary_client::Auto_releaser releaser(dd_client);
  auto rollback_guard = create_scope_guard([thd]() {
    if (rollback(thd)) assert(false); /* purecov: deadcode */
  });
  Srs_fetcher fetcher(thd);
  dd::Spatial_reference_system *srs = nullptr;
  if (fetcher.acquire_for_modification(m_srid, &srs))
    return true; /* purecov: inspected */

  if (srs != nullptr) {
    if (m_if_not_exists) {
      push_warning_printf(thd, Sql_condition::SL_WARNING,
                          ER_WARN_SRS_ID_ALREADY_EXISTS,
                          ER_THD(thd, ER_WARN_SRS_ID_ALREADY_EXISTS), m_srid);
      my_ok(thd);
      return false;
    }
    if (!m_or_replace) {
      my_error(ER_SRS_ID_ALREADY_EXISTS, MYF(0), m_srid);
      return true;
    }

    if (fill_srs(srs)) return true;  // Error has already been flagged.

    const dd::Spatial_reference_system *old_srs = nullptr;
    if (fetcher.acquire(m_srid, &old_srs)) return true; /* purecov: inspected */
    assert(old_srs != nullptr);
    if (srs_is_used(m_srid, thd) && !old_srs->can_be_modified_to(*srs)) {
      my_error(ER_CANT_MODIFY_SRS_USED_BY_COLUMN, MYF(0), m_srid);
      return true;
    }

    warn_if_in_reserved_range(m_srid, thd);

    if (dd_client->update(srs)) return true;  // Error has already been flagged.

    rollback_guard.commit();
    if (commit(thd)) return true; /* purecov: inspected */
    my_ok(thd);
    return false;
  }

  std::unique_ptr<dd::Spatial_reference_system> new_srs(
      dd::create_object<dd::Spatial_reference_system>());
  static_cast<dd::Spatial_reference_system_impl *>(new_srs.get())
      ->set_id(m_srid);
  if (fill_srs(new_srs.get())) return true;  // Error has already been flagged.

  warn_if_in_reserved_range(m_srid, thd);

  if (thd->dd_client()->store(new_srs.get())) return true;

  rollback_guard.commit();
  if (commit(thd)) return true; /* purecov: inspected */
  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_import.cc
Function: Sql_cmd_import_table::execute
bool Sql_cmd_import_table::execute(THD *thd) {
  assert(!m_sdi_patterns.empty());

  auto rbgrd = dd::sdi_utils::make_guard(thd, [&](THD *) {
    trans_rollback_stmt(thd);
    trans_rollback(thd);
  });

  // Need to keep this alive until after commit/rollback has been done
  dd::cache::Dictionary_client::Auto_releaser ar{thd->dd_client()};

  if (check_access(thd, FILE_ACL, nullptr, nullptr, nullptr, false, false)) {
    return true;
  }

  // Convert supplied sdi patterns into path,in_datadir pairs
  dd::sdi_file::Paths_type paths{key_memory_DD_import};
  paths.reserve(m_sdi_patterns.size());
  for (auto &pattern : m_sdi_patterns) {
    if (thd->charset() == files_charset_info) {
      if (dd::sdi_file::expand_pattern(thd, pattern, &paths)) {
        return true;
      }
      continue;
    }

    LEX_STRING converted;
    if (thd->convert_string(&converted, files_charset_info, pattern.str,
                            pattern.length, thd->charset())) {
      return true;
    }

    if (dd::sdi_file::expand_pattern(thd, converted, &paths)) {
      return true;
    }
  }

  Targets_type targets{key_memory_DD_import};

  auto tgtgrd = dd::sdi_utils::make_guard(thd, [&](THD *) {
    for (auto &tgt : targets) {
      tgt.rollback();
    }
  });

  for (auto &p : paths) {
    // Move the path string from paths to avoid copy - paths is now
    // empty shell
    targets.emplace_back(std::move(p.first), p.second);
  }
  // Have a valid list of sdi files to import

  dd::String_type shared_buffer;
  MDL_request_list mdl_requests;
  for (auto &t : targets) {
    if (t.load(thd, &shared_buffer)) {
      return true;
    }

    if (check_privileges(thd, t)) {
      return true;
    }

    mdl_requests.push_front(mdl_request(t, thd->mem_root));
  }
  // Table objects and their schema names have been loaded, privileges
  // checked and EXCLUSIVE MDL requests for the tables been added to
  // mdl_requests.

  std::vector<dd::String_type> schema_names;
  schema_names.reserve(targets.size());
  for (auto &t : targets) {
    schema_names.push_back(*t.can_schema_name());
  }
  std::sort(schema_names.begin(), schema_names.end());
  auto uniq_end = std::unique(schema_names.begin(), schema_names.end());
  schema_names.erase(uniq_end, schema_names.end());

  for (auto &sn : schema_names) {
    MDL_request *r = new (thd->mem_root) MDL_request;
    MDL_REQUEST_INIT(r, MDL_key::SCHEMA, sn.c_str(), "",
                     MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
    mdl_requests.push_front(r);
  }

  MDL_request *mdl_request_for_backup_lock = new (thd->mem_root) MDL_request;
  MDL_REQUEST_INIT(mdl_request_for_backup_lock, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  mdl_requests.push_front(mdl_request_for_backup_lock);

  // If we cannot acquire protection against GRL, err out.
  if (thd->global_read_lock.can_acquire_protection()) return true;

  MDL_request *mdl_request_for_grl = new (thd->mem_root) MDL_request;
  MDL_REQUEST_INIT(mdl_request_for_grl, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  mdl_requests.push_front(mdl_request_for_grl);

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout)) {
    return true;
  }

  // Now when we have protection against concurrent change of read_only
  // option we can safely re-check its value.
  if (check_readonly(thd, true)) return true;

  // Loop over schema names and check schema read only.
  for (auto &sn : schema_names) {
    if (check_schema_readonly(thd, sn.c_str())) return true;
  }

  // Now we have MDL on all schemas and tables involved

  for (auto &t : targets) {
    if (t.store_in_dd(thd)) {
      return true;
    }
  }

  rbgrd.release();
  tgtgrd.release();

  // Downgrade failing delete_file errors to warning, and
  // allow the transaction to commit.
  dd::sdi_utils::handle_errors(
      thd,
      [](uint, const char *, Sql_condition::enum_severity_level *level,
         const char *) {
        (*level) = Sql_condition::SL_WARNING;
        return false;
      },
      [&]() {
        for (auto &tgt : targets) {
          (void)tgt.commit();
        }
        return false;
      });

  my_ok(thd);
  return trans_commit_stmt(thd) || trans_commit(thd);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_insert.cc
Function: Query_result_create::send_eof
bool Query_result_create::send_eof(THD *thd) {
  /*
    The routine that writes the statement in the binary log
    is in Query_result_insert::send_eof(). For that reason, we
    mark the flag at this point.
  */
  if (create_info->options & HA_LEX_CREATE_TMP_TABLE)
    thd->get_transaction()->mark_created_temp_table(Transaction_ctx::STMT);

  bool error = false;

  /*
    For non-temporary tables, we update the unique_constraint_name for
    the FKs of referencing tables, after acquiring exclusive metadata locks.
    We also need to upgrade the SU locks on referenced tables to be exclusive
    before invalidating the referenced tables.
  */
  Foreign_key_parents_invalidator fk_invalidator;

  if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE) &&
      (create_info->db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
    MDL_request_list mdl_requests;

    if ((!dd::get_dictionary()->is_dd_table_name(create_table->db,
                                                 create_table->table_name) &&
         collect_fk_children(thd, create_table->db, create_table->table_name,
                             create_info->db_type, MDL_EXCLUSIVE,
                             &mdl_requests)) ||
        collect_fk_parents_for_new_fks(thd, create_table->db,
                                       create_table->table_name, alter_info,
                                       MDL_EXCLUSIVE, create_info->db_type,
                                       &mdl_requests, &fk_invalidator) ||
        (!mdl_requests.is_empty() &&
         thd->mdl_context.acquire_locks(&mdl_requests,
                                        thd->variables.lock_wait_timeout)))
      error = true;
    else {
      dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
      const dd::Table *new_table = nullptr;
      if (thd->dd_client()->acquire(create_table->db, create_table->table_name,
                                    &new_table))
        error = true;
      else {
        assert(new_table != nullptr);
        /*
          If we are to support FKs for storage engines which don't support
          atomic DDL we need to decide what to do for such SEs in case of
          failure to update children definitions and adjust code accordingly.
        */
        assert(create_info->db_type->flags & HTON_SUPPORTS_ATOMIC_DDL);

        if (adjust_fk_children_after_parent_def_change(
                thd, create_table->db, create_table->table_name,
                create_info->db_type, new_table, nullptr) ||
            adjust_fk_parents(thd, create_table->db, create_table->table_name,
                              true, nullptr))
          error = true;
      }
    }
  }

  {
    Uncommitted_tables_guard uncommitted_tables(thd);

    /*
      We can rollback target table creation by dropping it even for SEs which
      don't support atomic DDL. So there is no need to commit changes to
      metadata of dependent views below.
      Moreover, doing these intermediate commits can be harmful as in RBR mode
      they will flush CREATE TABLE event and row events to the binary log
      which, in case of later error, will create discrepancy with rollback of
      statement by target table removal.
      Such intermediate commits also wipe out transaction's unsafe-to-rollback
      flags which leads to broken assertions in Query_result_insert::send_eof().
    */
    if (!error)
      error = update_referencing_views_metadata(thd, create_table, false,
                                                &uncommitted_tables);
  }
  DBUG_EXECUTE_IF("crash_before_create_select_insert", DBUG_SUICIDE(););

  if (!error) error = Query_result_insert::send_eof(thd);
  if (error)
    abort_result_set(thd);
  else {
    DBUG_EXECUTE_IF("crash_after_create_select_insert", DBUG_SUICIDE(););
    /*
      Do an implicit commit at end of statement for non-temporary tables.
      This can fail in which case rollback will be done automatically.
      For storage engines supporting atomic DDL this will revert table
      creation in SE, data-dictionary and binlog changes.
      For other storage engines we might end-up with partially consistent
      state between data-dictionary, SE, data in table and binary log.
      However this should be extremely rare.
    */
    if (!table->s->tmp_table) {
      thd->get_stmt_da()->set_overwrite_status(true);
      error = trans_commit_stmt(thd) || trans_commit_implicit(thd);
      thd->get_stmt_da()->set_overwrite_status(false);
    }

    if (!error && m_plock) {
      mysql_unlock_tables(thd, *m_plock);
      *m_plock = nullptr;
      m_plock = nullptr;
    }

    if (!error && m_post_ddl_ht) {
      m_post_ddl_ht->post_ddl(thd);
    }

    fk_invalidator.invalidate(thd);
  }
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_insert.cc
Function: create_table_from_items 
static TABLE *create_table_from_items(THD *thd, HA_CREATE_INFO *create_info,
                                      Table_ref *create_table,
                                      Alter_info *alter_info,
                                      const mem_root_deque<Item *> &items,
                                      handlerton **post_ddl_ht) {
  DBUG_TRACE;

  // Check that the specified ENGINE exists and is enabled.
  if (get_viable_handlerton_for_create(thd, create_table->table_name,
                                       *create_info) == nullptr) {
    return nullptr;
  }

  if (!thd->variables.explicit_defaults_for_timestamp)
    promote_first_timestamp_column(&alter_info->create_list);

  TABLE_SHARE share;
  init_tmp_table_share(thd, &share, "", 0, "", "", nullptr);
  share.db_create_options = 0;
  share.db_low_byte_first = (create_info->db_type == myisam_hton ||
                             create_info->db_type == heap_hton);

  TABLE tmp_table;
  tmp_table.s = &share;
  tmp_table.set_not_started();

  /* Add selected items to field list */
  for (Item *item : VisibleFields(items)) {
    Create_field *create_field = generate_create_field(thd, item, &tmp_table);
    if (create_field == nullptr) return nullptr; /* purecov: deadcode */

    // Array columns may be returned if show_hidden_columns is enabled. Raise an
    // error instead of attempting to create array columns in the new table.
    DBUG_EXECUTE("show_hidden_columns", {
      if (create_field->is_array) {
        my_error(ER_NOT_SUPPORTED_YET, MYF(0),
                 "Creating tables with array columns.");
        return nullptr;
      }
    });
    assert(!create_field->is_array);

    alter_info->create_list.push_back(create_field);
  }

  /*
    Acquire SU metadata locks for the tables referenced
    in the FK constraints.
  */
  if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE) &&
      (create_info->db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
    /*
      CREATE TABLE SELECT fails under LOCK TABLES at open_tables() time
      if target table doesn't exist already. So we don't need to handle
      LOCK TABLES case here by checking that parent tables for new FKs
      are properly locked and there are no orphan child tables for which
      table being created will become parent.
    */
    assert(thd->locked_tables_mode != LTM_LOCK_TABLES &&
           thd->locked_tables_mode != LTM_PRELOCKED_UNDER_LOCK_TABLES);

    MDL_request_list mdl_requests;

    if (collect_fk_parents_for_new_fks(
            thd, create_table->db, create_table->table_name, alter_info,
            MDL_SHARED_UPGRADABLE, nullptr, &mdl_requests, nullptr) ||
        collect_fk_names_for_new_fks(thd, create_table->db,
                                     create_table->table_name, alter_info,
                                     create_info->db_type,
                                     0,  // No pre-existing FKs
                                     &mdl_requests)) {
      return nullptr;
    }

    if (!mdl_requests.is_empty() &&
        thd->mdl_context.acquire_locks(&mdl_requests,
                                       thd->variables.lock_wait_timeout)) {
      return nullptr;
    }
  }

  // Prepare check constraints.
  if (prepare_check_constraints_for_create(
          thd, create_table->db, create_table->table_name, alter_info)) {
    return nullptr;
  }

  /*
    If mode to generate invisible primary key is active then, generate primary
    key for the table.
  */
  if (is_generate_invisible_primary_key_mode_active(thd) &&
      is_candidate_table_for_invisible_primary_key_generation(create_info,
                                                              alter_info)) {
    if (validate_and_generate_invisible_primary_key(thd, alter_info))
      return nullptr;
  }

  DEBUG_SYNC(thd, "create_table_select_before_create");

  /*
    Create and lock table.

    Note that we are either creating (or opening existing) temporary table or
    creating base table on which name we have exclusive lock. So code below
    should not cause deadlocks or races.

    We don't log the statement, it will be logged later.

    If this is a HEAP table, the automatic DELETE FROM which is written to the
    binlog when a HEAP table is opened for the first time since startup, must
    not be written: 1) it would be wrong (imagine we're in CREATE SELECT: we
    don't want to delete from it) 2) it would be written before the CREATE
    TABLE, which is a wrong order. So we keep binary logging disabled when we
    open_table().
  */
  const size_t select_field_count = CountVisibleFields(items);
  if (mysql_create_table_no_lock(
          thd, create_table->db, create_table->table_name, create_info,
          alter_info, select_field_count, true, nullptr, post_ddl_ht)) {
    return nullptr;
  }

  DEBUG_SYNC(thd, "create_table_select_before_open");

  if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE)) {
    Open_table_context ot_ctx(thd, MYSQL_OPEN_REOPEN);
    /*
      Here we open the destination table, on which we already have
      an exclusive metadata lock.
    */
    if (open_table(thd, create_table, &ot_ctx)) {
      /* Play safe, remove table share for the table from the cache. */
      tdc_remove_table(thd, TDC_RT_REMOVE_ALL, create_table->db,
                       create_table->table_name, false);

      if (!(create_info->db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
        quick_rm_table(thd, create_info->db_type, create_table->db,
                       create_table->table_name, 0);
      }

      return nullptr;
    }
  } else {
    if (open_temporary_table(thd, create_table)) {
      /*
        This shouldn't happen as creation of temporary table should make
        it preparable for open. Anyway we can't drop temporary table if
        we are unable to find it.
      */
      assert(0);

      return nullptr;
    }
  }

  return create_table->table;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_partition_admin.cc
Function: Sql_cmd_alter_table_truncate_partition::execute
bool Sql_cmd_alter_table_truncate_partition::execute(THD *thd) {
  int error;
  ulong timeout = thd->variables.lock_wait_timeout;
  Table_ref *first_table = thd->lex->query_block->get_table_list();
  uint table_counter;
  Partition_handler *part_handler = nullptr;
  handlerton *hton;
  DBUG_TRACE;
  assert((m_alter_info->flags & (Alter_info::ALTER_ADMIN_PARTITION |
                                 Alter_info::ALTER_TRUNCATE_PARTITION)) ==
         (Alter_info::ALTER_ADMIN_PARTITION |
          Alter_info::ALTER_TRUNCATE_PARTITION));

  /* Fix the lock types (not the same as ordinary ALTER TABLE). */
  first_table->set_lock({TL_WRITE, THR_DEFAULT});
  first_table->mdl_request.set_type(MDL_EXCLUSIVE);

  /*
    Check table permissions and open it with a exclusive lock.
    Ensure it is a partitioned table and finally, upcast the
    handler and invoke the partition truncate method. Lastly,
    write the statement to the binary log if necessary.
  */

  if (check_one_table_access(thd, DROP_ACL, first_table)) return true;

  if (open_tables(thd, &first_table, &table_counter, 0)) return true;

  if (!first_table->table || first_table->is_view() ||
      !first_table->table->file->ht->partition_flags ||
      !(part_handler = first_table->table->file->get_partition_handler())) {
    my_error(ER_PARTITION_MGMT_ON_NONPARTITIONED, MYF(0));
    return true;
  }

  hton = first_table->table->file->ht;

  /*
    Prune all, but named partitions. SE can use partitions bitmap
    to understand what partitions need to be truncated. This also
    allows to avoid excessive calls to external_lock().
  */
  first_table->partition_names = &m_alter_info->partition_names;
  if (first_table->table->part_info->set_partition_bitmaps(first_table))
    return true;

  /*
    Under locked table modes we still don't have an exclusive lock.
    Hence, upgrade the lock since the handler truncate method mandates
    an exclusive metadata lock. Don't forget to downgrade the lock
    before leaving this method.
  */
  auto downgrade_mdl_lambda = [](MDL_ticket *ticket) {
    ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
  };
  std::unique_ptr<MDL_ticket, decltype(downgrade_mdl_lambda)>
      downgrade_mdl_guard(nullptr, downgrade_mdl_lambda);

  if (thd->locked_tables_mode) {
    MDL_ticket *ticket = first_table->table->mdl_ticket;
    if (thd->mdl_context.upgrade_shared_lock(ticket, MDL_EXCLUSIVE, timeout))
      return true;
    downgrade_mdl_guard.reset(ticket);
  }

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  dd::Table *table_def = nullptr;

  if (thd->dd_client()->acquire_for_modification<dd::Table>(
          first_table->db, first_table->table_name, &table_def))
    return true;

  /* Table was successfully opened above. */
  assert(table_def != nullptr);

  Table_ddl_hton_notification_guard notification_guard{
      thd, &first_table->mdl_request.key, ha_ddl_type::HA_TRUNCATE_DDL};

  if (notification_guard.notify()) return true;

  if (table_def->options().exists("secondary_engine")) {
    LEX_CSTRING secondary_engine;
    table_def->options().get("secondary_engine", &secondary_engine,
                             thd->mem_root);

    if (!ha_secondary_engine_supports_ddl(thd, secondary_engine)) {
      my_error(ER_SECONDARY_ENGINE_DDL, MYF(0));
      return true;
    }
  }

  if (hton->partition_flags() & HA_TRUNCATE_PARTITION_PRECLOSE) {
    /*
      Storage engine requires closing all open table instances before
      calling Partition_handler::truncate_partition().
    */
    char path[FN_REFLEN + 1];
    TABLE_SHARE share;
    TABLE table;

    /*
      Save information about which partitions need to be truncated
      before destroying partitions bitmaps along with open table
      instance.
    */
    MY_BITMAP saved_parts_map;
    if (first_table->table->part_info->init_partition_bitmap(&saved_parts_map,
                                                             thd->mem_root))
      return true;
    bitmap_copy(&saved_parts_map,
                &first_table->table->part_info->read_partitions);

    close_all_tables_for_name(thd, first_table->table->s, false, nullptr);

    /*
      Construct artificial TABLE/TABLE_SHARE and handler instances for
      calling Partition_handler::truncate_partition().
    */
    build_table_filename(path, sizeof(path) - 1, first_table->db,
                         first_table->table_name, "", 0);

    init_tmp_table_share(thd, &share, first_table->db, 0,
                         first_table->table_name, path, nullptr);

    auto free_share_lambda = [](TABLE_SHARE *share_arg) {
      free_table_share(share_arg);
    };
    std::unique_ptr<TABLE_SHARE, decltype(free_share_lambda)> free_share_guard(
        &share, free_share_lambda);

    error = open_table_def(thd, &share, *table_def);

    if (!error) {
      /*
        When db_stat is 0, we can pass nullptr as dd::Table since it
        won't be used.
      */
      destroy(&table);
      error = open_table_from_share(thd, &share, "", 0, (uint)READ_ALL, 0,
                                    &table, true, nullptr);

      if (!error) {
        auto closefrm_lambda = [](TABLE *t) { (void)closefrm(t, false); };
        std::unique_ptr<TABLE, decltype(closefrm_lambda)> closefrm_guard(
            &table, closefrm_lambda);

        bitmap_copy(&table.part_info->read_partitions, &saved_parts_map);

        part_handler = table.file->get_partition_handler();
        // We succeeded obtaining Partition_hanlder earlier.
        assert(part_handler != nullptr);

        if (!error && (error = part_handler->truncate_partition(table_def))) {
          table.file->print_error(error, MYF(0));
        }
      }
    }
  } else {
    if (lock_tables(thd, first_table, table_counter, 0)) return true;

    tdc_remove_table(thd, TDC_RT_REMOVE_NOT_OWN, first_table->db,
                     first_table->table_name, false);

    /* Invoke the handler method responsible for truncating the partition. */
    if ((error = part_handler->truncate_partition(table_def))) {
      first_table->table->file->print_error(error, MYF(0));
    }

    /*
      Since we about to update table definition in the data-dictionary below
      we need to remove its TABLE/TABLE_SHARE from TDC now.
    */
    close_all_tables_for_name(thd, first_table->table->s, false, nullptr);
  }

  if (hton->flags & HTON_SUPPORTS_ATOMIC_DDL) {
    /*
      Storage engine supporting atomic DDL can fully rollback truncate
      if any problem occurs. This will happen during statement rollback.

      In case of success we need to save dd::Table object which might
      have been updated by SE. If this step or subsequent write to binary
      log fail then statement rollback will also restore status quo ante.

      Note that Table Definition and Table Caches were invalidated above.
    */
    if (!error) {
      if (thd->dd_client()->update<dd::Table>(table_def) ||
          write_bin_log(thd, true, thd->query().str, thd->query().length, true))
        error = 1;
    }
  } else {
    /*
      For engines which don't support atomic DDL all effects of a
      truncate operation are committed even if the operation fails.
      Thus, the query must be written to the binary log.
      The exception is a unimplemented truncate method or failure
      before any call to handler::truncate() is done.
      Also, it is logged in statement format, regardless of the binlog format.
    */
    if (error != HA_ERR_WRONG_COMMAND) {
      error |=
          write_bin_log(thd, !error, thd->query().str, thd->query().length);
    }
  }

  if (!error) error = (trans_commit_stmt(thd) || trans_commit_implicit(thd));

  if (error) {
    trans_rollback_stmt(thd);
    /*
      Full rollback in case we have THD::transaction_rollback_request
      and to synchronize DD state in cache and on disk (as statement
      rollback doesn't clear DD cache of modified uncommitted objects).
    */
    trans_rollback(thd);
  }

  if ((hton->flags & HTON_SUPPORTS_ATOMIC_DDL) && hton->post_ddl)
    hton->post_ddl(thd);

  (void)thd->locked_tables_list.reopen_tables(thd);

  if (!error) my_ok(thd);

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_truncate.cc
Function: Sql_cmd_truncate_table::lock_table
bool Sql_cmd_truncate_table::lock_table(THD *thd, Table_ref *table_ref) {
  TABLE *table = nullptr;
  DBUG_TRACE;

  /* Lock types are set in the parser. */
  assert(table_ref->lock_descriptor().type == TL_WRITE);
  /* The handler truncate protocol dictates a exclusive lock. */
  assert(table_ref->mdl_request.type == MDL_EXCLUSIVE);

  /*
    Before doing anything else, acquire a metadata lock on the table,
    or ensure we have one.  We don't use open_and_lock_tables()
    right away because we want to be able to truncate (and recreate)
    corrupted tables, those that we can't fully open.

    MySQL manual documents that TRUNCATE can be used to repair a
    damaged table, i.e. a table that can not be fully "opened".
    In particular MySQL manual says: As long as the table format
    file tbl_name.frm is valid, the table can be re-created as
    an empty table with TRUNCATE TABLE, even if the data or index
    files have become corrupted.
  */
  if (thd->locked_tables_mode) {
    if (!(table = find_table_for_mdl_upgrade(thd, table_ref->db,
                                             table_ref->table_name, false)))
      return true;

    if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
      return true;

    table_ref->mdl_request.ticket = table->mdl_ticket;

    /*
      A storage engine can recreate or truncate the table only if there
      are no references to it from anywhere, i.e. no cached TABLE in the
      table cache.
    */
    DEBUG_SYNC(thd, "upgrade_lock_for_truncate");
    /* To remove the table from the cache we need an exclusive lock. */
    if (wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN))
      return true;
    m_ticket_downgrade = table->mdl_ticket;
    /* Close if table is going to be recreated. */
    if (table->s->db_type()->flags & HTON_CAN_RECREATE)
      close_all_tables_for_name(thd, table->s, false, nullptr);

    return false;
  }  //  if (thd->locked_tables_mode)
  assert(!thd->locked_tables_mode);

  /* Acquire an exclusive lock. */
  assert(table_ref->next_global == nullptr);
  if (lock_table_names(thd, table_ref, nullptr,
                       thd->variables.lock_wait_timeout, 0))
    return true;

  /* Table is already locked exclusively. Remove cached instances. */
  tdc_remove_table(thd, TDC_RT_REMOVE_ALL, table_ref->db, table_ref->table_name,
                   false);

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/xa/sql_xa_prepare.cc
Function: Sql_cmd_xa_prepare::trans_xa_prepare
bool Sql_cmd_xa_prepare::trans_xa_prepare(THD *thd) {
  DBUG_TRACE;

  auto tran = thd->get_transaction();
  auto xid_state = tran->xid_state();

  DBUG_PRINT("xa", ("trans_xa_prepare: formatID:%ld",
                    xid_state->get_xid()->get_format_id()));

  if (!xid_state->has_state(XID_STATE::XA_IDLE)) {
    my_error(ER_XAER_RMFAIL, MYF(0), xid_state->state_name());
    return true;
  }

  if (!xid_state->has_same_xid(m_xid)) {
    my_error(ER_XAER_NOTA, MYF(0));
    return true;
  }

  if (thd->slave_thread && is_transaction_empty(thd)) {
    my_error(ER_XA_REPLICATION_FILTERS,
             MYF(0));  // Empty XA transactions not allowed
    return true;
  }

  auto rollback_xa_tran = create_scope_guard([&]() {
#ifdef HAVE_PSI_TRANSACTION_INTERFACE
    assert(thd->m_transaction_psi == nullptr);
#endif

    // Reset rm_error in case ha_xa_prepare() returned error,
    // so thd->transaction.xid structure gets reset
    // by THD::transaction::cleanup().
    xid_state->reset_error();
    cleanup_trans_state(thd);
    xid_state->reset();
    tran->cleanup();
    my_error(ER_XA_RBROLLBACK, MYF(0));
  });

  /*
    Acquire metadata lock which will ensure that XA PREPARE is blocked
    by active FLUSH TABLES WITH READ LOCK (and vice versa PREPARE in
    progress blocks FTWRL). This is to avoid binlog and redo entries
    while a backup is in progress.
  */
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  if (DBUG_EVALUATE_IF("xaprep_mdl_fail", true, false) ||
      thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    // Rollback the transaction if lock failed.
    ha_rollback_trans(thd, true);
    return true;
  }

  // For ha_xa_prepare() failure scenarios, transaction is already
  // rolled back by ha_xa_prepare().
  if (DBUG_EVALUATE_IF("xaprep_ha_xa_prepare_fail",
                       (ha_rollback_trans(thd, true), true), false) ||
      ::process_xa_prepare(thd))
    return true;

  xid_state->set_state(XID_STATE::XA_PREPARED);
  MYSQL_SET_TRANSACTION_XA_STATE(thd->m_transaction_psi,
                                 (int)xid_state->get_state());
  if (thd->rpl_thd_ctx.session_gtids_ctx().notify_after_xa_prepare(thd))
    LogErr(WARNING_LEVEL, ER_TRX_GTID_COLLECT_REJECT);

  // Use old style prepare unless xa_detach_on_prepare==true
  if (!is_xa_tran_detached_on_prepare(thd)) {
    rollback_xa_tran.commit();
    return thd->is_error();
  }
  // If xa_detach_on_prepare==true, detach the transaction and clean-up session
  if (::detach_xa_transaction(thd)) return true;
  rollback_xa_tran.commit();
  ::reset_xa_connection(thd);

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/xa/sql_xa_rollback.cc
Function: Sql_cmd_xa_rollback::process_attached_xa_rollback 
bool Sql_cmd_xa_rollback::process_attached_xa_rollback(THD *thd) const {
  DBUG_TRACE;
  auto xid_state = thd->get_transaction()->xid_state();

  if (xid_state->has_state(XID_STATE::XA_NOTR) ||
      xid_state->has_state(XID_STATE::XA_ACTIVE)) {
    my_error(ER_XAER_RMFAIL, MYF(0), xid_state->state_name());
    return true;
  }

  /*
    Acquire metadata lock which will ensure that XA ROLLBACK is blocked
    by active FLUSH TABLES WITH READ LOCK (and vice versa ROLLBACK in
    progress blocks FTWRL). This is to avoid binlog and redo entries
    while a backup is in progress.
  */
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    /*
      We can't rollback an XA transaction on lock failure due to
      Innodb redo log and bin log update is involved in rollback.
      Return error to user for a retry.
    */
    my_error(ER_XAER_RMERR, MYF(0));
    return true;
  }

  bool gtid_error = false;
  bool need_clear_owned_gtid = false;
  std::tie(gtid_error, need_clear_owned_gtid) = commit_owned_gtids(thd, true);
  CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP("before_rollback_xa_trx");
  bool res = xa_trans_force_rollback(thd) || gtid_error;
  gtid_state_commit_or_rollback(thd, need_clear_owned_gtid, !gtid_error);
  // todo: report a bug in that the raised rm_error in this branch
  //       is masked unlike the detached rollback branch above.
  DBUG_EXECUTE_IF("simulate_xa_rm_error", {
    my_error(ER_XA_RBROLLBACK, MYF(0));
    res = true;
  });

  cleanup_trans_state(thd);

  xid_state->set_state(XID_STATE::XA_NOTR);
  xid_state->unset_binlogged();
  trans_track_end_trx(thd);
  /* The transaction should be marked as complete in P_S. */
  assert(thd->m_transaction_psi == nullptr);
  return res;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/event_scheduler.cc
Function: pre_init_event_thread
void pre_init_event_thread(THD *thd) {
  DBUG_TRACE;
  thd->security_context()->set_master_access(0);
  thd->security_context()->cache_current_db_access(0);
  thd->security_context()->set_host_or_ip_ptr(my_localhost,
                                              strlen(my_localhost));
  thd->get_protocol_classic()->init_net(nullptr);
  thd->security_context()->set_user_ptr(STRING_WITH_LEN("event_scheduler"));
  thd->get_protocol_classic()->get_net()->read_timeout = replica_net_timeout;
  thd->slave_thread = false;
  thd->variables.option_bits |= OPTION_AUTO_IS_NULL;
  thd->get_protocol_classic()->set_client_capabilities(CLIENT_MULTI_RESULTS);

  thd->set_new_thread_id();

  /*
    Guarantees that we will see the thread in SHOW PROCESSLIST though its
    vio is NULL.
  */

  thd->set_proc_info("Initialized");
  thd->set_time();

  /* Do not use user-supplied timeout value for system threads. */
  thd->variables.lock_wait_timeout = LONG_TIMEOUT;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/event_scheduler.cc
Function: Event_worker_thread::run
void Event_worker_thread::run(THD *thd, Event_queue_element_for_exec *event) {
  /* needs to be first for thread_stack */
  char my_stack;
  Event_job_data job_data;
  bool res;

  assert(thd->m_digest == nullptr);

  thd->thread_stack = &my_stack;  // remember where our stack is
  res = post_init_event_thread(thd);

  DBUG_TRACE;
  DBUG_PRINT("info", ("Time is %ld, THD: %p", (long)time(nullptr), thd));

  if (res) {
    delete event;
    deinit_event_thread(thd);
    return;
  }

  mysql_thread_set_secondary_engine(false);

#ifdef HAVE_PSI_STATEMENT_INTERFACE
  PSI_thread *thread = thd_get_psi(thd);
  if (thread != nullptr) {
    PSI_THREAD_CALL(detect_telemetry)(thread);
  }

  PSI_statement_locker_state state;
  assert(thd->m_statement_psi == nullptr);
  thd->m_statement_psi = MYSQL_START_STATEMENT(
      &state, event->get_psi_info()->m_key, event->dbname.str,
      event->dbname.length, thd->charset(), nullptr);
#endif
  /*
    We must make sure the schema is released and unlocked in the right
    order. Fail if we are unable to get a meta data lock on the schema
    name. Separate scope so that the Schema_MDL_locker dtor is run before
    thd is deleted.
  */
  {
    dd::Schema_MDL_locker mdl_handler(thd);
    if (mdl_handler.ensure_locked(event->dbname.str)) goto end;

    MDL_key mdl_key;
    dd::Event::create_mdl_key(event->dbname.str, event->name.str, &mdl_key);

    MDL_request event_mdl_request;
    MDL_REQUEST_INIT_BY_KEY(&event_mdl_request, &mdl_key, MDL_SHARED,
                            MDL_EXPLICIT);
    if (thd->mdl_context.acquire_lock(&event_mdl_request,
                                      thd->variables.lock_wait_timeout)) {
      DBUG_PRINT("error", ("Got error in getting MDL locks"));
      goto end;
    }

    if ((res = Event_db_repository::load_named_event(thd, event->dbname,
                                                     event->name, &job_data))) {
      DBUG_PRINT("error", ("Got error from load_named_event"));
      thd->mdl_context.release_lock(event_mdl_request.ticket);
      goto end;
    }
    thd->mdl_context.release_lock(event_mdl_request.ticket);
  }  // End scope so that schema metadata lock is released.

  thd->enable_slow_log = true;

  res = job_data.execute(thd, event->dropped);

  print_warnings(thd, &job_data);

  if (res)
    LogErr(INFORMATION_LEVEL, ER_EVENT_EXECUTION_FAILED, job_data.m_definer.str,
           job_data.m_schema_name.str, job_data.m_event_name.str);

end:
#ifdef HAVE_PSI_STATEMENT_INTERFACE
  MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());
  thd->m_statement_psi = nullptr;
#endif

  assert(thd->m_digest == nullptr);

  DBUG_PRINT("info",
             ("Done with Event %s.%s", event->dbname.str, event->name.str));

  delete event;
  deinit_event_thread(thd);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/server_component/mysql_system_variable_update_imp.cc
Function: prepare_thread_and_validate 
static bool prepare_thread_and_validate(Set_variables_helper &hlp,
                                        const char *variable_type,
                                        my_h_string variable_name,
                                        enum_var_type &var_type) {
  var_type = sysvar_type(variable_type);
  if (var_type == OPT_DEFAULT) var_type = OPT_GLOBAL;

  /* Use either the THD provided or create a temporary one */
  if (hlp.is_auto_thd()) {
    /* A session variable update for a temporary THD has no effect
       and is not supported. */
    if (var_type == OPT_SESSION) {
      String *name = reinterpret_cast<String *>(variable_name);
      LogErr(ERROR_LEVEL, ER_TMP_SESSION_FOR_VAR, name->c_ptr_safe());
      return true;
    }
    /*
      Set a temporary lock wait timeout before updating the system variable.
      Some system variables, such as super-read-only, can be blocked by other
      locks during the update. Should that happen, we don't want to be holding
      LOCK_system_variables_hash.
    */
    hlp.get_thd()->variables.lock_wait_timeout = 5;
  }
  // success
  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_locks_acquire_exclusive 
bool Ndb_dd_client::mdl_locks_acquire_exclusive(const char *schema_name,
                                                const char *table_name,
                                                bool custom_lock_wait,
                                                ulong lock_wait_timeout) {
  MDL_request_list mdl_requests;
  MDL_request schema_request;
  MDL_request mdl_request;
  MDL_request backup_lock_request;
  MDL_request grl_request;

  // If we cannot acquire protection against GRL, err out early.
  if (m_thd->global_read_lock.can_acquire_protection()) return false;

  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, schema_name, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, schema_name, table_name,
                   MDL_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&grl_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);

  mdl_requests.push_front(&schema_request);
  mdl_requests.push_front(&mdl_request);
  mdl_requests.push_front(&backup_lock_request);
  mdl_requests.push_front(&grl_request);

  if (!custom_lock_wait) {
    lock_wait_timeout = m_thd->variables.lock_wait_timeout;
  }

  if (!mdl_locks_acquire(mdl_requests, lock_wait_timeout)) {
    return false;
  }

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(m_thd, true)) return false;

  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_table 
bool Ndb_dd_client::mdl_lock_table(const char *schema_name,
                                   const char *table_name) {
  MDL_request_list mdl_requests;
  MDL_request schema_request;
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, schema_name, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, schema_name, table_name,
                   MDL_SHARED, MDL_EXPLICIT);

  mdl_requests.push_front(&schema_request);
  mdl_requests.push_front(&mdl_request);

  if (!mdl_locks_acquire(mdl_requests, m_thd->variables.lock_wait_timeout)) {
    return false;
  }

  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_schema_exclusive 
bool Ndb_dd_client::mdl_lock_schema_exclusive(const char *schema_name,
                                              bool custom_lock_wait,
                                              ulong lock_wait_timeout) {
  MDL_request_list mdl_requests;
  MDL_request schema_request;
  MDL_request backup_lock_request;
  MDL_request grl_request;

  // If protection against GRL can't be acquired, err out early.
  if (m_thd->global_read_lock.can_acquire_protection()) {
    return false;
  }

  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, schema_name, "",
                   MDL_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&grl_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);

  mdl_requests.push_front(&schema_request);
  mdl_requests.push_front(&backup_lock_request);
  mdl_requests.push_front(&grl_request);

  if (!custom_lock_wait) {
    lock_wait_timeout = m_thd->variables.lock_wait_timeout;
  }

  if (!mdl_locks_acquire(mdl_requests, lock_wait_timeout)) {
    return false;
  }

  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_schema
bool Ndb_dd_client::mdl_lock_schema(const char *schema_name) {
  MDL_request_list mdl_requests;
  MDL_request schema_request;

  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, schema_name, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  mdl_requests.push_front(&schema_request);

  if (!mdl_locks_acquire(mdl_requests, m_thd->variables.lock_wait_timeout)) {
    return false;
  }

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(m_thd, true)) return false;

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_logfile_group_exclusive 
bool Ndb_dd_client::mdl_lock_logfile_group_exclusive(
    const char *logfile_group_name, bool custom_lock_wait,
    ulong lock_wait_timeout) {
  MDL_request_list mdl_requests;
  MDL_request logfile_group_request;
  MDL_request backup_lock_request;
  MDL_request grl_request;

  // If protection against GRL can't be acquired, err out early.
  if (m_thd->global_read_lock.can_acquire_protection()) {
    return false;
  }

  MDL_REQUEST_INIT(&logfile_group_request, MDL_key::TABLESPACE, "",
                   logfile_group_name, MDL_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&grl_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);

  mdl_requests.push_front(&logfile_group_request);
  mdl_requests.push_front(&backup_lock_request);
  mdl_requests.push_front(&grl_request);

  if (!custom_lock_wait) {
    lock_wait_timeout = m_thd->variables.lock_wait_timeout;
  }

  if (!mdl_locks_acquire(mdl_requests, lock_wait_timeout)) {
    return false;
  }

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(m_thd, true)) return false;

  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_logfile_group 
bool Ndb_dd_client::mdl_lock_logfile_group(const char *logfile_group_name,
                                           bool intention_exclusive) {
  MDL_request_list mdl_requests;
  MDL_request logfile_group_request;

  enum_mdl_type mdl_type =
      intention_exclusive ? MDL_INTENTION_EXCLUSIVE : MDL_SHARED_READ;
  MDL_REQUEST_INIT(&logfile_group_request, MDL_key::TABLESPACE, "",
                   logfile_group_name, mdl_type, MDL_EXPLICIT);

  mdl_requests.push_front(&logfile_group_request);

  if (!mdl_locks_acquire(mdl_requests, m_thd->variables.lock_wait_timeout)) {
    return false;
  }

  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_tablespace_exclusive 
bool Ndb_dd_client::mdl_lock_tablespace_exclusive(const char *tablespace_name,
                                                  bool custom_lock_wait,
                                                  ulong lock_wait_timeout) {
  MDL_request_list mdl_requests;
  MDL_request tablespace_request;
  MDL_request backup_lock_request;
  MDL_request grl_request;

  // If protection against GRL can't be acquired, err out early.
  if (m_thd->global_read_lock.can_acquire_protection()) {
    return false;
  }

  MDL_REQUEST_INIT(&tablespace_request, MDL_key::TABLESPACE, "",
                   tablespace_name, MDL_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&grl_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);

  mdl_requests.push_front(&tablespace_request);
  mdl_requests.push_front(&backup_lock_request);
  mdl_requests.push_front(&grl_request);

  if (!custom_lock_wait) {
    lock_wait_timeout = m_thd->variables.lock_wait_timeout;
  }

  if (!mdl_locks_acquire(mdl_requests, lock_wait_timeout)) {
    return false;
  }

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(m_thd, true)) return false;

  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_tablespace 
bool Ndb_dd_client::mdl_lock_tablespace(const char *tablespace_name,
                                        bool intention_exclusive) {
  MDL_request_list mdl_requests;
  MDL_request tablespace_request;

  enum_mdl_type mdl_type =
      intention_exclusive ? MDL_INTENTION_EXCLUSIVE : MDL_SHARED_READ;
  MDL_REQUEST_INIT(&tablespace_request, MDL_key::TABLESPACE, "",
                   tablespace_name, mdl_type, MDL_EXPLICIT);

  mdl_requests.push_front(&tablespace_request);

  if (!mdl_locks_acquire(mdl_requests, m_thd->variables.lock_wait_timeout)) {
    return false;
  }

  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_geofunc_internal.cc
Function: Srs_fetcher::lock
bool Srs_fetcher::lock(gis::srid_t srid, enum_mdl_type lock_type) {
  DBUG_TRACE;
  assert(srid != 0);

  char id_str[11];  // uint32 => max 10 digits + \0
  longlong10_to_str(srid, id_str, 10);

  MDL_request mdl_request;
  mdl_request.init_with_source(MDL_key::SRID, "", id_str, lock_type,
                               MDL_TRANSACTION, __FILE__, __LINE__);
  if (m_thd->mdl_context.acquire_lock(&mdl_request,
                                      m_thd->variables.lock_wait_timeout)) {
    /* purecov: begin inspected */
    // If locking fails, an error has already been flagged.
    return true;
    /* purecov: end */
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_rli.cc
Function: MDL_lock_guard::lock 
bool MDL_lock_guard::lock(MDL_key::enum_mdl_namespace namespace_arg,
                          enum_mdl_type mdl_type_arg, bool blocking) {
  DBUG_TRACE;
  if (this->m_target != nullptr &&
      !this->m_target->mdl_context.has_locks(namespace_arg)) {
    MDL_REQUEST_INIT(&this->m_request, namespace_arg, "", "", mdl_type_arg,
                     MDL_EXPLICIT);

    if (blocking)
      this->m_target->mdl_context.acquire_lock(
          &this->m_request, this->m_target->variables.lock_wait_timeout);
    else
      this->m_target->mdl_context.try_acquire_lock(&this->m_request);

    return !this->is_locked();
  }
  return true;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: init_replica_thread
int init_replica_thread(THD *thd, SLAVE_THD_TYPE thd_type) {
  DBUG_TRACE;
#if !defined(NDEBUG)
  int simulate_error = 0;
#endif
  thd->system_thread = (thd_type == SLAVE_THD_WORKER)
                           ? SYSTEM_THREAD_SLAVE_WORKER
                           : (thd_type == SLAVE_THD_SQL)
                                 ? SYSTEM_THREAD_SLAVE_SQL
                                 : SYSTEM_THREAD_SLAVE_IO;
  thd->get_protocol_classic()->init_net(nullptr);
  thd->slave_thread = true;
  thd->enable_slow_log = opt_log_slow_replica_statements;
  set_slave_thread_options(thd);

  /*
    Replication threads are:
    - background threads in the server, not user sessions,
    - yet still assigned a PROCESSLIST_ID,
      for historical reasons (displayed in SHOW PROCESSLIST).
  */
  thd->set_new_thread_id();

#ifdef HAVE_PSI_THREAD_INTERFACE
  /*
    Populate the PROCESSLIST_ID in the instrumentation.
  */
  struct PSI_thread *psi = PSI_THREAD_CALL(get_thread)();
  PSI_THREAD_CALL(set_thread_id)(psi, thd->thread_id());
#endif /* HAVE_PSI_THREAD_INTERFACE */

  DBUG_EXECUTE_IF("simulate_io_replica_error_on_init",
                  simulate_error |= (1 << SLAVE_THD_IO););
  DBUG_EXECUTE_IF("simulate_sql_replica_error_on_init",
                  simulate_error |= (1 << SLAVE_THD_SQL););
  thd->store_globals();
#if !defined(NDEBUG)
  if (simulate_error & (1 << thd_type)) {
    return -1;
  }
#endif

  if (thd_type == SLAVE_THD_SQL) {
    THD_STAGE_INFO(thd, stage_waiting_for_the_next_event_in_relay_log);
    thd->set_command(
        COM_QUERY);  // the SQL thread does not use the server protocol
  } else {
    THD_STAGE_INFO(thd, stage_waiting_for_source_update);
  }
  thd->set_time();
  /* Do not use user-supplied timeout value for system threads. */
  thd->variables.lock_wait_timeout = LONG_TIMEOUT;
  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_schema.cc
Function: dd::mdl_lock_schema 
bool mdl_lock_schema(THD *thd, const char *schema_name,
                     enum_mdl_duration duration, MDL_ticket **ticket) {
  /*
    Make sure we have at least an IX lock on the schema name.
    Acquire a lock unless we already have it.
  */
  char name_buf[NAME_LEN + 1];
  const char *converted_name = schema_name;
  if (lower_case_table_names == 2) {
    // Lower case table names == 2 is tested on OSX.
    /* purecov: begin tested */
    my_stpcpy(name_buf, converted_name);
    my_casedn_str(&my_charset_utf8mb3_tolower_ci, name_buf);
    converted_name = name_buf;
    /* purecov: end */
  }

  // If we do not already have one, acquire a new lock.
  if (thd->mdl_context.owns_equal_or_stronger_lock(
          MDL_key::SCHEMA, converted_name, "", MDL_INTENTION_EXCLUSIVE)) {
    return false;
  }

  // Create a request for an IX_lock on the converted schema name.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::SCHEMA, converted_name, "",
                   MDL_INTENTION_EXCLUSIVE, duration);

  /*
    Acquire the lock request created above, and check if
    acquisition fails (e.g. timeout or deadlock).
  */
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    assert(thd->is_system_thread() || thd->killed || thd->is_error());
    return true;
  }
  if (ticket != nullptr) {
    *ticket = mdl_request.ticket;
  }
  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_shared_table_mdl 
bool acquire_shared_table_mdl(THD *thd, const char *schema_name,
                              const char *table_name, bool no_wait,
                              MDL_ticket **out_mdl_ticket) {
  return acquire_shared_mdl(thd, MDL_key::TABLE, schema_name, table_name,
                            no_wait, thd->variables.lock_wait_timeout,
                            MDL_EXPLICIT, out_mdl_ticket);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_exclusive_tablespace_mdl 
bool acquire_exclusive_tablespace_mdl(THD *thd, const char *tablespace_name,
                                      bool no_wait, MDL_ticket **ticket,
                                      bool for_trx) {
  enum_mdl_duration duration = (for_trx ? MDL_TRANSACTION : MDL_EXPLICIT);
  return acquire_exclusive_mdl(thd, MDL_key::TABLESPACE, "", tablespace_name,
                               no_wait, thd->variables.lock_wait_timeout,
                               duration, ticket);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_shared_tablespace_mdl 
bool acquire_shared_tablespace_mdl(THD *thd, const char *tablespace_name,
                                   bool no_wait, MDL_ticket **ticket,
                                   bool for_trx) {
  // When requesting a tablespace name lock, we leave the schema name empty.
  enum_mdl_duration duration = (for_trx ? MDL_TRANSACTION : MDL_EXPLICIT);
  return acquire_shared_mdl(thd, MDL_key::TABLESPACE, "", tablespace_name,
                            no_wait, thd->variables.lock_wait_timeout, duration,
                            ticket);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_exclusive_table_mdl 
bool acquire_exclusive_table_mdl(THD *thd, const char *schema_name,
                                 const char *table_name, bool no_wait,
                                 MDL_ticket **out_mdl_ticket) {
  return acquire_exclusive_mdl(thd, MDL_key::TABLE, schema_name, table_name,
                               no_wait, thd->variables.lock_wait_timeout,
                               MDL_TRANSACTION, out_mdl_ticket);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_exclusive_table_mdl 
bool acquire_exclusive_table_mdl(THD *thd, const char *schema_name,
                                 const char *table_name,
                                 unsigned long int lock_wait_timeout,
                                 MDL_ticket **out_mdl_ticket) {
  return acquire_exclusive_mdl(thd, MDL_key::TABLE, schema_name, table_name,
                               false, lock_wait_timeout, MDL_TRANSACTION,
                               out_mdl_ticket);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_exclusive_schema_mdl 
bool acquire_exclusive_schema_mdl(THD *thd, const char *schema_name,
                                  bool no_wait, MDL_ticket **out_mdl_ticket) {
  return acquire_exclusive_mdl(thd, MDL_key::SCHEMA, schema_name, "", no_wait,
                               thd->variables.lock_wait_timeout, MDL_EXPLICIT,
                               out_mdl_ticket);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::create_native_table 
bool create_native_table(THD *thd, const Plugin_table *pt) {
  if (dd::get_dictionary()->is_dd_table_name(pt->get_schema_name(),
                                             pt->get_name())) {
    my_error(ER_NO_SYSTEM_TABLE_ACCESS, MYF(0),
             ER_THD_NONCONST(thd, dd::get_dictionary()->table_type_error_code(
                                      pt->get_schema_name(), pt->get_name())),
             pt->get_schema_name(), pt->get_name());

    return true;
  }

  // Acquire MDL on new native table that we would create.
  bool error = false;
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, pt->get_schema_name(),
                   pt->get_name(), MDL_EXCLUSIVE, MDL_TRANSACTION);
  dd::Schema_MDL_locker mdl_locker(thd);
  if (mdl_locker.ensure_locked(pt->get_schema_name()) ||
      thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  /*
    1. Mark that we are executing a special DDL during
    plugin initialization. This will enable DDL to not be
    committed or binlogged. The called of this API would commit
    the transaction.

    2. Remove metadata of native table if already exists. This could
    happen if server was crashed and restarted.

    3. Create native table.

    4. Undo 1.
  */
  dd::cache::Dictionary_client *client = thd->dd_client();
  const dd::Table *table_def = nullptr;
  if (client->acquire(pt->get_schema_name(), pt->get_name(), &table_def))
    return true;

  thd->mark_plugin_fake_ddl(true);
  ulong master_access = thd->security_context()->master_access();
  thd->security_context()->set_master_access(~(ulong)0);
  {
    Disable_binlog_guard guard(thd);

    // Drop the table and related dynamic statistics too.
    if (table_def) {
      error =
          client->drop(table_def) || client->remove_table_dynamic_statistics(
                                         pt->get_schema_name(), pt->get_name());
    }

    if (!error) error = dd::execute_query(thd, pt->get_ddl());
  }

  thd->security_context()->set_master_access(master_access);
  thd->mark_plugin_fake_ddl(false);

  return error;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::drop_native_table 
bool drop_native_table(THD *thd, const char *schema_name,
                       const char *table_name) {
  if (dd::get_dictionary()->is_dd_table_name(schema_name, table_name)) {
    my_error(ER_NO_SYSTEM_TABLE_ACCESS, MYF(0),
             ER_THD_NONCONST(thd, dd::get_dictionary()->table_type_error_code(
                                      schema_name, table_name)),
             schema_name, table_name);

    return true;
  }

  // Acquire MDL on schema and table.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, schema_name, table_name,
                   MDL_EXCLUSIVE, MDL_TRANSACTION);
  dd::Schema_MDL_locker mdl_locker(thd);
  if (mdl_locker.ensure_locked(schema_name) ||
      thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  dd::cache::Dictionary_client *client = thd->dd_client();
  const dd::Table *table_def = nullptr;
  if (client->acquire(schema_name, table_name, &table_def)) {
    // Error is reported by the dictionary subsystem.
    return true;
  }

  // Not error is reported if table is not present.
  if (!table_def) return false;

  // Drop the table and related dynamic statistics too.
  return client->drop(table_def) ||
         client->remove_table_dynamic_statistics(schema_name, table_name);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map<T>::reset
template <typename T>
bool Shared_multi_map<T>::reset(THD *thd) {
  /*
    Establish a map from schema ids to schema names. Must do this
    before we can lock the cache partition.
  */
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  std::vector<const Schema *> schema_vector;
  if (thd->dd_client()->fetch_global_components(&schema_vector)) return true;

  schema_map_t schema_map;
  for (const Schema *schema : schema_vector)
    schema_map.insert(
        typename schema_map_t::value_type(schema->id(), schema->name()));

  // Now, we can lock the cache partition and start acquiring MDL.
  Autolocker lock(this);
  MDL_request_list mdl_requests;
  typename Element_map<const T *, Cache_element<T>>::Const_iterator it =
      m_map<const T *>()->begin();
  for (; it != m_map<const T *>()->end(); it++)
    mdl_requests.push_front(
        lock_request(thd, schema_map, it->second->object()));

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  /*
    We have now locked all objects, hence, once we evict the unused
    object, no objects should be left.
  */
  evict_all_unused(&lock);
  if (m_map<const T *>()->size() > 0) {
    dump();
    assert(m_map<const T *>()->size() == 0);
    return true;
  }

  return false;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/upgrade/server.cc
Function: dd::upgrade:: not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/info_schema/metadata.cc
Function: dd::info_schema::remove_I_S_view_metadata 
bool remove_I_S_view_metadata(THD *thd, const dd::String_type &view_name) {
  // Make sure you have lock on I_S schema.
  Schema_MDL_locker mdl_locker(thd);
  if (mdl_locker.ensure_locked(INFORMATION_SCHEMA_NAME.str)) return true;

  // Acquire exclusive lock on it before dropping.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, INFORMATION_SCHEMA_NAME.str,
                   view_name.c_str(), MDL_EXCLUSIVE, MDL_TRANSACTION);
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return (true);

  // Acquire the object.
  const dd::Abstract_table *at = nullptr;
  if (thd->dd_client()->acquire(INFORMATION_SCHEMA_NAME.str, view_name.c_str(),
                                &at))
    return (true);

  assert(at->type() == dd::enum_table_type::SYSTEM_VIEW);

  // Remove view from DD tables.
  Implicit_substatement_state_guard substatement_guard(thd);
  if (thd->dd_client()->drop(at)) {
    assert(thd->is_system_thread() || thd->killed || thd->is_error());
    return (true);
  }

  return (false);
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/info_schema/table_stats.cc
Function: dd::info_schema::Table_statistics::read_stat_from_SE 
ulonglong Table_statistics::read_stat_from_SE(
    THD *thd, const String &schema_name_ptr, const String &table_name_ptr,
    const String &index_name_ptr, const String &column_name_ptr,
    uint index_ordinal_position, uint column_ordinal_position,
    Object_id se_private_id, const char *ts_se_private_data,
    const char *tbl_se_private_data, enum_table_stats_type stype,
    handlerton *hton) {
  DBUG_TRACE;

  ulonglong return_value = 0;

  DBUG_EXECUTE_IF("information_schema_fetch_table_stats",
                  assert(strncmp(table_name_ptr.ptr(), "fts", 3)););

  // No engines implement these statistics retrieval. We always return zero.
  if (stype == enum_table_stats_type::CHECK_TIME ||
      stype == enum_table_stats_type::CHECKSUM)
    return 0;

  //
  // Get statistics from SE
  //
  ha_statistics ha_stat;
  uint error = 0;

  // Acquire MDL_EXPLICIT lock on table.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, schema_name_ptr.ptr(),
                   table_name_ptr.ptr(), MDL_SHARED_HIGH_PRIO, MDL_EXPLICIT);

  // Push deadlock error handler
  Info_schema_error_handler info_schema_error_handler(thd, &schema_name_ptr,
                                                      &table_name_ptr);
  thd->push_internal_handler(&info_schema_error_handler);
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    error = -1;
  }
  thd->pop_internal_handler();

  DEBUG_SYNC(thd, "after_acquiring_mdl_shared_to_fetch_stats");

  if (error == 0) {
    error = -1;

    // Prepare dd::Properties objects for se_private_data and send it to SE.
    std::unique_ptr<dd::Properties> ts_se_private_data_obj(
        dd::Properties::parse_properties(ts_se_private_data ? ts_se_private_data
                                                            : ""));
    std::unique_ptr<dd::Properties> tbl_se_private_data_obj(
        dd::Properties::parse_properties(
            tbl_se_private_data ? tbl_se_private_data : ""));

    assert(tbl_se_private_data_obj.get() && ts_se_private_data_obj.get());

    //
    // Read statistics from SE
    //
    return_value = -1;

    if (stype == enum_table_stats_type::INDEX_COLUMN_CARDINALITY &&
        !hton->get_index_column_cardinality(
            schema_name_ptr.ptr(), table_name_ptr.ptr(), index_name_ptr.ptr(),
            index_ordinal_position, column_ordinal_position, se_private_id,
            &return_value)) {
      error = 0;
    } else if (!hton->get_table_statistics(
                   schema_name_ptr.ptr(), table_name_ptr.ptr(), se_private_id,
                   *ts_se_private_data_obj.get(),
                   *tbl_se_private_data_obj.get(),
                   HA_STATUS_VARIABLE | HA_STATUS_TIME |
                       HA_STATUS_VARIABLE_EXTRA | HA_STATUS_AUTO,
                   &ha_stat)) {
      error = 0;
    }

    // Release the lock we got
    thd->mdl_context.release_lock(mdl_request.ticket);
  }

  // Cache and return the statistics
  if (error == 0) {
    if (stype != enum_table_stats_type::INDEX_COLUMN_CARDINALITY) {
      cache_stats_in_mem(schema_name_ptr, table_name_ptr, ha_stat);

      /*
        Update table statistics in the cache.
        All engines return ZERO for checksum, we hardcode it here.
      */
      if (can_persist_I_S_dynamic_statistics(thd, schema_name_ptr.ptr(),
                                             nullptr) &&
          persist_i_s_table_stats(thd, m_stats, schema_name_ptr, table_name_ptr,
                                  0)) {
        error = -1;
      } else
        return_value = get_stat(ha_stat, stype);

    }
    /*
      Only cardinality is not stored in the cache.
      Update index statistics in the mysql.index_stats.
    */
    else if (can_persist_I_S_dynamic_statistics(thd, schema_name_ptr.ptr(),
                                                nullptr) &&
             persist_i_s_index_stats(thd, schema_name_ptr, table_name_ptr,
                                     index_name_ptr, column_name_ptr,
                                     return_value)) {
      error = -1;
    }

    if (error == 0) return return_value;
  }

  // If we have a error, push a warning and clear the DA.
  if (thd->is_error()) {
    /*
      Hide error for a non-existing table.
      For example, this error can occur when we use a where condition
      with a db name and table, but the table does not exist.
     */
    if (!(thd->get_stmt_da()->mysql_errno() == ER_NO_SUCH_TABLE) &&
        !(thd->get_stmt_da()->mysql_errno() == ER_WRONG_OBJECT))
      push_warning(thd, Sql_condition::SL_WARNING,
                   thd->get_stmt_da()->mysql_errno(),
                   thd->get_stmt_da()->message_text());

    store_error_message(schema_name_ptr, table_name_ptr, nullptr,
                        thd->get_stmt_da()->message_text());
    thd->clear_error();
  }

  return error;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::Upgrade_MDL_guard::acquire_lock_tablespace 
bool acquire_lock_tablespace(Tablespace_hash_set *tablespace_names) {
    m_tablespace_lock = true;
    return lock_tablespace_names(m_thd, tablespace_names,
                                 m_thd->variables.lock_wait_timeout,
                                 m_thd->mem_root);
  }

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/dict/dict0dd.cc
Function: dd_tablespace_get_mdl 
bool dd_tablespace_get_mdl(const char *space_name, MDL_ticket **mdl_ticket,
                           bool foreground) {
  THD *thd = current_thd;
  /* Safeguard in release mode if background thread doesn't have THD. */
  if (thd == nullptr) {
    ut_d(ut_error);
    ut_o(return true);
  }
  /* Explicit duration for background threads. */
  bool trx_duration = foreground;

  /* Background thread should not block on MDL lock. */
  ulong timeout = foreground ? thd->variables.lock_wait_timeout : 0;
  bool result = acquire_shared_backup_lock(thd, timeout, trx_duration);

  if (!result) {
    result = dd::acquire_exclusive_tablespace_mdl(thd, space_name, false,
                                                  mdl_ticket, trx_duration);
    if (result) {
      release_backup_lock(thd);
    }
  }

  /* For background thread, clear timeout error. */
  if (result && !foreground && thd->is_error()) {
    thd->clear_error();
  }
  return result;
}

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_schema_event_handler::Lock_wait_timeout_guard::Lock_wait_timeout_guard 
Lock_wait_timeout_guard(THD *thd, ulong lock_wait_timeout)
        : m_thd(thd),
          m_save_lock_wait_timeout(thd->variables.lock_wait_timeout) {
      m_thd->variables.lock_wait_timeout = lock_wait_timeout;
    }

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_schema_event_handler::Lock_wait_timeout_guard:: ~Lock_wait_timeout_guard
 ~Lock_wait_timeout_guard() {
      m_thd->variables.lock_wait_timeout = m_save_lock_wait_timeout;
    }

