-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/mysqld.cc
Function: do_create_native_table_for_pfs
bool do_create_native_table_for_pfs(THD *thd, const Plugin_table *t) {
  const char *schema_name = t->get_schema_name();
  const char *table_name = t->get_name();
  MDL_request table_request;
  MDL_REQUEST_INIT(&table_request, MDL_key::TABLE, schema_name, table_name,
                   MDL_EXCLUSIVE, MDL_TRANSACTION);

  if (thd->mdl_context.acquire_lock(&table_request,
                                    thd->variables.lock_wait_timeout)) {
    /* Error, failed to get MDL lock. */
    return true;
  }

  tdc_remove_table(thd, TDC_RT_REMOVE_ALL, schema_name, table_name, false);

  if (dd::create_native_table(thd, t)) {
    /* Error, failed to create DD table. */
    return true;
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/mysqld.cc
Function: do_drop_native_table_for_pfs not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/mysqld.cc
Function: do_drop_native_table_for_pfs not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_mgr.cc
Function: resourcegroups::Resource_group_mgr::acquire_shared_mdl_for_resource_group
bool Resource_group_mgr::acquire_shared_mdl_for_resource_group(
    THD *thd, const char *res_grp_name, enum_mdl_duration lock_duration,
    MDL_ticket **ticket, bool try_acquire) {
  DBUG_TRACE;

  MDL_key mdl_key;
  dd::Resource_group::create_mdl_key(res_grp_name, &mdl_key);

  MDL_request mdl_request;
  MDL_REQUEST_INIT_BY_KEY(&mdl_request, &mdl_key, MDL_INTENTION_EXCLUSIVE,
                          lock_duration);

  bool res = try_acquire ? thd->mdl_context.acquire_lock(&mdl_request, 0)
                         : thd->mdl_context.acquire_lock(
                               &mdl_request, thd->variables.lock_wait_timeout);
  if (!res && ticket != nullptr) *ticket = mdl_request.ticket;

  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: wait_while_table_is_used
bool wait_while_table_is_used(THD *thd, TABLE *table,
                              enum ha_extra_function function) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("table: '%s'  share: %p  db_stat: %u  version: %lu",
                       table->s->table_name.str, table->s, table->db_stat,
                       table->s->version()));

  if (thd->mdl_context.upgrade_shared_lock(table->mdl_ticket, MDL_EXCLUSIVE,
                                           thd->variables.lock_wait_timeout))
    return true;

  tdc_remove_table(thd, TDC_RT_REMOVE_NOT_OWN, table->s->db.str,
                   table->s->table_name.str, false);
  /* extra() call must come only after all instances above are closed */
  (void)table->file->ha_extra(function);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: read_histograms not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: read_histograms not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_table
      It can be useful in situation when call to open_table()
      fails because some error which was suppressed by another
      error handler (e.g. in case of MDL deadlock which we
      decided to solve by back-off and retry).
    */
    return (m_handled_errors && (!m_unhandled_errors));
  }

 private:
  bool m_handled_errors;
  bool m_unhandled_errors;
};

/**
  @defgroup Data_Dictionary Data Dictionary
  @{
*/

/**
  LOCK_open protects the following variables/objects:

  1) The table_def_cache
     This is the hash table mapping table name to a table
     share object. The hash table can only be manipulated
     while holding LOCK_open.
  2) last_table_id
     Generation of a new unique table_map_id for a table
     share is done through incrementing last_table_id, a
     global variable used for this purpose.
  3) LOCK_open protects the initialisation of the table share
     object and all its members, however, it does not protect
     reading the .frm file from where the table share is
     initialised. In get_table_share, the lock is temporarily
     released while opening the table definition in order to
     allow a higher degree of concurrency. Concurrent access
     to the same share is controlled by introducing a condition
     variable for signaling when opening the share is completed.
  4) In particular the share->ref_count is updated each time
     a new table object is created that refers to a table share.
     This update is protected by LOCK_open.
  5) oldest_unused_share, end_of_unused_share and share->next
     and share->prev are variables to handle the lists of table
     share objects, these can only be read and manipulated while
     holding the LOCK_open mutex.
  6) table_def_shutdown_in_progress can be updated only while
     holding LOCK_open and ALL table cache mutexes.
  7) refresh_version
     This variable can only be updated while holding LOCK_open AND
     all table cache mutexes.
  8) share->version
     This variable is initialised while holding LOCK_open. It can only
     be updated while holding LOCK_open AND all table cache mutexes.
     So if a table share is found through a reference its version won't
     change if any of those mutexes are held.
  9) share->m_flush_tickets
*/

mysql_mutex_t LOCK_open;

/**
  COND_open synchronizes concurrent opening of the same share:

  If a thread calls get_table_share, it releases the LOCK_open
  mutex while reading the definition from file. If a different
  thread calls get_table_share for the same share at this point
  in time, it will find the share in the TDC, but with the
  m_open_in_progress flag set to true. This will make the
  (second) thread wait for the COND_open condition, while the
  first thread completes opening the table definition.

  When the first thread is done reading the table definition,
  it will set m_open_in_progress to false and broadcast the
  COND_open condition. Then, all threads waiting for COND_open
  will wake up and, re-search the TDC for the share, and:

  1) If the share is gone, the thread will continue to allocate
     and open the table definition. This happens, e.g., if the
     first thread failed when opening the table definition and
     had to destroy the share.
  2) If the share is still in the cache, and m_open_in_progress
     is still true, the thread will wait for the condition again.
     This happens if a different thread finished opening a
     different share.
  3) If the share is still in the cache, and m_open_in_progress
     has become false, the thread will check if the share is ok
     (no error), increment the ref counter, and return the share.
*/

mysql_cond_t COND_open;

#ifdef HAVE_PSI_INTERFACE
static PSI_mutex_key key_LOCK_open;
static PSI_cond_key key_COND_open;
static PSI_mutex_info all_tdc_mutexes[] = {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: Open_table_context::Open_table_context
Open_table_context::Open_table_context(THD *thd, uint flags)
    : m_thd(thd),
      m_failed_table(nullptr),
      m_start_of_statement_svp(thd->mdl_context.mdl_savepoint()),
      m_timeout(flags & MYSQL_LOCK_IGNORE_TIMEOUT
                    ? LONG_TIMEOUT
                    : thd->variables.lock_wait_timeout),
      m_flags(flags),
      m_action(OT_NO_ACTION),
      m_has_locks(thd->mdl_context.has_locks()),
      m_has_protection_against_grl(false) {}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: Open_table_context::recover_from_failed_open
bool Open_table_context::recover_from_failed_open() {
  if (m_action == OT_REPAIR) {
    DEBUG_SYNC(m_thd, "recover_ot_repair");
  }

  /*
    Skip repair and discovery in IS-queries as they require X lock
    which could lead to delays or deadlock. Instead set
    ER_WARN_I_S_SKIPPED_TABLE which will be converted to a warning
    later.
   */
  if ((m_action == OT_REPAIR || m_action == OT_DISCOVER ||
       m_action == OT_FIX_ROW_TYPE) &&
      (m_flags & MYSQL_OPEN_FAIL_ON_MDL_CONFLICT)) {
    my_error(ER_WARN_I_S_SKIPPED_TABLE, MYF(0),
             m_failed_table->mdl_request.key.db_name(),
             m_failed_table->mdl_request.key.name());
    return true;
  }

  bool result = false;
  MDL_deadlock_discovery_repair_handler handler;
  /*
    Install error handler to mark transaction to rollback on DEADLOCK error.
  */
  m_thd->push_internal_handler(&handler);

  /* Execute the action. */
  switch (m_action) {
    case OT_BACKOFF_AND_RETRY:
      break;
    case OT_REOPEN_TABLES:
      break;
    case OT_DISCOVER: {
      if ((result = lock_table_names(m_thd, m_failed_table, nullptr,
                                     get_timeout(), 0)))
        break;

      tdc_remove_table(m_thd, TDC_RT_REMOVE_ALL, m_failed_table->db,
                       m_failed_table->table_name, false);
      if (ha_create_table_from_engine(m_thd, m_failed_table->db,
                                      m_failed_table->table_name)) {
        result = true;
        break;
      }

      m_thd->get_stmt_da()->reset_condition_info(m_thd);
      m_thd->clear_error();  // Clear error message
      /*
        Rollback to start of the current statement to release exclusive lock
        on table which was discovered but preserve locks from previous
        statements in current transaction.
      */
      m_thd->mdl_context.rollback_to_savepoint(start_of_statement_svp());
      break;
    }
    case OT_REPAIR: {
      if ((result = lock_table_names(m_thd, m_failed_table, nullptr,
                                     get_timeout(), 0)))
        break;

      tdc_remove_table(m_thd, TDC_RT_REMOVE_ALL, m_failed_table->db,
                       m_failed_table->table_name, false);

      result = auto_repair_table(m_thd, m_failed_table);
      /*
        Rollback to start of the current statement to release exclusive lock
        on table which was discovered but preserve locks from previous
        statements in current transaction.
      */
      m_thd->mdl_context.rollback_to_savepoint(start_of_statement_svp());
      break;
    }
    case OT_FIX_ROW_TYPE: {
      /*
        Since we are going to commit changes to the data-dictionary there
        should not be any ongoing transaction.
        We already have checked that the connection holds no metadata locks
        earlier.
        Still there can be transaction started by START TRANSACTION, which
        we don't have right to implicitly finish (even more interesting case
        is START TRANSACTION WITH CONSISTENT SNAPSHOT). Hence explicit check
        for active transaction.
      */
      assert(!m_thd->mdl_context.has_locks());

      if (m_thd->in_active_multi_stmt_transaction()) {
        my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
        result = true;
        break;
      }

      if ((result = lock_table_names(m_thd, m_failed_table, nullptr,
                                     get_timeout(), 0)))
        break;

      result = fix_row_type(m_thd, m_failed_table);

      m_thd->mdl_context.release_transactional_locks();
      break;
    }
    default:
      assert(0);
  }
  m_thd->pop_internal_handler();
  /*
    Reset the pointers to conflicting MDL request and the
    Table_ref element, set when we need auto-discovery or repair,
    for safety.
  */
  m_failed_table = nullptr;
  /*
    Reset flag indicating that we have already acquired protection
    against GRL. It is no longer valid as the corresponding lock was
    released by close_tables_for_reopen().
  */
  m_has_protection_against_grl = false;
  /* Prepare for possible another back-off. */
  m_action = OT_NO_ACTION;
  return result;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_tables
                read lock in open_tables(), then we need to check
                if we have really requested lock and then unlock.
               */
              if (table->file->get_lock_type() != F_UNLCK)
                table->file->ha_external_lock(thd, F_UNLCK);
              close_thread_table(thd, prev);
              continue;
            }
          }
        }
        prev = &table->next;
      }  // End of for
    }

    /* Ensure we are calling ha_reset() for all used tables */
    mark_used_tables_as_free_for_reuse(thd, thd->open_tables);

    /*
      Mark this statement as one that has "unlocked" its tables.
      For purposes of Query_tables_list::lock_tables_state we treat
      any statement which passed through close_thread_tables() as
      such.
    */
    thd->lex->lock_tables_state = Query_tables_list::LTS_NOT_LOCKED;

    /*
      We are under simple LOCK TABLES or we're inside a sub-statement
      of a prelocked statement, so should not do anything else.

      Note that even if we are in LTM_LOCK_TABLES mode and statement
      requires prelocking (e.g. when we are closing tables after
      failing to "open" all tables required for statement execution)
      we will exit this function a few lines below.
    */
    if (!thd->lex->requires_prelocking()) return;

    /*
      We are in the top-level statement of a prelocked statement,
      so we have to leave the prelocked mode now with doing implicit
      UNLOCK TABLES if needed.
    */
    if (thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES)
      thd->locked_tables_mode = LTM_LOCK_TABLES;

    if (thd->locked_tables_mode == LTM_LOCK_TABLES) return;

    thd->leave_locked_tables_mode();

    /* Fallthrough */
  }

  if (thd->lock) {
    /*
      For RBR we flush the pending event just before we unlock all the
      tables.  This means that we are at the end of a topmost
      statement, so we ensure that the STMT_END_F flag is set on the
      pending event.  For statements that are *inside* stored
      functions, the pending event will not be flushed: that will be
      handled either before writing a query log event (inside
      binlog_query()) or when preparing a pending event.
     */
    (void)thd->binlog_flush_pending_rows_event(true);
    mysql_unlock_tables(thd, thd->lock);
    thd->lock = nullptr;
  }

  thd->lex->lock_tables_state = Query_tables_list::LTS_NOT_LOCKED;

  /*
    Closing a MERGE child before the parent would be fatal if the
    other thread tries to abort the MERGE lock in between.
  */
  if (thd->open_tables) close_open_tables(thd);
}

/**
  Helper function which returns TABLE to Table Cache or closes if
  table is marked as needing re-open.
*/
static void release_or_close_table(THD *thd, TABLE *table) {
  Table_cache *tc = table_cache_manager.get_cache(thd);

  tc->lock();

  if (table->s->has_old_version() || table->has_invalid_dict() ||
      table->has_invalid_stats() || table_def_shutdown_in_progress) {
    tc->remove_table(table);
    mysql_mutex_lock(&LOCK_open);
    intern_close_table(table);
    mysql_mutex_unlock(&LOCK_open);
  } else
    tc->release_table(thd, table);

  tc->unlock();
}

/* move one table to free list */

void close_thread_table(THD *thd, TABLE **table_ptr) {
  TABLE *table = *table_ptr;
  DBUG_TRACE;
  assert(table->key_read == 0);
  assert(!table->file || table->file->inited == handler::NONE);
  mysql_mutex_assert_not_owner(&LOCK_open);
  /*
    The metadata lock must be released after giving back
    the table to the table cache.
  */
  assert(thd->mdl_context.owns_equal_or_stronger_lock(
      MDL_key::TABLE, table->s->db.str, table->s->table_name.str, MDL_SHARED));
  table->mdl_ticket = nullptr;
  table->pos_in_table_list = nullptr;

  mysql_mutex_lock(&thd->LOCK_thd_data);
  *table_ptr = table->next;
  mysql_mutex_unlock(&thd->LOCK_thd_data);

  /*
    It is not safe to call the below code for TABLE objects for which
    handler::open() has not been called (for example, we use such objects
    while updating information about views which depend on table being
    ALTERed). Another possibly unsafe case is when TABLE/handler object
    has been marked as invalid (for example, it is unsafe to call
    handler::reset() for partitioned InnoDB tables after in-place ALTER
    TABLE API commit phase).
  */
  if (!table->has_invalid_dict()) {
    /* Avoid having MERGE tables with attached children in unused_tables. */
    table->file->ha_extra(HA_EXTRA_DETACH_CHILDREN);
    /* Free memory and reset for next loop. */
    free_blob_buffers_and_reset(table, MAX_TDC_BLOB_SIZE);
    table->file->ha_reset();
  }

  /* Do this *before* entering the LOCK_open critical section. */
  if (table->file != nullptr) table->file->unbind_psi();

  release_or_close_table(thd, table);
}

/* close_temporary_tables' internal, 4 is due to uint4korr definition */
static inline uint tmpkeyval(TABLE *table) {
  return uint4korr(table->s->table_cache_key.str +
                   table->s->table_cache_key.length - 4);
}

/*
  Close all temporary tables created by 'CREATE TEMPORARY TABLE' for thread
  creates one DROP TEMPORARY TABLE binlog event for each pseudo-thread.

  TODO: In future, we should have temporary_table= 0 and
        replica_open_temp_tables.fetch_add() at one place instead of repeating
        it all across the function. An alternative would be to use
        close_temporary_table() instead of close_temporary() that maintains
        the correct invariant regarding empty list of temporary tables
        and zero replica_open_temp_tables already.
*/

bool close_temporary_tables(THD *thd) {
  DBUG_TRACE;
  TABLE *table;
  TABLE *next = nullptr;
  TABLE *prev_table;
  /* Assume thd->variables.option_bits has OPTION_QUOTE_SHOW_CREATE */
  bool was_quote_show = true;
  bool error = false;
  int slave_closed_temp_tables = 0;

  if (!thd->temporary_tables) return false;

  assert(!thd->slave_thread ||
         thd->system_thread != SYSTEM_THREAD_SLAVE_WORKER);

  /*
    Ensure we don't have open HANDLERs for tables we are about to close.
    This is necessary when close_temporary_tables() is called as part
    of execution of BINLOG statement (e.g. for format description event).
  */
  mysql_ha_rm_temporary_tables(thd);
  if (!mysql_bin_log.is_open()) {
    TABLE *tmp_next;
    for (TABLE *t = thd->temporary_tables; t; t = tmp_next) {
      tmp_next = t->next;
      mysql_lock_remove(thd, thd->lock, t);
      /*
        We should not meet temporary tables created by ALTER TABLE here.
        It is responsibility of ALTER statement to close them. Otherwise
        it might be necessary to remove them from DD as well.
      */
      assert(t->s->tmp_table_def);
      close_temporary(thd, t, true, true);
      slave_closed_temp_tables++;
    }

    thd->temporary_tables = nullptr;
    if (thd->slave_thread) {
      atomic_replica_open_temp_tables -= slave_closed_temp_tables;
      thd->rli_slave->get_c_rli()->atomic_channel_open_temp_tables -=
          slave_closed_temp_tables;
    }

    return false;
  }

  /*
    We are about to generate DROP TEMPORARY TABLE statements for all
    the left out temporary tables. If GTID_NEXT is set (e.g. if user
    did SET GTID_NEXT just before disconnecting the client), we must
    ensure that it will be able to generate GTIDs for the statements
    with this server's UUID. Therefore we set gtid_next to
    AUTOMATIC_GTID.
  */
  gtid_state->update_on_rollback(thd);
  thd->variables.gtid_next.set_automatic();

  /*
    We must separate transactional temp tables and
    non-transactional temp tables in two distinct DROP statements
    to avoid the splitting if a slave server reads from this binlog.
  */

  /* Better add "if exists", in case a RESET MASTER has been done */
  const char stub[] = "DROP /*!40005 TEMPORARY */ TABLE IF EXISTS ";
  uint stub_len = sizeof(stub) - 1;
  char buf_trans[256], buf_non_trans[256];
  String s_query_trans =
      String(buf_trans, sizeof(buf_trans), system_charset_info);
  String s_query_non_trans =
      String(buf_non_trans, sizeof(buf_non_trans), system_charset_info);
  bool found_user_tables = false;
  bool found_trans_table = false;
  bool found_non_trans_table = false;

  memcpy(buf_trans, stub, stub_len);
  memcpy(buf_non_trans, stub, stub_len);

  /*
    Insertion sort of temp tables by pseudo_thread_id to build ordered list
    of sublists of equal pseudo_thread_id
  */

  for (prev_table = thd->temporary_tables, table = prev_table->next; table;
       prev_table = table, table = table->next) {
    TABLE *prev_sorted /* same as for prev_table */, *sorted;
    /*
      We should not meet temporary tables created by ALTER TABLE here.
      It is responsibility of ALTER statement to close them. Otherwise
      it might be necessary to remove them from DD as well.
    */
    assert(table->s->tmp_table_def);
    if (is_user_table(table)) {
      if (!found_user_tables) found_user_tables = true;
      for (prev_sorted = nullptr, sorted = thd->temporary_tables;
           sorted != table; prev_sorted = sorted, sorted = sorted->next) {
        if (!is_user_table(sorted) || tmpkeyval(sorted) > tmpkeyval(table)) {
          /* move into the sorted part of the list from the unsorted */
          prev_table->next = table->next;
          table->next = sorted;
          if (prev_sorted) {
            prev_sorted->next = table;
          } else {
            thd->temporary_tables = table;
          }
          table = prev_table;
          break;
        }
      }
    }
  }

  /* We always quote db,table names though it is slight overkill */
  if (found_user_tables && !(was_quote_show = (thd->variables.option_bits &
                                               OPTION_QUOTE_SHOW_CREATE))) {
    thd->variables.option_bits |= OPTION_QUOTE_SHOW_CREATE;
  }

  /*
    Make LEX consistent with DROP TEMPORARY TABLES statement which we
    are going to log. This is important for the binary logging code.
  */
  LEX *lex = thd->lex;
  enum_sql_command sav_sql_command = lex->sql_command;
  bool sav_drop_temp = lex->drop_temporary;
  lex->sql_command = SQLCOM_DROP_TABLE;
  lex->drop_temporary = true;

  /* scan sorted tmps to generate sequence of DROP */
  for (table = thd->temporary_tables; table; table = next) {
    if (is_user_table(table) && table->should_binlog_drop_if_temp()) {
      bool save_thread_specific_used = thd->thread_specific_used;
      my_thread_id save_pseudo_thread_id = thd->variables.pseudo_thread_id;
      /* Set pseudo_thread_id to be that of the processed table */
      thd->variables.pseudo_thread_id = tmpkeyval(table);
      String db;
      db.append(table->s->db.str);
      /* Loop forward through all tables that belong to a common database
         within the sublist of common pseudo_thread_id to create single
         DROP query
      */
      for (s_query_trans.length(stub_len), s_query_non_trans.length(stub_len),
           found_trans_table = false, found_non_trans_table = false;
           table && is_user_table(table) &&
           tmpkeyval(table) == thd->variables.pseudo_thread_id &&
           table->s->db.length == db.length() &&
           strcmp(table->s->db.str, db.ptr()) == 0;
           table = next) {
        /* Separate transactional from non-transactional temp tables */
        if (table->should_binlog_drop_if_temp()) {
          /* Separate transactional from non-transactional temp tables */
          if (table->s->tmp_table == TRANSACTIONAL_TMP_TABLE) {
            found_trans_table = true;
            /*
              We are going to add ` around the table names and possible more
              due to special characters
            */
            append_identifier(thd, &s_query_trans, table->s->table_name.str,
                              strlen(table->s->table_name.str));
            s_query_trans.append(',');
          } else if (table->s->tmp_table == NON_TRANSACTIONAL_TMP_TABLE) {
            found_non_trans_table = true;
            /*
              We are going to add ` around the table names and possible more
              due to special characters
            */
            append_identifier(thd, &s_query_non_trans, table->s->table_name.str,
                              strlen(table->s->table_name.str));
            s_query_non_trans.append(',');
          }
        }

        next = table->next;
        mysql_lock_remove(thd, thd->lock, table);
        close_temporary(thd, table, true, true);
        slave_closed_temp_tables++;
      }
      thd->clear_error();
      const CHARSET_INFO *cs_save = thd->variables.character_set_client;
      thd->variables.character_set_client = system_charset_info;
      thd->thread_specific_used = true;

      if (found_trans_table) {
        Query_log_event qinfo(thd, s_query_trans.ptr(),
                              s_query_trans.length() - 1, false, true, false,
                              0);
        qinfo.db = db.ptr();
        qinfo.db_len = db.length();
        thd->variables.character_set_client = cs_save;

        thd->get_stmt_da()->set_overwrite_status(true);
        if ((error = (mysql_bin_log.write_event(&qinfo) ||
                      mysql_bin_log.commit(thd, true) || error))) {
          /*
            If we're here following THD::cleanup, thence the connection
            has been closed already. So lets print a message to the
            error log instead of pushing yet another error into the
            Diagnostics_area.

            Also, we keep the error flag so that we propagate the error
            up in the stack. This way, if we're the SQL thread we notice
            that close_temporary_tables failed. (Actually, the SQL
            thread only calls close_temporary_tables while applying old
            Start_log_event_v3 events.)
          */
          LogErr(ERROR_LEVEL, ER_BINLOG_FAILED_TO_WRITE_DROP_FOR_TEMP_TABLES);
        }
        thd->get_stmt_da()->set_overwrite_status(false);
      }

      if (found_non_trans_table) {
        Query_log_event qinfo(thd, s_query_non_trans.ptr(),
                              s_query_non_trans.length() - 1, false, true,
                              false, 0);
        qinfo.db = db.ptr();
        qinfo.db_len = db.length();
        thd->variables.character_set_client = cs_save;

        thd->get_stmt_da()->set_overwrite_status(true);
        if ((error = (mysql_bin_log.write_event(&qinfo) ||
                      mysql_bin_log.commit(thd, true) || error))) {
          /*
            If we're here following THD::cleanup, thence the connection
            has been closed already. So lets print a message to the
            error log instead of pushing yet another error into the
            Diagnostics_area.

            Also, we keep the error flag so that we propagate the error
            up in the stack. This way, if we're the SQL thread we notice
            that close_temporary_tables failed. (Actually, the SQL
            thread only calls close_temporary_tables while applying old
            Start_log_event_v3 events.)
          */
          LogErr(ERROR_LEVEL, ER_BINLOG_FAILED_TO_WRITE_DROP_FOR_TEMP_TABLES);
        }
        thd->get_stmt_da()->set_overwrite_status(false);
      }

      thd->variables.pseudo_thread_id = save_pseudo_thread_id;
      thd->thread_specific_used = save_thread_specific_used;
    } else {
      next = table->next;
      /*
        This is for those cases when we have acquired lock but drop temporary
        table will not be logged.
      */
      mysql_lock_remove(thd, thd->lock, table);
      close_temporary(thd, table, true, true);
      slave_closed_temp_tables++;
    }
  }
  lex->drop_temporary = sav_drop_temp;
  lex->sql_command = sav_sql_command;

  if (!was_quote_show)
    thd->variables.option_bits &=
        ~OPTION_QUOTE_SHOW_CREATE; /* restore option */

  thd->temporary_tables = nullptr;
  if (thd->slave_thread) {
    atomic_replica_open_temp_tables -= slave_closed_temp_tables;
    thd->rli_slave->get_c_rli()->atomic_channel_open_temp_tables -=
        slave_closed_temp_tables;
  }

  return error;
}

/**
  Find table in global list.

  @param table          Pointer to table list
  @param db_name        Data base name
  @param table_name     Table name

  @returns Pointer to found table.
  @retval NULL  Table not found
*/

Table_ref *find_table_in_global_list(Table_ref *table, const char *db_name,
                                     const char *table_name) {
  for (; table; table = table->next_global) {
    if ((table->table == nullptr ||
         table->table->s->tmp_table == NO_TMP_TABLE) &&
        strcmp(table->db, db_name) == 0 &&
        strcmp(table->table_name, table_name) == 0)
      break;
  }
  return table;
}

/**
  Test that table is unique (It's only exists once in the table list)

  @param  table        table to be checked (must be updatable base table)
  @param  table_list   list of tables
  @param  check_alias  whether to check tables' aliases

  NOTE: to exclude derived tables from check we use following mechanism:
    a) during derived table processing set THD::derived_tables_processing
    b) Query_block::prepare set SELECT::exclude_from_table_unique_test if
       THD::derived_tables_processing set. (we can't use JOIN::execute
       because for PS we perform only Query_block::prepare, but we can't set
       this flag in Query_block::prepare if we are not sure that we are in
       derived table processing loop, because multi-update call fix_fields()
       for some its items (which mean Query_block::prepare for subqueries)
       before unique_table call to detect which tables should be locked for
       write).
    c) find_dup_table skip all tables which belong to SELECT with
       SELECT::exclude_from_table_unique_test set.
    Also SELECT::exclude_from_table_unique_test used to exclude from check
    tables of main SELECT of multi-delete and multi-update

    We also skip tables with Table_ref::prelocking_placeholder set,
    because we want to allow SELECTs from them, and their modification
    will rise the error anyway.

    TODO: when we will have table/view change detection we can do this check
          only once for PS/SP

  @retval !=0  found duplicate
  @retval 0 if table is unique
*/

static Table_ref *find_dup_table(const Table_ref *table, Table_ref *table_list,
                                 bool check_alias) {
  Table_ref *res;
  const char *d_name, *t_name, *t_alias;
  DBUG_TRACE;
  DBUG_PRINT("enter", ("table alias: %s", table->alias));

  assert(table == table->updatable_base_table());
  /*
    If this function called for CREATE command that we have not opened table
    (table->table equal to 0) and right names is in current Table_ref
    object.
  */
  if (table->table) {
    /* All MyISAMMRG children are plain MyISAM tables. */
    assert(table->table->file->ht->db_type != DB_TYPE_MRG_MYISAM);

    /* temporary table is always unique */
    if (table->table->s->tmp_table != NO_TMP_TABLE) return nullptr;
  }

  d_name = table->db;
  t_name = table->table_name;
  t_alias = table->alias;

  DBUG_PRINT("info", ("real table: %s.%s", d_name, t_name));
  for (;;) {
    /*
      Table is unique if it is present only once in the global list
      of tables and once in the list of table locks.
    */
    if (!(res = find_table_in_global_list(table_list, d_name, t_name))) break;

    /* Skip if same underlying table. */
    if (res->table && (res->table == table->table)) goto next;

    /* Skip if table alias does not match. */
    if (check_alias) {
      if (lower_case_table_names
              ? my_strcasecmp(files_charset_info, t_alias, res->alias)
              : strcmp(t_alias, res->alias))
        goto next;
    }

    /*
      Skip if marked to be excluded (could be a derived table) or if
      entry is a prelocking placeholder.
    */
    if (res->query_block && !res->query_block->exclude_from_table_unique_test &&
        !res->prelocking_placeholder)
      break;

    /*
      If we found entry of this table or table of SELECT which already
      processed in derived table or top select of multi-update/multi-delete
      (exclude_from_table_unique_test) or prelocking placeholder.
    */
  next:
    table_list = res->next_global;
    DBUG_PRINT("info",
               ("found same copy of table or table which we should skip"));
  }
  return res;
}

/**
  Test that the subject table of INSERT/UPDATE/DELETE/CREATE
  or (in case of MyISAMMRG) one of its children are not used later
  in the query.

  For MyISAMMRG tables, it is assumed that all the underlying
  tables of @c table (if any) are listed right after it and that
  their @c parent_l field points at the main table.

  @param  table      table to be checked (must be updatable base table)
  @param  table_list List of tables to check against
  @param  check_alias whether to check tables' aliases

  @retval non-NULL The table list element for the table that
                   represents the duplicate.
  @retval NULL     No duplicates found.
*/

Table_ref *unique_table(const Table_ref *table, Table_ref *table_list,
                        bool check_alias) {
  assert(table == table->updatable_base_table());

  Table_ref *dup;
  if (table->table && table->table->file->ht->db_type == DB_TYPE_MRG_MYISAM) {
    Table_ref *child;
    dup = nullptr;
    /* Check duplicates of all merge children. */
    for (child = table->next_global; child && child->parent_l == table;
         child = child->next_global) {
      if ((dup = find_dup_table(child, child->next_global, check_alias))) break;
    }
  } else
    dup = find_dup_table(table, table_list, check_alias);
  return dup;
}

/**
  Issue correct error message in case we found 2 duplicate tables which
  prevent some update operation

  @param update      table which we try to update
  @param operation   name of update operation
  @param duplicate   duplicate table which we found

  @note here we hide view underlying tables if we have them.
*/

void update_non_unique_table_error(Table_ref *update, const char *operation,
                                   Table_ref *duplicate) {
  update = update->top_table();
  duplicate = duplicate->top_table();
  if (!update->is_view() || !duplicate->is_view() ||
      update->view_query() == duplicate->view_query() ||
      update->table_name_length != duplicate->table_name_length ||
      update->db_length != duplicate->db_length ||
      my_strcasecmp(table_alias_charset, update->table_name,
                    duplicate->table_name) != 0 ||
      my_strcasecmp(table_alias_charset, update->db, duplicate->db) != 0) {
    /*
      it is not the same view repeated (but it can be parts of the same copy
      of view), so we have to hide underlying tables.
    */
    if (update->is_view()) {
      // Issue the ER_NON_INSERTABLE_TABLE error for an INSERT
      if (duplicate->is_view() &&
          update->view_query() == duplicate->view_query())
        my_error(!strncmp(operation, "INSERT", 6) ? ER_NON_INSERTABLE_TABLE
                                                  : ER_NON_UPDATABLE_TABLE,
                 MYF(0), update->alias, operation);
      else
        my_error(ER_VIEW_PREVENT_UPDATE, MYF(0),
                 (duplicate->is_view() ? duplicate->alias : update->alias),
                 operation, update->alias);
      return;
    }
    if (duplicate->is_view()) {
      my_error(ER_VIEW_PREVENT_UPDATE, MYF(0), duplicate->alias, operation,
               update->alias);
      return;
    }
  }
  my_error(ER_UPDATE_TABLE_USED, MYF(0), update->alias);
}

/**
  Find temporary table specified by database and table names in the
  THD::temporary_tables list.

  @return TABLE instance if a temporary table has been found; NULL otherwise.
*/

TABLE *find_temporary_table(THD *thd, const char *db, const char *table_name) {
  char key[MAX_DBKEY_LENGTH];
  size_t key_length = create_table_def_key_tmp(thd, db, table_name, key);
  return find_temporary_table(thd, key, key_length);
}

/**
  Find a temporary table specified by Table_ref instance in the
  THD::temporary_tables list.

  @return TABLE instance if a temporary table has been found; NULL otherwise.
*/

TABLE *find_temporary_table(THD *thd, const Table_ref *tl) {
  const char *key;
  size_t key_length;
  char key_suffix[TMP_TABLE_KEY_EXTRA];
  TABLE *table;

  key_length = get_table_def_key(tl, &key);

  int4store(key_suffix, thd->server_id);
  int4store(key_suffix + 4, thd->variables.pseudo_thread_id);

  for (table = thd->temporary_tables; table; table = table->next) {
    if ((table->s->table_cache_key.length ==
         key_length + TMP_TABLE_KEY_EXTRA) &&
        !memcmp(table->s->table_cache_key.str, key, key_length) &&
        !memcmp(table->s->table_cache_key.str + key_length, key_suffix,
                TMP_TABLE_KEY_EXTRA))
      return table;
  }
  return nullptr;
}

/**
  Find a temporary table specified by a key in the THD::temporary_tables list.

  @return TABLE instance if a temporary table has been found; NULL otherwise.
*/

static TABLE *find_temporary_table(THD *thd, const char *table_key,
                                   size_t table_key_length) {
  for (TABLE *table = thd->temporary_tables; table; table = table->next) {
    if (table->s->table_cache_key.length == table_key_length &&
        !memcmp(table->s->table_cache_key.str, table_key, table_key_length)) {
      return table;
    }
  }

  return nullptr;
}

/**
  Drop a temporary table.

  - If the table is locked with LOCK TABLES or by prelocking,
    unlock it and remove it from the list of locked tables
    (THD::lock). Currently only transactional temporary tables
    are locked.
  - Close the temporary table.
  - Remove the table from the list of temporary tables.
*/

void drop_temporary_table(THD *thd, Table_ref *table_list) {
  DBUG_TRACE;
  DBUG_PRINT("tmptable", ("closing table: '%s'.'%s'", table_list->db,
                          table_list->table_name));

  assert(is_temporary_table(table_list));

  TABLE *table = table_list->table;

  assert(!table->query_id || table->query_id == thd->query_id);

  /*
    If LOCK TABLES list is not empty and contains this table,
    unlock the table and remove the table from this list.
  */
  mysql_lock_remove(thd, thd->lock, table);
  close_temporary_table(thd, table, true, true);
  table_list->table = nullptr;
}

/*
  unlink from thd->temporary tables and close temporary table
*/

void close_temporary_table(THD *thd, TABLE *table, bool free_share,
                           bool delete_table) {
  DBUG_TRACE;
  DBUG_PRINT("tmptable",
             ("closing table: '%s'.'%s' %p  alias: '%s'", table->s->db.str,
              table->s->table_name.str, table, table->alias));

  if (table->prev) {
    table->prev->next = table->next;
    if (table->prev->next) table->next->prev = table->prev;
  } else {
    /* removing the item from the list */
    assert(table == thd->temporary_tables);
    /*
      slave must reset its temporary list pointer to zero to exclude
      passing non-zero value to end_slave via rli->save_temporary_tables
      when no temp tables opened, see an invariant below.
    */
    thd->temporary_tables = table->next;
    if (thd->temporary_tables) table->next->prev = nullptr;
  }
  if (thd->slave_thread) {
    /* natural invariant of temporary_tables */
    assert(thd->rli_slave->get_c_rli()->atomic_channel_open_temp_tables ||
           !thd->temporary_tables);
    --atomic_replica_open_temp_tables;
    --thd->rli_slave->get_c_rli()->atomic_channel_open_temp_tables;
  }
  close_temporary(thd, table, free_share, delete_table);
}

/*
  Close and delete a temporary table

  NOTE
    This doesn't unlink table from thd->temporary
    If this is needed, use close_temporary_table()
*/

void close_temporary(THD *thd, TABLE *table, bool free_share,
                     bool delete_table) {
  handlerton *table_type = table->s->db_type();
  DBUG_TRACE;
  DBUG_PRINT("tmptable", ("closing table: '%s'.'%s'", table->s->db.str,
                          table->s->table_name.str));

  free_io_cache(table);
  closefrm(table, false);
  if (delete_table) {
    assert(thd);
    rm_temporary_table(thd, table_type, table->s->path.str,
                       table->s->tmp_table_def);
  }

  if (free_share) {
    free_table_share(table->s);
    destroy(table);
    my_free(table);
  }
}

/*
  Used by ALTER TABLE when the table is a temporary one. It changes something
  only if the ALTER contained a RENAME clause (otherwise, table_name is the old
  name).
  Prepares a table cache key, which is the concatenation of db, table_name and
  thd->slave_proxy_id, separated by '\0'.
*/

bool rename_temporary_table(THD *thd, TABLE *table, const char *db,
                            const char *table_name) {
  char *key;
  size_t key_length;
  TABLE_SHARE *share = table->s;
  DBUG_TRACE;

  if (!(key = (char *)share->mem_root.Alloc(MAX_DBKEY_LENGTH)))
    return true; /* purecov: inspected */

  key_length = create_table_def_key_tmp(thd, db, table_name, key);
  share->set_table_cache_key(key, key_length);
  /* Also update table name in DD object. Database name is kept reset. */
  share->tmp_table_def->set_name(table_name);
  return false;
}

/**
   Force all other threads to stop using the table by upgrading
   metadata lock on it and remove unused TABLE instances from cache.

   @param thd      Thread handler
   @param table    Table to remove from cache
   @param function HA_EXTRA_PREPARE_FOR_DROP if table is to be deleted
                   HA_EXTRA_FORCE_REOPEN if table is not be used
                   HA_EXTRA_PREPARE_FOR_RENAME if table is to be renamed

   @note When returning, the table will be unusable for other threads
         until metadata lock is downgraded.

   @retval false Success.
   @retval true  Failure (e.g. because thread was killed).
*/

bool wait_while_table_is_used(THD *thd, TABLE *table,
                              enum ha_extra_function function) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("table: '%s'  share: %p  db_stat: %u  version: %lu",
                       table->s->table_name.str, table->s, table->db_stat,
                       table->s->version()));

  if (thd->mdl_context.upgrade_shared_lock(table->mdl_ticket, MDL_EXCLUSIVE,
                                           thd->variables.lock_wait_timeout))
    return true;

  tdc_remove_table(thd, TDC_RT_REMOVE_NOT_OWN, table->s->db.str,
                   table->s->table_name.str, false);
  /* extra() call must come only after all instances above are closed */
  (void)table->file->ha_extra(function);
  return false;
}

/**
    Check that table exists in data-dictionary or in some storage engine.

    @param       thd     Thread context
    @param       table   Table list element
    @param[out]  exists  Out parameter which is set to true if table
                         exists and to false otherwise.

    @note If there is no table in data-dictionary but it exists in one
          of engines (e.g. it was created on another node of NDB cluster)
          this function will fetch and add proper table description to
          the data-dictionary.

    @retval  true   Some error occurred
    @retval  false  No error. 'exists' out parameter set accordingly.
*/

static bool check_if_table_exists(THD *thd, Table_ref *table, bool *exists) {
  DBUG_TRACE;

  *exists = true;

  assert(thd->mdl_context.owns_equal_or_stronger_lock(
      MDL_key::TABLE, table->db, table->table_name, MDL_SHARED));

  if (dd::table_exists(thd->dd_client(), table->db, table->table_name, exists))
    return true;  // Error is already reported.

  if (*exists) goto end;

  /* Table doesn't exist. Check if some engine can provide it. */
  if (ha_check_if_table_exists(thd, table->db, table->table_name, exists)) {
    my_printf_error(ER_OUT_OF_RESOURCES,
                    "Failed to open '%-.64s', error while "
                    "unpacking from engine",
                    MYF(0), table->table_name);
    return true;
  }
end:
  return false;
}

/**
  An error handler which converts, if possible, ER_LOCK_DEADLOCK error
  that can occur when we are trying to acquire a metadata lock to
  a request for back-off and re-start of open_tables() process.
*/

class MDL_deadlock_handler : public Internal_error_handler {
 public:
  MDL_deadlock_handler(Open_table_context *ot_ctx_arg)
      : m_ot_ctx(ot_ctx_arg), m_is_active(false) {}

  bool handle_condition(THD *, uint sql_errno, const char *,
                        Sql_condition::enum_severity_level *,
                        const char *) override {
    if (!m_is_active && sql_errno == ER_LOCK_DEADLOCK) {
      /* Disable the handler to avoid infinite recursion. */
      m_is_active = true;
      (void)m_ot_ctx->request_backoff_action(
          Open_table_context::OT_BACKOFF_AND_RETRY, nullptr);
      m_is_active = false;
      /*
        If the above back-off request failed, a new instance of
        ER_LOCK_DEADLOCK error was emitted. Thus the current
        instance of error condition can be treated as handled.
      */
      return true;
    }
    return false;
  }

 private:
  /** Open table context to be used for back-off request. */
  Open_table_context *m_ot_ctx;
  /**
    Indicates that we are already in the process of handling
    ER_LOCK_DEADLOCK error. Allows to re-emit the error from
    the error handler without falling into infinite recursion.
  */
  bool m_is_active;
};

/**
  Try to acquire an MDL lock for a table being opened.

  @param[in,out] thd      Session context, to report errors.
  @param[out]    ot_ctx   Open table context, to hold the back off
                          state. If we failed to acquire a lock
                          due to a lock conflict, we add the
                          failed request to the open table context.
  @param[in,out] table_list Table list element for the table being opened.
                            Its "mdl_request" member specifies the MDL lock
                            to be requested. If we managed to acquire a
                            ticket (no errors or lock conflicts occurred),
                            Table_ref::mdl_request contains a reference
                            to it on return. However, is not modified if
                            MDL lock type- modifying flags were provided.
                            We also use Table_ref::lock_type member to
                            detect cases when MDL_SHARED_WRITE_LOW_PRIO
                            lock should be acquired instead of the normal
                            MDL_SHARED_WRITE lock.
  @param[in]    flags flags MYSQL_OPEN_FORCE_SHARED_MDL,
                          MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL or
                          MYSQL_OPEN_FAIL_ON_MDL_CONFLICT
                          @sa open_table().
  @param[out]   mdl_ticket Only modified if there was no error.
                          If we managed to acquire an MDL
                          lock, contains a reference to the
                          ticket, otherwise is set to NULL.

  @retval true  An error occurred.
  @retval false No error, but perhaps a lock conflict, check mdl_ticket.
*/

static bool open_table_get_mdl_lock(THD *thd, Open_table_context *ot_ctx,
                                    Table_ref *table_list, uint flags,
                                    MDL_ticket **mdl_ticket) {
  MDL_request *mdl_request = &table_list->mdl_request;
  MDL_request new_mdl_request;

  if (flags &
      (MYSQL_OPEN_FORCE_SHARED_MDL | MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL)) {
    /*
      MYSQL_OPEN_FORCE_SHARED_MDL flag means that we are executing
      PREPARE for a prepared statement and want to override
      the type-of-operation aware metadata lock which was set
      in the parser/during view opening with a simple shared
      metadata lock.
      This is necessary to allow concurrent execution of PREPARE
      and LOCK TABLES WRITE statement against the same table.

      MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL flag means that we open
      the table in order to get information about it for one of I_S
      queries and also want to override the type-of-operation aware
      shared metadata lock which was set earlier (e.g. during view
      opening) with a high-priority shared metadata lock.
      This is necessary to avoid unnecessary waiting and extra
      ER_WARN_I_S_SKIPPED_TABLE warnings when accessing I_S tables.

      These two flags are mutually exclusive.
    */
    assert(!(flags & MYSQL_OPEN_FORCE_SHARED_MDL) ||
           !(flags & MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL));

    MDL_REQUEST_INIT_BY_KEY(&new_mdl_request, &mdl_request->key,
                            (flags & MYSQL_OPEN_FORCE_SHARED_MDL)
                                ? MDL_SHARED
                                : MDL_SHARED_HIGH_PRIO,
                            MDL_TRANSACTION);
    mdl_request = &new_mdl_request;
  } else if (thd->variables.low_priority_updates &&
             mdl_request->type == MDL_SHARED_WRITE &&
             (table_list->lock_descriptor().type == TL_WRITE_DEFAULT ||
              table_list->lock_descriptor().type ==
                  TL_WRITE_CONCURRENT_DEFAULT)) {
    /*
      We are in @@low_priority_updates=1 mode and are going to acquire
      SW metadata lock on a table which for which neither LOW_PRIORITY nor
      HIGH_PRIORITY clauses were used explicitly.
      To keep compatibility with THR_LOCK locks and to avoid starving out
      concurrent LOCK TABLES READ statements, we need to acquire the low-prio
      version of SW lock instead of a normal SW lock in this case.
    */
    MDL_REQUEST_INIT_BY_KEY(&new_mdl_request, &mdl_request->key,
                            MDL_SHARED_WRITE_LOW_PRIO, MDL_TRANSACTION);
    mdl_request = &new_mdl_request;
  }

  if (flags & MYSQL_OPEN_FAIL_ON_MDL_CONFLICT) {
    /*
      When table is being open in order to get data for I_S table,
      we might have some tables not only open but also locked (e.g. when
      this happens under LOCK TABLES or in a stored function).
      As a result by waiting on a conflicting metadata lock to go away
      we may create a deadlock which won't entirely belong to the
      MDL subsystem and thus won't be detectable by this subsystem's
      deadlock detector.
      To avoid such situation we skip the trouble-making table if
      there is a conflicting lock.
    */
    if (thd->mdl_context.try_acquire_lock(mdl_request)) return true;
    if (mdl_request->ticket == nullptr) {
      my_error(ER_WARN_I_S_SKIPPED_TABLE, MYF(0), mdl_request->key.db_name(),
               mdl_request->key.name());
      return true;
    }
  } else {
    /*
      We are doing a normal table open. Let us try to acquire a metadata
      lock on the table. If there is a conflicting lock, acquire_lock()
      will wait for it to go away. Sometimes this waiting may lead to a
      deadlock, with the following results:
      1) If a deadlock is entirely within MDL subsystem, it is
         detected by the deadlock detector of this subsystem.
         ER_LOCK_DEADLOCK error is produced. Then, the error handler
         that is installed prior to the call to acquire_lock() attempts
         to request a back-off and retry. Upon success, ER_LOCK_DEADLOCK
         error is suppressed, otherwise propagated up the calling stack.
      2) Otherwise, a deadlock may occur when the wait-for graph
         includes edges not visible to the MDL deadlock detector.
         One such example is a wait on an InnoDB row lock, e.g. when:
         conn C1 gets SR MDL lock on t1 with SELECT * FROM t1
         conn C2 gets a row lock on t2 with  SELECT * FROM t2 FOR UPDATE
         conn C3 gets in and waits on C1 with DROP TABLE t0, t1
         conn C2 continues and blocks on C3 with SELECT * FROM t0
         conn C1 deadlocks by waiting on C2 by issuing SELECT * FROM
         t2 LOCK IN SHARE MODE.
         Such circular waits are currently only resolved by timeouts,
         e.g. @@innodb_lock_wait_timeout or @@lock_wait_timeout.

      Note that we want to force DML deadlock weight for our context
      when acquiring locks in this place. This is done to avoid situation
      when LOCK TABLES statement, which acquires strong SNRW and SRO locks
      on implicitly used tables, deadlocks with a concurrent DDL statement
      and the DDL statement is aborted since it is chosen as a deadlock
      victim. It is better to choose LOCK TABLES as a victim in this case
      as a deadlock can be easily caught here and handled by back-off and retry,
      without reporting any error to the user.
      We still have a few weird cases, like FLUSH TABLES <table-list> WITH
      READ LOCK, where we use "strong" metadata locks and open_tables() is
      called with some metadata locks pre-acquired. In these cases we still
      want to use DDL deadlock weight as back-off is not possible.
    */
    MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);

    thd->push_internal_handler(&mdl_deadlock_handler);
    thd->mdl_context.set_force_dml_deadlock_weight(ot_ctx->can_back_off());

    bool result =
        thd->mdl_context.acquire_lock(mdl_request, ot_ctx->get_timeout());

    thd->mdl_context.set_force_dml_deadlock_weight(false);
    thd->pop_internal_handler();

    if (result && !ot_ctx->can_recover_from_failed_open()) return true;
  }
  *mdl_ticket = mdl_request->ticket;
  return false;
}

/**
  Check if table's share is being removed from the table definition
  cache and, if yes, wait until the flush is complete.

  @param thd             Thread context.
  @param db              Database name.
  @param table_name      Table name.
  @param wait_timeout    Timeout for waiting.
  @param deadlock_weight Weight of this wait for deadlock detector.

  @retval false   Success. Share is up to date or has been flushed.
  @retval true    Error (OOM, our was killed, the wait resulted
                  in a deadlock or timeout). Reported.
*/

static bool tdc_wait_for_old_version(THD *thd, const char *db,
                                     const char *table_name, ulong wait_timeout,
                                     uint deadlock_weight) {
  TABLE_SHARE *share;
  bool res = false;

  mysql_mutex_lock(&LOCK_open);
  if ((share = get_cached_table_share(db, table_name)) &&
      share->has_old_version()) {
    struct timespec abstime;
    set_timespec(&abstime, wait_timeout);
    res = share->wait_for_old_version(thd, &abstime, deadlock_weight);
  }
  mysql_mutex_unlock(&LOCK_open);
  return res;
}

/**
  Add a dummy LEX object for a view.

  @param  thd         Thread context
  @param  table_list  The list of tables in the view

  @retval  true   error occurred
  @retval  false  view place holder successfully added
*/

bool add_view_place_holder(THD *thd, Table_ref *table_list) {
  Prepared_stmt_arena_holder ps_arena_holder(thd);
  LEX *lex_obj = new (thd->mem_root) st_lex_local;
  if (lex_obj == nullptr) return true;
  table_list->set_view_query(lex_obj);
  // Create empty list of view_tables.
  table_list->view_tables =
      new (thd->mem_root) mem_root_deque<Table_ref *>(thd->mem_root);
  if (table_list->view_tables == nullptr) return true;
  return false;
}

/**
  Open a base table.

  @param thd            Thread context.
  @param table_list     Open first table in list.
  @param ot_ctx         Context with flags which modify how open works
                        and which is used to recover from a failed
                        open_table() attempt.
                        Some examples of flags:
                        MYSQL_OPEN_IGNORE_FLUSH - Open table even if
                        someone has done a flush. No version number
                        checking is done.
                        MYSQL_OPEN_HAS_MDL_LOCK - instead of acquiring
                        metadata locks rely on that caller already has
                        appropriate ones.

  Uses a cache of open tables to find a TABLE instance not in use.

  If Table_ref::open_strategy is set to OPEN_IF_EXISTS, the table is
  opened only if it exists. If the open strategy is OPEN_STUB, the
  underlying table is never opened. In both cases, metadata locks are
  always taken according to the lock strategy.

  @retval true  Open failed. "action" parameter may contain type of action
                needed to remedy problem before retrying again.
  @retval false Success. Members of Table_ref structure are filled
  properly (e.g.  Table_ref::table is set for real tables and
                Table_ref::view is set for views).
*/

bool open_table(THD *thd, Table_ref *table_list, Open_table_context *ot_ctx) {
  TABLE *table = nullptr;
  TABLE_SHARE *share = nullptr;
  const char *key;
  size_t key_length;
  const char *alias = table_list->alias;
  uint flags = ot_ctx->get_flags();
  MDL_ticket *mdl_ticket = nullptr;
  int error = 0;

  DBUG_TRACE;

  // Temporary tables and derived tables are not allowed:
  assert(!is_temporary_table(table_list) && !table_list->is_derived());

  /*
    The table must not be opened already. The table can be pre-opened for
    some statements if it is a temporary table.

    open_temporary_table() must be used to open temporary tables.
    A derived table cannot be opened with this.
  */
  assert(table_list->is_view() || table_list->table == nullptr);

  /* an open table operation needs a lot of the stack space */
  if (check_stack_overrun(thd, STACK_MIN_SIZE_FOR_OPEN, (uchar *)&alias))
    return true;

  // New DD- In current_thd->is_strict_mode() mode we call open_table
  // on new DD tables like mysql.tables/* when CREATE fails and we
  // try to abort the operation and invoke quick_rm_table().
  // Currently, we ignore deleting table in strict mode. Need to fix this.
  // TODO.

  DBUG_EXECUTE_IF("kill_query_on_open_table_from_tz_find", {
    /*
      When on calling my_tz_find the following
      tables are opened in specified order: time_zone_name,
      time_zone, time_zone_transition_type,
      time_zone_transition. Emulate killing a query
      on opening the second table in the list.
    */
    if (!strcmp("time_zone", table_list->table_name))
      thd->killed = THD::KILL_QUERY;
  });

  if (!(flags & MYSQL_OPEN_IGNORE_KILLED) && thd->killed) return true;

  /*
    Check if we're trying to take a write lock in a read only transaction.

    Note that we allow write locks on log tables as otherwise logging
    to general/slow log would be disabled in read only transactions.
  */
  if (table_list->mdl_request.is_write_lock_request() && thd->tx_read_only &&
      !(flags & (MYSQL_LOCK_LOG_TABLE | MYSQL_OPEN_HAS_MDL_LOCK))) {
    my_error(ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION, MYF(0));
    return true;
  }

  /*
    FLUSH TABLES is ignored for DD, I_S and P_S tables/views.
    Hence setting MYSQL_OPEN_IGNORE_FLUSH flag.
  */
  if (table_list->is_system_view || belongs_to_dd_table(table_list) ||
      belongs_to_p_s(table_list))
    flags |= MYSQL_OPEN_IGNORE_FLUSH;

  key_length = get_table_def_key(table_list, &key);

  // If a table in a secondary storage engine has been requested,
  // adjust the key to refer to the secondary table.
  std::string secondary_key;
  if ((flags & MYSQL_OPEN_SECONDARY_ENGINE) != 0) {
    secondary_key = create_table_def_key_secondary(
        table_list->get_db_name(), table_list->get_table_name());
    key = secondary_key.data();
    key_length = secondary_key.length();
  }

  /*
    If we're in pre-locked or LOCK TABLES mode, let's try to find the
    requested table in the list of pre-opened and locked tables. If the
    table is not there, return an error - we can't open not pre-opened
    tables in pre-locked/LOCK TABLES mode.

    There is a special case where we allow opening not pre-opened tables
    in LOCK TABLES mode for new DD tables. The reason is as following.
    With new DD, IS system views need to be accessible in LOCK TABLE
    mode without user explicitly calling LOCK TABLE on IS view or its
    underlying DD tables. This is required to keep the old behavior the
    MySQL server had without new DD.

    In case user executes IS system view under LOCK TABLE mode
    (LTM and not prelocking), then MySQL server implicitly opens system
    view and related DD tables. Such DD tables are then implicitly closed
    upon end of statement execution.

    Our goal is to hide DD tables from users, so there is no possibility of
    explicit locking DD table using LOCK TABLE. In case user does LOCK TABLE
    on IS system view explicitly, MySQL server throws a error.

    TODO: move this block into a separate function.
  */
  if (thd->locked_tables_mode && !(flags & MYSQL_OPEN_GET_NEW_TABLE) &&
      !(in_LTM(thd) &&
        (table_list->is_system_view || belongs_to_dd_table(table_list) ||
         belongs_to_p_s(table_list)))) {  // Using table locks
    TABLE *best_table = nullptr;
    int best_distance = INT_MIN;
    for (table = thd->open_tables; table; table = table->next) {
      if (table->s->table_cache_key.length == key_length &&
          !memcmp(table->s->table_cache_key.str, key, key_length)) {
        if (!my_strcasecmp(system_charset_info, table->alias, alias) &&
            table->query_id != thd->query_id && /* skip tables already used */
            (thd->locked_tables_mode == LTM_LOCK_TABLES ||
             table->query_id == 0)) {
          int distance = ((int)table->reginfo.lock_type -
                          (int)table_list->lock_descriptor().type);

          /*
            Find a table that either has the exact lock type requested,
            or has the best suitable lock. In case there is no locked
            table that has an equal or higher lock than requested,
            we us the closest matching lock to be able to produce an error
            message about wrong lock mode on the table. The best_table
            is changed if bd < 0 <= d or bd < d < 0 or 0 <= d < bd.

            distance <  0 - No suitable lock found
            distance >  0 - we have lock mode higher then we require
            distance == 0 - we have lock mode exactly which we need
          */
          if ((best_distance < 0 && distance > best_distance) ||
              (distance >= 0 && distance < best_distance)) {
            best_distance = distance;
            best_table = table;
            if (best_distance == 0) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_table_get_mdl_lock not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_table_get_mdl_lock not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_and_process_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_and_process_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_and_process_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_and_process_routine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: acquire_backup_lock_in_lock_tables_mode
          acquire_backup_lock_in_lock_tables_mode(thd, *start, end_table)) {
        error = true;
        goto err;
      }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.h
Function: Open_table_context::get_timeout not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.h
Function: Open_table_context::get_timeout not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.h
Function: Open_table_context::get_timeout not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_component.cc
Function: Sql_cmd_install_component::execute
bool Sql_cmd_install_component::execute(THD *thd) {
  my_service<SERVICE_TYPE(persistent_dynamic_loader)> persisted_loader(
      "persistent_dynamic_loader", srv_registry);
  if (persisted_loader) {
    my_error(ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION, MYF(0),
             "persistent_dynamic_loader");
    return true;
  }

  if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard autocommit_guard(thd);
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  DBUG_EXECUTE_IF("disable_rg_pfs_notifications", {
    auto name = "file://component_test_pfs_notification";
    if (m_urns.size() == 1 && strcmp(name, m_urns[0].str) == 0)
      resourcegroups::Resource_group_mgr::instance()
          ->disable_pfs_notification();
  });

  m_arg_list_size = m_set_exprs->size() * 2 + 1;
  m_arg_list = thd->mem_root->ArrayAlloc<char *>(m_arg_list_size + 1);
  m_arg_list[m_arg_list_size] = nullptr;
  char **arg = m_arg_list;

  *arg++ = nullptr;  // no program name

  for (auto &set : *m_set_exprs) {
    if (!set.expr->fixed && set.expr->fix_fields(thd, &set.expr)) return true;

    char buff[STRING_BUFFER_USUAL_SIZE];
    String value(buff, sizeof(buff), system_charset_info), *val;
    val = set.expr->val_str(&value);

    if (!val || set.expr->is_null()) {
      String x;
      if (set.name.prefix.length > 0) {
        x.append(set.name.prefix);
        x.append('.');
      }
      x.append(set.name.name);
      my_error(ER_INSTALL_COMPONENT_SET_NULL_VALUE, MYF(0), x.c_ptr());
      return true;
    }

    String argument(STRING_WITH_LEN("--"), system_charset_info);
    if (set.name.prefix.length > 0) {
      argument.append(set.name.prefix);
      argument.append('.');
    }
    argument.append(set.name.name);
    char *arg_name = thd->strmake(argument.c_ptr(), argument.length());
    convert_underscore_to_dash(arg_name, argument.length());

    *arg++ = arg_name;
    *arg++ = thd->strmake(val->c_ptr_safe(), val->length());
  }

  std::vector<const char *> urns(m_urns.size());
  for (size_t i = 0; i < m_urns.size(); ++i) {
    urns[i] = m_urns[i].str;
  }
  if (persisted_loader->load(thd, urns.data(), m_urns.size())) {
    return (end_transaction(thd, true));
  }

  bool set_var_failed = false;

  if (m_arg_list_size > 1) {
    std::stringstream str;
    str << m_arg_list[1] + 2;
    for (int idx = 3; idx < m_arg_list_size; idx += 2)
      str << ((idx + 2 < m_arg_list_size) ? ", " : " and ")
          << (m_arg_list[idx] + 2);
    my_error(ER_INSTALL_COMPONENT_SET_UNUSED_VALUE, MYF(0), str.str().c_str());
    set_var_failed = true;
  }
  /* persist the values that need persisting */
  if (!set_var_failed && m_set_exprs->elements > 0) {
    Set_variables_helper hlp(thd);
    for (auto &set_var : *m_set_exprs) {
      enum_var_type type = set_var.type;
      /* we already did the SET GLOBAL part, convert to PERSIST */
      if (type == enum_var_type::OPT_PERSIST)
        type = enum_var_type::OPT_PERSIST_ONLY;

      if (type == enum_var_type::OPT_PERSIST ||
          type == enum_var_type::OPT_PERSIST_ONLY) {
        if (hlp.add_variable(set_var.name.prefix.str,
                             set_var.name.prefix.length, set_var.name.name.str,
                             set_var.name.name.length, set_var.expr, type)) {
          set_var_failed = true;
          break;
        }
      } else if (hlp.check_variable_update_type(
                     set_var.name.prefix.str, set_var.name.prefix.length,
                     set_var.name.name.str, set_var.name.name.length,
                     set_var.expr)) {
        set_var_failed = true;
        break;
      }
    }
    if (set_var_failed || hlp.execute()) {
      set_var_failed = true;
    }
  }
  if (set_var_failed) {
    if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout) ||
        acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout))
      return true;
    if (dynamic_loader_srv->unload(urns.data(), m_urns.size()) ||
        mysql_persistent_dynamic_loader_imp::remove_from_cache(
            urns.data(), urns.size()) != (int)urns.size()) {
      assert(0);
    }
    return (end_transaction(thd, true));
  }

  my_ok(thd);
  return (end_transaction(thd, false));
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_component.cc
Function: Sql_cmd_uninstall_component::execute
bool Sql_cmd_install_component::execute(THD *thd) {
  my_service<SERVICE_TYPE(persistent_dynamic_loader)> persisted_loader(
      "persistent_dynamic_loader", srv_registry);
  if (persisted_loader) {
    my_error(ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION, MYF(0),
             "persistent_dynamic_loader");
    return true;
  }

  if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard autocommit_guard(thd);
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  DBUG_EXECUTE_IF("disable_rg_pfs_notifications", {
    auto name = "file://component_test_pfs_notification";
    if (m_urns.size() == 1 && strcmp(name, m_urns[0].str) == 0)
      resourcegroups::Resource_group_mgr::instance()
          ->disable_pfs_notification();
  });

  m_arg_list_size = m_set_exprs->size() * 2 + 1;
  m_arg_list = thd->mem_root->ArrayAlloc<char *>(m_arg_list_size + 1);
  m_arg_list[m_arg_list_size] = nullptr;
  char **arg = m_arg_list;

  *arg++ = nullptr;  // no program name

  for (auto &set : *m_set_exprs) {
    if (!set.expr->fixed && set.expr->fix_fields(thd, &set.expr)) return true;

    char buff[STRING_BUFFER_USUAL_SIZE];
    String value(buff, sizeof(buff), system_charset_info), *val;
    val = set.expr->val_str(&value);

    if (!val || set.expr->is_null()) {
      String x;
      if (set.name.prefix.length > 0) {
        x.append(set.name.prefix);
        x.append('.');
      }
      x.append(set.name.name);
      my_error(ER_INSTALL_COMPONENT_SET_NULL_VALUE, MYF(0), x.c_ptr());
      return true;
    }

    String argument(STRING_WITH_LEN("--"), system_charset_info);
    if (set.name.prefix.length > 0) {
      argument.append(set.name.prefix);
      argument.append('.');
    }
    argument.append(set.name.name);
    char *arg_name = thd->strmake(argument.c_ptr(), argument.length());
    convert_underscore_to_dash(arg_name, argument.length());

    *arg++ = arg_name;
    *arg++ = thd->strmake(val->c_ptr_safe(), val->length());
  }

  std::vector<const char *> urns(m_urns.size());
  for (size_t i = 0; i < m_urns.size(); ++i) {
    urns[i] = m_urns[i].str;
  }
  if (persisted_loader->load(thd, urns.data(), m_urns.size())) {
    return (end_transaction(thd, true));
  }

  bool set_var_failed = false;

  if (m_arg_list_size > 1) {
    std::stringstream str;
    str << m_arg_list[1] + 2;
    for (int idx = 3; idx < m_arg_list_size; idx += 2)
      str << ((idx + 2 < m_arg_list_size) ? ", " : " and ")
          << (m_arg_list[idx] + 2);
    my_error(ER_INSTALL_COMPONENT_SET_UNUSED_VALUE, MYF(0), str.str().c_str());
    set_var_failed = true;
  }
  /* persist the values that need persisting */
  if (!set_var_failed && m_set_exprs->elements > 0) {
    Set_variables_helper hlp(thd);
    for (auto &set_var : *m_set_exprs) {
      enum_var_type type = set_var.type;
      /* we already did the SET GLOBAL part, convert to PERSIST */
      if (type == enum_var_type::OPT_PERSIST)
        type = enum_var_type::OPT_PERSIST_ONLY;

      if (type == enum_var_type::OPT_PERSIST ||
          type == enum_var_type::OPT_PERSIST_ONLY) {
        if (hlp.add_variable(set_var.name.prefix.str,
                             set_var.name.prefix.length, set_var.name.name.str,
                             set_var.name.name.length, set_var.expr, type)) {
          set_var_failed = true;
          break;
        }
      } else if (hlp.check_variable_update_type(
                     set_var.name.prefix.str, set_var.name.prefix.length,
                     set_var.name.name.str, set_var.name.name.length,
                     set_var.expr)) {
        set_var_failed = true;
        break;
      }
    }
    if (set_var_failed || hlp.execute()) {
      set_var_failed = true;
    }
  }
  if (set_var_failed) {
    if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout) ||
        acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout))
      return true;
    if (dynamic_loader_srv->unload(urns.data(), m_urns.size()) ||
        mysql_persistent_dynamic_loader_imp::remove_from_cache(
            urns.data(), urns.size()) != (int)urns.size()) {
      assert(0);
    }
    return (end_transaction(thd, true));
  }

  my_ok(thd);
  return (end_transaction(thd, false));
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_db.cc
Function: mysql_alter_db
bool mysql_alter_db(THD *thd, const char *db, HA_CREATE_INFO *create_info) {
  DBUG_TRACE;

  // Reject altering the system schema except for system threads.
  if (!thd->is_dd_system_thread() &&
      dd::get_dictionary()->is_dd_schema_name(db)) {
    my_error(ER_NO_SYSTEM_SCHEMA_ACCESS, MYF(0), db);
    return true;
  }

  /*
    Check if user has permission to alter database, if encryption type
    provided differ from global 'default_table_encryption' setting.
  */
  if (create_info->encrypt_type.str && opt_table_encryption_privilege_check &&
      dd::is_encrypted(create_info->encrypt_type) !=
          thd->variables.default_table_encryption &&
      check_table_encryption_admin_access(thd)) {
    my_error(ER_CANNOT_SET_DATABASE_ENCRYPTION, MYF(0));
    return true;
  }

  if (lock_schema_name(thd, db)) return true;

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  dd::Schema *schema = nullptr;
  if (thd->dd_client()->acquire_for_modification(db, &schema)) return true;

  if (schema == nullptr) {
    my_error(ER_NO_SUCH_DB, MYF(0), db);
    return true;
  }

  /*
    If the schema is in read_only state, then the only change allowed is to:

    - Turn off read_only, possibly along with other option changes.
    - Keep read_only turned on, i.e., a no-op. In this case, other options may
      not be changed in the same statement.

     This means we fail if:

     - HA_CREATE_USED_READ_ONLY is not set.
     - Or if we set other fields as well and set READ ONLY to true.

     We check this before locking tables to avoid unnecessary lock acquisition.
  */
  bool schema_read_only = false;
  schema_read_only = schema->read_only();
  if (!thread_can_ignore_schema_read_only(thd) && schema_read_only) {
    if (!(create_info->used_fields & HA_CREATE_USED_READ_ONLY) ||
        ((create_info->used_fields & ~HA_CREATE_USED_READ_ONLY) &&
         create_info->schema_read_only)) {
      my_error(ER_SCHEMA_READ_ONLY, MYF(0), db);
      return true;
    }
  }

  /*
    Lock all tables while under schema lock so that we block all transactions
    from touching these tables until the ALTER is done. Because the schema read
    only check and the COMMIT are not done atomically, we use the table MDL
    to serialize ALTER SCHEMA and any write statements.
  */
  Table_ref *tables = nullptr;
  if (find_db_tables(thd, *schema, db, &tables) ||
      lock_table_names(thd, tables, nullptr, thd->variables.lock_wait_timeout,
                       0))
    return true;

  // Set new collation ID if submitted in the statement.
  if (create_info->used_fields & HA_CREATE_USED_DEFAULT_CHARSET) {
    set_db_default_charset(thd, create_info);
    schema->set_default_collation_id(
        create_info->default_table_charset->number);
  }

  // Set encryption type.
  if (create_info->used_fields & HA_CREATE_USED_DEFAULT_ENCRYPTION) {
    assert(create_info->encrypt_type.length > 0);
    schema->set_default_encryption(dd::is_encrypted(create_info->encrypt_type));
  }

  // Set read_only option.
  if (create_info->used_fields & HA_CREATE_USED_READ_ONLY) {
    schema->set_read_only(create_info->schema_read_only);
  }

  // Update schema.
  if (thd->dd_client()->update(schema)) return true;

  /*
    The original query is submitted to the engine's log handler
    because e.g. NDB needs to propagate the read only option to
    other mysqld servers in the cluster.
  */
  ha_binlog_log_query(thd, nullptr, LOGCOM_ALTER_DB, thd->query().str,
                      thd->query().length, db, "");

  /*
    The original query is written to the binlog and hence replicated.
    Binlogging must be switched off while executing ALTER SCHEMA if
    this is not desired.
  */
  if (write_db_cmd_to_binlog(thd, db, true)) return true;

  /*
    Commit the statement locally instead of relying on caller,
    in order to be sure that it is successful, before changing
    options of current database.
  */
  if (trans_commit_stmt(thd) || trans_commit(thd)) return true;

  /*
    Change collation options if the current database is being
    altered and the clause is explicitly submitted in the ALTER
    statement.
  */
  if (create_info->used_fields & HA_CREATE_USED_DEFAULT_CHARSET &&
      thd->db().str && !my_strcasecmp(table_alias_charset, thd->db().str, db)) {
    thd->db_charset = create_info->default_table_charset
                          ? create_info->default_table_charset
                          : thd->variables.collation_server;
    thd->variables.collation_database = thd->db_charset;
  }

  /*
    If the schema read only option was changed, then we must also evict the
    tables belonging to the schema from the TDC since the option is cached
    in the table shares. This is safe since we have already acquired
    exclusive MDL for each table.
  */
  if (create_info->used_fields & HA_CREATE_USED_READ_ONLY) {
    mysql_ha_flush_tables(thd, tables);
    for (Table_ref *table = tables; table != nullptr;
         table = table->next_global) {
      tdc_remove_table(thd, TDC_RT_REMOVE_ALL, table->db, table->table_name,
                       false);
    }
  }

  my_ok(thd, 1);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_db.cc
Function: mysql_rm_db
bool mysql_rm_db(THD *thd, const LEX_CSTRING &db, bool if_exists) {
  ulong deleted_tables = 0;
  bool error = false;
  char path[2 * FN_REFLEN + 16];
  Table_ref *tables = nullptr;
  Table_ref *table;
  Drop_table_error_handler err_handler;
  bool dropped_non_atomic = false;
  std::set<handlerton *> post_ddl_htons;
  Foreign_key_parents_invalidator fk_invalidator;

  DBUG_TRACE;

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  // Reject dropping the system schema except for system threads.
  if (!thd->is_dd_system_thread() &&
      dd::get_dictionary()->is_dd_schema_name(dd::String_type(db.str))) {
    my_error(ER_NO_SYSTEM_SCHEMA_ACCESS, MYF(0), db.str);
    return true;
  }

  if (lock_schema_name(thd, db.str)) return true;

  build_table_filename(path, sizeof(path) - 1, db.str, "", "", 0);

  DEBUG_SYNC(thd, "before_acquire_in_drop_schema");
  const dd::Schema *schema = nullptr;
  if (thd->dd_client()->acquire(db.str, &schema)) return true;

  DBUG_EXECUTE_IF("pretend_no_schema_in_drop_schema", { schema = nullptr; });

  /* See if the directory exists */
  MY_DIR *schema_dirp = my_dir(path, MYF(MY_DONT_SORT));

  auto dirender = [](MY_DIR *dirp) { my_dirend(dirp); };
  std::unique_ptr<MY_DIR, decltype(dirender)> grd{schema_dirp, dirender};

  if (schema == nullptr)  // Schema not found in DD
  {
    if (schema_dirp != nullptr)  // Schema directory exists
    {
      // This is always an error, even when if_exists is true
      my_error(ER_SCHEMA_DIR_UNKNOWN, MYF(0), db.str, path);
      return true;
    }

    if (!if_exists)  // IF EXISTS not given
    {
      my_error(ER_DB_DROP_EXISTS, MYF(0), db.str);
      return true;
    }
    push_warning_printf(thd, Sql_condition::SL_NOTE, ER_DB_DROP_EXISTS,
                        ER_THD(thd, ER_DB_DROP_EXISTS), db.str);

    /*
      We don't have active transaction at this point so we can't use
      binlog's trx cache, which requires transaction with valid XID.
    */
    if (write_db_cmd_to_binlog(thd, db.str, false)) return true;

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd)) return true;

    /* Fall-through to resetting current database in connection. */
  } else  // Schema found in DD
  {
    /* Database directory does not exist. */
    if (schema_dirp == nullptr) {
      if (!if_exists) {
        my_error(ER_SCHEMA_DIR_MISSING, MYF(0), path);
        return true;
      }
      push_warning_printf(thd, Sql_condition::SL_NOTE, ER_SCHEMA_DIR_MISSING,
                          ER_THD(thd, ER_SCHEMA_DIR_MISSING), path);
    } else {
      if (find_unknown_and_remove_deletable_files(thd, schema_dirp, path)) {
        return true;
      }
    }

    if (find_db_tables(thd, *schema, db.str, &tables)) {
      return true;
    }

    /* Lock all tables and stored routines about to be dropped. */
    if (lock_table_names(thd, tables, nullptr, thd->variables.lock_wait_timeout,
                         0) ||
        rm_table_do_discovery_and_lock_fk_tables(thd, tables) ||
        lock_check_constraint_names(thd, tables) ||
        Events::lock_schema_events(thd, *schema) ||
        lock_db_routines(thd, *schema) || lock_trigger_names(thd, tables))
      return true;

    /* mysql_ha_rm_tables() requires a non-null Table_ref. */
    if (tables) mysql_ha_rm_tables(thd, tables);

    for (table = tables; table; table = table->next_local) {
      deleted_tables++;
    }

    if (thd->killed) return true;

    thd->push_internal_handler(&err_handler);
    if (tables)
      error = mysql_rm_table_no_locks(thd, tables, true, false, true,
                                      &dropped_non_atomic, &post_ddl_htons,
                                      &fk_invalidator, nullptr);

    DBUG_EXECUTE_IF("rm_db_fail_after_dropping_tables", {
      my_error(ER_UNKNOWN_ERROR, MYF(0));
      error = true;
    });

    if (!error) {
      /*
        We temporarily disable the binary log while dropping SPs
        in the database. Since the DROP DATABASE statement is always
        replicated as a statement, execution of it will drop all objects
        in the database on the slave as well, so there is no need to
        replicate the removal of the individual objects in the database
        as well.

        This is more of a safety precaution, since normally no objects
        should be dropped while the database is being cleaned, but in
        the event that a change in the code to remove other objects is
        made, these drops should still not be logged.

        Notice that the binary log have to be enabled over the call to
        ha_drop_database(), since NDB otherwise detects the binary log
        as disabled and will not log the drop database statement on any
        other connected server.
      */

      ha_drop_database(path);
      thd->clear_error(); /* @todo Do not ignore errors */
      Disable_binlog_guard binlog_guard(thd);
      error = Events::drop_schema_events(thd, *schema);
      error = (error || sp_drop_db_routines(thd, *schema));
    }
    thd->pop_internal_handler();

    if (!error) error = thd->dd_client()->drop(schema);

    /*
      If database exists and there was no error we should
      write statement to binary log and remove DD entry.
    */
    if (!error) error = write_db_cmd_to_binlog(thd, db.str, true);

    if (!error) error = trans_commit_stmt(thd) || trans_commit(thd);

    /*
      In case of error rollback the transaction in order to revert
      changes which are possible to rollback (e.g. removal of tables
      in SEs supporting atomic DDL, events and routines).
    */
    if (error) {
      trans_rollback_stmt(thd);
      /*
        Play safe to be sure that THD::transaction_rollback_request is
        cleared before work-around code below is run. This also necessary
        to synchronize state of data-dicitionary on disk and in cache (to
        clear cache of uncommitted objects).
      */
      trans_rollback_implicit(thd);
    }

    /*
      Call post-DDL handlerton hook. For engines supporting atomic DDL
      tables' files are removed from disk on this step.
    */
    for (handlerton *hton : post_ddl_htons) hton->post_ddl(thd);

    fk_invalidator.invalidate(thd);

    /*
      Now we can try removing database directory.

      If the directory is a symbolic link, remove the link first, then
      remove the directory the symbolic link pointed at.

      This can happen only after post-DDL handlerton hook removes files
      from the directory.

      Since the statement is committed already, we do not report unlikely
      failure to remove the directory as an error. Instead we report it
      as a warning, which is sent to user and written to server error log.
    */
    if (!error && schema_dirp != nullptr) {
      Rmdir_error_handler rmdir_handler;
      thd->push_internal_handler(&rmdir_handler);
      (void)rm_dir_w_symlink(path, true);
      thd->pop_internal_handler();
    }

    if (error) {
      if (mysql_bin_log.is_open()) {
        /*
          If GTID_NEXT=='UUID:NUMBER', we must not log an incomplete
          statement.  However, the incomplete DROP has already 'committed'
          (some tables were removed).  So we generate an error and let
          user fix the situation.
        */
        if (thd->variables.gtid_next.type == ASSIGNED_GTID &&
            dropped_non_atomic) {
          char gtid_buf[Gtid::MAX_TEXT_LENGTH + 1];
          thd->variables.gtid_next.gtid.to_string(global_sid_map, gtid_buf,
                                                  true);
          my_error(ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID, MYF(0), path,
                   gtid_buf, db.str);
          return true;
        }
      }
      return true;
    }
  }

  /*
    If this database was the client's selected database, we silently
    change the client's selected database to nothing (to have an empty
    SELECT DATABASE() in the future). For this we free() thd->db and set
    it to 0.
  */
  if (thd->db().str && !strcmp(thd->db().str, db.str)) {
    mysql_change_db_impl(thd, NULL_CSTR, 0, thd->variables.collation_server);
    /*
      Check if current database tracker is enabled. If so, set the 'changed'
      flag.
    */
    if (thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)
            ->is_enabled()) {
      thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)
          ->mark_as_changed(thd, {});
    }
  }

  thd->server_status |= SERVER_STATUS_DB_DROPPED;
  my_ok(thd, deleted_tables);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_handler.cc
Function: Sql_cmd_handler_read::execute
bool Sql_cmd_handler_open::execute(THD *thd) {
  Table_ref *hash_tables = nullptr;
  char *db, *name, *alias;
  Table_ref *tables = thd->lex->query_block->get_table_list();
  DBUG_TRACE;
  DBUG_PRINT("enter", ("'%s'.'%s' as '%s'", tables->db, tables->table_name,
                       tables->alias));

  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }
  if (tables->schema_table) {
    my_error(ER_WRONG_USAGE, MYF(0), "HANDLER OPEN",
             INFORMATION_SCHEMA_NAME.str);
    DBUG_PRINT("exit", ("ERROR"));
    return true;
  }

  /*
    We might have a handler with the same name already.

    Note that it is safe to disclose this information before doing privilege
    check. Current user can always find out that handler is open by using
    HANDLER ... READ command, which doesn't requires any privileges.
  */
  if (thd->handler_tables_hash.count(tables->alias) != 0) {
    DBUG_PRINT("info", ("duplicate '%s'", tables->alias));
    DBUG_PRINT("exit", ("ERROR"));
    my_error(ER_NONUNIQ_TABLE, MYF(0), tables->alias);
    return true;
  }

  /* copy the Table_ref struct */
  const size_t db_alloc_len = strlen(tables->db) + 1;
  const size_t name_alloc_len = strlen(tables->table_name) + 1;
  const size_t alias_alloc_len = strlen(tables->alias) + 1;

  if (!(my_multi_malloc(key_memory_THD_handler_tables_hash, MYF(MY_WME),
                        &hash_tables, sizeof(*hash_tables), &db, db_alloc_len,
                        &name, name_alloc_len, &alias, alias_alloc_len,
                        NullS))) {
    DBUG_PRINT("exit", ("ERROR"));
    return true;
  }
  memcpy(db, tables->db, db_alloc_len);
  memcpy(name, tables->table_name, name_alloc_len);
  memcpy(alias, tables->alias, alias_alloc_len);
  /*
    We can't request lock with explicit duration for this table
    right from the start as open_tables() can't handle properly
    back-off for such locks.
  */
  assert(tables->table == nullptr);
  new (hash_tables) Table_ref(db, tables->db_length, name,
                              tables->table_name_length, alias, MDL_SHARED);

  /* for now HANDLER can be used only for real TABLES */
  hash_tables->required_type = dd::enum_table_type::BASE_TABLE;
  /* add to hash */
  thd->handler_tables_hash.emplace(alias,
                                   unique_ptr_my_free<Table_ref>(hash_tables));

  if (open_temporary_tables(thd, hash_tables) ||
      check_table_access(thd, SELECT_ACL, hash_tables, false, UINT_MAX,
                         false) ||
      mysql_ha_open_table(thd, hash_tables))

  {
    thd->handler_tables_hash.erase(alias);
    DBUG_PRINT("exit", ("ERROR"));
    return true;
  }

  my_ok(thd);

  DBUG_PRINT("exit", ("OK"));
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_parse.cc
Function: lock_tables_open_and_lock_tables
static bool lock_tables_open_and_lock_tables(THD *thd, Table_ref *tables) {
  Lock_tables_prelocking_strategy lock_tables_prelocking_strategy;
  MDL_deadlock_and_lock_abort_error_handler deadlock_handler;
  MDL_savepoint mdl_savepoint = thd->mdl_context.mdl_savepoint();
  uint counter;
  Table_ref *table;

  thd->in_lock_tables = true;

retry:

  if (open_tables(thd, &tables, &counter, 0, &lock_tables_prelocking_strategy))
    goto err;

  deadlock_handler.init();
  thd->push_internal_handler(&deadlock_handler);

  for (table = tables; table; table = table->next_global) {
    if (!table->is_placeholder()) {
      if (table->table->s->tmp_table) {
        /*
          We allow to change temporary tables even if they were locked for read
          by LOCK TABLES. To avoid a discrepancy between lock acquired at LOCK
          TABLES time and by the statement which is later executed under LOCK
          TABLES we ensure that for temporary tables we always request a write
          lock (such discrepancy can cause problems for the storage engine).
          We don't set Table_ref::lock_type in this case as this might
          result in extra warnings from THD::decide_logging_format() even though
          binary logging is totally irrelevant for LOCK TABLES.
        */
        table->table->reginfo.lock_type = TL_WRITE;
      } else if (table->lock_descriptor().type == TL_READ &&
                 !table->prelocking_placeholder &&
                 table->table->file->ha_table_flags() & HA_NO_READ_LOCAL_LOCK) {
        /*
          In case when LOCK TABLE ... READ LOCAL was issued for table with
          storage engine which doesn't support READ LOCAL option and doesn't
          use THR_LOCK locks we need to upgrade weak SR metadata lock acquired
          in open_tables() to stronger SRO metadata lock.
          This is not needed for tables used through stored routines or
          triggers as we always acquire SRO (or even stronger SNRW) metadata
          lock for them.
        */
        bool result = thd->mdl_context.upgrade_shared_lock(
            table->table->mdl_ticket, MDL_SHARED_READ_ONLY,
            thd->variables.lock_wait_timeout);

        if (deadlock_handler.need_reopen()) {
          /*
            Deadlock occurred during upgrade of metadata lock.
            Let us restart acquiring and opening tables for LOCK TABLES.
          */
          thd->pop_internal_handler();
          close_tables_for_reopen(thd, &tables, mdl_savepoint);
          if (open_temporary_tables(thd, tables)) goto err;
          goto retry;
        }

        if (result) {
          thd->pop_internal_handler();
          goto err;
        }
      }
    }
  }

  thd->pop_internal_handler();

  if (lock_tables(thd, tables, counter, 0) ||
      thd->locked_tables_list.init_locked_tables(thd))
    goto err;

  thd->in_lock_tables = false;

  return false;

err:
  thd->in_lock_tables = false;

  trans_rollback_stmt(thd);
  /*
    Need to end the current transaction, so the storage engine (InnoDB)
    can free its locks if LOCK TABLES locked some tables before finding
    that it can't lock a table in its list
  */
  trans_rollback(thd);
  /* Close tables and release metadata locks. */
  close_thread_tables(thd);
  assert(!thd->locked_tables_mode);
  thd->mdl_context.release_transactional_locks();
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_install_plugin not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_install_plugin not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_install_plugin not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_install_plugin not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_install_plugin not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_install_plugin not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_uninstall_plugin
static bool mysql_uninstall_plugin(THD *thd, LEX_CSTRING name) {
  TABLE *table;
  st_plugin_int *plugin;
  bool error = true;
  int rc = 0;
  bool remove_IS_metadata_from_dd = false;
  dd::Schema_MDL_locker mdl_handler(thd);
  dd::String_type orig_plugin_name;

  DBUG_TRACE;

  Table_ref tables("mysql", 5, "plugin", 6, "plugin", TL_WRITE);

  if (!opt_noacl &&
      check_table_access(thd, DELETE_ACL, &tables, false, 1, false)) {
    assert(thd->is_error());
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard autocommit_guard(thd);
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  /* need to open before acquiring LOCK_plugin or it will deadlock */
  if (!(table =
            open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT))) {
    assert(thd->is_error());
    return true;
  }

  /*
    System table mysql.plugin is supported by only InnoDB engine. Changing
    table's engine is not allowed. But to support logical upgrade creating
    system table is allowed in MyISAM engine. UNINSTALL PLUGIN operation is
    *not* allowed in this case.
  */
  if ((table->file->ht->is_supported_system_table != nullptr) &&
      !table->file->ht->is_supported_system_table(tables.db, tables.table_name,
                                                  true)) {
    my_error(ER_UNSUPPORTED_ENGINE, MYF(0),
             ha_resolve_storage_engine_name(table->file->ht), tables.db,
             tables.table_name);
    return end_transaction(thd, error);
  }

  // UNINSTALL PLUGIN operation is *not* allowed if table structure is changed.
  System_table_intact table_intact(thd);
  if (table_intact.check(thd, table, &mysql_plugin_table_def))
    return end_transaction(thd, error);

  mysql_mutex_lock(&LOCK_plugin_install);
  if (!table->key_info) {
    my_error(ER_MISSING_KEY, MYF(0), table->s->db.str,
             table->s->table_name.str);
    goto err;
  }

  /*
    Pre-acquire audit plugins for events that may potentially occur
    during [UN]INSTALL PLUGIN.

    When audit event is triggered, audit subsystem acquires interested
    plugins by walking through plugin list. Evidently plugin list
    iterator protects plugin list by acquiring LOCK_plugin, see
    plugin_foreach_with_mask().

    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin
    rather for a long time.

    When audit event is triggered during [UN]INSTALL PLUGIN, plugin
    list iterator acquires the same lock (within the same thread)
    second time.

    This hack should be removed when LOCK_plugin is fixed so it
    protects only what it supposed to protect.
  */
  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS,
                              MYSQL_AUDIT_GENERAL_ALL);

  mysql_mutex_lock(&LOCK_plugin);
  if (!(plugin = plugin_find_internal(name, MYSQL_ANY_PLUGIN)) ||
      plugin->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_DYING)) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), "PLUGIN", name.str);
    goto err;
  }
  if (!plugin->plugin_dl) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_PLUGIN_DELETE_BUILTIN, MYF(0));
    goto err;
  }
  if (plugin->load_option == PLUGIN_FORCE_PLUS_PERMANENT) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_PLUGIN_IS_PERMANENT, MYF(0), name.str);
    goto err;
  }
  /*
    Error message for ER_PLUGIN_IS_PERMANENT is not suitable for
    plugins marked as not dynamically uninstallable, so we have a
    separate one instead of changing the old one.
   */
  if (plugin->plugin->flags & PLUGIN_OPT_NO_UNINSTALL) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_PLUGIN_NO_UNINSTALL, MYF(0), plugin->plugin->name);
    goto err;
  }

  if ((plugin->plugin->check_uninstall) && (plugin->state == PLUGIN_IS_READY)) {
    int check;
    /*
      Prevent other threads to uninstall concurrently this plugin.
    */
    plugin->state = PLUGIN_IS_DYING;
    mysql_mutex_unlock(&LOCK_plugin);

    DEBUG_SYNC(current_thd, "in_plugin_check_uninstall");

    /*
      Check uninstall may perform complex operations,
      including acquiring MDL locks, which in turn may need LOCK_plugin.
    */
    DBUG_PRINT("info", ("check uninstall plugin: '%s'", plugin->name.str));
    check = plugin->plugin->check_uninstall(plugin);

    mysql_mutex_lock(&LOCK_plugin);
    assert(plugin->state == PLUGIN_IS_DYING);

    if (check) {
      DBUG_PRINT("warning",
                 ("Plugin '%s' blocked uninstall.", plugin->name.str));
      plugin->state = PLUGIN_IS_READY;
      mysql_mutex_unlock(&LOCK_plugin);
      my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name.str,
               "Plugin is still in use.");
      goto err;
    }
  }

  plugin->state = PLUGIN_IS_DELETED;
  if (plugin->ref_count)
    push_warning(thd, Sql_condition::SL_WARNING, WARN_PLUGIN_BUSY,
                 ER_THD(thd, WARN_PLUGIN_BUSY));
  else
    reap_needed = true;

  // Check if we need to remove I_S plugin metadata from DD.
  remove_IS_metadata_from_dd =
      (plugin->plugin->type == MYSQL_INFORMATION_SCHEMA_PLUGIN &&
       plugin->load_option != PLUGIN_OFF);

  orig_plugin_name = dd::String_type(plugin->name.str, plugin->name.length);
  reap_plugins();
  mysql_mutex_unlock(&LOCK_plugin);

  uchar user_key[MAX_KEY_LENGTH];
  table->use_all_columns();
  table->field[0]->store(name.str, name.length, system_charset_info);
  key_copy(user_key, table->record[0], table->key_info,
           table->key_info->key_length);

  if ((rc = table->file->ha_index_read_idx_map(
           table->record[0], 0, user_key, HA_WHOLE_KEY, HA_READ_KEY_EXACT)) ==
      0) {
    /*
      We do not replicate the UNINSTALL PLUGIN statement. Disable binlogging
      of the delete from the plugin table, so that it is not replicated in
      row based mode.
    */
    assert(!thd->is_error());
    Disable_binlog_guard binlog_guard(thd);
    rc = table->file->ha_delete_row(table->record[0]);
    if (rc) {
      assert(thd->is_error());
    } else
      error = false;
  } else if (rc != HA_ERR_KEY_NOT_FOUND && rc != HA_ERR_END_OF_FILE) {
    assert(thd->is_error());
  } else
    error = false;

  if (error) {
    const char msg[] = "got '%s' deleting from mysql.plugin";
    char buf[MYSQL_ERRMSG_SIZE + sizeof(msg) - 2];
    char errbuf[MYSQL_ERRMSG_SIZE];
    my_strerror(errbuf, sizeof(errbuf), error);
    snprintf(buf, sizeof(buf), msg, errbuf);
    report_error(REPORT_TO_USER, ER_PLUGIN_UNINSTALL_ERROR, name.str, buf);
  }

  if (!error && !thd->transaction_rollback_request &&
      remove_IS_metadata_from_dd) {
    error = dd::info_schema::remove_I_S_view_metadata(
        thd,
        dd::String_type(orig_plugin_name.c_str(), orig_plugin_name.length()));
    assert(!error || thd->is_error());

    if (!error) {
      Uncommitted_tables_guard uncommitted_tables(thd);
      error = update_referencing_views_metadata(
          thd, INFORMATION_SCHEMA_NAME.str, orig_plugin_name.c_str(), false,
          &uncommitted_tables);
    }

    if (error) {
      report_error(REPORT_TO_USER, ER_PLUGIN_UNINSTALL_ERROR, name.str,
                   "error updating metadata");
    }
  }

err:
  mysql_mutex_unlock(&LOCK_plugin_install);
  return end_transaction(thd, error || thd->transaction_rollback_request);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_reload.cc
Function: handle_reload_request
    pointer where handle_reload_request() will put 0 if
    it thinks we really should not write to the binlog.
    Otherwise it will put 1.

  @return Error status code
    @retval 0 Ok
    @retval !=0  Error; thd->killed is set or thd->is_error() is true
*/

bool handle_reload_request(THD *thd, unsigned long options, Table_ref *tables,
                           int *write_to_binlog) {
  bool result = false;
  select_errors = 0; /* Write if more errors */
  int tmp_write_to_binlog = *write_to_binlog = 1;

  assert(!thd || !thd->in_sub_stmt);

  if (options & REFRESH_GRANT) {
    THD *tmp_thd = nullptr;
    /*
      If handle_reload_request() is called from SIGHUP handler we have to
      allocate temporary THD for execution of acl_reload()/grant_reload().
    */
    if (!thd && (thd = (tmp_thd = new THD))) {
      thd->thread_stack = (char *)&tmp_thd;
      thd->store_globals();
    }

    if (thd) {
      bool reload_acl_failed = reload_acl_caches(thd, false);
      bool reload_servers_failed = servers_reload(thd);
      notify_flush_event(thd);
      if (reload_acl_failed || reload_servers_failed) {
        result = true;
        /*
          When an error is returned, my_message may have not been called and
          the client will hang waiting for a response.
        */
        my_error(ER_UNKNOWN_ERROR, MYF(0));
      }
    }

    reset_mqh(thd, (LEX_USER *)nullptr, true);
    if (tmp_thd) {
      delete tmp_thd;
      thd = nullptr;
    }
  }

  if (options & REFRESH_LOG) {
    /*
      Flush the normal query log, the update log, the binary log,
      the slow query log, the relay log (if it exists) and the log
      tables.
    */

    options |= REFRESH_BINARY_LOG;
    options |= REFRESH_RELAY_LOG;
    options |= REFRESH_SLOW_LOG;
    options |= REFRESH_GENERAL_LOG;
    options |= REFRESH_ENGINE_LOG;
    options |= REFRESH_ERROR_LOG;
  }

  if (options & REFRESH_ERROR_LOG) {
    if (reopen_error_log()) result = true;
  }

  if ((options & REFRESH_SLOW_LOG) && opt_slow_log &&
      (log_output_options & LOG_FILE))
    if (query_logger.reopen_log_file(QUERY_LOG_SLOW)) result = true;

  if ((options & REFRESH_GENERAL_LOG) && opt_general_log &&
      (log_output_options & LOG_FILE))
    if (query_logger.reopen_log_file(QUERY_LOG_GENERAL)) result = true;

  if (options & REFRESH_ENGINE_LOG) {
    if (ha_flush_logs()) {
      result = true;
    }
  }
  if ((options & REFRESH_BINARY_LOG) || (options & REFRESH_RELAY_LOG)) {
    /*
      If handle_reload_request() is called from SIGHUP handler we have to
      allocate temporary THD for execution of binlog/relay log rotation.
     */
    THD *tmp_thd = nullptr;
    if (!thd && (thd = (tmp_thd = new THD))) {
      thd->thread_stack = (char *)(&tmp_thd);
      thd->store_globals();
    }

    if (options & REFRESH_BINARY_LOG) {
      /*
        Writing this command to the binlog may result in infinite loops
        when doing mysqlbinlog|mysql, and anyway it does not really make
        sense to log it automatically (would cause more trouble to users
        than it would help them)
       */
      tmp_write_to_binlog = 0;
      if (mysql_bin_log.is_open()) {
        if (mysql_bin_log.rotate_and_purge(thd, true)) *write_to_binlog = -1;
      }
    }
    if (options & REFRESH_RELAY_LOG) {
      if (flush_relay_logs_cmd(thd)) *write_to_binlog = -1;
    }
    if (tmp_thd) {
      delete tmp_thd;
      /* Remember that we don't have a THD */
      current_thd = nullptr;
      thd = nullptr;
    }
  }

  assert(!thd || thd->locked_tables_mode || !thd->mdl_context.has_locks() ||
         !thd->handler_tables_hash.empty() ||
         thd->mdl_context.has_locks(MDL_key::USER_LEVEL_LOCK) ||
         thd->mdl_context.has_locks(MDL_key::LOCKING_SERVICE) ||
         thd->mdl_context.has_locks(MDL_key::BACKUP_LOCK) ||
         thd->global_read_lock.is_acquired());

  /*
    Note that if REFRESH_READ_LOCK bit is set then REFRESH_TABLES is set too
    (see sql_yacc.yy)
  */
  if (options & (REFRESH_TABLES | REFRESH_READ_LOCK)) {
    if ((options & REFRESH_READ_LOCK) && thd) {
      /*
        On the first hand we need write lock on the tables to be flushed,
        on the other hand we must not try to aspire a global read lock
        if we have a write locked table as this would lead to a deadlock
        when trying to reopen (and re-lock) the table after the flush.
      */
      if (thd->locked_tables_mode) {
        my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
        return true;
      }
      /*
        Writing to the binlog could cause deadlocks, as we don't log
        UNLOCK TABLES
      */
      tmp_write_to_binlog = 0;
      if (thd->global_read_lock.lock_global_read_lock(thd))
        return true;  // Killed
      if (close_cached_tables(thd, tables,
                              ((options & REFRESH_FAST) ? false : true),
                              thd->variables.lock_wait_timeout)) {
        /*
          NOTE: my_error() has been already called by reopen_tables() within
          close_cached_tables().
        */
        result = true;
      }

      if (thd->global_read_lock.make_global_read_lock_block_commit(
              thd))  // Killed
      {
        /* Don't leave things in a half-locked state */
        thd->global_read_lock.unlock_global_read_lock(thd);
        return true;
      }
    } else {
      if (thd && thd->locked_tables_mode) {
        /*
          If we are under LOCK TABLES we should have a write
          lock on tables which we are going to flush.
        */
        if (tables) {
          for (Table_ref *t = tables; t; t = t->next_local)
            if (!find_table_for_mdl_upgrade(thd, t->db, t->table_name, false))
              return true;
        } else {
          /*
            It is not safe to upgrade the metadata lock without GLOBAL IX lock.
            This can happen with FLUSH TABLES <list> WITH READ LOCK as we in
            these cases don't take a GLOBAL IX lock in order to be compatible
            with global read lock.
          */
          if (thd->open_tables &&
              !thd->mdl_context.owns_equal_or_stronger_lock(
                  MDL_key::GLOBAL, "", "", MDL_INTENTION_EXCLUSIVE)) {
            my_error(ER_TABLE_NOT_LOCKED_FOR_WRITE, MYF(0),
                     thd->open_tables->s->table_name.str);
            return true;
          }

          for (TABLE *tab = thd->open_tables; tab; tab = tab->next) {
            if (!tab->mdl_ticket->is_upgradable_or_exclusive()) {
              my_error(ER_TABLE_NOT_LOCKED_FOR_WRITE, MYF(0),
                       tab->s->table_name.str);
              return true;
            }
          }
        }
      }

      if (close_cached_tables(
              thd, tables, ((options & REFRESH_FAST) ? false : true),
              (thd ? thd->variables.lock_wait_timeout : LONG_TIMEOUT))) {
        /*
          NOTE: my_error() has been already called by reopen_tables() within
          close_cached_tables().
        */
        result = true;
      }
    }
  }
  if (options & REFRESH_HOSTS) hostname_cache_refresh();
  if (thd && (options & REFRESH_STATUS)) refresh_status();
  if (options & REFRESH_THREADS)
    Per_thread_connection_handler::kill_blocked_pthreads();
  if (options & REFRESH_MASTER) {
    assert(thd);
    tmp_write_to_binlog = 0;
    /*
      RESET MASTER acquired global read lock (if the thread is not acquired
      already) to make sure no transaction commits are getting executed
      while the operation is in process. If (and only if) it is
      acquired by RESET MASTER internal process (options will contain
      REFRESH_READ_LOCK flag in this case), unlock the global read lock
      in reset_master().
    */
    if (reset_master(thd, options & REFRESH_READ_LOCK)) {
      /* NOTE: my_error() has been already called by reset_master(). */
      result = true;
    }
  }
  if (options & REFRESH_OPTIMIZER_COSTS) reload_optimizer_cost_constants();
  if (options & REFRESH_REPLICA) {
    tmp_write_to_binlog = 0;
    if (reset_slave_cmd(thd)) {
      /*NOTE: my_error() has been already called by reset_slave() */
      result = true;
    }
  }
  if (options & REFRESH_USER_RESOURCES)
    reset_mqh(thd, nullptr, false); /* purecov: inspected */
  if (*write_to_binlog != -1) *write_to_binlog = tmp_write_to_binlog;
  /*
    If the query was killed then this function must fail.
  */
  return result || (thd ? thd->killed : 0);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_reload.cc
Function: flush_tables_with_read_lock
bool flush_tables_with_read_lock(THD *thd, Table_ref *all_tables) {
  Lock_tables_prelocking_strategy lock_tables_prelocking_strategy;
  Table_ref *table_list;

  /*
    This is called from SQLCOM_FLUSH, the transaction has
    been committed implicitly.
  */

  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    goto error;
  }

  /*
    Acquire SNW locks on tables to be flushed. Don't acquire global
    IX and database-scope IX locks on the tables as this will make
    this statement incompatible with FLUSH TABLES WITH READ LOCK.
  */
  if (lock_table_names(thd, all_tables, nullptr,
                       thd->variables.lock_wait_timeout,
                       MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK))
    goto error;

  DEBUG_SYNC(thd, "flush_tables_with_read_lock_after_acquire_locks");

  for (table_list = all_tables; table_list;
       table_list = table_list->next_global) {
    /* Request removal of table from cache. */
    tdc_remove_table(thd, TDC_RT_REMOVE_UNUSED, table_list->db,
                     table_list->table_name, false);
    /* Reset ticket to satisfy asserts in open_tables(). */
    table_list->mdl_request.ticket = nullptr;
  }

  /*
    Before opening and locking tables the below call also waits
    for old shares to go away, so the fact that we don't pass
    MYSQL_OPEN_IGNORE_FLUSH flag to it is important.
    Also we don't pass MYSQL_OPEN_HAS_MDL_LOCK flag as we want
    to open underlying tables if merge table is flushed.
    For underlying tables of the merge the below call has to
    acquire SNW locks to ensure that they can be locked for
    read without further waiting.
  */
  if (open_and_lock_tables(thd, all_tables, MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK,
                           &lock_tables_prelocking_strategy) ||
      thd->locked_tables_list.init_locked_tables(thd)) {
    goto error;
  }
  thd->variables.option_bits |= OPTION_TABLE_LOCK;

  /*
    We don't downgrade MDL_SHARED_NO_WRITE here as the intended
    post effect of this call is identical to LOCK TABLES <...> READ,
    and we didn't use thd->in_lock_talbes and
    thd->sql_command= SQLCOM_LOCK_TABLES hacks to enter the LTM.
  */

  return false;

error:
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_rename.cc
Function: mysql_rename_tables
bool mysql_rename_tables(THD *thd, Table_ref *table_list) {
  Table_ref *ren_table = nullptr;
  DBUG_TRACE;

  mysql_ha_rm_tables(thd, table_list);

  /*
    The below Auto_releaser allows to keep uncommitted versions of data-
    dictionary objects cached in the Dictionary_client for the whole duration
    of the statement.
  */
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  if (query_logger.is_log_table_enabled(QUERY_LOG_GENERAL) ||
      query_logger.is_log_table_enabled(QUERY_LOG_SLOW)) {
    int to_table;
    const char *rename_log_table[2] = {nullptr, nullptr};

    /*
      Rules for rename of a log table:

      IF   1. Log tables are enabled
      AND  2. Rename operates on the log table and nothing is being
              renamed to the log table.
      DO   3. Throw an error message.
      ELSE 4. Perform rename.
    */

    for (to_table = 0, ren_table = table_list; ren_table;
         to_table = 1 - to_table, ren_table = ren_table->next_local) {
      int log_table_rename = 0;

      if ((log_table_rename =
               query_logger.check_if_log_table(ren_table, true))) {
        /*
          as we use log_table_rename as an array index, we need it to start
          with 0, while QUERY_LOG_SLOW == 1 and QUERY_LOG_GENERAL == 2.
          So, we shift the value to start with 0;
        */
        log_table_rename--;
        if (rename_log_table[log_table_rename]) {
          if (to_table)
            rename_log_table[log_table_rename] = nullptr;
          else {
            /*
              Two renames of "log_table TO" w/o rename "TO log_table" in
              between.
            */
            my_error(ER_CANT_RENAME_LOG_TABLE, MYF(0), ren_table->table_name,
                     ren_table->table_name);
            return true;
          }
        } else {
          if (to_table) {
            /*
              Attempt to rename a table TO log_table w/o renaming
              log_table TO some table.
            */
            my_error(ER_CANT_RENAME_LOG_TABLE, MYF(0), ren_table->table_name,
                     ren_table->table_name);
            return true;
          } else {
            /* save the name of the log table to report an error */
            rename_log_table[log_table_rename] = ren_table->table_name;
          }
        }
      }
    }
    if (rename_log_table[0] || rename_log_table[1]) {
      if (rename_log_table[0])
        my_error(ER_CANT_RENAME_LOG_TABLE, MYF(0), rename_log_table[0],
                 rename_log_table[0]);
      else
        my_error(ER_CANT_RENAME_LOG_TABLE, MYF(0), rename_log_table[1],
                 rename_log_table[1]);
      return true;
    }
  }

  /*
    Array in which pointers to MDL requests for acquired schema locks are
    stored. Each schema can be present in this array only once.
  */
  Prealloced_array<MDL_request *, 1> schema_reqs(PSI_INSTRUMENT_ME);

  if (thd->locked_tables_mode) {
    /*
      LOCK TABLES case.

      Check that tables to be renamed are locked for WRITE. Take into
      account that name of table to be renamed might be result of some
      previous step in multi-step RENAME TABLES.

      In theory, we could disregard whether they locked or not and just try
      to acquire exclusive metadata locks on them, but this is too deadlock
      prone.

      Most probably, there is no tables which correspond to target table
      names, so similar check doesn't make sense for them.

      In theory, we can reduce chance of MDL deadlocks by also checking at
      this stage that all child and parent tables for FKs in which tables
      to be renamed participate are locked for WRITE (as we will have to
      acquire to exclusive MDLs on these tables later).
      But this is, probably, too severe restriction which will make
      RENAMES TABLES under LOCK TABLES hard to use in 3rd-party online
      ALTER TABLE tools.
    */
    malloc_unordered_set<Table_ref *, table_list_hash, table_list_equal>
        new_names(PSI_INSTRUMENT_ME);

    Table_ref *new_table;
    for (ren_table = table_list; ren_table; ren_table = new_table->next_local) {
      new_table = ren_table->next_local;

      auto new_name_it = new_names.find(ren_table);
      if (new_name_it == new_names.end()) {
        if (check_if_owns_upgradable_mdl(thd, ren_table->db,
                                         ren_table->table_name))
          return true;
      } else {
        new_names.erase(new_name_it);
      }
      new_names.insert(new_table);
    }

    /*
      Now proceed to acquiring exclusive metadata locks on both source and
      target table names as well as necessary schema, global and backup locks.
      Since we already have SNRW locks on source table names, we, in fact, are
      upgrading locks for them.
    */
  }

  if (lock_table_names(thd, table_list, nullptr,
                       thd->variables.lock_wait_timeout, 0, &schema_reqs) ||
      lock_trigger_names(thd, table_list))
    return true;

  const dd::Table *table_def = nullptr;
  for (Table_ref *table = table_list; table && table->next_local;
       table = table->next_local) {
    if (thd->dd_client()->acquire(table->db, table->table_name, &table_def)) {
      return true;
    }
    if (table_def && table_def->hidden() == dd::Abstract_table::HT_HIDDEN_SE) {
      my_error(ER_NO_SUCH_TABLE, MYF(0), table->db, table->table_name);
      return true;
    }
  }

  for (ren_table = table_list; ren_table; ren_table = ren_table->next_local) {
    if (thd->locked_tables_mode)
      close_all_tables_for_name(thd, ren_table->db, ren_table->table_name,
                                false);
    else
      tdc_remove_table(thd, TDC_RT_REMOVE_ALL, ren_table->db,
                       ren_table->table_name, false);
  }
  bool error = false;
  bool int_commit_done = false;
  /*
    Indicates whether we managed fully revert non-atomic RENAME TABLES
    after the failure.
  */
  bool int_commit_full_revert = false;
  std::set<handlerton *> post_ddl_htons;
  Foreign_key_parents_invalidator fk_invalidator;
  /*
    An exclusive lock on table names is satisfactory to ensure
    no other thread accesses this table.
  */
  if ((ren_table = rename_tables(thd, table_list, &int_commit_done,
                                 &post_ddl_htons, &fk_invalidator))) {
    /* Rename didn't succeed;  rename back the tables in reverse order */
    Table_ref *table;

    if (int_commit_done) {
      /* Reverse the table list */
      table_list = reverse_table_list(table_list);

      /* Find the last renamed table */
      for (table = table_list; table->next_local != ren_table;
           table = table->next_local->next_local)
        ;
      table = table->next_local->next_local;  // Skip error table

      /*
        Revert to old names. In 5.7 we have ignored most of errors occurring
        in the process. However, this looks like a risky idea -- by ignoring
        errors we are likely to end up in some awkward state and not going to
        restore status quo ante.

        So starting from 8.0 we chose to abort reversal on the first failure.
        We will still end up in some awkward case in this case but at least
        no additional damage will be done. Note that since InnoDB tables are
        new default and this engine supports atomic DDL, non-atomic RENAME
        TABLES, which this code deals with, is not the main use case anyway.
      */
      int_commit_full_revert = !rename_tables(thd, table, &int_commit_done,
                                              &post_ddl_htons, &fk_invalidator);

      /* Revert the table list (for prepared statements) */
      table_list = reverse_table_list(table_list);
    }

    error = true;
  }

  if (!error) {
    error = write_bin_log(thd, true, thd->query().str, thd->query().length,
                          !int_commit_done);
  }

  if (!error) {
    Uncommitted_tables_guard uncommitted_tables(thd);

    for (ren_table = table_list; ren_table;
         ren_table = ren_table->next_local->next_local) {
      Table_ref *new_table = ren_table->next_local;
      assert(new_table);

      uncommitted_tables.add_table(ren_table);
      uncommitted_tables.add_table(new_table);

      if ((error = update_referencing_views_metadata(
               thd, ren_table, new_table->db, new_table->table_name,
               int_commit_done, &uncommitted_tables)))
        break;
    }
  }

  if (!error && !int_commit_done) {
    error = (trans_commit_stmt(thd) || trans_commit_implicit(thd));

    if (!error) {
      /*
        Don't try to invalidate foreign key parents on error,
        as we might miss necessary locks on them.
      */
      fk_invalidator.invalidate(thd);
    }
  }

  if (error) {
    trans_rollback_stmt(thd);
    /*
      Full rollback in case we have THD::transaction_rollback_request
      and to synchronize DD state in cache and on disk (as statement
      rollback doesn't clear DD cache of modified uncommitted objects).
    */
    trans_rollback(thd);
  }

  for (handlerton *hton : post_ddl_htons) hton->post_ddl(thd);

  if (thd->locked_tables_mode) {
    if (!error) {
      /*
        Adjust locked tables list and reopen tables under new names.
        Also calculate sets of metadata locks to release (on old table
        names) and to keep until UNLOCK TABLES (on new table names).

        In addition to keeping locks on tables we also do the same for
        schemas in order to keep set of metadata locks consistent with
        one acquired by LOCK TABLES. We don't release locks on old table
        schemas as it is non-trivial to figure out which locks can be
        released.

        Tablespaces do not need special handling though, as metadata locks
        on them are acquired at LOCK TABLES time and are unaffected by
        RENAME TABLES.
      */
      malloc_unordered_set<Table_ref *, table_list_hash, table_list_equal>
          to_release(PSI_INSTRUMENT_ME), to_keep(PSI_INSTRUMENT_ME);
      Table_ref *new_table;
      for (ren_table = table_list; ren_table;
           ren_table = new_table->next_local) {
        new_table = ren_table->next_local;
        thd->locked_tables_list.rename_locked_table(
            ren_table, new_table->db, new_table->table_name,
            new_table->mdl_request.ticket);
        to_release.insert(ren_table);
        to_keep.erase(ren_table);
        to_keep.insert(new_table);
        to_release.erase(new_table);
      }

      error = thd->locked_tables_list.reopen_tables(thd);

      for (Table_ref *t : to_release) {
        // Also releases locks with EXPLICIT duration for the same name.
        thd->mdl_context.release_all_locks_for_name(t->mdl_request.ticket);
      }

      for (Table_ref *t : to_keep) {
        thd->mdl_context.set_lock_duration(t->mdl_request.ticket, MDL_EXPLICIT);
        t->mdl_request.ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
        find_and_set_explicit_duration_for_schema_mdl(thd, t, &schema_reqs);
      }
    } else if (!int_commit_done || int_commit_full_revert) {
      /*
        Error happened but all (actually not quite all, see below) changes
        were reverted. We just need to reopen tables.

        Since changes were reverted no additional metadata locks need to
        be kept after statement end. All additional locks acquired by
        this statement will be released automatically at its end, since
        they have transactional duration.

        In case of non-atomic RENAME TABLE previously orphan foreign keys
        which got new parents will keep these parents after reversal, but
        this is not important in this context.
      */
      thd->locked_tables_list.reopen_tables(thd);
    } else {
      /*
        Error happened and we failed to revert all changes. We simply close
        all tables involved.
      */
      thd->locked_tables_list.unlink_all_closed_tables(thd, nullptr, 0);
      /*
        We need to keep metadata locks on both old and new table names
        to avoid breaking foreign key invariants for LOCK TABLES.
        So we set duration of locks on new names to explicit and downgrade
        them from X to SNRW metadata locks. Also keep locks for new schemas.

        Prune list of duplicates first as setting explicit duration for the
        same MDL ticket twice is disallowed.
      */
      malloc_unordered_set<Table_ref *, table_list_hash, table_list_equal>
          to_keep(PSI_INSTRUMENT_ME);
      Table_ref *new_table;
      for (ren_table = table_list; ren_table;
           ren_table = new_table->next_local) {
        new_table = ren_table->next_local;
        to_keep.insert(new_table);
      }
      for (Table_ref *t : to_keep) {
        thd->mdl_context.set_lock_duration(t->mdl_request.ticket, MDL_EXPLICIT);
        t->mdl_request.ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
        find_and_set_explicit_duration_for_schema_mdl(thd, t, &schema_reqs);
      }
    }
  }

  if (!error) my_ok(thd);

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_servers.cc
Function: Sql_cmd_common_server::check_and_open_table
bool Sql_cmd_common_server::check_and_open_table(THD *thd) {
  if (check_global_access(thd, SUPER_ACL) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Table_ref tables("mysql", "servers", TL_WRITE);

  table = open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT);
  if (table == nullptr) return true;

  /*
    System table mysql.servers is supported by only InnoDB engine. Changing
    table's engine is not allowed. But to support logical upgrade creating
    system table is allowed in MyISAM engine. CREATE, ALTER and DROP SERVER
    operations are not allowed in this case.
  */
  if ((table->file->ht->is_supported_system_table != nullptr) &&
      !table->file->ht->is_supported_system_table(tables.db, tables.table_name,
                                                  true)) {
    my_error(ER_UNSUPPORTED_ENGINE, MYF(0),
             ha_resolve_storage_engine_name(table->file->ht), tables.db,
             tables.table_name);
    return true;
  }

  /*
    CREATE, ALTER and DROP SERVER operations are *not* allowed if table
    structure is changed.
  */
  System_table_intact table_intact(thd);
  if (table_intact.check(thd, table, &mysql_servers_table_def)) return true;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: Sql_cmd_show_schema_base::set_metadata_lock
bool Sql_cmd_show_schema_base::set_metadata_lock(THD *thd) {
  LEX_STRING lex_str_db;
  LEX *lex = thd->lex;
  if (lex_string_strmake(thd->mem_root, &lex_str_db, lex->query_block->db,
                         strlen(lex->query_block->db)))
    return true;

  // Acquire IX MDL lock on schema name.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::SCHEMA, lex_str_db.str, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: try_acquire_high_prio_shared_mdl_lock not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: try_acquire_high_prio_shared_mdl_lock not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: acquire_mdl_for_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: acquire_mdl_for_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: rm_table_do_discovery_and_lock_fk_tables
bool rm_table_do_discovery_and_lock_fk_tables(THD *thd, Table_ref *tables) {
  MEM_ROOT mdl_reqs_root(key_memory_rm_db_mdl_reqs_root, MEM_ROOT_BLOCK_SIZE);
  MDL_request_list mdl_requests;

  for (Table_ref *table = tables; table; table = table->next_local) {
    if (table->open_type != OT_BASE_ONLY && is_temporary_table(table)) continue;

    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    const dd::Abstract_table *abstract_table_def = nullptr;
    if (thd->dd_client()->acquire(table->db, table->table_name,
                                  &abstract_table_def))
      return true;

    if (!abstract_table_def) {
      /*
        If table is missing try to discover it from some storage engine
        as it might have foreign keys.
      */
      int result = ha_create_table_from_engine(
          thd, table->db,
          (lower_case_table_names == 2) ? table->alias : table->table_name);
      if (result > 0) {
        // Error during discovery, error should be reported already.
        return true;
      } else if (result == 0) {
        // Table was discovered. Re-try to retrieve its definition.
        if (thd->dd_client()->acquire(table->db, table->table_name,
                                      &abstract_table_def))
          return true;
      } else  // result < 0
      {
        // No table was found.
      }
    }

    if (!abstract_table_def ||
        abstract_table_def->type() != dd::enum_table_type::BASE_TABLE)
      continue;

    const dd::Table *table_def =
        dynamic_cast<const dd::Table *>(abstract_table_def);

    /*
      Ensure that we don't hold memory used by MDL_requests after locks
      have been acquired. This reduces memory usage in cases when we have
      DROP DATABASE that needs to drop lots of different objects.
    */
    MEM_ROOT *save_thd_mem_root = thd->mem_root;
    auto restore_thd_mem_root =
        create_scope_guard([&]() { thd->mem_root = save_thd_mem_root; });
    thd->mem_root = &mdl_reqs_root;

    if (collect_fk_parents_for_all_fks(thd, table_def, nullptr, MDL_EXCLUSIVE,
                                       &mdl_requests, nullptr))
      return true;

    if (collect_fk_children(thd, table_def, MDL_EXCLUSIVE, &mdl_requests))
      return true;

    if (collect_fk_names(thd, table->db, table_def, &mdl_requests)) return true;
  }

  if (!mdl_requests.is_empty() &&
      thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_rm_table
   mysql_rm_table()
   thd      Thread handle
   tables   List of tables to delete
   if_exists    If 1, don't give error if one table doesn't exists

  NOTES
    Will delete all tables that can be deleted and give a compact error
    messages for tables that could not be deleted.
    If a table is in use, we will wait for all users to free the table
    before dropping it

    Wait if global_read_lock (FLUSH TABLES WITH READ LOCK) is set, but
    not if under LOCK TABLES.

  RETURN
    false OK.  In this case ok packet is sent to user
    true  Error

*/

bool mysql_rm_table(THD *thd, Table_ref *tables, bool if_exists,
                    bool drop_temporary) {
  bool error;
  Drop_table_error_handler err_handler;
  Table_ref *table;
  uint have_non_tmp_table = 0;

  DBUG_TRACE;

  // DROP table is not allowed in the XA_IDLE or XA_PREPARED transaction states.
  if (thd->get_transaction()->xid_state()->check_xa_idle_or_prepared(true)) {
    return true;
  }

  /*
    DROP tables need to have their logging format determined if
    in MIXED mode and dropping a TEMP table.
  */
  if (thd->decide_logging_format(tables)) {
    return true;
  }

  /* Disable drop of enabled log tables, must be done before name locking */
  for (table = tables; table; table = table->next_local) {
    if (query_logger.check_if_log_table(table, true)) {
      my_error(ER_BAD_LOG_STATEMENT, MYF(0), "DROP");
      return true;
    }
  }

  if (!drop_temporary) {
    if (!thd->locked_tables_mode) {
      if (lock_table_names(thd, tables, nullptr,
                           thd->variables.lock_wait_timeout, 0) ||
          lock_trigger_names(thd, tables))
        return true;

      DEBUG_SYNC(thd, "mysql_rm_table_after_lock_table_names");

      for (table = tables; table; table = table->next_local) {
        if (is_temporary_table(table)) continue;

        /* Here we are sure that a non-tmp table exists */
        have_non_tmp_table = 1;
      }
    } else {
      bool acquire_backup_lock = false;

      for (table = tables; table; table = table->next_local)
        if (is_temporary_table(table)) {
          /*
            A temporary table.

            Don't try to find a corresponding MDL lock or assign it
            to table->mdl_request.ticket. There can't be metadata
            locks for temporary tables: they are local to the session.

            Later in this function we release the MDL lock only if
            table->mdl_requeset.ticket is not NULL. Thus here we
            ensure that we won't release the metadata lock on the base
            table locked with LOCK TABLES as a side effect of temporary
            table drop.
          */
          assert(table->mdl_request.ticket == nullptr);
        } else {
          /*
            Not a temporary table.

            Since 'tables' list can't contain duplicates (this is ensured
            by parser) it is safe to cache pointer to the TABLE instances
            in its elements.
          */
          table->table = find_table_for_mdl_upgrade(thd, table->db,
                                                    table->table_name, false);
          if (!table->table) return true;
          table->mdl_request.ticket = table->table->mdl_ticket;

          if (wait_while_table_is_used(thd, table->table,
                                       HA_EXTRA_FORCE_REOPEN))
            return true;

          /* Here we are sure that a non-tmp table exists */
          have_non_tmp_table = 1;

          if (!acquire_backup_lock) acquire_backup_lock = true;
        }

      if (acquire_backup_lock &&
          acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
        return true;
    }

    if (rm_table_do_discovery_and_lock_fk_tables(thd, tables)) return true;

    if (lock_check_constraint_names(thd, tables)) return true;
  }

  std::vector<MDL_ticket *> safe_to_release_mdl;

  {
    // This Auto_releaser needs to go out of scope before we start releasing
    // metadata locks below. Otherwise we end up having acquired objects for
    // which we no longer have any locks held.
    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    std::set<handlerton *> post_ddl_htons;
    Foreign_key_parents_invalidator fk_invalidator;
    bool not_used;

    /* mark for close and remove all cached entries */
    thd->push_internal_handler(&err_handler);
    error = mysql_rm_table_no_locks(thd, tables, if_exists, drop_temporary,
                                    false, &not_used, &post_ddl_htons,
                                    &fk_invalidator, &safe_to_release_mdl);
    thd->pop_internal_handler();
  }

  if (!drop_temporary) {
    /*
      Under LOCK TABLES we should release meta-data locks on the tables
      which were dropped.

      Leave LOCK TABLES mode if we managed to drop all tables which were
      locked. Additional check for 'non_temp_tables_count' is to avoid
      leaving LOCK TABLES mode if we have dropped only temporary tables.
    */
    if (thd->locked_tables_mode) {
      /*
        First we need to reopen tables which data-dictionary entries were
        updated/invalidated (and thus they were closed) due to fact that
        they participate in the same FKs as tables which were dropped.
      */
      if (thd->locked_tables_list.reopen_tables(thd)) error = true;

      if (thd->lock && thd->lock->table_count == 0 && have_non_tmp_table > 0) {
        thd->mdl_context.release_statement_locks();
        thd->locked_tables_list.unlock_locked_tables(thd);
      } else {
        for (MDL_ticket *mdl_ticket : safe_to_release_mdl) {
          /*
            Under LOCK TABLES we may have several instances of table open
            and locked and therefore have to remove several metadata lock
            requests associated with them.
          */
          thd->mdl_context.release_all_locks_for_name(mdl_ticket);
        }
      }
    }
  }

  if (error) return true;

  if (thd->lex->drop_temporary && thd->in_multi_stmt_transaction_mode()) {
    /*
      When autocommit is disabled, dropping temporary table sets this flag
      to start transaction in any case (regardless of binlog=on/off,
      binlog format and transactional/non-transactional engine) to make
      behavior consistent.
    */
    thd->server_status |= SERVER_STATUS_IN_TRANS;
  }

  if (thd->variables.binlog_format == BINLOG_FORMAT_STMT &&
      thd->lex->drop_temporary && (thd->in_sub_stmt & SUB_STMT_FUNCTION) &&
      thd->binlog_evt_union.do_union) {
    /*
      This does not write the query into binary log, it just sets
      thd->binlog_evt_union.unioned_events to true for writing
      its top function call to the binary log on function exit
      in mixed mode and statement mode. So this does not cause
      any error.
    */
    write_bin_log(thd, true, thd->query().str, thd->query().length, true);
  }

  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: lock_check_constraint_names
bool lock_check_constraint_names(THD *thd, Table_ref *tables) {
  DBUG_TRACE;
  MEM_ROOT mdl_reqs_root(key_memory_rm_db_mdl_reqs_root, MEM_ROOT_BLOCK_SIZE);
  MDL_request_list mdl_requests;

  for (Table_ref *table = tables; table != nullptr; table = table->next_local) {
    if (table->open_type != OT_BASE_ONLY && is_temporary_table(table)) continue;

    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    const dd::Abstract_table *abstract_table_def = nullptr;
    if (thd->dd_client()->acquire(table->db, table->table_name,
                                  &abstract_table_def))
      return true;

    if (abstract_table_def == nullptr ||
        abstract_table_def->type() != dd::enum_table_type::BASE_TABLE)
      continue;

    const dd::Table *table_def =
        dynamic_cast<const dd::Table *>(abstract_table_def);
    assert(table_def != nullptr);

    /*
      Ensure that we don't hold memory used by MDL_requests after locks
      have been acquired. This reduces memory usage in cases when we have
      DROP DATABASE that needs to drop lots of different objects.
    */
    MEM_ROOT *save_thd_mem_root = thd->mem_root;
    auto restore_thd_mem_root =
        create_scope_guard([&]() { thd->mem_root = save_thd_mem_root; });
    thd->mem_root = &mdl_reqs_root;

    for (auto &cc : table_def->check_constraints()) {
      if (push_check_constraint_mdl_request_to_list(
              thd, table->db, cc->name().c_str(), mdl_requests))
        return false;
    }
  }

  // Acquire MDL lock on all the check constraint names.
  if (!mdl_requests.is_empty() &&
      thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_create_table
  mysql_create_table() is a wrapper that can be used for this.

  @note On failure, for engines supporting atomic DDL, the caller must
        rollback statement and transaction before doing anything else.

  @retval false OK
  @retval true  error
*/

static bool create_table_impl(
    THD *thd, const dd::Schema &schema, const char *db, const char *table_name,
    const char *error_table_name, const char *path, HA_CREATE_INFO *create_info,
    Alter_info *alter_info, bool internal_tmp_table, uint select_field_count,
    bool find_parent_keys, bool no_ha_table, bool do_not_store_in_dd,
    bool *is_trans, KEY **key_info, uint *key_count,
    Alter_info::enum_enable_or_disable keys_onoff, FOREIGN_KEY **fk_key_info,
    uint *fk_key_count, FOREIGN_KEY *existing_fk_info, uint existing_fk_count,
    const dd::Table *existing_fk_table, uint fk_max_generated_name_number,
    std::unique_ptr<dd::Table> *table_def, handlerton **post_ddl_ht) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("db: '%s'  table: '%s'  tmp: %d", db, table_name,
                       internal_tmp_table));

  // Check that we have at least one visible column.
  bool has_visible_column = false;
  for (const Create_field &create_field : alter_info->create_list) {
    if (create_field.hidden == dd::Column::enum_hidden_type::HT_VISIBLE) {
      has_visible_column = true;
      break;
    }
  }
  if (!has_visible_column) {
    my_error(ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN, MYF(0));
    return true;
  }

  if (check_engine(db, table_name, create_info)) return true;

  // Secondary engine cannot be defined for temporary tables.
  if (create_info->secondary_engine.str != nullptr &&
      create_info->options & HA_LEX_CREATE_TMP_TABLE) {
    my_error(ER_SECONDARY_ENGINE, MYF(0), "Temporary tables not supported");
    return true;
  }

  if (set_table_default_charset(thd, create_info, schema)) return true;

  const char *alias = table_case_name(create_info, table_name);

  partition_info *part_info = thd->work_part_info;

  std::unique_ptr<handler, Destroy_only<handler>> file(get_new_handler(
      (TABLE_SHARE *)nullptr,
      (part_info ||
       (create_info->db_type->partition_flags &&
        (create_info->db_type->partition_flags() & HA_USE_AUTO_PARTITION))),
      thd->mem_root, create_info->db_type));
  if (file.get() == nullptr) {
    mem_alloc_error(sizeof(handler));
    return true;
  }

  if (!part_info && create_info->db_type->partition_flags &&
      (create_info->db_type->partition_flags() & HA_USE_AUTO_PARTITION)) {
    Partition_handler *part_handler = file->get_partition_handler();
    assert(part_handler != nullptr);

    /*
      Table is not defined as a partitioned table but the engine handles
      all tables as partitioned. The handler will set up the partition info
      object with the default settings.
    */
    thd->work_part_info = part_info = new (thd->mem_root) partition_info();
    if (!part_info) {
      mem_alloc_error(sizeof(partition_info));
      return true;
    }
    part_handler->set_auto_partitions(part_info);
    part_info->default_engine_type = create_info->db_type;
    part_info->is_auto_partitioned = true;
  }
  if (part_info) {
    /*
      The table has been specified as a partitioned table.
      If this is part of an ALTER TABLE the handler will be the partition
      handler but we need to specify the default handler to use for
      partitions also in the call to check_partition_info. We transport
      this information in the default_db_type variable, it is either
      DB_TYPE_DEFAULT or the engine set in the ALTER TABLE command.
    */
    handlerton *engine_type;
    List_iterator<partition_element> part_it(part_info->partitions);
    partition_element *part_elem;

    while ((part_elem = part_it++)) {
      if (part_elem->part_comment) {
        size_t comment_len = strlen(part_elem->part_comment);

        // Validate partition comment string
        std::string invalid_sub_str;
        if (is_invalid_string({part_elem->part_comment, comment_len},
                              system_charset_info, invalid_sub_str)) {
          my_error(ER_COMMENT_CONTAINS_INVALID_STRING, MYF(0), "partition",
                   (std::string(db) + "." + std::string(error_table_name) +
                    "." + std::string(part_elem->partition_name))
                       .c_str(),
                   system_charset_info->csname, invalid_sub_str.c_str());
          return true;
        }

        if (validate_comment_length(thd, part_elem->part_comment, &comment_len,
                                    TABLE_PARTITION_COMMENT_MAXLEN,
                                    ER_TOO_LONG_TABLE_PARTITION_COMMENT,
                                    part_elem->partition_name))
          return true;
        part_elem->part_comment[comment_len] = '\0';
      }
      if (part_elem->subpartitions.elements) {
        List_iterator<partition_element> sub_it(part_elem->subpartitions);
        partition_element *subpart_elem;
        while ((subpart_elem = sub_it++)) {
          if (subpart_elem->part_comment) {
            size_t comment_len = strlen(subpart_elem->part_comment);

            // Validate subpartition comment string
            std::string invalid_sub_str;
            if (is_invalid_string({subpart_elem->part_comment, comment_len},
                                  system_charset_info, invalid_sub_str)) {
              my_error(ER_COMMENT_CONTAINS_INVALID_STRING, MYF(0),
                       "subpartition",
                       (std::string(db) + "." + std::string(error_table_name) +
                        "." + std::string(part_elem->partition_name) + "." +
                        std::string(subpart_elem->partition_name))
                           .c_str(),
                       system_charset_info->csname, invalid_sub_str.c_str());
              return true;
            }

            if (validate_comment_length(thd, subpart_elem->part_comment,
                                        &comment_len,
                                        TABLE_PARTITION_COMMENT_MAXLEN,
                                        ER_TOO_LONG_TABLE_PARTITION_COMMENT,
                                        subpart_elem->partition_name))
              return true;
            subpart_elem->part_comment[comment_len] = '\0';
          }
        }
      }
    }
    if (create_info->options & HA_LEX_CREATE_TMP_TABLE) {
      my_error(ER_PARTITION_NO_TEMPORARY, MYF(0));
      return true;
    }
    if (create_info->used_fields & HA_CREATE_USED_ENGINE) {
      part_info->default_engine_type = create_info->db_type;
    } else {
      if (part_info->default_engine_type == nullptr) {
        part_info->default_engine_type =
            ha_checktype(thd, DB_TYPE_DEFAULT, false, false);
      }
    }
    DBUG_PRINT("info",
               ("db_type = %s create_info->db_type = %s",
                ha_resolve_storage_engine_name(part_info->default_engine_type),
                ha_resolve_storage_engine_name(create_info->db_type)));
    if (part_info->check_partition_info(thd, &engine_type, file.get(),
                                        create_info, false))
      return true;
    part_info->default_engine_type = engine_type;

    if (!engine_type->partition_flags) {
      /*
        The handler assigned to the table cannot handle partitioning.
      */
      my_error(ER_CHECK_NOT_IMPLEMENTED, MYF(0), "native partitioning");
      return true;
    }
    if (create_info->db_type != engine_type) {
      /*
        We come here when we don't use a partitioned handler.
        Since we use a partitioned table it must be "native partitioned".
        We have switched engine from defaults, most likely only specified
        engines in partition clauses.
      */
      file.reset(get_new_handler((TABLE_SHARE *)nullptr, true, thd->mem_root,
                                 engine_type));
      if (file.get() == nullptr) {
        mem_alloc_error(sizeof(handler));
        return true;
      }
      create_info->db_type = engine_type;
    }
  }

  Table_exists_result ter = check_if_table_exists(
      thd, db, table_name, alias,
      (create_info->options & HA_LEX_CREATE_TMP_TABLE),
      (create_info->options & HA_LEX_CREATE_IF_NOT_EXISTS), internal_tmp_table);
  if (ter.m_error) {
    return true;
  }
  if (ter.m_table_exists) {
    return false;
  }

  /* Suppress key length errors if this is a white listed table. */
  Key_length_error_handler error_handler;
  bool is_whitelisted_table =
      (create_info->options & HA_LEX_CREATE_TMP_TABLE) !=
          HA_LEX_CREATE_TMP_TABLE &&
      (thd->is_server_upgrade_thread() ||
       create_info->db_type->db_type == DB_TYPE_INNODB) &&
      (dd::get_dictionary()->is_dd_table_name(db, error_table_name) ||
       dd::get_dictionary()->is_system_table_name(db, error_table_name));
  if (is_whitelisted_table) thd->push_internal_handler(&error_handler);

  bool prepare_error = mysql_prepare_create_table(
      thd, db, error_table_name, create_info, alter_info, file.get(),
      (part_info != nullptr), key_info, key_count, fk_key_info, fk_key_count,
      existing_fk_info, existing_fk_count, existing_fk_table,
      fk_max_generated_name_number, select_field_count, find_parent_keys);

  if (is_whitelisted_table) thd->pop_internal_handler();

  if (prepare_error) return true;

  THD_STAGE_INFO(thd, stage_creating_table);

  {
    size_t dirlen;
    char dirpath[FN_REFLEN];

    /*
      data_file_name and index_file_name include the table name without
      extension. Mostly this does not refer to an existing file. When
      comparing data_file_name or index_file_name against the data
      directory, we try to resolve all symbolic links. On some systems,
      we use realpath(3) for the resolution. This returns ENOENT if the
      resolved path does not refer to an existing file. my_realpath()
      does then copy the requested path verbatim, without symlink
      resolution. Thereafter the comparison can fail even if the
      requested path is within the data directory. E.g. if symlinks to
      another file system are used. To make realpath(3) return the
      resolved path, we strip the table name and compare the directory
      path only. If the directory doesn't exist either, table creation
      will fail anyway.
    */
    if (create_info->data_file_name) {
      dirname_part(dirpath, create_info->data_file_name, &dirlen);
      if (test_if_data_home_dir(dirpath)) {
        my_error(ER_WRONG_ARGUMENTS, MYF(0), "DATA DIRECTORY");
        return true;
      }
    }
    if (create_info->index_file_name) {
      dirname_part(dirpath, create_info->index_file_name, &dirlen);
      if (test_if_data_home_dir(dirpath)) {
        my_error(ER_WRONG_ARGUMENTS, MYF(0), "INDEX DIRECTORY");
        return true;
      }
    }
  }

  if (check_partition_dirs(thd->lex->part_info)) return true;

  if (thd->variables.sql_mode & MODE_NO_DIR_IN_CREATE) {
    if (create_info->data_file_name)
      push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_OPTION_IGNORED,
                          ER_THD(thd, WARN_OPTION_IGNORED), "DATA DIRECTORY");
    if (create_info->index_file_name)
      push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_OPTION_IGNORED,
                          ER_THD(thd, WARN_OPTION_IGNORED), "INDEX DIRECTORY");
    create_info->data_file_name = create_info->index_file_name = nullptr;
  }

  if (thd->variables.keep_files_on_create)
    create_info->options |= HA_CREATE_KEEP_FILES;

  /*
    Create table definitions.
    If "no_ha_table" is false also create table in storage engine.
  */
  if (create_info->options & HA_LEX_CREATE_TMP_TABLE) {
    if (rea_create_tmp_table(thd, path, schema, db, table_name, create_info,
                             alter_info->create_list, *key_count, *key_info,
                             keys_onoff,
                             &alter_info->check_constraint_spec_list,
                             file.get(), no_ha_table, is_trans, table_def))
      return true;
  } else {
    if (rea_create_base_table(thd, path, schema, db, table_name, create_info,
                              alter_info->create_list, *key_count, *key_info,
                              keys_onoff, *fk_key_count, *fk_key_info,
                              &alter_info->check_constraint_spec_list,
                              file.get(), no_ha_table, do_not_store_in_dd,
                              part_info, is_trans, table_def, post_ddl_ht))
      return true;
  }

  THD_STAGE_INFO(thd, stage_after_create);
  if ((create_info->options & HA_LEX_CREATE_TMP_TABLE) &&
      thd->in_multi_stmt_transaction_mode()) {
    /*
      When autocommit is disabled, creating temporary table sets this
      flag to start transaction in any case (regardless of binlog=on/off,
      binlog format and transactional/non-transactional engine) to make
      behavior consistent.
    */
    thd->server_status |= SERVER_STATUS_IN_TRANS;
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: prepare_check_constraints_for_create
bool prepare_check_constraints_for_create(THD *thd, const char *db_name,
                                          const char *table_name,
                                          Alter_info *alter_info) {
  DBUG_TRACE;
  MDL_request_list cc_mdl_request_list;
  uint cc_max_generated_number = 0;

  /*
    Do not process check constraint specification list if master is on version
    not supporting check constraints feature.
  */
  if (is_slave_with_master_without_check_constraints_support(thd)) {
    alter_info->check_constraint_spec_list.clear();
    return false;
  }

  for (auto &cc_spec : alter_info->check_constraint_spec_list) {
    // If check constraint name is omitted then generate name.
    if (cc_spec->name.length == 0) {
      if (generate_check_constraint_name(
              thd, table_name, ++cc_max_generated_number, cc_spec->name, false))
        return true;
    }

    // Pre-validate check constraint.
    if (cc_spec->pre_validate()) return true;

    // Create MDL request for the check constraint.
    if (push_check_constraint_mdl_request_to_list(
            thd, db_name, cc_spec->name.str, cc_mdl_request_list))
      return true;
  }

  // Make sure fields used by the check constraint exists in the create list.
  mem_root_deque<Item_field *> fields(thd->mem_root);
  for (auto &cc_spec : alter_info->check_constraint_spec_list) {
    cc_spec->check_expr->walk(&Item::collect_item_field_processor,
                              enum_walk::POSTFIX, (uchar *)&fields);

    Create_field *cur_fld;
    List_iterator<Create_field> create_fields_it(alter_info->create_list);
    for (Item_field *cur_item_fld : fields) {
      if (cur_item_fld->type() != Item::FIELD_ITEM) continue;

      while ((cur_fld = create_fields_it++)) {
        if (!my_strcasecmp(system_charset_info, cur_item_fld->field_name,
                           cur_fld->field_name))
          break;
      }
      create_fields_it.rewind();

      if (cur_fld == nullptr) {
        my_error(ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN, MYF(0),
                 cc_spec->name.str, cur_item_fld->field_name);
        return true;
      }
    }
    fields.clear();
  }

  DEBUG_SYNC(thd, "before_acquiring_lock_on_check_constraints");
  if (thd->mdl_context.acquire_locks(&cc_mdl_request_list,
                                     thd->variables.lock_wait_timeout))
    return true;
  DEBUG_SYNC(thd, "after_acquiring_lock_on_check_constraints");

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_create_like_table
    mysql_create_like_table()
    thd    Thread object
    table       Table list element for target table
    src_table   Table list element for source table
    create_info Create info

  RETURN VALUES
    false OK
    true  error
*/

bool mysql_create_like_table(THD *thd, Table_ref *table, Table_ref *src_table,
                             HA_CREATE_INFO *create_info) {
  Alter_info local_alter_info(thd->mem_root);
  Alter_table_ctx local_alter_ctx;  // Not used
  bool is_trans = false;
  uint not_used;
  Tablespace_hash_set tablespace_set(PSI_INSTRUMENT_ME);
  handlerton *post_ddl_ht = nullptr;
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  DBUG_TRACE;

  /*
    We the open source table to get its description in HA_CREATE_INFO
    and Alter_info objects. This also acquires a shared metadata lock
    on this table which ensures that no concurrent DDL operation will
    mess with it.
    Also in case when we create non-temporary table open_tables()
    call obtains an exclusive metadata lock on target table ensuring
    that we can safely perform table creation.
    Thus by holding both these locks we ensure that our statement is
    properly isolated from all concurrent operations which matter.

    CREATE LIKE needs to have the logging format determined if in
    MIXED mode and creating LIKE a TEMP table.
  */
  if (open_tables(thd, &thd->lex->query_tables, &not_used, 0) ||
      thd->decide_logging_format(thd->lex->query_tables))
    return true;
  src_table->table->use_all_columns();

  const dd::Table *src_table_obj = nullptr;
  if (!src_table->table->s->tmp_table) {
    if (thd->dd_client()->acquire(src_table->db, src_table->table_name,
                                  &src_table_obj)) {
      return true;
    }
    // Should not happen, we know the table exists and can be opened.
    assert(src_table_obj != nullptr);
  }

  DEBUG_SYNC(thd, "create_table_like_after_open");

  /* Fill HA_CREATE_INFO and Alter_info with description of source table. */
  HA_CREATE_INFO local_create_info;
  local_create_info.db_type = get_viable_handlerton_for_create_like(
      thd, table->table_name, *create_info, src_table->table->s->db_type());
  if (local_create_info.db_type == nullptr) return true;

  // This should be ok even if engine substitution has taken place since
  // row_type denontes the desired row_type, and a different row_type may be
  // assigned to real_row_type later.
  local_create_info.row_type = src_table->table->s->row_type;
  if (mysql_prepare_alter_table(thd, src_table_obj, src_table->table,
                                &local_create_info, &local_alter_info,
                                &local_alter_ctx))
    return true;

  if (prepare_check_constraints_for_create_like_table(thd, src_table, table,
                                                      &local_alter_info))
    return true;

  for (const Create_field &sql_field : local_alter_info.create_list) {
    warn_on_deprecated_float_precision(thd, sql_field);
    warn_on_deprecated_float_unsigned(thd, sql_field);
    warn_on_deprecated_zerofill(thd, sql_field);
  }

  /*
    During open_tables(), the target tablespace name(s) for a table being
    created or altered should be locked. However, for 'CREATE TABLE ... LIKE',
    the source table is not being created, yet its tablespace name should be
    locked since it is used as the target tablespace name for the table being
    created. The  target tablespace name cannot be set before open_tables()
    (which is how we handle this for e.g. CREATE TABLE ... TABLESPACE ...'),
    since before open_tables(), the source table itself is not locked, which
    means that a DDL operation may sneak in and change the tablespace of the
    source table *after* we retrieved it from the .FRM file of the source
    table, and *before* the source table itself is locked. Thus, we lock the
    target tablespace here in a separate mdl lock acquisition phase after
    open_tables(). Since the table is already opened (and locked), we retrieve
    the tablespace name from the table share instead of reading it from the
    .FRM file.
  */

  /* Partition info is not handled by mysql_prepare_alter_table() call. */
  if (src_table->table->part_info)
    thd->work_part_info = src_table->table->part_info->get_clone(thd);

  // Add the tablespace name, if used.
  if (src_table->table->s->tablespace &&
      strlen(src_table->table->s->tablespace) > 0) {
    assert(
        src_table->table->s->tmp_table ||
        thd->mdl_context.owns_equal_or_stronger_lock(
            MDL_key::TABLE, src_table->db, src_table->table_name, MDL_SHARED));

    tablespace_set.insert(src_table->table->s->tablespace);
  }

  // Add tablespace names used under partition/subpartition definitions.
  if (fill_partition_tablespace_names(src_table->table->part_info,
                                      &tablespace_set))
    return true;

  /*
    After we have identified the tablespace names, we iterate
    over the names and acquire MDL lock for each of them.
  */
  if (lock_tablespace_names(thd, &tablespace_set,
                            thd->variables.lock_wait_timeout, thd->mem_root)) {
    return true;
  }

  /*
    Adjust description of source table before using it for creation of
    target table.

    Similarly to SHOW CREATE TABLE we ignore MAX_ROWS attribute of
    temporary table which represents I_S table.
  */
  if (src_table->schema_table) local_create_info.max_rows = 0;
  /* Set IF NOT EXISTS option as in the CREATE TABLE LIKE statement. */
  local_create_info.options |=
      create_info->options & HA_LEX_CREATE_IF_NOT_EXISTS;
  /* Replace type of source table with one specified in the statement. */
  local_create_info.options &= ~HA_LEX_CREATE_TMP_TABLE;
  local_create_info.options |= create_info->options & HA_LEX_CREATE_TMP_TABLE;
  /* Reset auto-increment counter for the new table. */
  local_create_info.auto_increment_value = 0;
  /*
    Do not inherit values of DATA and INDEX DIRECTORY options from
    the original table. This is documented behavior.
  */
  local_create_info.data_file_name = local_create_info.index_file_name =
      nullptr;
  local_create_info.alias = create_info->alias;

  /*
    Keep tablespace, only if it was specified explicitly in CREATE
    TABLE when source table was created.
  */
  if (src_table_obj && !src_table_obj->is_explicit_tablespace()) {
    local_create_info.tablespace = nullptr;
  }

  /*
    Do not keep ENCRYPTION clause for unencrypted table.
    We raise error if we are creating encrypted temporary table later.
  */
  if (local_create_info.encrypt_type.str &&
      !dd::is_encrypted(local_create_info.encrypt_type)) {
    local_create_info.encrypt_type = {nullptr, 0};
  }

  /*
    Lock the FK children, in case the new table introduces a missing parent.
  */
  if (!(table->table || table->is_view()) &&
      !(create_info->options & HA_LEX_CREATE_TMP_TABLE) &&
      (local_create_info.db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
    /*
      CREATE TABLE LIKE fails under LOCK TABLES at open_tables() time if
      target table doesn't exist already. So we don't need to handle
      LOCK TABLES case here by checking that parent tables for new FKs
      are properly locked and there are no orphan child tables for which
      table being created will become parent.
    */
    assert(thd->locked_tables_mode != LTM_LOCK_TABLES &&
           thd->locked_tables_mode != LTM_PRELOCKED_UNDER_LOCK_TABLES);

    MDL_request_list mdl_requests;

    if ((!dd::get_dictionary()->is_dd_table_name(table->db,
                                                 table->table_name) &&
         collect_fk_children(thd, table->db, table->table_name,
                             local_create_info.db_type, MDL_EXCLUSIVE,
                             &mdl_requests)) ||
        (!mdl_requests.is_empty() &&
         thd->mdl_context.acquire_locks(&mdl_requests,
                                        thd->variables.lock_wait_timeout)))
      return true;
  }

  if (mysql_create_table_no_lock(
          thd, table->db, table->table_name, &local_create_info,
          &local_alter_info, 0,
          false,  // No FKs, no need to lookup parent keys
          &is_trans, &post_ddl_ht))
    goto err;

  /*
    Ensure that table or view does not exist and we have an exclusive lock on
    target table if we are creating non-temporary table. In LOCK TABLES mode
    the only way the table is locked, is if it already exists (since you cannot
    LOCK TABLE a non-existing table). And the only way we then can end up here
    is if IF EXISTS was used.
  */
  assert(
      table->table || table->is_view() ||
      (create_info->options & HA_LEX_CREATE_TMP_TABLE) ||
      (thd->locked_tables_mode != LTM_LOCK_TABLES &&
       thd->mdl_context.owns_equal_or_stronger_lock(
           MDL_key::TABLE, table->db, table->table_name, MDL_EXCLUSIVE)) ||
      (thd->locked_tables_mode == LTM_LOCK_TABLES &&
       (create_info->options & HA_LEX_CREATE_IF_NOT_EXISTS) &&
       thd->mdl_context.owns_equal_or_stronger_lock(
           MDL_key::TABLE, table->db, table->table_name, MDL_SHARED_NO_WRITE)));

  DEBUG_SYNC(thd, "create_table_like_before_binlog");

  /*
    CREATE TEMPORARY TABLE doesn't terminate a transaction. Calling
    stmt.mark_created_temp_table() guarantees the transaction can be binlogged
    correctly.
  */
  if (create_info->options & HA_LEX_CREATE_TMP_TABLE)
    thd->get_transaction()->mark_created_temp_table(Transaction_ctx::STMT);

  /*
    We have to write the query before we unlock the tables.
  */
  if (!thd->is_current_stmt_binlog_disabled() &&
      thd->is_current_stmt_binlog_format_row()) {
    /*
       Since temporary tables are not replicated under row-based
       replication, CREATE TABLE ... LIKE ... needs special
       treatment.  We have four cases to consider, according to the
       following decision table:

           ==== ========= ========= ==============================
           Case    Target    Source Write to binary log
           ==== ========= ========= ==============================
           1       normal    normal Original statement
           2       normal temporary Generated statement
           3    temporary    normal Nothing
           4    temporary temporary Nothing
           ==== ========= ========= ==============================
    */
    if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE)) {
      if (src_table->table->s->tmp_table)  // Case 2
      {
        char buf[2048];
        String query(buf, sizeof(buf), system_charset_info);
        query.length(0);  // Have to zero it since constructor doesn't
        Open_table_context ot_ctx(thd, MYSQL_OPEN_REOPEN);
        bool new_table = false;  // Whether newly created table is open.

        /*
          The condition avoids a crash as described in BUG#48506. Other
          binlogging problems related to CREATE TABLE IF NOT EXISTS LIKE
          when the existing object is a view will be solved by BUG 47442.
        */
        if (!table->is_view()) {
          if (!table->table) {
            /*
              In order for store_create_info() to work we need to open
              destination table if it is not already open (i.e. if it
              has not existed before). We don't need acquire metadata
              lock in order to do this as we already hold exclusive
              lock on this table. The table will be closed by
              close_thread_table() at the end of this branch.
            */
            bool result = open_table(thd, table, &ot_ctx);

            /*
              Play safe, ensure that we won't poison TDC/TC by storing
              not-yet-committed table definition there.
            */
            tdc_remove_table(thd, TDC_RT_REMOVE_NOT_OWN, table->db,
                             table->table_name, false);

            if (result) goto err;
            new_table = true;
          }

          /*
            After opening a MERGE table add the children to the query list of
            tables, so that children tables info can be used on "CREATE TABLE"
            statement generation by the binary log.
            Note that placeholders don't have the handler open.
          */
          if (table->table->file->ha_extra(HA_EXTRA_ADD_CHILDREN_LIST)) {
            if (new_table) {
              assert(thd->open_tables == table->table);
              close_thread_table(thd, &thd->open_tables);
              table->table = nullptr;
            }
            goto err;
          }

          /*
            As the reference table is temporary and may not exist on slave, we
            must force the ENGINE to be present into CREATE TABLE.
          */
          create_info->used_fields |= HA_CREATE_USED_ENGINE;

          bool result [[maybe_unused]] = store_create_info(
              thd, table, &query, create_info, true /* show_database */,
              false /* SHOW CREATE TABLE */);

          assert(result == 0);  // store_create_info() always return 0

          if (new_table) {
            assert(thd->open_tables == table->table);
            /*
              When opening the table, we ignored the locked tables
              (MYSQL_OPEN_GET_NEW_TABLE). Now we can close the table
              without risking to close some locked table.
            */
            close_thread_table(thd, &thd->open_tables);
            table->table = nullptr;
          }

          if (write_bin_log(thd, true, query.ptr(), query.length(), is_trans))
            goto err;
        }
      } else  // Case 1
          if (write_bin_log(thd, true, thd->query().str, thd->query().length,
                            is_trans))
        goto err;
    }
    /*
      Case 3 and 4 does nothing under RBR
    */
  } else if (write_bin_log(thd, true, thd->query().str, thd->query().length,
                           is_trans))
    goto err;

  if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE)) {
    /*
      Update the FK information for the children that were locked previously.
    */
    if (!(table->table || table->is_view()) &&
        !dd::get_dictionary()->is_dd_table_name(table->db, table->table_name) &&
        (local_create_info.db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
      const dd::Table *new_table = nullptr;
      if (thd->dd_client()->acquire(table->db, table->table_name, &new_table))
        goto err;
      else {
        assert(new_table != nullptr);
        /*
          If we are to support FKs for storage engines which don't support
          atomic DDL we need to decide what to do for such SEs in case of
          failure to update children definitions and adjust code accordingly.
        */
        assert(is_trans);

        if (adjust_fk_children_after_parent_def_change(
                thd, table->db, table->table_name, local_create_info.db_type,
                new_table, nullptr) ||
            adjust_fk_parents(thd, table->db, table->table_name, true, nullptr))
          goto err;
      }
    }

    /*
      Update view metadata. Use nested block to ensure that TDC
      invalidation happens before commit.
    */
    {
      Uncommitted_tables_guard uncommitted_tables(thd);

      if (!table->table && !table->is_view())
        uncommitted_tables.add_table(table);

      if (update_referencing_views_metadata(thd, table, !is_trans,
                                            &uncommitted_tables))
        goto err;
    }

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd)) goto err;

    if (post_ddl_ht) post_ddl_ht->post_ddl(thd);
  }
  return false;

err:
  if (!(create_info->options & HA_LEX_CREATE_TMP_TABLE)) {
    trans_rollback_stmt(thd);
    /*
      Full rollback in case we have THD::transaction_rollback_request
      and to synchronize DD state in cache and on disk (as statement
      rollback doesn't clear DD cache of modified uncommitted objects).
    */
    trans_rollback(thd);

    if (post_ddl_ht) post_ddl_ht->post_ddl(thd);
  }
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: prepare_check_constraints_for_create_like_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: prepare_check_constraints_for_create_like_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: Sql_cmd_discard_import_tablespace::mysql_discard_or_import_tablespace
bool Sql_cmd_discard_import_tablespace::mysql_discard_or_import_tablespace(
    THD *thd, Table_ref *table_list) {
  Alter_table_prelocking_strategy alter_prelocking_strategy;
  int error;
  DBUG_TRACE;

  /*
    Note that DISCARD/IMPORT TABLESPACE always is the only operation in an
    ALTER TABLE
  */

  /*
    DISCARD/IMPORT TABLESPACE do not respect ALGORITHM and LOCK clauses.
  */
  if (m_alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_DEFAULT) {
    my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0),
             "LOCK=NONE/SHARED/EXCLUSIVE", "LOCK=DEFAULT");
    return true;
  } else if (m_alter_info->requested_algorithm !=
             Alter_info::ALTER_TABLE_ALGORITHM_DEFAULT) {
    my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0),
             "ALGORITHM=COPY/INPLACE/INSTANT", "ALGORITHM=DEFAULT");
    return true;
  }

  THD_STAGE_INFO(thd, stage_discard_or_import_tablespace);

  /*
    Adjust values of table-level and metadata which was set in parser
    for the case general ALTER TABLE.
  */
  table_list->mdl_request.set_type(MDL_EXCLUSIVE);
  table_list->set_lock({TL_WRITE, THR_DEFAULT});
  /* Do not open views. */
  table_list->required_type = dd::enum_table_type::BASE_TABLE;

  if (open_and_lock_tables(thd, table_list, 0, &alter_prelocking_strategy)) {
    /* purecov: begin inspected */
    return true;
    /* purecov: end */
  }

  if (table_list->table->part_info) {
    /*
      If not ALL is mentioned and there is at least one specified
      [sub]partition name, use the specified [sub]partitions only.
    */
    if (m_alter_info->partition_names.elements > 0 &&
        !(m_alter_info->flags & Alter_info::ALTER_ALL_PARTITION)) {
      table_list->partition_names = &m_alter_info->partition_names;
      /* Set all [named] partitions as used. */
      if (table_list->table->part_info->set_partition_bitmaps(table_list))
        return true;
    }
  } else {
    if (m_alter_info->partition_names.elements > 0 ||
        m_alter_info->flags & Alter_info::ALTER_ALL_PARTITION) {
      /* Don't allow DISCARD/IMPORT PARTITION on a nonpartitioned table */
      my_error(ER_PARTITION_MGMT_ON_NONPARTITIONED, MYF(0));
      return true;
    }
  }

  bool is_non_tmp_table = (table_list->table->s->tmp_table == NO_TMP_TABLE);
  handlerton *hton = table_list->table->s->db_type();

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  dd::Table *table_def = nullptr;

  if (is_non_tmp_table) {
    if (thd->dd_client()->acquire_for_modification(
            table_list->db, table_list->table_name, &table_def))
      return true;

    /* Table was successfully opened above. */
    assert(table_def != nullptr);
  } else
    table_def = table_list->table->s->tmp_table_def;

  /*
    Under LOCK TABLES we need to upgrade SNRW metadata lock to X lock
    before doing discard or import of tablespace.

    Skip this step for temporary tables as metadata locks are not
    applicable for them.

    Remember the ticket for the future downgrade.
  */
  MDL_ticket *mdl_ticket = nullptr;

  if (is_non_tmp_table &&
      (thd->locked_tables_mode == LTM_LOCK_TABLES ||
       thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES)) {
    mdl_ticket = table_list->table->mdl_ticket;
    if (thd->mdl_context.upgrade_shared_lock(mdl_ticket, MDL_EXCLUSIVE,
                                             thd->variables.lock_wait_timeout))
      return true;
  }

  /*
    The parser sets a flag in the Alter_info struct to indicate
    whether this is DISCARD or IMPORT. The flag is used for two purposes:

    1. To submit the appropriate parameter to the SE to indicate which
       operation is to be performed (see the source code below).
    2. To implement a callback function (the plugin API function
       'thd_tablespace_op()') allowing the SEs supporting these
       operations to check if we are doing a DISCARD or IMPORT, in order to
       suppress errors otherwise being thrown when opening tables with a
       missing tablespace.
  */

  bool discard = (m_alter_info->flags & Alter_info::ALTER_DISCARD_TABLESPACE);
  error = table_list->table->file->ha_discard_or_import_tablespace(discard,
                                                                   table_def);

  THD_STAGE_INFO(thd, stage_end);

  if (error) {
    table_list->table->file->print_error(error, MYF(0));
  } else {
    // When we have imported a tablespace we need to remove any old SDIs stored
    // in it because new SDIs need not have the same keys as those found in the
    // tablspace.
    if ((m_alter_info->flags & Alter_info::ALTER_IMPORT_TABLESPACE)) {
      // When we have imported tablespaces for individual partitions, we must
      // limit SDI removal to the tablespaces for the mentioned partitions.
      if (m_alter_info->partition_names.elements > 0) {
        DBUG_PRINT("ddsdi", ("Import partition tablespace for query:%s",
                             thd->query().str));
        const auto &pi = *table_list->table->part_info;
#ifndef NDEBUG
        for (const auto &pn : *table_list->partition_names) {
          DBUG_PRINT("ddsdi", ("Importing partition %s", pn.ptr()));
        }
        const auto &part_name_hash =
            *static_cast<Partition_share *>(table_list->table->s->ha_share)
                 ->partition_name_hash;
#endif /* NDEBUG */
        uint pa_id = 0;
        for (const auto &lp : *table_def->leaf_partitions()) {
#ifndef NDEBUG
          // Verify that part_id corresponds to index in leaf partition vector.
          auto part_def = find_or_nullptr(
              part_name_hash,
              std::string(lp->name().c_str(), lp->name().length()));
          assert(part_def != nullptr);
          assert(part_def->part_id == pa_id);
#endif /* NDEBUG */
          DBUG_PRINT("ddsdi",
                     ("Checking leaf partition %s, is_used(pa_id:%u):%s",
                      lp->name().c_str(), pa_id,
                      pi.is_partition_used(pa_id) ? "true" : "false"));
          if (pi.is_partition_used(pa_id) &&
              dd::sdi::drop_all_for_part(thd, lp)) {
            error = 1;
            break;
          }
          ++pa_id;
        }
      } else {
        assert(m_alter_info->partition_names.elements == 0);
        // We get here when we have imported a table tablespace, or all
        // partition tablespaces. In this case, we remove SDIs from all
        // tablespaces associated with the table.
        if (dd::sdi::drop_all_for_table(thd, table_def)) {
          error = 1;
        }
      }
    }

    /*
      Storage engine supporting atomic DDL can fully rollback discard/
      import if any problem occurs. This will happen during statement
      rollback.

      In case of success we need to save dd::Table object which might
      have been updated by SE. If this step or subsequent write to binary
      log fail then statement rollback will also restore status quo ante.
    */
    if (!error && is_non_tmp_table &&
        (hton->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        thd->dd_client()->update(table_def))
      error = 1;

    if (!error)
      error = write_bin_log(thd, false, thd->query().str, thd->query().length,
                            (hton->flags & HTON_SUPPORTS_ATOMIC_DDL));

      /*
        TODO: In theory since we have updated table definition in the
              data-dictionary above we need to remove its TABLE/TABLE_SHARE
              from TDC now. However this makes InnoDB to produce too many
              warnings about discarded tablespace which are not always well
              justified. So this code should be enabled after InnoDB is
              adjusted to be less verbose in these cases.
      */
#ifdef NEEDS_SUPPORT_FROM_INNODB
    if (is_non_tmp_table)
      close_all_tables_for_name(thd, table_list->table->s, false, nullptr);
    table_list->table = nullptr;  // Safety.
#endif
  }

  if (!error) error = trans_commit_stmt(thd) || trans_commit_implicit(thd);

  if (error) {
    trans_rollback_stmt(thd);
    trans_rollback_implicit(thd);
  }

  if (is_non_tmp_table && (hton->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
      hton->post_ddl)
    hton->post_ddl(thd);

  if (thd->locked_tables_mode && thd->locked_tables_list.reopen_tables(thd))
    error = 1;

  if (mdl_ticket) mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);

  if (error == 0) {
    my_ok(thd);
    return false;
  }

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: Sql_cmd_secondary_load_unload::mysql_secondary_load_or_unload
bool Sql_cmd_secondary_load_unload::mysql_secondary_load_or_unload(
    THD *thd, Table_ref *table_list) {
  Alter_table_prelocking_strategy alter_prelocking_strategy;

  // Because SECONDARY_LOAD and SECONDARY_UNLOAD are standalone alter table
  // actions, it should be impossible to set ALGORITHM and LOCK.
  assert(m_alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_DEFAULT);
  assert(m_alter_info->requested_algorithm ==
         Alter_info::ALTER_TABLE_ALGORITHM_DEFAULT);

  table_list->mdl_request.set_type(MDL_EXCLUSIVE);

  // Always use isolation level READ_COMMITTED to ensure consistent view of
  // table data during entire load operation. Higher isolation levels provide no
  // benefits for this operation and could impact performance, so it's fine to
  // downgrade from both REPEATABLE_READ and SERIALIZABLE.
  const enum_tx_isolation orig_tx_isolation = thd->tx_isolation;
  auto tx_isolation_guard = create_scope_guard(
      [thd, orig_tx_isolation] { thd->tx_isolation = orig_tx_isolation; });
  thd->tx_isolation = ISO_READ_COMMITTED;

  // Open base table.
  table_list->required_type = dd::enum_table_type::BASE_TABLE;
  if (open_and_lock_tables(thd, table_list, 0, &alter_prelocking_strategy))
    return true;

  // Omit hidden generated columns and columns marked as NOT SECONDARY from
  // read_set. It is the responsibility of the secondary engine handler to load
  // only the columns included in the read_set.
  bitmap_clear_all(table_list->table->read_set);
  for (Field **field = table_list->table->field; *field != nullptr; ++field) {
    // Skip hidden generated columns.
    if (bitmap_is_set(&table_list->table->fields_for_functional_indexes,
                      (*field)->field_index()))
      continue;

    // Skip columns marked as NOT SECONDARY.
    if ((*field)->is_flag_set(NOT_SECONDARY_FLAG)) continue;

    // Mark column as eligible for loading.
    table_list->table->mark_column_used(*field, MARK_COLUMNS_READ);
  }

  // SECONDARY_LOAD/SECONDARY_UNLOAD requires a secondary engine.
  if (!table_list->table->s->has_secondary_engine()) {
    my_error(ER_SECONDARY_ENGINE, MYF(0), "No secondary engine defined");
    return true;
  }

  // It should not have been possible to define a temporary table with a
  // secondary engine.
  assert(table_list->table->s->tmp_table == NO_TMP_TABLE);

  handlerton *hton = table_list->table->s->db_type();
  assert(hton->flags & HTON_SUPPORTS_ATOMIC_DDL &&
         hton->flags & HTON_SUPPORTS_SECONDARY_ENGINE &&
         hton->post_ddl != nullptr);

  // cache table name locally for future use
  const size_t name_len = table_list->db_length +
                          table_list->table_name_length +
                          5;  // for backticks, dot `db`.`tab`
  // allocated on thread, freed-up on thread exit
  char *full_tab_name = (char *)sql_calloc(name_len + 1);  // for \0 at the end
  sprintf(full_tab_name, "`%s`.`%s`", table_list->db, table_list->table_name);
  full_tab_name[name_len] = '\0';  // may not needed, since inited with 0

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  dd::Table *table_def = nullptr;
  if (thd->dd_client()->acquire_for_modification(
          table_list->db, table_list->table_name, &table_def))
    return true;

  MDL_ticket *mdl_ticket = table_list->table->mdl_ticket;

  auto downgrade_guard = create_scope_guard([mdl_ticket, thd] {
    // Under LOCK TABLES, downgrade to MDL_SHARED_NO_READ_WRITE after all
    // operations have completed.
    if (secondary_engine_lock_tables_mode(*thd)) {
      mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
    }
  });
  if (thd->mdl_context.upgrade_shared_lock(mdl_ticket, MDL_EXCLUSIVE,
                                           thd->variables.lock_wait_timeout))
    return true;

  // Cleanup that must be done regardless of commit or rollback.
  auto cleanup = [thd, hton]() {
    hton->post_ddl(thd);
    return thd->locked_tables_mode &&
           thd->locked_tables_list.reopen_tables(thd);
  };

  // This scope guard is responsible for rolling back the transaction in case of
  // any errors.
  auto rollback_guard = create_scope_guard([thd, cleanup] {
    trans_rollback_stmt(thd);
    trans_rollback_implicit(thd);
    cleanup();
  });

  /* Currently, if the DDL rolls back after completing the secondary engine
   * operation, then during undo only the secondary_flag update is undone, but
   * the secondary engine operation (load/unload) is not undone. This creates
   * a temporary inconsistency in the system where the secondary_load flag is
   * not in sync with the actual status of the table in the secondary engine. */

  // TODO: undo handling of secondary engine operation

  // Load if SECONDARY_LOAD, unload if SECONDARY_UNLOAD
  const bool is_load = m_alter_info->flags & Alter_info::ALTER_SECONDARY_LOAD;

  // Initiate loading into or unloading from secondary engine.
  if (is_load) {
    DEBUG_SYNC(thd, "before_secondary_engine_load_table");
    if (DBUG_EVALUATE_IF("sim_secload_fail",
                         (my_error(ER_SECONDARY_ENGINE, MYF(0),
                                   "Simulated failure of secondary_load()"),
                          true),
                         false) ||
        secondary_engine_load_table(thd, *table_list->table))
      return true;
  } else {
    if (DBUG_EVALUATE_IF("sim_secunload_fail",
                         (my_error(ER_SECONDARY_ENGINE, MYF(0),
                                   "Simulated failure of secondary_unload()"),
                          true),
                         false) ||
        secondary_engine_unload_table(thd, table_list->db,
                                      table_list->table_name, *table_def, true))
      return true;
  }
  DBUG_PRINT("sec_load_unload", ("secondary engine %s succeeded for table %s",
                                 (is_load ? "load" : "unload"), full_tab_name));

  DBUG_EXECUTE_IF("sim_fail_before_metadata_update", {
    DBUG_PRINT("sec_load_unload", ("Force exit before metadata update"));
    my_error(
        ER_SECONDARY_ENGINE, MYF(0),
        "Simulated failure of sec_{un}load before secondary_load flag update");
    return true;
  });

  // Update the secondary_load flag based on the current operation.
  if (DBUG_EVALUATE_IF("sim_fail_metadata_update",
                       (my_error(ER_SECONDARY_ENGINE, MYF(0),
                                 "Simulated failure during metadata update"),
                        true),
                       false) ||
      table_def->options().set("secondary_load", is_load) ||
      thd->dd_client()->update(table_def)) {
    LogErr(ERROR_LEVEL, ER_SECONDARY_ENGINE_DDL_FAILED, full_tab_name,
           (is_load ? "secondary_load" : "secondary_unload"),
           "metadata update failed");
    return true;
  }

  DBUG_PRINT("sec_load_unload", ("secondary_load flag %s for table %s",
                                 (is_load ? "set" : "reset"), full_tab_name));

  DBUG_EXECUTE_IF("sim_fail_before_write_bin_log", {
    DBUG_PRINT("sec_load_unload", ("Force exit before binlog write"));
    my_error(ER_SECONDARY_ENGINE, MYF(0),
             "Simulated failure of sec_{un}load before write_bin_log()");
    return true;
  });

  /* Write binlog to maintain replication consistency. Read-Replica's may not
   * have binlog enabled. write_bin_log API takes care of such cases. */
  if (DBUG_EVALUATE_IF("sim_fail_binlog_write",
                       (my_error(ER_SECONDARY_ENGINE, MYF(0),
                                 "Simulated failure during binlog write"),
                        true),
                       false) ||
      (write_bin_log(thd, true, thd->query().str, thd->query().length, true) !=
       0)) {
    LogErr(ERROR_LEVEL, ER_SECONDARY_ENGINE_DDL_FAILED, full_tab_name,
           (is_load ? "secondary_load" : "secondary_unload"),
           "binlog write failed");
    return true;
  }

  DBUG_PRINT("sec_load_unload",
             ("binlog entry added for alter table %s secondary_%s",
              full_tab_name, (is_load ? "load" : "unload")));

  DBUG_EXECUTE_IF("sim_fail_after_write_bin_log", {
    DBUG_PRINT("sec_load_unload", ("Force exit after binlog write"));
    my_error(ER_SECONDARY_ENGINE, MYF(0),
             "Simulated failure of sec_{un}load after write_bin_log()");
    return true;
  });

  // Close primary table.
  close_all_tables_for_name(thd, table_list->table->s, false, nullptr);
  table_list->table = nullptr;

  // Commit transaction if no errors.
  if (DBUG_EVALUATE_IF("sim_fail_transaction_commit",
                       (my_error(ER_SECONDARY_ENGINE, MYF(0),
                                 "Simulated failure during metadata update"),
                        true),
                       false) ||
      trans_commit_stmt(thd) || trans_commit_implicit(thd)) {
    LogErr(ERROR_LEVEL, ER_SECONDARY_ENGINE_DDL_FAILED, full_tab_name,
           (is_load ? "secondary_load" : "secondary_unload"),
           "transaction commit failed");
    return true;
  }

  DBUG_PRINT("sec_load_unload",
             ("commit succeeded for alter table %s secondary_%s", full_tab_name,
              (is_load ? "load" : "unload")));
  // Transaction committed successfully, no rollback will be necessary.
  rollback_guard.commit();

  if (cleanup()) return true;

  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: collect_and_lock_fk_tables_for_rename_table
bool collect_and_lock_fk_tables_for_rename_table(
    THD *thd, const char *db, const char *table_name,
    const dd::Table *table_def, const char *new_db, const char *new_table_name,
    handlerton *hton, Foreign_key_parents_invalidator *fk_invalidator) {
  MDL_request_list mdl_requests;

  if (collect_fk_children(thd, db, table_name, hton, MDL_EXCLUSIVE,
                          &mdl_requests) ||
      collect_fk_children(thd, new_db, new_table_name, hton, MDL_EXCLUSIVE,
                          &mdl_requests) ||
      collect_fk_parents_for_all_fks(thd, table_def, hton, MDL_EXCLUSIVE,
                                     &mdl_requests, fk_invalidator) ||
      collect_fk_names_for_rename_table(thd, db, table_name, table_def, hton,
                                        new_db, new_table_name, &mdl_requests))
    return true;

  if (!mdl_requests.is_empty() &&
      thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_alter_table
bool mysql_alter_table(THD *thd, const char *new_db, const char *new_name,
                       HA_CREATE_INFO *create_info, Table_ref *table_list,
                       Alter_info *alter_info) {
  DBUG_TRACE;

  /*
    Check if we attempt to alter mysql.slow_log or
    mysql.general_log table and return an error if
    it is the case.
    TODO: this design is obsolete and will be removed.
  */
  enum_log_table_type table_kind =
      query_logger.check_if_log_table(table_list, false);

  if (table_kind != QUERY_LOG_NONE) {
    /* Disable alter of enabled query log tables */
    if (query_logger.is_log_table_enabled(table_kind)) {
      my_error(ER_BAD_LOG_STATEMENT, MYF(0), "ALTER");
      return true;
    }

    /* Disable alter of log tables to unsupported engine */
    if ((create_info->used_fields & HA_CREATE_USED_ENGINE) &&
        (!create_info->db_type || /* unknown engine */
         !(create_info->db_type->flags & HTON_SUPPORT_LOG_TABLES))) {
      my_error(ER_UNSUPORTED_LOG_ENGINE, MYF(0));
      return true;
    }

    if (alter_info->flags & Alter_info::ALTER_PARTITION) {
      my_error(ER_WRONG_USAGE, MYF(0), "PARTITION", "log table");
      return true;
    }
  }

  // Reject request to ALTER TABLE with START TRANSACTION.
  if (create_info->m_transactional_ddl) {
    my_error(ER_NOT_ALLOWED_WITH_START_TRANSACTION, MYF(0),
             "with ALTER TABLE command.");
    return true;
  }

  if (alter_info->with_validation != Alter_info::ALTER_VALIDATION_DEFAULT &&
      !(alter_info->flags &
        (Alter_info::ALTER_ADD_COLUMN | Alter_info::ALTER_CHANGE_COLUMN))) {
    my_error(ER_WRONG_USAGE, MYF(0), "ALTER", "WITH VALIDATION");
    return true;
  }

  if ((alter_info->flags & Alter_info::ALTER_ADD_COLUMN) ==
      Alter_info::ALTER_ADD_COLUMN) {
    for (auto create_field : alter_info->create_list) {
      if (create_field.m_default_val_expr) {
        // ALTER TABLE .. DEFAULT (NDF function) should be rejected for mixed or
        // row binlog_format. For statement binlog_format it should be allowed
        // to continue and warning should be logged and/or pushed to the client
        if ((thd->variables.option_bits & OPTION_BIN_LOG) &&
            thd->lex->is_stmt_unsafe(
                Query_tables_list::BINLOG_STMT_UNSAFE_SYSTEM_FUNCTION)) {
          if (thd->variables.binlog_format == BINLOG_FORMAT_STMT) {
            LogErr(WARNING_LEVEL, ER_SERVER_BINLOG_UNSAFE_SYSTEM_FUNCTION,
                   "ALTER TABLE .. DEFAULT (NDF function)");
            push_warning(thd, Sql_condition::SL_WARNING,
                         ER_BINLOG_UNSAFE_SYSTEM_FUNCTION,
                         ER_THD(thd, ER_BINLOG_UNSAFE_SYSTEM_FUNCTION));
            break;
          } else {
            my_error(ER_BINLOG_UNSAFE_SYSTEM_FUNCTION, MYF(0));
            return true;
          }
        }
      }
    }
  }

  // LOCK clause doesn't make any sense for ALGORITHM=INSTANT.
  if (alter_info->requested_algorithm ==
          Alter_info::ALTER_TABLE_ALGORITHM_INSTANT &&
      alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_DEFAULT) {
    my_error(ER_WRONG_USAGE, MYF(0), "ALGORITHM=INSTANT",
             "LOCK=NONE/SHARED/EXCLUSIVE");
    return true;
  }

  THD_STAGE_INFO(thd, stage_init);

  // Reject invalid usage of the 'mysql' tablespace.
  if (dd::invalid_tablespace_usage(thd, table_list->db, table_list->table_name,
                                   create_info))
    return true;

  /*
    Assign target tablespace name to enable locking in lock_table_names().
    Reject invalid name lengths. Names will be validated after the table is
    opened and the SE (needed for SE specific validation) is identified.
  */
  if (create_info->tablespace) {
    if (validate_tablespace_name_length(create_info->tablespace)) return true;

    if (lex_string_strmake(thd->mem_root, &table_list->target_tablespace_name,
                           create_info->tablespace,
                           strlen(create_info->tablespace))) {
      my_error(ER_OUT_OF_RESOURCES, MYF(ME_FATALERROR));
      return true;
    }
  }

  /* Validate that AUTOEXTEND_SIZE option is not specified for
  temporary tables */
  if (is_temporary_table(table_list)) {
    if (create_info->m_implicit_tablespace_autoextend_size > 0) {
      my_error(ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE, MYF(0), "temporary");
      return true;
    }
  }

  /*
    Reject invalid tablespace name lengths specified for partitions.
    Names will be validated after the table has been opened.
  */
  if (validate_partition_tablespace_name_lengths(thd->lex->part_info))
    return true;

  /*
    Assign the partition info, so that the locks on tablespaces
    assigned for any new partitions added would be acquired during
    open_table.
  */
  thd->work_part_info = thd->lex->part_info;

  /*
    Code below can handle only base tables so ensure that we won't open a view.
    Note that RENAME TABLE the only ALTER clause which is supported for views
    has been already processed.
  */
  table_list->required_type = dd::enum_table_type::BASE_TABLE;

  /*
    If we are about to ALTER non-temporary table we need to get permission
    from/notify interested storage engines.
  */
  Table_ddl_hton_notification_guard notification_guard{
      thd, &table_list->mdl_request.key, HA_ALTER_DDL};

  if (!is_temporary_table(table_list) && notification_guard.notify())
    return true;

  Alter_table_prelocking_strategy alter_prelocking_strategy;

  DEBUG_SYNC(thd, "alter_table_before_open_tables");
  uint tables_opened;
  bool error = open_tables(thd, &table_list, &tables_opened, 0,
                           &alter_prelocking_strategy);

  DEBUG_SYNC(thd, "alter_opened_table");

  if (error) return true;

  // If we are removing a functional index, add any related hidden generated
  // columns to the drop list as well.
  if (handle_drop_functional_index(thd, alter_info, table_list)) {
    return true;
  }

  // If we are renaming a functional index, rename any related hidden generated
  // columns as well.
  if (alter_info->flags & Alter_info::ALTER_RENAME_INDEX) {
    if (handle_rename_functional_index(thd, alter_info, table_list)) {
      return true; /* purecov: deadcode */
    }
  }

  // Check tablespace name validity for the relevant engine.
  {
    // If there is no target handlerton, use the current.
    const handlerton *target_handlerton = create_info->db_type;
    if (target_handlerton == nullptr)
      target_handlerton = table_list->table->file->ht;

    /*
      Reject invalid tablespace names for the relevant engine, if the ALTER
      statement changes either tablespace or engine. We do this after the table
      has been opened because we need the handlerton and tablespace information.
      No need to validate if neither engine nor tablespace is changed, then the
      validation was done when the table was created.
    */
    if (create_info->tablespace || create_info->db_type) {
      // If there is no target table level tablespace, use the current.
      const char *target_tablespace = create_info->tablespace;
      if (target_tablespace == nullptr)
        target_tablespace = table_list->table->s->tablespace;

      // Check the tablespace/engine combination.
      assert(target_handlerton);
      if (target_tablespace != nullptr &&
          validate_tablespace_name(TS_CMD_NOT_DEFINED, target_tablespace,
                                   target_handlerton))
        return true;
    }

    // Reject invalid tablespace names specified for partitions.
    if (validate_partition_tablespace_names(thd->lex->part_info,
                                            target_handlerton))
      return true;
  }

  if (validate_secondary_engine_option(thd, *alter_info, *create_info,
                                       *table_list->table))
    return true;

  if (lock_trigger_names(thd, table_list)) return true;

  /*
    If we're in LOCK TABLE mode, we must lock the target tablespace name
    as well as the currently used tablesapces (since these may have been
    introduced by a previous ALTER while already in LOCK TABLE mode).
  */
  if (thd->locked_tables_mode &&
      get_and_lock_tablespace_names(thd, table_list, nullptr,
                                    thd->variables.lock_wait_timeout, MYF(0))) {
    return true;
  }

  if (table_list->table->s->db_type() != create_info->db_type &&
      (alter_info->flags & Alter_info::ALTER_OPTIONS) &&
      (create_info->used_fields & HA_CREATE_USED_ENGINE)) {
    handlerton *actual_hton = get_viable_handlerton_for_alter(
        thd, *create_info, table_list->table->s->db_type());
    if (actual_hton == nullptr) return true;

    create_info->db_type = actual_hton;
  }

  const handlerton *hton = create_info->db_type;
  if (hton == nullptr) {
    hton = table_list->table->s->db_type();
  }
  assert(hton != nullptr);
  if ((alter_info->flags & Alter_info::ANY_ENGINE_ATTRIBUTE) != 0 &&
      ((hton->flags & HTON_SUPPORTS_ENGINE_ATTRIBUTE) == 0 &&
       DBUG_EVALUATE_IF("simulate_engine_attribute_support", false, true))) {
    my_error(ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED, MYF(0),
             ha_resolve_storage_engine_name(hton));
    return true;
  }

  TABLE *table = table_list->table;
  table->use_all_columns();
  MDL_ticket *mdl_ticket = table->mdl_ticket;

  /*
    Prohibit changing of the UNION list of a non-temporary MERGE table
    under LOCK tables. It would be quite difficult to reuse a shrunk
    set of tables from the old table or to open a new TABLE object for
    an extended list and verify that they belong to locked tables.
  */
  if ((thd->locked_tables_mode == LTM_LOCK_TABLES ||
       thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) &&
      (create_info->used_fields & HA_CREATE_USED_UNION) &&
      (table->s->tmp_table == NO_TMP_TABLE)) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  Alter_table_ctx alter_ctx(thd, table_list, tables_opened, new_db, new_name);

  /*
    Acquire and keep schema locks until commit time, so the DD layer can
    safely assert that we have proper MDL on objects stored in the DD.
  */
  dd::Schema_MDL_locker mdl_locker_1(thd), mdl_locker_2(thd);
  const dd::Schema *schema = nullptr;
  const dd::Schema *new_schema = nullptr;
  const dd::Table *old_table_def = nullptr;
  /*
    This releaser allows us to keep uncommitted DD objects cached
    in the Dictionary_client until commit time.
  */
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  if (mdl_locker_1.ensure_locked(alter_ctx.db) ||
      mdl_locker_2.ensure_locked(alter_ctx.new_db) ||
      thd->dd_client()->acquire(alter_ctx.db, &schema) ||
      thd->dd_client()->acquire(alter_ctx.new_db, &new_schema))
    return true;

  if ((table->s->tmp_table == NO_TMP_TABLE) &&
      thd->dd_client()->acquire(alter_ctx.db, alter_ctx.table_name,
                                &old_table_def))
    return true;

  // If this is a temporary table, the schema might not exist even
  // if we have successfully opened the table
  if (schema == nullptr) {
    assert(table->s->tmp_table);
    my_error(ER_BAD_DB_ERROR, MYF(0), alter_ctx.db);
    return true;
  }

  assert((table->s->tmp_table != NO_TMP_TABLE) || old_table_def != nullptr);

  if (new_schema == nullptr) {
    my_error(ER_BAD_DB_ERROR, MYF(0), alter_ctx.new_db);
    return true;
  }

  /*
    Add old and new (if any) databases to the list of accessed databases
    for this statement. Needed for MTS.
  */
  thd->add_to_binlog_accessed_dbs(alter_ctx.db);
  if (alter_ctx.is_database_changed())
    thd->add_to_binlog_accessed_dbs(alter_ctx.new_db);

  // Ensure that triggers are in the same schema as their subject table.
  if (alter_ctx.is_database_changed() && old_table_def != nullptr &&
      old_table_def->has_trigger()) {
    my_error(ER_TRG_IN_WRONG_SCHEMA, MYF(0));
    return true;
  }

  /* Check that we are not trying to rename to an existing table */
  if (alter_ctx.is_table_renamed()) {
    if (table->s->tmp_table != NO_TMP_TABLE) {
      if (find_temporary_table(thd, alter_ctx.new_db, alter_ctx.new_name)) {
        my_error(ER_TABLE_EXISTS_ERROR, MYF(0), alter_ctx.new_alias);
        return true;
      }
    } else {
      MDL_request_list mdl_requests;

      mdl_requests.push_front(&alter_ctx.target_mdl_request);
      /*
        If we are moving the table to a different database, we also
        need IX lock on the database name so that the target database
        is protected by MDL while the table is moved.
      */
      if (alter_ctx.is_database_changed())
        mdl_requests.push_front(&alter_ctx.target_db_mdl_request);

      /*
        Global intention exclusive lock must have been already acquired when
        table to be altered was open, so there is no need to do it here.
      */
      assert(thd->mdl_context.owns_equal_or_stronger_lock(
          MDL_key::GLOBAL, "", "", MDL_INTENTION_EXCLUSIVE));

      if (thd->mdl_context.acquire_locks(&mdl_requests,
                                         thd->variables.lock_wait_timeout))
        return true;

      DEBUG_SYNC(thd, "locked_table_name");
      /*
        Table maybe does not exist, but we got an exclusive lock
        on the name, now we can safely try to find out for sure.
      */
      const dd::Abstract_table *at = nullptr;
      if (thd->dd_client()->acquire(alter_ctx.new_db, alter_ctx.new_name, &at))
        return true;

      if (at != nullptr) {
        /* Table will be closed in do_command() */
        my_error(ER_TABLE_EXISTS_ERROR, MYF(0), alter_ctx.new_alias);
        return true;
      }
    }
  }

  if (!create_info->db_type) {
    if (table->part_info && create_info->used_fields & HA_CREATE_USED_ENGINE) {
      /*
        This case happens when the user specified
        ENGINE = x where x is a non-existing storage engine
        We set create_info->db_type to default_engine_type
        to ensure we don't change underlying engine type
        due to a erroneously given engine name.
      */
      create_info->db_type = table->part_info->default_engine_type;
    } else
      create_info->db_type = table->s->db_type();
  }

  if (check_engine(alter_ctx.new_db, alter_ctx.new_name, create_info))
    return true;

  /*
    Do not allow change of storage engine if table participates in a foreign
    key. Even in cases when both source and target storage engines support
    foreign keys the fine details of what is supported might differ.
  */
  if (create_info->db_type != table->s->db_type() && old_table_def != nullptr &&
      (old_table_def->foreign_keys().size() ||
       old_table_def->foreign_key_parents().size())) {
    my_error(ER_FK_CANNOT_CHANGE_ENGINE, MYF(0));
    return true;
  }

  /*
   If foreign key is added then check permission to access parent table.

   In function "check_fk_parent_table_access", create_info->db_type is used
   to identify whether engine supports FK constraint or not. Since
   create_info->db_type is set here, check to parent table access is delayed
   till this point for the alter operation.
  */
  if ((alter_info->flags & Alter_info::ADD_FOREIGN_KEY) &&
      check_fk_parent_table_access(thd, create_info, alter_info))
    return true;

  Foreign_key_parents_invalidator fk_invalidator;

  if (table->s->tmp_table == NO_TMP_TABLE) {
    MDL_request_list mdl_requests;

    if (collect_fk_parents_for_new_fks(
            thd, table_list->db, table_list->table_name, alter_info,
            MDL_SHARED_UPGRADABLE, nullptr, &mdl_requests, nullptr))
      return true;

    /*
      Acquire SU locks on parent and child tables so we can access
      their definition while checking if this ALTER TABLE will break
      any FKs involving them.

      TODO: Refine set of ALTER TABLE commands for which we do this.
            This is obviously necessary for ADD/DROP KEY and COLUMN
            modifications. But are there any other operations which
            might affect indexes somehow?
    */
    if (!is_simple_rename_or_index_change(alter_info)) {
      if (collect_fk_parents_for_all_fks(thd, old_table_def, nullptr,
                                         MDL_SHARED_UPGRADABLE, &mdl_requests,
                                         nullptr))
        return true;

      if (create_info->db_type != table->s->db_type()) {
        /*
          By changing table's storage engine we might be introducing parent
          table for previously orphan foreign keys in the new SE. We need
          to lock child tables of such orphan foreign keys. OTOH it is safe
          to assume that if SE is changed table can't be parent in any
          foreign keys in old SE.

          Note that here and in other similar places we assume that ALTER
          TABLE which combines change of SE and renaming of table is executed
          by changing SE first and then performing rename (this is closer to
          ALTER TABLE real implementation). Because of this such ALTER TABLEs
          need to pick up orphan foreign keys associated with old table names
          as well. Thus we use old table name to get list of orphans.
        */
        assert(old_table_def->foreign_key_parents().size() == 0);

        if (collect_fk_children(thd, table_list->db, table_list->table_name,
                                create_info->db_type, MDL_SHARED_UPGRADABLE,
                                &mdl_requests))
          return true;
      } else {
        if (collect_fk_children(thd, old_table_def, MDL_SHARED_UPGRADABLE,
                                &mdl_requests))
          return true;
      }

      if (alter_ctx.is_table_renamed() &&
          collect_fk_children(thd, alter_ctx.new_db, alter_ctx.new_alias,
                              create_info->db_type, MDL_SHARED_UPGRADABLE,
                              &mdl_requests))
        return true;
    }

    /*
      Lock names of foreign keys to be dropped.

      Note that we can't lock names of foreign keys to be added yet
      because database in which they will be created depends on ALTER
      TABLE algorithm we are going to choose later.
    */
    if (collect_fk_names_for_dropped_fks(thd, table_list->db, alter_info,
                                         old_table_def, &mdl_requests))
      return true;

    /*
      Under LOCK TABLES all parent tables must be locked at least in READ
      mode. Otherwise, our ALTER TABLE will leave after itself child table
      locked for WRITE, without corresponding parent tables locked and thus
      without ability to perform FK checks when child table is modified.
    */
    if (thd->locked_tables_mode == LTM_LOCK_TABLES ||
        thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) {
      MDL_request_list::Iterator it(mdl_requests);
      MDL_request *mdl_request;

      while ((mdl_request = it++) != nullptr) {
        if (mdl_request->key.mdl_namespace() != MDL_key::TABLE) continue;

        if (!thd->mdl_context.owns_equal_or_stronger_lock(
                MDL_key::TABLE, mdl_request->key.db_name(),
                mdl_request->key.name(), MDL_SHARED_READ_ONLY)) {
          my_error(ER_TABLE_NOT_LOCKED, MYF(0), mdl_request->key.name());
          return true;
        }
      }
    }

    if (!mdl_requests.is_empty() &&
        thd->mdl_context.acquire_locks(&mdl_requests,
                                       thd->variables.lock_wait_timeout))
      return true;

    DEBUG_SYNC(thd, "alter_table_after_mdl_lock_fk");

    /*
      If we are executing ALTER TABLE RENAME under LOCK TABLES we also need
      to check that all previously orphan tables which reference new table
      name through foreign keys are locked for write. Otherwise this ALTER
      will leave after itself parent table locked for WRITE without child
      tables locked for WRITE. This will break FK LOCK TABLES invariants if
      some of previously orphan FKs have referential actions which update
      child table.

      The same should be done when we are going to add parent table to
      previously orphan foreign keys by changing table storage engine.

      In theory, we can reduce chance of MDL deadlocks by also checking at
      this stage that all child and parent tables for FKs in which this
      table participates are locked for WRITE (as we will have to acquire
      to exclusive MDLs on these tables later). But this is, probably, too
      severe restriction since many 3rd-party online ALTER tools use ALTER
      TABLE RENAME under LOCK TABLES and are unaware of it.
    */
    if (thd->locked_tables_mode == LTM_LOCK_TABLES ||
        thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) {
      MDL_request_list orphans_mdl_requests;

      if (create_info->db_type != table->s->db_type()) {
        assert(old_table_def->foreign_key_parents().size() == 0);
        if (collect_fk_children(thd, table_list->db, table_list->table_name,
                                create_info->db_type, MDL_EXCLUSIVE,
                                &orphans_mdl_requests))
          return true;
      }
      if (alter_ctx.is_table_renamed() &&
          collect_fk_children(thd, alter_ctx.new_db, alter_ctx.new_alias,
                              create_info->db_type, MDL_EXCLUSIVE,
                              &orphans_mdl_requests))
        return true;

      if (!orphans_mdl_requests.is_empty()) {
        MDL_request_list::Iterator it(orphans_mdl_requests);
        MDL_request *mdl_request;

        while ((mdl_request = it++) != nullptr) {
          if (mdl_request->key.mdl_namespace() != MDL_key::TABLE) continue;

          if (!thd->mdl_context.owns_equal_or_stronger_lock(
                  MDL_key::TABLE, mdl_request->key.db_name(),
                  mdl_request->key.name(), MDL_SHARED_NO_READ_WRITE)) {
            my_error(ER_TABLE_NOT_LOCKED_FOR_WRITE, MYF(0),
                     mdl_request->key.name());
            return true;
          }
        }
      }
    }
  }

  /*
   If this is an ALTER TABLE and no explicit row type specified reuse
   the table's row type.
   Note : this is the same as if the row type was specified explicitly.
  */
  if (create_info->row_type == ROW_TYPE_NOT_USED) {
    /* ALTER TABLE without explicit row type */
    create_info->row_type = table->s->row_type;
  } else {
    /* ALTER TABLE with specific row type */
    create_info->used_fields |= HA_CREATE_USED_ROW_FORMAT;
  }

  DBUG_PRINT("info", ("old type: %s  new type: %s",
                      ha_resolve_storage_engine_name(table->s->db_type()),
                      ha_resolve_storage_engine_name(create_info->db_type)));
  if (ha_check_storage_engine_flag(table->s->db_type(),
                                   HTON_ALTER_NOT_SUPPORTED) ||
      ha_check_storage_engine_flag(create_info->db_type,
                                   HTON_ALTER_NOT_SUPPORTED)) {
    DBUG_PRINT("info", ("doesn't support alter"));
    my_error(ER_ILLEGAL_HA, MYF(0), table_list->table_name);
    return true;
  }

  THD_STAGE_INFO(thd, stage_setup);

  if (is_simple_rename_or_index_change(alter_info) && !table->s->tmp_table) {
    // This requires X-lock, no other lock levels supported.
    if (alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_DEFAULT &&
        alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "LOCK=NONE/SHARED",
               "LOCK=EXCLUSIVE");
      return true;
    }
    return simple_rename_or_index_change(thd, *new_schema, table_list,
                                         alter_info->keys_onoff, &alter_ctx);
  }

  /* We have to do full alter table. */
  bool partition_changed = false;
  partition_info *new_part_info = nullptr;
  {
    if (prep_alter_part_table(thd, table, alter_info, create_info, &alter_ctx,
                              &partition_changed, &new_part_info)) {
      return true;
    }
  }

  /*
    Store all columns that are going to be dropped, since we need this list
    when removing column statistics later. The reason we need to store it here,
    is that 'mysql_prepare_alter_table' may remove some of the columns from
    the drop_list.
  */
  histograms::columns_set columns;
  for (const auto column : alter_info->drop_list) {
    if (column->type == Alter_drop::COLUMN) columns.emplace(column->name);
  }
  const Alter_column *alter = nullptr;
  uint i = 0;
  while (i < alter_info->alter_list.size()) {
    alter = alter_info->alter_list[i];
    if (alter->change_type() == Alter_column::Type::RENAME_COLUMN)
      columns.emplace(alter->name);
    i++;
  }

  Create_field *create_field;
  List_iterator<Create_field> list_it(alter_info->create_list);
  while ((create_field = list_it++)) {
    if (create_field->change != nullptr) columns.emplace(create_field->change);
  }

  /*
    Type of a constraint marked for DROP with DROP CONSTRAINT clause is unknown.
    Resolve type of a constraint by name.
  */
  Drop_constraint_type_resolver drop_constraint_type_resolver(alter_info);
  if (drop_constraint_type_resolver.is_type_resolution_needed() &&
      (drop_constraint_type_resolver.resolve_constraints_type(thd, table,
                                                              old_table_def)))
    return true;

  /*
    Type of a constraint marked for ALTER with ALTER CONSTRAINT clause is
    unknown. Resolve type of a constraint by name.
  */
  Enforce_constraint_type_resolver enforce_constraint_type_resolver(alter_info);
  if (enforce_constraint_type_resolver.is_type_resolution_needed() &&
      (enforce_constraint_type_resolver.resolve_constraints_type(
          thd, table, old_table_def)))
    return true;

  // Prepare check constraints for alter table operation.
  if (prepare_check_constraints_for_alter(thd, table, alter_info, &alter_ctx))
    return true;

  if (mysql_prepare_alter_table(thd, old_table_def, table, create_info,
                                alter_info, &alter_ctx)) {
    return true;
  }

  // Check restrictions on ALTER TABLE operations that affects GIPK and PK.
  if (check_primary_key_alter_restrictions(thd, create_info->db_type,
                                           alter_info, table))
    return true;

  /*
    Check if we are changing the SRID specification on a geometry column that
    has a spatial index. If that is the case, reject the change since allowing
    geometries with different SRIDs in a spatial index will make the index
    useless.
  */
  if (!is_alter_geometry_column_valid(alter_info)) return true;

  if (set_table_default_charset(thd, create_info, *schema)) return true;

  /*
    Use copy algorithm if:
    - old_alter_table system variable is set without in-place requested using
      the ALGORITHM clause.
    - Or if in-place is impossible for given operation.
    - Changes to partitioning needs to be handled using table copying
      algorithm unless the engine supports partitioning changes using
      in-place API (because it supports auto-partitioning or simply
      can do partitioning changes using in-place using mark-up in
      partition_info object).
  */
  if ((thd->variables.old_alter_table &&
       alter_info->requested_algorithm !=
           Alter_info::ALTER_TABLE_ALGORITHM_INPLACE &&
       alter_info->requested_algorithm !=
           Alter_info::ALTER_TABLE_ALGORITHM_INSTANT) ||
      is_inplace_alter_impossible(table, create_info, alter_info) ||
      (partition_changed &&
       !(table->s->db_type()->partition_flags() & HA_USE_AUTO_PARTITION) &&
       !new_part_info)) {
    if (alter_info->requested_algorithm ==
        Alter_info::ALTER_TABLE_ALGORITHM_INPLACE) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "ALGORITHM=INPLACE",
               "ALGORITHM=COPY");
      return true;
    }
    if (alter_info->requested_algorithm ==
        Alter_info::ALTER_TABLE_ALGORITHM_INSTANT) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "ALGORITHM=INSTANT",
               "ALGORITHM=COPY");
      return true;
    }
    alter_info->requested_algorithm = Alter_info::ALTER_TABLE_ALGORITHM_COPY;
  }

  /*
    If 'avoid_temporal_upgrade' mode is not enabled, then the
    pre MySQL 5.6.4 old temporal types if present is upgraded to the
    current format.
  */

  mysql_mutex_lock(&LOCK_global_system_variables);
  bool check_temporal_upgrade = !avoid_temporal_upgrade;
  mysql_mutex_unlock(&LOCK_global_system_variables);

  if (check_temporal_upgrade) {
    if (upgrade_old_temporal_types(thd, alter_info)) return true;
  }

  /*
    ALTER TABLE ... ENGINE to the same engine is a common way to
    request table rebuild. Set ALTER_RECREATE flag to force table
    rebuild.
  */
  if (create_info->db_type == table->s->db_type() &&
      create_info->used_fields & HA_CREATE_USED_ENGINE)
    alter_info->flags |= Alter_info::ALTER_RECREATE;

  /*
    If the old table had partitions and we are doing ALTER TABLE ...
    engine= <new_engine>, the new table must preserve the original
    partitioning. This means that the new engine is still the
    partitioning engine, not the engine specified in the parser.
    This is discovered in prep_alter_part_table, which in such case
    updates create_info->db_type.
    It's therefore important that the assignment below is done
    after prep_alter_part_table.
  */
  handlerton *new_db_type = create_info->db_type;
  handlerton *old_db_type = table->s->db_type();
  TABLE *new_table = nullptr;
  ha_rows copied = 0, deleted = 0;

  /*
    Handling of symlinked tables:
    If no rename:
      Create new data file and index file on the same disk as the
      old data and index files.
      Copy data.
      Rename new data file over old data file and new index file over
      old index file.
      Symlinks are not changed.

   If rename:
      Create new data file and index file on the same disk as the
      old data and index files.  Create also symlinks to point at
      the new tables.
      Copy data.
      At end, rename intermediate tables, and symlinks to intermediate
      table, to final table name.
      Remove old table and old symlinks

    If rename is made to another database:
      Create new tables in new database.
      Copy data.
      Remove old table and symlinks.
  */
  char index_file[FN_REFLEN], data_file[FN_REFLEN];

  if (!alter_ctx.is_database_changed()) {
    if (create_info->index_file_name) {
      /* Fix index_file_name to have 'tmp_name' as basename */
      my_stpcpy(index_file, alter_ctx.tmp_name);
      create_info->index_file_name =
          fn_same(index_file, create_info->index_file_name, 1);
    }
    if (create_info->data_file_name) {
      /* Fix data_file_name to have 'tmp_name' as basename */
      my_stpcpy(data_file, alter_ctx.tmp_name);
      create_info->data_file_name =
          fn_same(data_file, create_info->data_file_name, 1);
    }
  } else {
    /* Ignore symlink if db is changed. */
    create_info->data_file_name = create_info->index_file_name = nullptr;
  }

  DEBUG_SYNC(thd, "alter_table_before_create_table_no_lock");
  DBUG_EXECUTE_IF("sleep_before_create_table_no_lock", my_sleep(100000););
  /*
    Promote first timestamp column, when explicit_defaults_for_timestamp
    is not set
  */
  if (!thd->variables.explicit_defaults_for_timestamp)
    promote_first_timestamp_column(&alter_info->create_list);

  /*
    Create .FRM for new version of table with a temporary name.
    We don't log the statement, it will be logged later.

    Keep information about keys in newly created table as it
    will be used later to construct Alter_inplace_info object
    and by fill_alter_inplace_info() call.
  */
  KEY *key_info;
  uint key_count;
  FOREIGN_KEY *fk_key_info = nullptr;
  uint fk_key_count = 0;

  Alter_info::enum_enable_or_disable keys_onoff =
      ((alter_info->keys_onoff == Alter_info::LEAVE_AS_IS &&
        table->file->indexes_are_disabled())
           ? Alter_info::DISABLE
           : alter_info->keys_onoff);

  /*
    Take the X metadata lock on temporary name used for new version of
    the table. This ensures that concurrent I_S queries won't try to open it.
  */

  MDL_request tmp_name_mdl_request;
  bool is_tmp_table = (table->s->tmp_table != NO_TMP_TABLE);

  // Avoid these tables to be visible by I_S/SHOW queries.
  create_info->m_hidden = !is_tmp_table;

  if (!is_tmp_table) {
    MDL_REQUEST_INIT(&tmp_name_mdl_request, MDL_key::TABLE, alter_ctx.new_db,
                     alter_ctx.tmp_name, MDL_EXCLUSIVE, MDL_STATEMENT);
    if (thd->mdl_context.acquire_lock(&tmp_name_mdl_request,
                                      thd->variables.lock_wait_timeout))
      return true;
  }

  // Stop if we have invalid encryption clause.
  if (!is_tmp_table && validate_table_encryption(thd, create_info)) return true;

  /*
    For temporary tables or tables in SEs supporting atomic DDL dd::Table
    object describing new version of table. This object will be created in
    memory in create_table_impl() and will not be put into the on-disk DD
    and DD Object Cache.

    We become responsible for destroying this dd::Table object (for
    temporary tables until we pass its ownership to the TABLE_SHARE).
  */
  std::unique_ptr<dd::Table> non_dd_table_def;

  {
    Disable_binlog_guard binlog_guard(thd);
    /* Prevent intermediate commits to invoke commit order */
    Implicit_substatement_state_guard substatement_guard(
        thd, enum_implicit_substatement_guard_mode ::
                 DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);
    error = create_table_impl(
        thd, *new_schema, alter_ctx.new_db, alter_ctx.tmp_name,
        alter_ctx.table_name, alter_ctx.get_tmp_path(), create_info, alter_info,
        true, 0, true, true,
        /*
          If target SE supports atomic DDL do not store
          new table version in on-disk DD.
          It is not required to rollback statement in
          case of error and allows to keep correct names
          for pre-existing foreign keys in the dd::Table
          object for new table version.
         */
        (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL), nullptr, &key_info,
        &key_count, keys_onoff, &fk_key_info, &fk_key_count, alter_ctx.fk_info,
        alter_ctx.fk_count, old_table_def,
        alter_ctx.fk_max_generated_name_number, &non_dd_table_def, nullptr);
  }

  if (error) {
    /*
      Play it safe, rollback possible changes to the data-dictionary,
      so failed mysql_alter_table()/mysql_recreate_table() do not
      require rollback in the caller. Also do full rollback in unlikely
      case we have THD::transaction_rollback_request.
    */
    trans_rollback_stmt(thd);
    trans_rollback(thd);
    return true;
  }

  /*
    Atomic replacement of the table is possible only if both old and new
    storage engines support DDL atomicity.
  */
  bool atomic_replace = (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
                        (old_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL);

  /* Remember that we have not created table in storage engine yet. */
  bool no_ha_table = true;

  /* Indicates special case when we do ALTER TABLE which is really no-op. */
  bool is_noop = false;

  /*
    Indicates special case involving non-atomic ALTER TABLE which adds
    foreign keys and then fails at the late stage. Such ALTER TABLE still
    requires FK parent invalidation even despite of error.
  */
  bool invalidate_fk_parents_on_error = false;

  dd::Encrypt_result old_er{false, false};
  dd::Encrypt_result new_er{false, false};

  /*
    If we are ALTERing non-temporary table in SE not supporting atomic DDL
    we don't have dd::Table object describing new version of table yet.
    Retrieve it now.
  */
  dd::Table *table_def = non_dd_table_def.get();
  if (!table_def) {
    if (thd->dd_client()->acquire_for_modification(
            alter_ctx.new_db, alter_ctx.tmp_name, &table_def))
      goto err_new_table_cleanup;

    set_check_constraints_alter_mode(table_def, alter_info);

    assert(table_def);
  }

  if (!is_tmp_table) {
    // Check for usage of prefix key index in PARTITION BY KEY() function.
    dd::warn_on_deprecated_prefix_key_partition(
        thd, alter_ctx.db, alter_ctx.table_name, table_def, false);
  }

  if (remove_secondary_engine(thd, *table_list, *create_info, old_table_def))
    goto err_new_table_cleanup;

  // If we are changing the tablespace or the table encryption type.
  if (old_table_def &&
      (create_info->used_fields & HA_CREATE_USED_TABLESPACE ||
       create_info->used_fields & HA_CREATE_USED_ENCRYPT ||
       create_info->used_fields & HA_CREATE_USED_AUTOEXTEND_SIZE ||
       alter_ctx.is_database_changed())) {
    bool source_is_general_tablespace{false};
    bool source_encrytion_type{false};
    bool destination_is_general_tablespace{false};
    bool destination_encrytion_type{false};

    // Determine source tablespace type and encryption type.
    old_er = dd::is_tablespace_encrypted(thd, *old_table_def,
                                         &source_is_general_tablespace);
    if (old_er.error) {
      goto err_new_table_cleanup;
    }
    source_encrytion_type = old_er.value;
    if (!source_is_general_tablespace &&
        old_table_def->options().exists("encrypt_type")) {
      dd::String_type et;
      (void)old_table_def->options().get("encrypt_type", &et);
      assert(et.empty() == false);
      source_encrytion_type = is_encrypted(et);
    }

    // Determine destination tablespace type and encryption type.
    new_er = dd::is_tablespace_encrypted(thd, *table_def,
                                         &destination_is_general_tablespace);
    if (new_er.error) {
      goto err_new_table_cleanup;
    }
    destination_encrytion_type = new_er.value;
    if (!destination_is_general_tablespace &&
        table_def->options().exists("encrypt_type")) {
      dd::String_type et;
      (void)table_def->options().get("encrypt_type", &et);
      assert(et.empty() == false);
      destination_encrytion_type = is_encrypted(et);
    }

    /*
      Disallow converting a general tablespace to a file-per-table
      tablespace without a explicit ENCRYPTION clause.
    */
    if (source_is_general_tablespace && source_encrytion_type == true &&
        !destination_is_general_tablespace &&
        !(create_info->used_fields & HA_CREATE_USED_ENCRYPT)) {
      my_error(ER_TARGET_TABLESPACE_UNENCRYPTED, MYF(0));
      goto err_new_table_cleanup;
    }

    /*
      Disallow moving encrypted table (using general or file-per-table
      tablespace) to a unencrypted general tablespace.
    */
    if (source_encrytion_type && destination_is_general_tablespace &&
        !destination_encrytion_type) {
      my_error(ER_TARGET_TABLESPACE_UNENCRYPTED, MYF(0));
      goto err_new_table_cleanup;
    }

    /*
      Check table encryption privilege, if table encryption type differ
      from schema encryption type.
    */
    if (new_schema->default_encryption() != destination_encrytion_type) {
      // Ignore privilege check and show warning if database is same and
      // table encryption type is not changed.
      bool show_warning = !alter_ctx.is_database_changed() &&
                          source_encrytion_type == destination_encrytion_type;

      if (!show_warning && opt_table_encryption_privilege_check) {
        if (check_table_encryption_admin_access(thd)) {
          my_error(ER_CANNOT_SET_TABLE_ENCRYPTION, MYF(0));
          return true;
        }
      } else if (new_schema->default_encryption() &&
                 !destination_encrytion_type) {
        push_warning(thd, Sql_condition::SL_WARNING,
                     WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB,
                     ER_THD(thd, WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB));
      }
    }
  }

  if (old_table_def) {
    if (is_checked_for_upgrade(*old_table_def)) {
      DBUG_PRINT("admin", ("Transfering upgrade mark "
                           "from Table %s (%llu) to Table %s (%llu)",
                           old_table_def->name().c_str(), old_table_def->id(),
                           table_def->name().c_str(), table_def->id()));
      table_def->mark_as_checked_for_upgrade();
    }
  }

  /*
    Check if new table definition is compatible with foreign keys
    on other tales which reference this one. We want to do this
    before starting potentially expensive main phases of COPYing
    or INPLACE ALTER TABLE.
  */
  if (!is_tmp_table) {
    if (new_db_type != old_db_type) {
      /*
        By changing table's storage engine we might be introducing parent
        table for previously orphan foreign keys in the new SE. We need
        to lock child tables of such orphan foreign keys. OTOH it is safe
        to assume that if SE is changed table can't be parent in any
        foreign keys in old SE.

        We assume that ALTER TABLE which combines change of SE and renaming
        of table is executed by changing SE first and then performing rename
        (this is closer to ALTER TABLE real implementation). So such ALTER
        TABLEs  need to pick up orphan foreign keys associated with old table
        names as well. Thus we use old table name in the below check.
      */
      assert(old_table_def->foreign_key_parents().size() == 0);

      if (check_fk_children_after_parent_def_change(
              thd, table_list->db, table_list->table_name, nullptr, nullptr,
              new_db_type, table_def))
        goto err_new_table_cleanup;
    } else {
      if (check_fk_children_after_parent_def_change(
              thd, table_list->db, table_list->table_name, new_db_type,
              old_table_def, table_def, alter_info))
        goto err_new_table_cleanup;
    }

    if (alter_ctx.is_table_renamed() &&
        check_fk_children_after_parent_def_change(
            thd, alter_ctx.new_db, alter_ctx.new_alias, table_list->db,
            table_list->table_name, new_db_type, table_def))
      goto err_new_table_cleanup;
  }

  if (alter_info->requested_algorithm !=
      Alter_info::ALTER_TABLE_ALGORITHM_COPY) {
    Alter_inplace_info ha_alter_info(create_info, alter_info,
                                     alter_ctx.error_if_not_empty, key_info,
                                     key_count, thd->work_part_info);
    TABLE *altered_table = nullptr;
    bool use_inplace = true;

    /* Fill the Alter_inplace_info structure. */
    if (fill_alter_inplace_info(thd, table, &ha_alter_info))
      goto err_new_table_cleanup;

    DBUG_EXECUTE_IF("innodb_index_drop_count_zero", {
      if (ha_alter_info.index_drop_count) {
        my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "Index rebuild",
                 "Without rebuild");
        return true;
      }
    };);

    DBUG_EXECUTE_IF("innodb_index_drop_count_one", {
      if (ha_alter_info.index_drop_count != 1) {
        my_error(ER_ALTER_OPERATION_NOT_SUPPORTED, MYF(0), "Index change",
                 "Index rebuild");
        return true;
      }
    };);

    // We assume that the table is non-temporary.
    assert(!table->s->tmp_table);

    if (!(altered_table = open_table_uncached(
              thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
              alter_ctx.tmp_name, true, false, *table_def)))
      goto err_new_table_cleanup;

    /* Set markers for fields in TABLE object for altered table. */
    update_altered_table(ha_alter_info, altered_table);

    /*
      Mark all columns in 'altered_table' as used to allow usage
      of its record[0] buffer and Field objects during in-place
      ALTER TABLE.
    */
    altered_table->column_bitmaps_set_no_signal(&altered_table->s->all_set,
                                                &altered_table->s->all_set);

    set_column_static_defaults(altered_table, alter_info->create_list);

    if (ha_alter_info.handler_flags == 0) {
      /*
        No-op ALTER, no need to call handler API functions.

        If this code path is entered for an ALTER statement that
        should not be a real no-op, new handler flags should be added
        and fill_alter_inplace_info() adjusted.

        Note that we can end up here if an ALTER statement has clauses
        that cancel each other out (e.g. ADD/DROP identically index).

        Also note that we ignore the LOCK clause here.
      */
      close_temporary_table(thd, altered_table, true, false);

      if (!(create_info->db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
        // Delete temporary table object from data dictionary.
        bool result = dd::drop_table(thd, alter_ctx.new_db, alter_ctx.tmp_name,
                                     *table_def);
        (void)trans_intermediate_ddl_commit(thd, result);
      }

      is_noop = true;
      goto end_inplace_noop;
    }

    // Ask storage engine whether to use copy or in-place
    enum_alter_inplace_result inplace_supported =
        table->file->check_if_supported_inplace_alter(altered_table,
                                                      &ha_alter_info);

    // If INSTANT was requested but it is not supported, report error.
    if (alter_info->requested_algorithm ==
            Alter_info::ALTER_TABLE_ALGORITHM_INSTANT &&
        inplace_supported != HA_ALTER_INPLACE_INSTANT &&
        inplace_supported != HA_ALTER_ERROR) {
      ha_alter_info.report_unsupported_error("ALGORITHM=INSTANT",
                                             "ALGORITHM=COPY/INPLACE");
      close_temporary_table(thd, altered_table, true, false);
      goto err_new_table_cleanup;
    }

    switch (inplace_supported) {
      case HA_ALTER_INPLACE_EXCLUSIVE_LOCK:
        // If SHARED lock and no particular algorithm was requested, use COPY.
        if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_SHARED &&
            alter_info->requested_algorithm ==
                Alter_info::ALTER_TABLE_ALGORITHM_DEFAULT) {
          use_inplace = false;
        }
        // Otherwise, if weaker lock was requested, report error.
        else if (alter_info->requested_lock ==
                     Alter_info::ALTER_TABLE_LOCK_NONE ||
                 alter_info->requested_lock ==
                     Alter_info::ALTER_TABLE_LOCK_SHARED) {
          ha_alter_info.report_unsupported_error("LOCK=NONE/SHARED",
                                                 "LOCK=EXCLUSIVE");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        break;
      case HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE:
      case HA_ALTER_INPLACE_SHARED_LOCK:
        // If weaker lock was requested, report error.
        if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_NONE) {
          ha_alter_info.report_unsupported_error("LOCK=NONE", "LOCK=SHARED");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        break;
      case HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE:
      case HA_ALTER_INPLACE_NO_LOCK:
      case HA_ALTER_INPLACE_INSTANT:
        /*
          Note that any instant operation is also in fact in-place operation.

          It is totally safe to execute operation using instant algorithm if it
          has no drawbacks as compared to in-place algorithm even if user
          explicitly asked for ALGORITHM=INPLACE. Doing so, also allows to
          keep code in engines which support only limited subset of in-place
          ALTER TABLE operations as instant metadata only changes simple.

          If instant algorithm has some downsides to in-place algorithm and user
          explicitly asks for ALGORITHM=INPLACE it is responsibility of storage
          engine to fallback to in-place algorithm execution by returning
          HA_ALTER_INPLACE_NO_LOCK or HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE.
        */
        break;
      case HA_ALTER_INPLACE_NOT_SUPPORTED:
        // If INPLACE was requested, report error.
        if (alter_info->requested_algorithm ==
            Alter_info::ALTER_TABLE_ALGORITHM_INPLACE) {
          ha_alter_info.report_unsupported_error("ALGORITHM=INPLACE",
                                                 "ALGORITHM=COPY");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        // COPY with LOCK=NONE is not supported, no point in trying.
        if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_NONE) {
          ha_alter_info.report_unsupported_error("LOCK=NONE", "LOCK=SHARED");
          close_temporary_table(thd, altered_table, true, false);
          goto err_new_table_cleanup;
        }
        // Otherwise use COPY
        use_inplace = false;
        break;
      case HA_ALTER_ERROR:
      default:
        close_temporary_table(thd, altered_table, true, false);
        goto err_new_table_cleanup;
    }

    if (use_inplace) {
      if (mysql_inplace_alter_table(thd, *schema, *new_schema, old_table_def,
                                    table_def, table_list, table, altered_table,
                                    &ha_alter_info, inplace_supported,
                                    &alter_ctx, columns, fk_key_info,
                                    fk_key_count, &fk_invalidator)) {
        return true;
      }

      goto end_inplace;
    } else {
      close_temporary_table(thd, altered_table, true, false);
    }
  }

  /* ALTER TABLE using copy algorithm. */

  /* Check if ALTER TABLE is compatible with foreign key definitions. */
  if (fk_check_copy_alter_table(thd, table_list, old_table_def, alter_info))
    goto err_new_table_cleanup;

  if (!table->s->tmp_table) {
    MDL_request_list mdl_requests;

    // COPY algorithm doesn't work with concurrent writes.
    if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_NONE) {
      my_error(ER_ALTER_OPERATION_NOT_SUPPORTED_REASON, MYF(0), "LOCK=NONE",
               ER_THD(thd, ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY),
               "LOCK=SHARED");
      goto err_new_table_cleanup;
    }

    // If EXCLUSIVE lock is requested, upgrade already.
    if (alter_info->requested_lock == Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE &&
        wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN))
      goto err_new_table_cleanup;

    /*
      Otherwise upgrade to SHARED_NO_WRITE.
      Note that under LOCK TABLES, we will already have SHARED_NO_READ_WRITE.
    */
    if (alter_info->requested_lock != Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE &&
        thd->mdl_context.upgrade_shared_lock(mdl_ticket, MDL_SHARED_NO_WRITE,
                                             thd->variables.lock_wait_timeout))
      goto err_new_table_cleanup;

    DEBUG_SYNC(thd, "alter_table_copy_after_lock_upgrade");

    /*
      COPY algorithm creates new table version in the new database.
      So if new database differs from old one we need to lock all
      foreign key names in new table version. If it is the same as
      the old one we need to lock only names of foreign keys added.

      Also if table is renamed we need to acquire locks on all foreign
      key names involved (taking into account adjustment of auto-generated
      names).
    */
    if (alter_ctx.is_database_changed()) {
      if (collect_fk_names(thd, alter_ctx.new_db, table_def, &mdl_requests))
        goto err_new_table_cleanup;
    } else {
      if (collect_fk_names_for_new_fks(
              thd, alter_ctx.new_db, table_list->table_name, alter_info,
              new_db_type,
              get_fk_max_generated_name_number(table_list->table_name,
                                               old_table_def, new_db_type),
              &mdl_requests))
        goto err_new_table_cleanup;
    }

    if (alter_ctx.is_table_renamed() &&
        collect_fk_names_for_rename_table(
            thd, table_list->db, table_list->table_name, table_def, new_db_type,
            alter_ctx.new_db, alter_ctx.new_name, &mdl_requests))
      goto err_new_table_cleanup;

    /*
      Acquire SRO locks on parent tables for newly added foreign keys
      in order to prevent concurrent DML on them.

      This is temporary workaround to the problem caused by the fact that
      InnoDB makes such foreign keys visible in its internal dictionary
      cache before ALTER TABLE commit. So such DML can result in access
      to our temporary table without prior acquisition of metadata lock
      on it (which would have blocked such access normally). As result
      our ALTER TABLE can fail due to locks acquired by these accesses.

      Long-term the problem should be solved by adjusting InnoDB code
      to avoid making such uncommitted changes visible to other
      connections.
    */
    if (collect_fk_parents_for_new_fks(
            thd, table_list->db, table_list->table_name, alter_info,
            MDL_SHARED_READ_ONLY, nullptr, &mdl_requests, nullptr))
      goto err_new_table_cleanup;

    if (!mdl_requests.is_empty() &&
        thd->mdl_context.acquire_locks(&mdl_requests,
                                       thd->variables.lock_wait_timeout))
      goto err_new_table_cleanup;

    /*
      Check if ALTER TABLE results in any foreign key name conflicts
      before starting potentially expensive copying operation.
    */
    if (!dd::get_dictionary()->is_dd_table_name(table_list->db,
                                                table_list->table_name) &&
        (new_db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS)) {
      if (alter_ctx.is_database_changed()) {
        /*
          If new table version was created schema different from the old one
          we need to check names for both pre-existing and newly added foreign
          keys.
        */
        for (FOREIGN_KEY *fk = fk_key_info; fk < fk_key_info + fk_key_count;
             ++fk) {
          bool exists;
          if (thd->dd_client()->check_foreign_key_exists(*new_schema, fk->name,
                                                         &exists))
            goto err_new_table_cleanup;

          if (exists) {
            my_error(ER_FK_DUP_NAME, MYF(0), fk->name);
            goto err_new_table_cleanup;
          }
        }
      } else {
        /* Otherwise we can limit our check to newly added foreign keys only. */
        for (FOREIGN_KEY *fk = fk_key_info + alter_ctx.fk_count;
             fk < fk_key_info + fk_key_count; ++fk) {
          bool exists;
          if (thd->dd_client()->check_foreign_key_exists(*new_schema, fk->name,
                                                         &exists))
            goto err_new_table_cleanup;

          if (exists) {
            my_error(ER_FK_DUP_NAME, MYF(0), fk->name);
            goto err_new_table_cleanup;
          }
        }
      }

      if (alter_ctx.is_table_renamed() &&
          check_fk_names_before_rename(thd, table_list, *table_def, new_db_type,
                                       *new_schema, alter_ctx))
        goto err_new_table_cleanup;
    }
  }

  {
    if (ha_create_table(thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
                        alter_ctx.tmp_name, create_info, false, true,
                        table_def))
      goto err_new_table_cleanup;

    /* Mark that we have created table in storage engine. */
    no_ha_table = false;

    if (create_info->options & HA_LEX_CREATE_TMP_TABLE) {
      if (thd->decide_logging_format(table_list) ||
          !open_table_uncached(thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
                               alter_ctx.tmp_name, true, true, *table_def))
        goto err_new_table_cleanup;
      /* in case of alter temp table send the tracker in OK packet */
      if (thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
              ->is_enabled())
        thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
            ->mark_as_changed(thd, {});
    }

    /* Open the table since we need to copy the data. */
    if (table->s->tmp_table != NO_TMP_TABLE) {
      Table_ref tbl(alter_ctx.new_db, alter_ctx.tmp_name, TL_READ_NO_INSERT);
      /* Table is in thd->temporary_tables */
      (void)open_temporary_table(thd, &tbl);
      new_table = tbl.table;
      /* Transfer dd::Table ownership to temporary table's share. */
      new_table->s->tmp_table_def = non_dd_table_def.release();
    } else {
      /* table is a normal table: Create temporary table in same directory */
      /* Open our intermediate table. */
      new_table =
          open_table_uncached(thd, alter_ctx.get_tmp_path(), alter_ctx.new_db,
                              alter_ctx.tmp_name, true, true, *table_def);
    }
    if (!new_table) goto err_new_table_cleanup;
    /*
      Note: In case of MERGE table, we do not attach children. We do not
      copy data for MERGE tables. Only the children have data.
    */

    // It's now safe to take the table level lock.
    if (lock_tables(thd, table_list, alter_ctx.tables_opened, 0))
      goto err_new_table_cleanup;
  }

  /*
    We do not copy data for MERGE tables. Only the children have data.
    MERGE tables have HA_NO_COPY_ON_ALTER set.
  */
  if (!(new_table->file->ha_table_flags() & HA_NO_COPY_ON_ALTER)) {
    new_table->next_number_field = new_table->found_next_number_field;
    THD_STAGE_INFO(thd, stage_copy_to_tmp_table);
    DBUG_EXECUTE_IF("abort_copy_table", {
      my_error(ER_LOCK_WAIT_TIMEOUT, MYF(0));
      goto err_new_table_cleanup;
    });

    if (copy_data_between_tables(thd, thd->m_stage_progress_psi, table,
                                 new_table, alter_info->create_list, &copied,
                                 &deleted, alter_info->keys_onoff, &alter_ctx))
      goto err_new_table_cleanup;

    DEBUG_SYNC(thd, "alter_after_copy_table");
  } else {
    /* Should be MERGE only */
    assert(new_table->file->ht->db_type == DB_TYPE_MRG_MYISAM);
    if (!table->s->tmp_table &&
        wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN))
      goto err_new_table_cleanup;
    THD_STAGE_INFO(thd, stage_manage_keys);
    DEBUG_SYNC(thd, "alter_table_manage_keys");
    alter_table_manage_keys(thd, table, table->file->indexes_are_disabled(),
                            alter_info->keys_onoff);
    assert(!(new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL));

    /* Prevent intermediate commits to invoke commit order */
    Implicit_substatement_state_guard substatement_guard(
        thd, enum_implicit_substatement_guard_mode ::
                 DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd))
      goto err_new_table_cleanup;
  }

  if (table->s->tmp_table != NO_TMP_TABLE) {
    /* Close lock if this is a transactional table */
    if (thd->lock) {
      if (thd->locked_tables_mode != LTM_LOCK_TABLES &&
          thd->locked_tables_mode != LTM_PRELOCKED_UNDER_LOCK_TABLES) {
        mysql_unlock_tables(thd, thd->lock);
        thd->lock = nullptr;
      } else {
        /*
          If LOCK TABLES list is not empty and contains this table,
          unlock the table and remove the table from this list.
        */
        mysql_lock_remove(thd, thd->lock, table);
      }
    }
    /* Remove link to old table and rename the new one */
    close_temporary_table(thd, table, true, true);
    /* Should pass the 'new_name' as we store table name in the cache */
    if (rename_temporary_table(thd, new_table, alter_ctx.new_db,
                               alter_ctx.new_name))
      goto err_new_table_cleanup;
    /*
      We don't replicate alter table statement on temporary tables
      in RBR mode.
    */
    if (!thd->is_current_stmt_binlog_format_row() &&
        write_bin_log(thd, true, thd->query().str, thd->query().length)) {
      /*
        We can't revert replacement of old table version with a new one
        at this point. So, if possible, commit the statement to avoid
        new table version being emptied by statement rollback.
      */
      if (!thd->transaction_rollback_request) {
        (void)trans_commit_stmt(thd);
        (void)trans_commit_implicit(thd);
      }
      return true;
    }

    // Do implicit commit for consistency with non-temporary table case/
    if (trans_commit_stmt(thd) || trans_commit_implicit(thd)) return true;

    goto end_temporary;
  }

  /*
    Close the intermediate table that will be the new table, but do
    not delete it! Even though MERGE tables do not have their children
    attached here it is safe to call close_temporary_table().
  */
  close_temporary_table(thd, new_table, true, false);
  new_table = nullptr;

  DEBUG_SYNC(thd, "alter_table_before_rename_result_table");
  DBUG_EXECUTE_IF("exit_after_alter_table_before_rename", {
    my_error(ER_UNKNOWN_ERROR, MYF(0));
    return true;
  });

  /*
    Data is copied. Now we:
    1) Wait until all other threads will stop using old version of table
       by upgrading shared metadata lock to exclusive one.
    2) Close instances of table open by this thread and replace them
       with placeholders to simplify reopen process.
    3) Rename the old table to a temp name, rename the new one to the
       old name.
    4) If we are under LOCK TABLES and don't do ALTER TABLE ... RENAME
       we reopen new version of table.
    5) Write statement to the binary log.
    6) If we are under LOCK TABLES and do ALTER TABLE ... RENAME we
       remove placeholders and release metadata locks.
    7) If we are not not under LOCK TABLES we rely on the caller
      (mysql_execute_command()) to release metadata locks.
  */

  THD_STAGE_INFO(thd, stage_rename_result_table);

  if (wait_while_table_is_used(thd, table, HA_EXTRA_PREPARE_FOR_RENAME))
    goto err_new_table_cleanup;

  if (collect_and_lock_fk_tables_for_complex_alter_table(
          thd, table_list, old_table_def, &alter_ctx, alter_info, old_db_type,
          new_db_type, &fk_invalidator))
    goto err_new_table_cleanup;

  /*
    To ensure DDL atomicity after this point support from both old and
    new engines is necessary. If either of them lacks such support let
    us commit transaction so changes to data-dictionary are more closely
    reflect situations in SEs.

    Also if new SE supports atomic DDL then we have not stored new table
    definition in on-disk data-dictionary so far. It is time to do this
    now if ALTER TABLE as a whole won't be atomic.
  */
  if (!atomic_replace) {
    if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        thd->dd_client()->store(non_dd_table_def.get()))
      goto err_new_table_cleanup;

    /* Prevent intermediate commits to invoke commit order */
    Implicit_substatement_state_guard substatement_guard(thd);

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd))
      goto err_new_table_cleanup;

    // Safety, in-memory dd::Table is no longer totally correct.
    non_dd_table_def.reset();
  }

  char backup_name[32];
  assert(sizeof(my_thread_id) == 4);
  snprintf(backup_name, sizeof(backup_name), "%s2-%lx-%x", tmp_file_prefix,
           current_pid, thd->thread_id());
  if (lower_case_table_names) my_casedn_str(files_charset_info, backup_name);

  close_all_tables_for_name(thd, table->s, false, nullptr);
  table_list->table = table = nullptr; /* Safety */

  /*
    Rename the old version to temporary name to have a backup in case
    anything goes wrong while renaming the new table.

    Take the X metadata lock on this temporary name too. This ensures that
    concurrent I_S queries won't try to open it. Assert to ensure we do not
    come here when ALTERing temporary table.
  */
  {
    assert(!is_tmp_table);
    MDL_request backup_name_mdl_request;
    MDL_REQUEST_INIT(&backup_name_mdl_request, MDL_key::TABLE, alter_ctx.db,
                     backup_name, MDL_EXCLUSIVE, MDL_STATEMENT);
    dd::cache::Dictionary_client::Auto_releaser releaser_2(thd->dd_client());
    const dd::Table *backup_table = nullptr;

    if (thd->mdl_context.acquire_lock(&backup_name_mdl_request,
                                      thd->variables.lock_wait_timeout) ||
        thd->dd_client()->acquire(alter_ctx.db, backup_name, &backup_table)) {
      /* purecov: begin tested */
      /*
        We need to clear THD::transaction_rollback_request (which might
        be set due to MDL deadlock) before attempting to remove new version
        of table.
      */
      if (thd->transaction_rollback_request) {
        trans_rollback_stmt(thd);
        trans_rollback(thd);
      }

      if (!atomic_replace) {
        (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                             alter_ctx.tmp_name, FN_IS_TMP);
      }
      goto err_with_mdl;
      /* purecov: end */
    }

    if (backup_table != nullptr) {
      /* purecov: begin tested */
      my_error(ER_TABLE_EXISTS_ERROR, MYF(0), backup_name);

      if (!atomic_replace) {
        (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                             alter_ctx.tmp_name, FN_IS_TMP);
      }
      goto err_with_mdl;
      /* purecov: end */
    }
  }

  if (mysql_rename_table(thd, old_db_type, alter_ctx.db, alter_ctx.table_name,
                         alter_ctx.db, alter_ctx.table_name, *schema,
                         alter_ctx.db, backup_name,
                         FN_TO_IS_TMP | (atomic_replace ? NO_DD_COMMIT : 0) |
                             NO_FK_RENAME | NO_CC_RENAME)) {
    // Rename to temporary name failed, delete the new table, abort ALTER.
    if (!atomic_replace) {
      /*
        In non-atomic mode situations when the SE has requested rollback
        should be handled already, by executing rollback right inside
        mysql_rename_table() call.
      */
      assert(!thd->transaction_rollback_request);
      (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                           alter_ctx.tmp_name, FN_IS_TMP);
    }
    goto err_with_mdl;
  }

  /*
    The below code assumes that only SE capable of atomic DDL support FK.
    This is somewhat simplifies error handling below.

    Note that we need to handle FKs atomically with this rename in order
    to handle scenario when, for example, MyISAM table is altered to InnoDB
    SE and some FKs are added at the same time.
  */
  assert(!(new_db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS) ||
         (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL));

  /*
    We also assume that we can't have non-atomic ALTER TABLE which
    will preserve any foreign keys (i.e. such ALTER TABLE can only
    drop all foreign keys on the table, or add new foreign keys to
    table which previously didn't have any).
  */
  assert(atomic_replace || alter_ctx.fk_count == 0);

  /*
    If both old and new SEs support atomic DDL then we have not stored
    new table definition in on-disk data-dictionary so far. It is time
    to do this now. However, before doing this we need to rename foreign
    keys in old table definition to temporary names to avoid conflicts
    with duplicate names.
  */
  if (atomic_replace) {
    if (alter_ctx.fk_count > 0 &&
        adjust_foreign_key_names_for_old_table_version(thd, alter_ctx.db,
                                                       backup_name))
      goto err_with_mdl;

    if (thd->dd_client()->store(non_dd_table_def.get())) goto err_with_mdl;

    // Safety, in-memory dd::Table is no longer totally correct.
    non_dd_table_def.reset();
  }

  // Rename the new table to the correct name.
  if (mysql_rename_table(
          thd, new_db_type, alter_ctx.new_db, alter_ctx.tmp_name, alter_ctx.db,
          alter_ctx.table_name, *new_schema, alter_ctx.new_db,
          alter_ctx.new_alias,
          (FN_FROM_IS_TMP |
           ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) ? NO_DD_COMMIT
                                                            : 0) |
           (alter_ctx.is_table_renamed() ? 0 : NO_FK_RENAME | NO_CC_RENAME))) ||
      ((new_db_type->flags & HTON_SUPPORTS_FOREIGN_KEYS) &&
       adjust_fks_for_complex_alter_table(thd, table_list, &alter_ctx,
                                          alter_info, new_db_type,
                                          &fk_invalidator)) ||
      /*
        Try commit changes if ALTER TABLE as whole is not atomic and we have
        not done this in the above mysql_rename_table() call.
      */
      (!atomic_replace && (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
       trans_intermediate_ddl_commit(thd, false))) {
    // Rename failed, delete the temporary table.
    if (!atomic_replace) {
      if (new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) {
        /*
          If ALTER TABLE as whole is not atomic and the above rename or
          FK changes have failed without cleaning up after themselves,
          we need to do this now.
        */
        (void)trans_intermediate_ddl_commit(thd, true);
      }

      /*
        In non-atomic mode situations when the SE has requested rollback
        should be handled already.
      */
      assert(!thd->transaction_rollback_request);

      (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                           alter_ctx.tmp_name, FN_IS_TMP);

      // Restore the backup of the original table to its original name.
      // If the operation fails, we need to retry it to avoid leaving
      // the dictionary inconsistent.
      //
      // This hack might become unnecessary once InnoDB stops acquiring
      // gap locks on DD tables (which might cause deadlocks).
      uint retries = 20;
      while (retries-- &&
             mysql_rename_table(
                 thd, old_db_type, alter_ctx.db, backup_name, alter_ctx.db,
                 backup_name, *schema, alter_ctx.db, alter_ctx.alias,
                 FN_FROM_IS_TMP | NO_FK_CHECKS | NO_FK_RENAME | NO_CC_RENAME))
        ;
    }
    goto err_with_mdl;
  }

  /*
    If ALTER TABLE is non-atomic and fails after this point it can add
    foreign keys and such addition won't be reverted. So we need to
    invalidate table objects for foreign key parents even on error.
  */
  if (!atomic_replace) invalidate_fk_parents_on_error = true;

  // Handle trigger name, check constraint names and histograms statistics.
  {
    dd::Table *backup_table = nullptr;
    dd::Table *new_dd_table = nullptr;
    if (thd->dd_client()->acquire_for_modification(alter_ctx.db, backup_name,
                                                   &backup_table) ||
        thd->dd_client()->acquire_for_modification(
            alter_ctx.new_db, alter_ctx.new_alias, &new_dd_table))
      goto err_with_mdl;
    assert(backup_table != nullptr && new_dd_table != nullptr);

    /*
      Check if this is an ALTER command that will cause histogram statistics to
      become invalid. If that is the case; remove the histogram statistics.

      This will take care of scenarios when COPY alter is used, but not INPLACE.
      Do this before the commit for non-transactional tables, because the
      new_dd_table is invalidated on commit.
    */
    if (alter_table_drop_histograms(thd, table_list, alter_info, create_info,
                                    columns, backup_table, new_dd_table))
      goto err_with_mdl; /* purecov: deadcode */

    bool update = (new_dd_table->check_constraints()->size() > 0);
    // Set mode for new_dd_table's check constraints.
    set_check_constraints_alter_mode(new_dd_table, alter_info);

    /*
      Check constraint names are unique per schema, we cannot create them while
      both table version exists. Adjust check constraint names in old table
      version.
    */
    if (adjust_check_constraint_names_for_old_table_version(thd, alter_ctx.db,
                                                            backup_table))
      goto err_with_mdl;

    // Reset check constraint's mode.
    reset_check_constraints_alter_mode(new_dd_table);

    /*
      Since trigger names have to be unique per schema, we cannot
      create them while both the old and the tmp version of the
      table exist.
    */
    if (backup_table->has_trigger()) {
      new_dd_table->copy_triggers(backup_table);
      backup_table->drop_all_triggers();
      update = true;
    }
    if (!is_checked_for_upgrade(*new_dd_table) &&
        is_checked_for_upgrade(*backup_table)) {
      new_dd_table->mark_as_checked_for_upgrade();
      update = true;
    }
    if (update) {
      if (thd->dd_client()->update(backup_table) ||
          thd->dd_client()->update(new_dd_table))
        goto err_with_mdl;

      /* Prevent intermediate commits to invoke commit order */
      Implicit_substatement_state_guard substatement_guard(thd);
      if (!atomic_replace && (trans_commit_stmt(thd) || trans_commit(thd)))
        goto err_with_mdl;
    }
  }

  // If the ALTER command was a rename, rename any existing histograms.
  if (alter_ctx.is_table_renamed() &&
      rename_histograms(thd, table_list->db, table_list->table_name, new_db,
                        new_name)) {
    goto err_with_mdl; /* purecov: deadcode */
  }

  // ALTER TABLE succeeded, delete the backup of the old table.
  if (quick_rm_table(thd, old_db_type, alter_ctx.db, backup_name,
                     FN_IS_TMP | (atomic_replace ? NO_DD_COMMIT : 0))) {
    /*
      The fact that deletion of the backup failed is not critical
      error, but still worth reporting as it might indicate serious
      problem with server.

      TODO: In !atomic_replace case we might need to do FK parents
            invalidation here. However currently our FKs are not
            even named correctly at this point, so we postpone
            fixing this issue until we solve FK naming problem.
    */
    goto err_with_mdl;
  }

end_inplace_noop:

  THD_STAGE_INFO(thd, stage_end);

  DBUG_EXECUTE_IF("sleep_alter_before_main_binlog", my_sleep(6000000););
  DEBUG_SYNC(thd, "alter_table_before_main_binlog");

  ha_binlog_log_query(thd, create_info->db_type, LOGCOM_ALTER_TABLE,
                      thd->query().str, thd->query().length, alter_ctx.db,
                      alter_ctx.table_name);

  assert(!(mysql_bin_log.is_open() &&
           thd->is_current_stmt_binlog_format_row() &&
           (create_info->options & HA_LEX_CREATE_TMP_TABLE)));

  /*
    If this is no-op ALTER TABLE we don't have transaction started.
    We can't use binlog's trx cache in this case as it requires active
    transaction with valid XID.
  */
  if (write_bin_log(thd, true, thd->query().str, thd->query().length,
                    atomic_replace && !is_noop))
    goto err_with_mdl;

  if (!is_noop) {
    Uncommitted_tables_guard uncommitted_tables(thd);

    uncommitted_tables.add_table(table_list);

    if (update_referencing_views_metadata(thd, table_list, new_db, new_name,
                                          !atomic_replace, &uncommitted_tables))
      goto err_with_mdl;

    if (alter_ctx.is_table_renamed())
      tdc_remove_table(thd, TDC_RT_REMOVE_ALL, alter_ctx.new_db,
                       alter_ctx.new_name, false);
  }

  // Commit if it was not done before in order to be able to reopen tables.
  if (atomic_replace && (trans_commit_stmt(thd) || trans_commit_implicit(thd)))
    goto err_with_mdl;

  if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && new_db_type->post_ddl)
    new_db_type->post_ddl(thd);
  if ((old_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && old_db_type->post_ddl)
    old_db_type->post_ddl(thd);

#ifndef WORKAROUND_TO_BE_REMOVED_BY_WL6049
  {
    Table_ref table_list_reopen(alter_ctx.new_db, alter_ctx.new_name,
                                alter_ctx.new_alias, TL_READ);
    table_list_reopen.mdl_request.ticket =
        alter_ctx.is_table_renamed() ? alter_ctx.target_mdl_request.ticket
                                     : mdl_ticket;

    Open_table_context ot_ctx(thd, MYSQL_OPEN_REOPEN);

    if (open_table(thd, &table_list_reopen, &ot_ctx)) return true;

    assert(table_list_reopen.table == thd->open_tables);
    close_thread_table(thd, &thd->open_tables);
  }
#endif

end_inplace:

  fk_invalidator.invalidate(thd);

  if (alter_ctx.is_table_renamed())
    thd->locked_tables_list.rename_locked_table(
        table_list, alter_ctx.new_db, alter_ctx.new_name,
        alter_ctx.target_mdl_request.ticket);

  {
    bool reopen_error = thd->locked_tables_list.reopen_tables(thd);

    if (thd->locked_tables_mode == LTM_LOCK_TABLES ||
        thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) {
      if (alter_ctx.is_table_renamed()) {
        /*
          Release metadata lock on old table name and keep the lock
          on the new one. We have to ignore reopen_error in this case
          as we will mess up FK invariants for LOCK TABLES otherwise.
        */
        thd->mdl_context.release_all_locks_for_name(mdl_ticket);
        thd->mdl_context.set_lock_duration(alter_ctx.target_mdl_request.ticket,
                                           MDL_EXPLICIT);
        alter_ctx.target_mdl_request.ticket->downgrade_lock(
            MDL_SHARED_NO_READ_WRITE);
        if (alter_ctx.is_database_changed())
          thd->mdl_context.set_lock_duration(
              alter_ctx.target_db_mdl_request.ticket, MDL_EXPLICIT);
      } else
        mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
    }

    if (reopen_error) return true;
  }

end_temporary:
  snprintf(alter_ctx.tmp_name, sizeof(alter_ctx.tmp_name),
           ER_THD(thd, ER_INSERT_INFO), (long)(copied + deleted), (long)deleted,
           (long)thd->get_stmt_da()->current_statement_cond_count());
  my_ok(thd, copied + deleted, 0L, alter_ctx.tmp_name);
  return false;

err_new_table_cleanup:
  if (create_info->options & HA_LEX_CREATE_TMP_TABLE) {
    if (new_table)
      close_temporary_table(thd, new_table, true, true);
    else if (!no_ha_table)
      rm_temporary_table(thd, new_db_type, alter_ctx.get_tmp_path(),
                         non_dd_table_def.get());
  } else {
    /* close_temporary_table() frees the new_table pointer. */
    if (new_table) close_temporary_table(thd, new_table, true, false);

    if (!(new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL)) {
      if (no_ha_table)  // Only remove from DD.
      {
        dd::cache::Dictionary_client::Auto_releaser releaser_3(
            thd->dd_client());
        const dd::Table *drop_table_def = nullptr;
        if (!thd->dd_client()->acquire(alter_ctx.new_db, alter_ctx.tmp_name,
                                       &drop_table_def)) {
          assert(drop_table_def != nullptr);
          bool result = dd::drop_table(thd, alter_ctx.new_db,
                                       alter_ctx.tmp_name, *drop_table_def);
          (void)trans_intermediate_ddl_commit(thd, result);
        }
      } else  // Remove from both DD and SE.
        (void)quick_rm_table(thd, new_db_type, alter_ctx.new_db,
                             alter_ctx.tmp_name, FN_IS_TMP);
    } else {
      trans_rollback_stmt(thd);
      /*
        Full rollback in case we have THD::transaction_rollback_request
        and to synchronize DD state in cache and on disk (as statement
        rollback doesn't clear DD cache of modified uncommitted objects).
      */
      trans_rollback(thd);
    }
    if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        new_db_type->post_ddl)
      new_db_type->post_ddl(thd);
  }

  if (alter_ctx.error_if_not_empty &
      Alter_table_ctx::GEOMETRY_WITHOUT_DEFAULT) {
    my_error(ER_INVALID_USE_OF_NULL, MYF(0));
  }

  /*
    No default value was provided for a DATE/DATETIME field, the
    current sql_mode doesn't allow the '0000-00-00' value and
    the table to be altered isn't empty.
    Report error here. Ignore error checkin for push_zero_date_warning()
    as we return true right below.
  */
  if ((alter_ctx.error_if_not_empty &
       Alter_table_ctx::DATETIME_WITHOUT_DEFAULT) &&
      (thd->variables.sql_mode & MODE_NO_ZERO_DATE) &&
      thd->get_stmt_da()->current_row_for_condition()) {
    (void)push_zero_date_warning(thd, alter_ctx.datetime_field);
  }
  return true;

err_with_mdl:
  /*
    An error happened while we were holding exclusive name metadata lock
    on table being altered. Before releasing locks we need to rollback
    changes to the data-dictionary, storage angine and binary log (if
    they were not committed earlier) and execute post DDL hooks.
    We also try to reopen old version of the table under LOCK TABLES
    if possible.
  */

  trans_rollback_stmt(thd);
  /*
    Full rollback in case we have THD::transaction_rollback_request
    and to synchronize DD state in cache and on disk (as statement
    rollback doesn't clear DD cache of modified uncommitted objects).
  */
  trans_rollback(thd);
  if ((new_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && new_db_type->post_ddl)
    new_db_type->post_ddl(thd);
  if ((old_db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) && old_db_type->post_ddl)
    old_db_type->post_ddl(thd);

  if (atomic_replace) {
    /*
      If both old and new storage engines support atomic DDL all changes
      were reverted at this point. So we can safely try to reopen table
      under old name.
    */
  } else {
    /*
      If ALTER TABLE ... RENAME ... ALGORITHM=COPY is non-atomic we can't
      be sure that rename step was reverted, so we simply remove table
      from the list of locked tables.
    */
    if (alter_ctx.is_table_renamed())
      thd->locked_tables_list.unlink_all_closed_tables(thd, nullptr, 0);
  }

  /*
    ALTER TABLE which changes table storage engine from MyISAM to InnoDB
    and adds foreign keys at the same time can fail after installing
    new table version. In this case we still need to invalidate table
    objects for parent tables to avoid creating discrepancy between
    data-dictionary and cache contents.
  */
  if (invalidate_fk_parents_on_error) fk_invalidator.invalidate(thd);

  (void)thd->locked_tables_list.reopen_tables(thd);

  if ((thd->locked_tables_mode == LTM_LOCK_TABLES ||
       thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES)) {
    /*
      Non-atomic ALTER TABLE ... RENAME ... ALGORITHM=COPY can add
      foreign keys if at the same time SE is changed from, e.g.,
      MyISAM to InnoDB. Since releasing metadata locks on old or new
      table name can break FK invariants for LOCK TABLES in various
      scenarios we keep both of them.
    */
    if (!atomic_replace && alter_ctx.is_table_renamed()) {
      thd->mdl_context.set_lock_duration(alter_ctx.target_mdl_request.ticket,
                                         MDL_EXPLICIT);
      alter_ctx.target_mdl_request.ticket->downgrade_lock(
          MDL_SHARED_NO_READ_WRITE);
      if (alter_ctx.is_database_changed())
        thd->mdl_context.set_lock_duration(
            alter_ctx.target_db_mdl_request.ticket, MDL_EXPLICIT);
    }
    mdl_ticket->downgrade_lock(MDL_SHARED_NO_READ_WRITE);
  }

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: prepare_check_constraints_for_alter
            prepare_check_constraints_for_alter().
          */
          break;
        case Alter_drop::ANY_CONSTRAINT:
          /*
            Constraint type is resolved by name and a new Alter_drop element
            with resolved type is added to the Alter_drop list.
            Alter_drop::ANY_CONSTRAINT element is retained in the Alter_drop
            list to support re-execution of stored routine or prepared
            statement.
          */
          break;
        default:
          assert(false);
          break;
      }
    }
  }

  if (rename_key_list.size() > 0) {
    my_error(ER_KEY_DOES_NOT_EXITS, MYF(0), rename_key_list[0]->old_name,
             table->s->table_name.str);
    return true;
  }
  if (index_visibility_list.size() > 0) {
    my_error(ER_KEY_DOES_NOT_EXITS, MYF(0), index_visibility_list[0]->name(),
             table->s->table_name.str);
    return true;
  }

  alter_info->create_list.swap(new_create_list);
  alter_info->key_list.clear();
  alter_info->key_list.resize(new_key_list.size());
  std::copy(new_key_list.begin(), new_key_list.end(),
            alter_info->key_list.begin());

  return false;
}

/**
  Prepare column and key definitions for CREATE TABLE in ALTER TABLE.

  This function transforms parse output of ALTER TABLE - lists of
  columns and keys to add, drop or modify into, essentially,
  CREATE TABLE definition - a list of columns and keys of the new
  table. While doing so, it also performs some (bug not all)
  semantic checks.

  This function is invoked when we know that we're going to
  perform ALTER TABLE via a temporary table -- i.e. in-place ALTER TABLE
  is not possible, perhaps because the ALTER statement contains
  instructions that require change in table data, not only in
  table definition or indexes.

  @param[in,out]  thd         thread handle. Used as a memory pool
                              and source of environment information.
  @param[in]      src_table   DD table object for the table to be
  created/altered. Will be nullptr for temporary tables.
  @param[in]      table       the source table, open and locked
                              Used as an interface to the storage engine
                              to acquire additional information about
                              the original table.
  @param[in,out]  create_info A blob with CREATE/ALTER TABLE
                              parameters
  @param[in,out]  alter_info  Another blob with ALTER/CREATE parameters.
                              Originally create_info was used only in
                              CREATE TABLE and alter_info only in ALTER TABLE.
                              But since ALTER might end-up doing CREATE,
                              this distinction is gone and we just carry
                              around two structures.
  @param[in,out]  alter_ctx   Runtime context for ALTER TABLE.

  @return
    Fills various create_info members based on information retrieved
    from the storage engine.
    Sets create_info->varchar if the table has a VARCHAR column.
    Prepares alter_info->create_list and alter_info->key_list with
    columns and keys of the new table.
  @retval true   error, out of memory or a semantical error in ALTER
                 TABLE instructions
  @retval false  success
*/

bool mysql_prepare_alter_table(THD *thd, const dd::Table *src_table,
                               TABLE *table, HA_CREATE_INFO *create_info,
                               Alter_info *alter_info,
                               Alter_table_ctx *alter_ctx) {
  uint db_create_options =
      (table->s->db_create_options & ~(HA_OPTION_PACK_RECORD));
  uint64_t used_fields = create_info->used_fields;

  DBUG_TRACE;

  // Prepare data in HA_CREATE_INFO shared by ALTER and upgrade code.
  create_info->init_create_options_from_share(table->s, used_fields);

  if (!(used_fields & HA_CREATE_USED_AUTO) && table->found_next_number_field) {
    /* Table has an autoincrement, copy value to new table */
    table->file->info(HA_STATUS_AUTO);
    create_info->auto_increment_value = table->file->stats.auto_increment_value;
  }

  if (prepare_fields_and_keys(thd, src_table, table, create_info, alter_info,
                              alter_ctx, used_fields))
    return true;

  table->file->update_create_info(create_info);

  /* Get the autoextend_size value for the old table if the user did not
  specify it on the command line */
  if (src_table && src_table->engine() == "InnoDB") {
    ulonglong autoextend_size{};

    dd::get_implicit_tablespace_options(thd, src_table, &autoextend_size);

    if (!create_info->m_implicit_tablespace_autoextend_size_change) {
      create_info->m_implicit_tablespace_autoextend_size = autoextend_size;
    }
  }

  /*
    NDB storage engine misuses handler::update_create_info() to implement
    special handling of table comments which are used to specify and store
    some NDB-specific table options. In the process it might report error.
    In order to detect and correctly handle such situation we need to call
    THD::is_error().
  */
  if (thd->is_error()) return true;

  if ((create_info->table_options &
       (HA_OPTION_PACK_KEYS | HA_OPTION_NO_PACK_KEYS)) ||
      (used_fields & HA_CREATE_USED_PACK_KEYS))
    db_create_options &= ~(HA_OPTION_PACK_KEYS | HA_OPTION_NO_PACK_KEYS);
  if ((create_info->table_options &
       (HA_OPTION_STATS_PERSISTENT | HA_OPTION_NO_STATS_PERSISTENT)) ||
      (used_fields & HA_CREATE_USED_STATS_PERSISTENT))
    db_create_options &=
        ~(HA_OPTION_STATS_PERSISTENT | HA_OPTION_NO_STATS_PERSISTENT);
  if (create_info->table_options & (HA_OPTION_CHECKSUM | HA_OPTION_NO_CHECKSUM))
    db_create_options &= ~(HA_OPTION_CHECKSUM | HA_OPTION_NO_CHECKSUM);
  if (create_info->table_options &
      (HA_OPTION_DELAY_KEY_WRITE | HA_OPTION_NO_DELAY_KEY_WRITE))
    db_create_options &=
        ~(HA_OPTION_DELAY_KEY_WRITE | HA_OPTION_NO_DELAY_KEY_WRITE);
  create_info->table_options |= db_create_options;

  if (table->s->tmp_table) create_info->options |= HA_LEX_CREATE_TMP_TABLE;

  return false;
}

/**
  Get Create_field object for newly created table by its name
  in the old version of table.

  @param alter_info  Alter_info describing newly created table.
  @param old_name    Name of field in old table.

  @returns Pointer to Create_field object, NULL - if field is
           not present in new version of table.
*/

static const Create_field *get_field_by_old_name(Alter_info *alter_info,
                                                 const char *old_name) {
  List_iterator_fast<Create_field> new_field_it(alter_info->create_list);
  const Create_field *new_field;

  while ((new_field = new_field_it++)) {
    if (new_field->field &&
        (my_strcasecmp(system_charset_info, new_field->field->field_name,
                       old_name) == 0))
      break;
  }
  return new_field;
}

/** Type of change to foreign key column, */

enum fk_column_change_type {
  FK_COLUMN_NO_CHANGE,
  FK_COLUMN_DATA_CHANGE,
  FK_COLUMN_RENAMED,
  FK_COLUMN_DROPPED
};

/**
  Check that ALTER TABLE's changes on columns of a foreign key are allowed.

  @tparam     F                 Function class which returns foreign key's
                                referenced or referencing (depending on
                                whether we check ALTER TABLE that changes
                                parent or child table) column name by its
                                index.

  @param[in]   thd              Thread context.
  @param[in]   alter_info       Alter_info describing changes to be done
                                by ALTER TABLE.
  @param[in]   fk_col_count     Number of columns in the foreign key.
  @param[in]   fk_columns       Object of F type bound to the specific foreign
                                key for which check is carried out.
  @param[out]  bad_column_name  Name of field on which ALTER TABLE tries to
                                do prohibited operation.

  @note This function takes into account value of @@foreign_key_checks
        setting.

  @retval FK_COLUMN_NO_CHANGE    No significant changes are to be done on
                                 foreign key columns.
  @retval FK_COLUMN_DATA_CHANGE  ALTER TABLE might result in value
                                 change in foreign key column (and
                                 foreign_key_checks is on).
  @retval FK_COLUMN_RENAMED      Foreign key column is renamed.
  @retval FK_COLUMN_DROPPED      Foreign key column is dropped.
*/

template <class F>
static fk_column_change_type fk_check_column_changes(
    THD *thd, Alter_info *alter_info, uint fk_col_count, const F &fk_columns,
    const char **bad_column_name) {
  *bad_column_name = nullptr;

  for (uint i = 0; i < fk_col_count; ++i) {
    const char *column = fk_columns(i);
    const Create_field *new_field = get_field_by_old_name(alter_info, column);

    if (new_field) {
      Field *old_field = new_field->field;

      if (my_strcasecmp(system_charset_info, old_field->field_name,
                        new_field->field_name)) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: remove_secondary_engine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: remove_secondary_engine not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: mysql_inplace_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: collect_and_lock_fk_tables_for_complex_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: collect_and_lock_fk_tables_for_complex_alter_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: adjust_foreign_key_names_for_old_table_version not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: adjust_foreign_key_names_for_old_table_version not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: adjust_check_constraint_names_for_old_table_version not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: adjust_check_constraint_names_for_old_table_version not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_table.cc
Function: lock_check_constraint_names_for_rename
bool lock_check_constraint_names_for_rename(THD *thd, const char *db,
                                            const char *table_name,
                                            const dd::Table *table_def,
                                            const char *target_db,
                                            const char *target_table_name) {
  DBUG_TRACE;
  MDL_request_list mdl_requests;
  size_t table_name_len = strlen(table_name);

  // Push lock requests for the check constraints defined on db.table_name.
  for (auto &cc : table_def->check_constraints()) {
    if (push_check_constraint_mdl_request_to_list(thd, db, cc->name().c_str(),
                                                  mdl_requests))
      return true;
  }

  // Push lock request for the check constraints in target table.
  for (auto &cc : table_def->check_constraints()) {
    const char *cc_name = cc->name().c_str();
    /*
      If check constraint name is a generated name in the source table then
      generate name with the target table to create mdl_request with it.
    */
    bool is_generated_name = dd::is_generated_check_constraint_name(
        table_name, table_name_len, cc->name().c_str(), cc->name().length());
    if (is_generated_name) {
      char *end;
      uint number =
          my_strtoull(cc->name().c_str() + table_name_len +
                          sizeof(dd::CHECK_CONSTRAINT_NAME_SUBSTR) - 1,
                      &end, 10);
      LEX_STRING name;
      if (generate_check_constraint_name(thd, target_table_name, number, name,
                                         true))
        return true;
      cc_name = name.str;
    }

    /*
      If check constraint name is generated or table moved different database
      then create mdl_request with target_db.cc_name.
    */
    if ((is_generated_name ||
         my_strcasecmp(table_alias_charset, db, target_db)) &&
        push_check_constraint_mdl_request_to_list(thd, target_db, cc_name,
                                                  mdl_requests))
      return true;
  }

  // Acquire locks on all the collected check constraint names.
  if (!mdl_requests.is_empty() &&
      thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  DEBUG_SYNC(thd, "after_acquiring_lock_on_check_constraints_for_rename");

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_tablespace.cc
Function: set_table_encryption_type not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_tablespace.cc
Function: set_table_encryption_type not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_tablespace.cc
Function: Sql_cmd_alter_tablespace_rename::execute
bool Sql_cmd_create_tablespace::execute(THD *thd) {
  Rollback_guard rollback_on_return{thd};

  if (check_global_access(thd, CREATE_TABLESPACE_ACL)) {
    return true;
  }

  handlerton *hton = nullptr;
  if (get_stmt_hton(thd, m_options->engine_name, m_tablespace_name.str,
                    "CREATE TABLESPACE", &hton)) {
    return true;
  }
  rollback_on_return.m_hton = hton;  // Allow rollback to call hton->post_ddl

  // Check the tablespace name and acquire an MDL X lock.
  if (validate_tablespace_name(CREATE_TABLESPACE, m_tablespace_name.str,
                               hton) ||
      lock_tablespace_names(thd, m_tablespace_name)) {
    return true;
  }

  /*
    Check if user has permission to create tablespace, if encryption type
    provided differ from global 'default_table_encryption' setting.
    We use 'default_table_encryption' value if encryption is not supplied
    by user.
  */
  bool encrypt_tablespace = false;
  dd::String_type encrypt_type;
  if (m_options->encryption.str) {
    encrypt_tablespace = dd::is_encrypted(m_options->encryption);
    encrypt_type = dd::make_string_type(m_options->encryption);
  } else {
    encrypt_tablespace = thd->variables.default_table_encryption;
    encrypt_type = encrypt_tablespace ? "Y" : "N";
  }

  if (opt_table_encryption_privilege_check &&
      encrypt_tablespace != thd->variables.default_table_encryption &&
      check_table_encryption_admin_access(thd)) {
    my_error(ER_CANNOT_SET_TABLESPACE_ENCRYPTION, MYF(0));
    return true;
  }

  auto &dc = *thd->dd_client();
  dd::cache::Dictionary_client::Auto_releaser releaser{&dc};

  // Check if same tablespace already exists.
  auto tsn = dd::make_string_type(m_tablespace_name);
  const dd::Tablespace *ts = nullptr;
  if (dc.acquire(tsn, &ts)) {
    return true;
  }

  if (ts != nullptr) {
    my_error(ER_TABLESPACE_EXISTS, MYF(0), tsn.c_str());
    return true;
  }

  // Create new tablespace.
  std::unique_ptr<dd::Tablespace> tablespace(
      dd::create_object<dd::Tablespace>());

  // Set tablespace name
  tablespace->set_name(tsn);

  // Engine type
  tablespace->set_engine(ha_resolve_storage_engine_name(hton));

  // - Store ENCRYPTION if SE supports it.
  // - Disallow encryption='y', if SE does not support it.
  if (hton->flags & HTON_SUPPORTS_TABLE_ENCRYPTION) {
    tablespace->options().set("encryption", encrypt_type);
  } else if (encrypt_tablespace) {
    my_error(ER_CHECK_NOT_IMPLEMENTED, MYF(0), "ENCRYPTION");
    return true;
  }

  // Validate tablespace comment string
  std::string invalid_sub_str;
  if (is_invalid_string(
          LEX_CSTRING{m_options->ts_comment.str, m_options->ts_comment.length},
          system_charset_info, invalid_sub_str)) {
    // Provide contextual information
    my_error(ER_COMMENT_CONTAINS_INVALID_STRING, MYF(0), "tablespace",
             m_tablespace_name.str, system_charset_info->csname,
             invalid_sub_str.c_str());
    return true;
  }

  size_t cl = m_options->ts_comment.length;
  if (validate_comment_length(
          thd, m_options->ts_comment.str, &cl, TABLESPACE_COMMENT_MAXLEN,
          ER_TOO_LONG_TABLESPACE_COMMENT, m_tablespace_name.str)) {
    return true;
  }

  tablespace->set_comment(dd::String_type{m_options->ts_comment.str, cl});

  if (m_options->engine_attribute.str)
    tablespace->set_engine_attribute(m_options->engine_attribute);

  LEX_STRING tblspc_datafile_name = {m_datafile_name.str,
                                     m_datafile_name.length};
  if (m_auto_generate_datafile_name) {
    char tmp_buf[40];
    String str(tmp_buf, sizeof(tmp_buf), &my_charset_bin);
    String *uuid = mysql_generate_uuid(&str);
    if (hton->get_tablespace_filename_ext)
      uuid->append(hton->get_tablespace_filename_ext());

    tblspc_datafile_name.str =
        thd->strmake(uuid->c_ptr_quick(), uuid->length());
    tblspc_datafile_name.length = uuid->length();
  }

  if (tblspc_datafile_name.length > FN_REFLEN) {
    my_error(ER_PATH_LENGTH, MYF(0), "DATAFILE");
    return true;
  }

  // Add datafile
  tablespace->add_file()->set_filename(
      dd::make_string_type(tblspc_datafile_name));

  tablespace->options().set("autoextend_size",
                            m_options->autoextend_size.has_value()
                                ? m_options->autoextend_size.value()
                                : 0);

  // Write changes to dictionary.
  if (dc.store(tablespace.get())) {
    return true;
  }

  const bool atomic_ddl = ddl_is_atomic(hton);
  /*
    Commit after creation of tablespace in the data-dictionary for
    storage engines which don't support atomic DDL. We do this to
    avoid being left with tablespace in SE but not in data-dictionary
    in case of crash. Indeed, in this case, we can end-up with tablespace
    present in the data-dictionary and not present in SE. But this can be
    easily fixed by doing DROP TABLESPACE.
  */
  if (intermediate_commit_unless_atomic_ddl(thd, hton)) {
    return true; /* purecov: inspected */
  }

  auto tsmp = get_mod_pair<dd::Tablespace>(&dc, m_tablespace_name.str);
  if (tsmp.first == nullptr) {
    my_error(ER_TABLESPACE_MISSING_WITH_NAME, MYF(0), m_tablespace_name.str);
    return true;
  }
  st_alter_tablespace ts_info{m_tablespace_name.str,
                              m_logfile_group_name.str,
                              CREATE_TABLESPACE,
                              TS_ALTER_TABLESPACE_TYPE_NOT_DEFINED,
                              tblspc_datafile_name.str,
                              nullptr,
                              *m_options};

  if (map_errors(
          hton->alter_tablespace(hton, thd, &ts_info, tsmp.first, tsmp.second),
          "CREATE TABLESPACE", &ts_info)) {
    if (!atomic_ddl) {
      /*
        For engines which don't support atomic DDL addition of tablespace to
        data-dictionary has been committed already so we need to revert it.
      */
      /* purecov: begin inspected */
      if (dc.drop(tsmp.second)) {
        return true;
      }

      Implicit_substatement_state_guard substatement_guard{thd};
      (void)trans_commit_stmt(thd);
      (void)trans_commit(thd);
      /* purecov: end */
    }
    return true;
  }  // if (map_errors

  /*
    Per convention only engines supporting atomic DDL are allowed to
    modify data-dictionary objects in handler::create() and other
    similar calls.
  */
  if (atomic_ddl && dc.update(tsmp.second)) {
    return true; /* purecov: inspected */
  }

  if (complete_stmt(thd, hton, [&]() { rollback_on_return.disable(); })) {
    return true;
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_trigger.cc
Function: Sql_cmd_ddl_trigger_common::open_and_lock_subj_table
    calling the method open_and_lock_subj_table().
  */
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  DEBUG_SYNC(thd, "after_acquiring_mdl_lock_on_trigger");

  return false;
}

/**
  Check that the user has TRIGGER privilege on the subject table.

  @param thd  current thread context
  @param table  table to check

  @return Operation status.
    @retval false Success
    @retval true  Failure
*/

bool Sql_cmd_ddl_trigger_common::check_trg_priv_on_subj_table(
    THD *thd, Table_ref *table) const {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_trigger.cc
Function: acquire_mdl_for_trigger
bool acquire_mdl_for_trigger(THD *thd, const char *db, const char *trg_name,
                             enum_mdl_type trigger_name_mdl_type) {
  DBUG_TRACE;
  assert(trg_name != nullptr);
  assert(trigger_name_mdl_type == MDL_EXCLUSIVE ||
         trigger_name_mdl_type == MDL_SHARED_HIGH_PRIO);

  MDL_key mdl_key;
  dd::Trigger::create_mdl_key(dd::String_type(db), dd::String_type(trg_name),
                              &mdl_key);

  MDL_request mdl_request;
  MDL_REQUEST_INIT_BY_KEY(&mdl_request, &mdl_key, trigger_name_mdl_type,
                          MDL_TRANSACTION);
  /*
    It isn't required to create MDL request for MDL_key::GLOBAL,
    MDL_key::SCHEMA since it was already done before while
    calling the method open_and_lock_subj_table().
  */
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  DEBUG_SYNC(thd, "after_acquiring_mdl_lock_on_trigger");

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_view.cc
Function: mysql_drop_view
bool mysql_drop_view(THD *thd, Table_ref *views) {
  bool some_views_deleted = false;

  DBUG_TRACE;

  /*
    We can't allow dropping of unlocked view under LOCK TABLES since this
    might lead to deadlock. But since we can't really lock view with LOCK
    TABLES we have to simply prohibit dropping of views.
  */
  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  if (lock_table_names(thd, views, nullptr, thd->variables.lock_wait_timeout,
                       0))
    return true;

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  Security_context *sctx = thd->security_context();

  // First check which views exist
  String non_existant_views;
  for (Table_ref *view = views; view; view = view->next_local) {
    /*
      Either, the entity does not exist, in which case we will
      issue a warning (if running with DROP ... IF EXISTS), or
      we will fail with an error later due to views not existing.

      Otherwise, the entity does indeed exist, and we must take
      different actions depending on the table type.
    */
    const dd::Abstract_table *at = nullptr;
    if (thd->dd_client()->acquire(view->db, view->table_name, &at)) return true;

    if (at == nullptr) {
      String tbl_name(view->db, system_charset_info);
      tbl_name.append('.');
      tbl_name.append(String(view->table_name, system_charset_info));

      if (thd->lex->drop_if_exists)
        push_warning_printf(thd, Sql_condition::SL_NOTE, ER_BAD_TABLE_ERROR,
                            ER_THD(thd, ER_BAD_TABLE_ERROR), tbl_name.c_ptr());
      else {
        if (non_existant_views.length()) non_existant_views.append(',');
        non_existant_views.append(tbl_name);
      }
    } else if (at->type() == dd::enum_table_type::BASE_TABLE) {
      my_error(ER_WRONG_OBJECT, MYF(0), view->db, view->table_name, "VIEW");
      return true;
    }
  }
  if (non_existant_views.length()) {
    my_error(ER_BAD_TABLE_ERROR, MYF(0), non_existant_views.c_ptr());
    return true;
  }

  // Then actually start dropping views.
  for (Table_ref *view = views; view; view = view->next_local) {
    DBUG_EXECUTE_IF("fail_while_acquiring_view_obj",
                    DBUG_SET("+d,fail_while_acquiring_dd_object"););
    /*
      Either, the entity does not exist, in which case we will
      issue a warning (if running with DROP ... IF EXISTS), or
      we will fail with an error later due to views not existing.

      Otherwise, the entity does indeed exist, and we must take
      different actions depending on the table type.
    */
    const dd::Abstract_table *at = nullptr;
    if (thd->dd_client()->acquire(view->db, view->table_name, &at)) {
      DBUG_EXECUTE_IF("fail_while_acquiring_view_obj",
                      DBUG_SET("-d,fail_while_acquiring_dd_object"););
      trans_rollback_stmt(thd);
      // Full rollback in case we have THD::transaction_rollback_request.
      trans_rollback(thd);
      return true;
    }

    if (at == nullptr) {
      assert(thd->lex->drop_if_exists);
      continue;  // Warning reported above.
    }

    assert(at->type() == dd::enum_table_type::SYSTEM_VIEW ||
           at->type() == dd::enum_table_type::USER_VIEW);

    const dd::View *vw = dynamic_cast<const dd::View *>(at);
    assert(vw);
    /*
      If definer has the SYSTEM_USER privilege then invoker can drop view
      only if latter also has same privilege.
    */
    Auth_id definer(vw->definer_user().c_str(), vw->definer_host().c_str());
    if (sctx->can_operate_with(definer, consts::system_user, true)) return true;

    Uncommitted_tables_guard uncommitted_tables(thd);
    /*
      For a view, there is a TABLE_SHARE object, but its
      ref_count never goes above 1. Remove it from the table
      definition cache, in case the view was cached.
    */
    uncommitted_tables.add_table(view);

    /*
      Remove view from DD tables and update metadata of other views
      referecing view being dropped.
    */
    if (thd->dd_client()->drop(at) ||
        update_referencing_views_metadata(thd, view, false,
                                          &uncommitted_tables)) {
      trans_rollback_stmt(thd);
      /*
        Full rollback in case we have THD::transaction_rollback_request
        and to synchronize DD state in cache and on disk (as statement
        rollback doesn't clear DD cache of modified uncommitted objects).
      */
      trans_rollback(thd);
      return true;
    }

    thd->add_to_binlog_accessed_dbs(view->db);
    some_views_deleted = true;
  }

  if (some_views_deleted) sp_cache_invalidate();

  if (write_bin_log(thd, false, thd->query().str, thd->query().length,
                    some_views_deleted) ||
      DBUG_EVALUATE_IF("simulate_drop_view_failure", true, false)) {
    DBUG_EXECUTE_IF("simulate_drop_view_failure",
                    my_error(ER_UNKNOWN_ERROR, MYF(0)););
    trans_rollback_stmt(thd);
    /*
      Full rollback in case we have THD::transaction_rollback_request
      and to synchronize DD state in cache and on disk (as statement
      rollback doesn't clear DD cache of modified uncommitted objects).
    */
    trans_rollback(thd);
    return true;
  }

  if (trans_commit_stmt(thd) || trans_commit(thd)) return true;

  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/xa.cc
Function: acquire_mandatory_metadata_locks
bool acquire_mandatory_metadata_locks(THD *thd, xid_t *detached_xid) {
  /*
    Acquire metadata lock which will ensure that XA ROLLBACK is blocked
    by active FLUSH TABLES WITH READ LOCK (and vice versa ROLLBACK in
    progress blocks FTWRL). This is to avoid binlog and redo entries
    while a backup is in progress.
  */
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    return true;
  }

  /*
    Like in the commit case a failure to store gtid is regarded
    as the resource manager issue.
  */

  if (MDL_context_backup_manager::instance().restore_backup(
          &thd->mdl_context, detached_xid->key(), detached_xid->key_length())) {
    return true;
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/xa/sql_xa_commit.cc
Function: Sql_cmd_xa_commit::process_attached_xa_commit
bool Sql_cmd_xa_commit::process_attached_xa_commit(THD *thd) const {
  DBUG_TRACE;
  bool res = false;
  bool gtid_error = false, need_clear_owned_gtid = false;
  auto xid_state = thd->get_transaction()->xid_state();

  if (xid_state->xa_trans_rolled_back()) {
    xa_trans_force_rollback(thd);
    res = thd->is_error();
  } else if (xid_state->has_state(XID_STATE::XA_IDLE) &&
             m_xa_opt == XA_ONE_PHASE) {
    int r = ha_commit_trans(thd, true);
    if ((res = r)) my_error(r == 1 ? ER_XA_RBROLLBACK : ER_XAER_RMERR, MYF(0));
  } else if (xid_state->has_state(XID_STATE::XA_PREPARED) &&
             m_xa_opt == XA_NONE) {
    MDL_request mdl_request;

    /*
      Acquire metadata lock which will ensure that COMMIT is blocked
      by active FLUSH TABLES WITH READ LOCK (and vice versa COMMIT in
      progress blocks FTWRL).

      We allow FLUSHer to COMMIT; we assume FLUSHer knows what it does.
    */
    MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "",
                     MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
    if (thd->mdl_context.acquire_lock(&mdl_request,
                                      thd->variables.lock_wait_timeout)) {
      /*
        We can't rollback an XA transaction on lock failure due to
        Innodb redo log and bin log update are involved in rollback.
        Return error to user for a retry.
      */
      my_error(ER_XA_RETRY, MYF(0));
      return true;
    }

    std::tie(gtid_error, need_clear_owned_gtid) = commit_owned_gtids(thd, true);
    if (gtid_error) {
      res = true;
      /*
        Failure to store gtid is regarded as a unilateral one of the
        resource manager therefore the transaction is to be rolled back.
        The specified error is the same as @c xa_trans_force_rollback.
        The prepared XA will be rolled back along and so will do Gtid state,
        see ha_rollback_trans().

        Todo/fixme: fix binlogging, "XA rollback" event could be missed out.
        Todo/fixme: as to XAER_RMERR, should not it be XA_RBROLLBACK?
                    Rationale: there's no consistency concern after rollback,
                    unlike what XAER_RMERR suggests.
      */
      ha_rollback_trans(thd, true);
      my_error(ER_XAER_RMERR, MYF(0));
    } else {
      CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP("before_commit_xa_trx");
      DEBUG_SYNC(thd, "trans_xa_commit_after_acquire_commit_lock");

      if (tc_log != nullptr)
        res = tc_log->commit(thd, /* all */ true);
      else
        res = ha_commit_low(thd, /* all */ true);

      DBUG_EXECUTE_IF("simulate_xa_commit_log_failure", { res = true; });

      if (res)
        my_error(ER_XAER_RMERR, MYF(0));  // todo/fixme: consider to rollback it
#ifdef HAVE_PSI_TRANSACTION_INTERFACE
      else {
        /*
          Since we don't call ha_commit_trans() for prepared transactions,
          we need to explicitly mark the transaction as committed.
        */
        MYSQL_COMMIT_TRANSACTION(thd->m_transaction_psi);
      }

      thd->m_transaction_psi = nullptr;
#endif
    }
  } else {
    my_error(ER_XAER_RMFAIL, MYF(0), xid_state->state_name());
    return true;
  }

  gtid_state_commit_or_rollback(thd, need_clear_owned_gtid, !gtid_error);
  cleanup_trans_state(thd);

  xid_state->set_state(XID_STATE::XA_NOTR);
  xid_state->unset_binlogged();
  trans_track_end_trx(thd);
  /* The transaction should be marked as complete in P_S. */
  assert(thd->m_transaction_psi == nullptr || res);
  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/events.cc
Function: Events::lock_schema_events
bool Events::lock_schema_events(THD *thd, const dd::Schema &schema) {
  DBUG_TRACE;

  std::vector<dd::String_type> event_names;
  if (thd->dd_client()->fetch_schema_component_names<dd::Event>(&schema,
                                                                &event_names))
    return true;

  /*
    If lower_case_table_names == 2 then schema names should be lower cased for
    proper hash key comparisons.
  */
  const char *schema_name = schema.name().c_str();
  char schema_name_buf[NAME_LEN + 1];
  if (lower_case_table_names == 2) {
    my_stpcpy(schema_name_buf, schema_name);
    my_casedn_str(system_charset_info, schema_name_buf);
    schema_name = schema_name_buf;
  }

  /*
    Ensure that we don't hold memory used by MDL_requests after locks have
    been acquired. This reduces memory usage in cases when we have DROP
    DATABASE that needs to drop lots of different objects.
  */
  MEM_ROOT mdl_reqs_root(key_memory_rm_db_mdl_reqs_root, MEM_ROOT_BLOCK_SIZE);

  MDL_request_list mdl_requests;
  for (std::vector<dd::String_type>::const_iterator name = event_names.begin();
       name != event_names.end(); ++name) {
    MDL_key mdl_key;
    dd::Event::create_mdl_key(dd::String_type(schema_name), *name, &mdl_key);

    // Add MDL_request for routine to mdl_requests list.
    MDL_request *mdl_request = new (&mdl_reqs_root) MDL_request;
    MDL_REQUEST_INIT_BY_KEY(mdl_request, &mdl_key, MDL_EXCLUSIVE,
                            MDL_TRANSACTION);
    mdl_requests.push_front(mdl_request);
  }

  return thd->mdl_context.acquire_locks(&mdl_requests,
                                        thd->variables.lock_wait_timeout);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/events.cc
Function: Events::show_create_event
bool Events::show_create_event(THD *thd, LEX_CSTRING dbname, LEX_CSTRING name) {
  Event_timed et;
  bool ret;

  DBUG_TRACE;
  DBUG_PRINT("enter", ("name: %s@%s", dbname.str, name.str));

  if (check_access(thd, EVENT_ACL, dbname.str, nullptr, nullptr, false, false))
    return true;

  // We must make sure the schema is released and unlocked in the right
  // order. Fail if we are unable to get a meta data lock on the schema
  // name.
  dd::Schema_MDL_locker mdl_handler(thd);
  if (mdl_handler.ensure_locked(dbname.str)) return true;

  // Grab MDL lock on object in shared mode.
  MDL_key mdl_key;
  dd::Event::create_mdl_key(dbname.str, name.str, &mdl_key);
  MDL_request event_mdl_request;
  MDL_REQUEST_INIT_BY_KEY(&event_mdl_request, &mdl_key, MDL_SHARED_HIGH_PRIO,
                          MDL_TRANSACTION);
  if (thd->mdl_context.acquire_lock(&event_mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  DEBUG_SYNC(thd, "after_acquiring_shared_lock_on_the_event");

  /*
    We would like to allow SHOW CREATE EVENT under LOCK TABLES and
    in pre-locked mode. mysql.event table is marked as a system table.
    This flag reduces the set of its participation scenarios in LOCK TABLES
    operation, and therefore an out-of-bound open of this table
    for reading like the one below (sic, only for reading) is
    more or less deadlock-free. For additional information about when a
    deadlock can occur please refer to the description of 'system table'
    flag.
  */
  ret = Event_db_repository::load_named_event(thd, dbname, name, &et);
  if (!ret) ret = send_show_create_event(thd, &et, thd->get_protocol());

  return ret;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_authorization.cc
Function: mysql_table_grant
    mysql_table_grant()
    thd                 Thread handle
    table_list          List of tables to give grant
    user_list           List of users to give grant
    columns             List of columns to give grant
    rights              Table level grant
    revoke_grant        Set to true if this is a REVOKE command

  RETURN
    false ok
    true  error
*/

int mysql_table_grant(THD *thd, Table_ref *table_list,
                      List<LEX_USER> &user_list, List<LEX_COLUMN> &columns,
                      ulong rights, bool revoke_grant) {
  ulong column_priv = 0;
  List_iterator<LEX_USER> str_list(user_list);
  LEX_USER *Str, *tmp_Str;
  Table_ref tables[ACL_TABLES::LAST_ENTRY];
  const char *db_name, *table_name;
  bool transactional_tables;
  acl_table::Pod_user_what_to_update what_to_set;
  bool result = false;
  int ret = 0;
  std::set<LEX_USER *> existing_users;

  DBUG_TRACE;

  assert(initialized);

  if (rights & ~TABLE_ACLS) {
    my_error(ER_ILLEGAL_GRANT_FOR_TABLE, MYF(0));
    return true;
  }

  if (!revoke_grant) {
    if (columns.elements) {
      class LEX_COLUMN *column;
      List_iterator<LEX_COLUMN> column_iter(columns);

      if (open_tables_for_query(thd, table_list, 0)) return true;

      if (table_list->is_view() &&
          !table_list->derived_query_expression()->is_prepared()) {
        Prepared_stmt_arena_holder ps_arena_holder(thd);

        if (table_list->resolve_derived(thd, false))
          return true; /* purecov: inspected */

        // Prepare a readonly (materialized) view for access to columns
        if (table_list->setup_materialized_derived(thd))
          return true; /* purecov: inspected */
      }
      while ((column = column_iter++)) {
        uint unused_field_idx = NO_FIELD_INDEX;
        Table_ref *dummy;
        Field *f = find_field_in_table_ref(
            thd, table_list, column->column.ptr(), column->column.length(),
            column->column.ptr(), nullptr, nullptr, nullptr,
            // check that we have the
            // to-be-granted privilege:
            column->rights, false, &unused_field_idx, false, &dummy);
        if (f == (Field *)nullptr) {
          my_error(ER_BAD_FIELD_ERROR, MYF(0), column->column.c_ptr(),
                   table_list->alias);
          return true;
        }
        if (f == (Field *)-1) return true;
        column_priv |= column->rights;
      }
      close_mysql_tables(thd);
    } else {
      if (!(rights & CREATE_ACL)) {
        // We need at least a shared MDL lock on the table to be allowed
        // to safely check its existence.
        MDL_request mdl_request;
        MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, table_list->db,
                         table_list->table_name, MDL_SHARED, MDL_TRANSACTION);
        if (thd->mdl_context.acquire_lock(&mdl_request,
                                          thd->variables.lock_wait_timeout))
          return true;

        bool exists;
        if (dd::table_exists(thd->dd_client(), table_list->db,
                             table_list->table_name, &exists))
          return true;

        if (!exists) {
          my_error(ER_NO_SUCH_TABLE, MYF(0), table_list->db, table_list->alias);
          return true;
        }
      }
      ulong missing_privilege = rights & ~table_list->grant.privilege;
      if (missing_privilege) {
        char command[128];
        get_privilege_desc(command, sizeof(command), missing_privilege);
        my_error(ER_TABLEACCESS_DENIED_ERROR, MYF(0), command,
                 thd->security_context()->priv_user().str,
                 thd->security_context()->host_or_ip().str, table_list->alias);
        return true;
      }
    }
  }

  /*
    This statement will be replicated as a statement, even when using
    row-based replication.  The binlog state will be cleared here to
    statement based replication and will be reset to the originals
    values when we are out of this function scope
  */
  Save_and_Restore_binlog_format_state binlog_format_state(thd);

  /*
    The lock api is depending on the thd->lex variable which needs to be
    re-initialized.
  */
  Query_tables_list backup;
  thd->lex->reset_n_backup_query_tables_list(&backup);
  /*
    Restore Query_tables_list::sql_command value, which was reset
    above, as the code writing query to the binary log assumes that
    this value corresponds to the statement being executed.
  */
  thd->lex->sql_command = backup.sql_command;

  { /* Critical Section */
    Acl_cache_lock_guard acl_cache_lock(thd, Acl_cache_lock_mode::WRITE_MODE);

    if ((ret = open_grant_tables(thd, tables, &transactional_tables))) {
      thd->lex->restore_backup_query_tables_list(&backup);
      return ret != 1; /* purecov: deadcode */
    }

    if (!acl_cache_lock.lock()) {
      commit_and_close_mysql_tables(thd);
      return true;
    }

    if (check_system_user_privilege(thd, user_list)) {
      commit_and_close_mysql_tables(thd);
      return true;
    }

    MEM_ROOT *old_root = thd->mem_root;
    thd->mem_root = &memex;
    grant_version++;

    while ((tmp_Str = str_list++)) {
      int error;
      GRANT_TABLE *grant_table;

      if (!(Str = get_current_user(thd, tmp_Str))) {
        result = true;
        continue;
      }

      Userhostpassword_list password_list;
      if (set_and_validate_user_attributes(
              thd, Str, what_to_set, false, false,
              &tables[ACL_TABLES::TABLE_PASSWORD_HISTORY], nullptr,
              revoke_grant ? "REVOKE" : "GRANT", password_list)) {
        result = true;
        continue;
      }

      ACL_USER *this_user = find_acl_user(Str->host.str, Str->user.str, true);
      if (this_user && (what_to_set.m_what & PLUGIN_ATTR))
        existing_users.insert(tmp_Str);

      db_name = table_list->get_db_name();
      thd->add_to_binlog_accessed_dbs(db_name);  // collecting db:s for MTS
      table_name = table_list->get_table_name();

      /* Find/create cached table grant */
      grant_table = table_hash_search(Str->host.str, NullS, db_name,
                                      Str->user.str, table_name, true);
      if (!grant_table) {
        if (revoke_grant) {
          result = report_missing_user_grant_message(
              thd, (this_user ? true : false), Str->user.str, Str->host.str,
              table_list->table_name, ER_NONEXISTING_TABLE_GRANT);
          continue;
        }

        DBUG_EXECUTE_IF("mysql_table_grant_out_of_memory",
                        DBUG_SET("+d,simulate_out_of_memory"););
        grant_table = new (thd->mem_root)
            GRANT_TABLE(Str->host.str, db_name, Str->user.str, table_name,
                        rights, column_priv);
        DBUG_EXECUTE_IF("mysql_table_grant_out_of_memory",
                        DBUG_SET("-d,simulate_out_of_memory"););

        if (!grant_table) {
          result = true; /* purecov: deadcode */
          break;         /* purecov: deadcode */
        }
        column_priv_hash->emplace(
            grant_table->hash_key,
            unique_ptr_destroy_only<GRANT_TABLE>(grant_table));
      }

      /* If revoke_grant, calculate the new column privilege for tables_priv */
      if (revoke_grant) {
        class LEX_COLUMN *column;
        List_iterator<LEX_COLUMN> column_iter(columns);
        GRANT_COLUMN *grant_column;

        /* Fix old grants */
        while ((column = column_iter++)) {
          grant_column = column_hash_search(grant_table, column->column.ptr(),
                                            column->column.length());
          if (grant_column) grant_column->rights &= ~(column->rights | rights);
        }
        /* scan through all columns to get new column grant */
        column_priv = 0;
        for (const auto &key_and_value : grant_table->hash_columns) {
          grant_column = key_and_value.second.get();
          grant_column->rights &= ~rights;  // Fix other columns
          column_priv |= grant_column->rights;
        }
      } else {
        column_priv |= grant_table->cols;
      }

      /* update table and columns */

      // Hold on to grant_table if it gets deleted, since we use it below.
      std::unique_ptr<GRANT_TABLE, Destroy_only<GRANT_TABLE>>
          deleted_grant_table;

      if ((error = replace_table_table(
               thd, grant_table, &deleted_grant_table,
               tables[ACL_TABLES::TABLE_TABLES_PRIV].table, *Str, db_name,
               table_name, rights, column_priv, revoke_grant))) {
        result = true;
        if (error < 0) break;

        continue;
      }

      if (tables[3].table) {
        if ((error = replace_column_table(
                 thd, grant_table, tables[ACL_TABLES::TABLE_COLUMNS_PRIV].table,
                 *Str, columns, db_name, table_name, rights, revoke_grant))) {
          result = true;
          if (error < 0) break;

          continue;
        }
      }
    }
    thd->mem_root = old_root;

    assert(!result || thd->is_error());

    result = log_and_commit_acl_ddl(thd, transactional_tables);

    {
      /* Notify audit plugin. We will ignore the return value. */
      LEX_USER *existing_user;
      for (LEX_USER *one_user : existing_users) {
        if ((existing_user = get_current_user(thd, one_user)))
          mysql_audit_notify(
              thd, AUDIT_EVENT(MYSQL_AUDIT_AUTHENTICATION_CREDENTIAL_CHANGE),
              thd->is_error(), existing_user->user.str, existing_user->host.str,
              existing_user->first_factor_auth_info.plugin.str,
              is_role_id(existing_user), nullptr, nullptr);
      }
    }
    get_global_acl_cache()->increase_version();
  } /* Critical section */

  if (!result) {
    my_ok(thd);
    /* Notify storage engines */
    acl_notify_htons(thd, revoke_grant ? SQLCOM_REVOKE : SQLCOM_GRANT,
                     &user_list);
  }

  thd->lex->restore_backup_query_tables_list(&backup);
  DEBUG_SYNC(thd, "after_table_grant_revoke");
  return result;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user_table.cc
Function: acl_tables_setup_for_write_and_acquire_mdl not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_user_table.cc
Function: acl_tables_setup_for_write_and_acquire_mdl not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: open_views_and_update_metadata not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: open_views_and_update_metadata not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: open_views_and_update_metadata not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: open_views_and_update_metadata not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/handler.cc
Function: ha_commit_trans
int ha_commit_trans(THD *thd, bool all, bool ignore_global_read_lock) {
  int error = 0;
  THD_STAGE_INFO(thd, stage_waiting_for_handler_commit);
  bool run_slave_post_commit = false;
  bool need_clear_owned_gtid = false;
  /*
    Save transaction owned gtid into table before transaction prepare
    if binlog is disabled, or binlog is enabled and log_replica_updates
    is disabled with slave SQL thread or slave worker thread.
  */
  std::tie(error, need_clear_owned_gtid) = commit_owned_gtids(thd, all);

  /*
    'all' means that this is either an explicit commit issued by
    user, or an implicit commit issued by a DDL.
  */
  Transaction_ctx *trn_ctx = thd->get_transaction();
  Transaction_ctx::enum_trx_scope trx_scope =
      all ? Transaction_ctx::SESSION : Transaction_ctx::STMT;

  /*
    "real" is a nick name for a transaction for which a commit will
    make persistent changes. E.g. a 'stmt' transaction inside a 'all'
    transaction is not 'real': even though it's possible to commit it,
    the changes are not durable as they might be rolled back if the
    enclosing 'all' transaction is rolled back.
  */
  bool is_real_trans = all || !trn_ctx->is_active(Transaction_ctx::SESSION);
#ifndef NDEBUG
  bool transaction_to_skip = false;
  DBUG_EXECUTE_IF("replica_crash_after_commit", {
    transaction_to_skip = is_already_logged_transaction(thd);
  });
#endif  // NDEBUG
  auto ha_info = trn_ctx->ha_trx_info(trx_scope);
  XID_STATE *xid_state = trn_ctx->xid_state();

  DBUG_TRACE;

  DBUG_PRINT("info", ("all=%d thd->in_sub_stmt=%d ha_info=%p is_real_trans=%d",
                      all, thd->in_sub_stmt, ha_info.head(), is_real_trans));
  /*
    We must not commit the normal transaction if a statement
    transaction is pending. Otherwise statement transaction
    flags will not get propagated to its normal transaction's
    counterpart.
  */
  assert(!trn_ctx->is_active(Transaction_ctx::STMT) || !all);

  DBUG_EXECUTE_IF("pre_commit_error", {
    error = true;
    my_error(ER_UNKNOWN_ERROR, MYF(0));
  });

  /*
    When atomic DDL is executed on the slave, we would like to
    to update slave applier state as part of DDL's transaction.
    Call Relay_log_info::pre_commit() hook to do this before DDL
    gets committed in the following block.
    Failed atomic DDL statements should've been marked as executed/committed
    during statement rollback, though some like GRANT may continue until
    this point.
    When applying a DDL statement on a slave and the statement is filtered
    out by a table filter, we report an error "ER_REPLICA_IGNORED_TABLE" to
    warn slave applier thread. We need to save the DDL statement's gtid
    into mysql.gtid_executed system table if the binary log is disabled
    on the slave and gtids are enabled.
  */
  if (is_real_trans && is_atomic_ddl_commit_on_slave(thd) &&
      (!thd->is_error() ||
       (thd->is_operating_gtid_table_implicitly &&
        thd->get_stmt_da()->mysql_errno() == ER_REPLICA_IGNORED_TABLE))) {
    run_slave_post_commit = true;
    error = error || thd->rli_slave->pre_commit();

    DBUG_EXECUTE_IF("rli_pre_commit_error", {
      error = true;
      my_error(ER_UNKNOWN_ERROR, MYF(0));
    });
    DBUG_EXECUTE_IF("replica_crash_before_commit", {
      /* This pre-commit crash aims solely at atomic DDL */
      DBUG_SUICIDE();
    });
  }

  if (thd->in_sub_stmt) {
    assert(0);
    /*
      Since we don't support nested statement transactions in 5.0,
      we can't commit or rollback stmt transactions while we are inside
      stored functions or triggers. So we simply do nothing now.
      TODO: This should be fixed in later ( >= 5.1) releases.
    */
    if (!all) return 0;
    /*
      We assume that all statements which commit or rollback main transaction
      are prohibited inside of stored functions or triggers. So they should
      bail out with error even before ha_commit_trans() call. To be 100% safe
      let us throw error in non-debug builds.
    */
    my_error(ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG, MYF(0));
    return 2;
  }

  MDL_request mdl_request;
  bool release_mdl = false;
  if (ha_info && !error) {
    uint rw_ha_count = 0;
    bool rw_trans;

    DBUG_EXECUTE_IF("crash_commit_before", DBUG_SUICIDE(););

    /*
     skip 2PC if the transaction is empty and it is not marked as started (which
     can happen when the slave's binlog is disabled)
    */
    if (ha_info->is_started())
      rw_ha_count = ha_check_and_coalesce_trx_read_only(thd, ha_info, all);
    trn_ctx->set_rw_ha_count(trx_scope, rw_ha_count);
    /* rw_trans is true when we in a transaction changing data */
    rw_trans = is_real_trans && (rw_ha_count > 0);

    DBUG_EXECUTE_IF("dbug.enabled_commit", {
      const char act[] = "now signal Reached wait_for signal.commit_continue";
      assert(!debug_sync_set_action(thd, STRING_WITH_LEN(act)));
    };);
    DEBUG_SYNC(thd, "ha_commit_trans_before_acquire_commit_lock");
    if (rw_trans && !ignore_global_read_lock) {
      /*
        Acquire a metadata lock which will ensure that COMMIT is blocked
        by an active FLUSH TABLES WITH READ LOCK (and vice versa:
        COMMIT in progress blocks FTWRL).

        We allow the owner of FTWRL to COMMIT; we assume that it knows
        what it does.
      */
      MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "",
                       MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);

      DBUG_PRINT("debug", ("Acquire MDL commit lock"));
      if (thd->mdl_context.acquire_lock(&mdl_request,
                                        thd->variables.lock_wait_timeout)) {
        ha_rollback_trans(thd, all);
        return 1;
      }
      release_mdl = true;

      DEBUG_SYNC(thd, "ha_commit_trans_after_acquire_commit_lock");
    }

    if (rw_trans && stmt_has_updated_trans_table(ha_info) &&
        check_readonly(thd, true)) {
      ha_rollback_trans(thd, all);
      error = 1;
      goto end;
    }

    if (!trn_ctx->no_2pc(trx_scope) && (trn_ctx->rw_ha_count(trx_scope) > 1))
      error = tc_log->prepare(thd, all);
  }
  /*
    The state of XA transaction is changed to Prepared, intermediately.
    It's going to change to the regular NOTR at the end.
    The fact of the Prepared state is of interest to binary logger.
  */
  if (!error && all && xid_state->has_state(XID_STATE::XA_IDLE)) {
    assert(
        thd->lex->sql_command == SQLCOM_XA_COMMIT &&
        static_cast<Sql_cmd_xa_commit *>(thd->lex->m_sql_cmd)->get_xa_opt() ==
            XA_ONE_PHASE);

    xid_state->set_state(XID_STATE::XA_PREPARED);
  }
  if (error || (error = tc_log->commit(thd, all))) {
    ha_rollback_trans(thd, all);
    error = 1;
    goto end;
  }
/*
        Mark multi-statement (any autocommit mode) or single-statement
        (autocommit=1) transaction as rolled back
*/
#ifdef HAVE_PSI_TRANSACTION_INTERFACE
  if (is_real_trans && thd->m_transaction_psi != nullptr) {
    MYSQL_COMMIT_TRANSACTION(thd->m_transaction_psi);
    thd->m_transaction_psi = nullptr;
  }
#endif
  DBUG_EXECUTE_IF("crash_commit_after",
                  if (!thd->is_operating_gtid_table_implicitly)
                      DBUG_SUICIDE(););
end:
  if (release_mdl && mdl_request.ticket) {
    /*
      We do not always immediately release transactional locks
      after ha_commit_trans() (see uses of ha_enable_transaction()),
      thus we release the commit blocker lock as soon as it's
      not needed.
    */
    DBUG_PRINT("debug", ("Releasing MDL commit lock"));
    thd->mdl_context.release_lock(mdl_request.ticket);
  }
  /* Free resources and perform other cleanup even for 'empty' transactions. */
  if (is_real_trans) {
    trn_ctx->cleanup();
    thd->tx_priority = 0;
  }

  if (need_clear_owned_gtid) {
    thd->server_status &= ~SERVER_STATUS_IN_TRANS;
    /*
      Release the owned GTID when binlog is disabled, or binlog is
      enabled and log_replica_updates is disabled with slave SQL thread
      or slave worker thread.
    */
    if (error)
      gtid_state->update_on_rollback(thd);
    else
      gtid_state->update_on_commit(thd);
  } else {
    if (has_commit_order_manager(thd) && error) {
      gtid_state->update_on_rollback(thd);
    }
  }
  if (run_slave_post_commit) {
    DBUG_EXECUTE_IF("replica_crash_after_commit", DBUG_SUICIDE(););

    thd->rli_slave->post_commit(error != 0);
    /*
      SERVER_STATUS_IN_TRANS may've been gained by pre_commit alone
      when the main DDL transaction is filtered out of execution.
      In such case the status has to be reset now.

      TODO: move/refactor this handling onto trans_commit/commit_implicit()
            the caller level.
    */
    thd->server_status &= ~SERVER_STATUS_IN_TRANS;
  } else {
    DBUG_EXECUTE_IF("replica_crash_after_commit", {
      if (thd->slave_thread && thd->rli_slave &&
          thd->rli_slave->current_event &&
          thd->rli_slave->current_event->get_type_code() ==
              binary_log::XID_EVENT &&
          !thd->is_operating_substatement_implicitly &&
          !thd->is_operating_gtid_table_implicitly && !transaction_to_skip)
        DBUG_SUICIDE();
    });
  }

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/handler.cc
Function: Temp_table_handle::open
  the handler specific open().

  Try O_RDONLY if cannot open as O_RDWR. Don't wait for locks if not
  HA_OPEN_WAIT_IF_LOCKED is set

  @param  [out] table_arg             Table structure.
  @param        name                  Full path of table name.
  @param        mode                  Open mode flags.
  @param        test_if_locked        ?
  @param        table_def             dd::Table object describing table
                                      being open. Can be NULL for temporary
                                      tables created by optimizer.

  @retval >0    Error.
  @retval  0    Success.
*/

int handler::ha_open(TABLE *table_arg, const char *name, int mode,
                     int test_if_locked, const dd::Table *table_def) {
  int error;
  DBUG_TRACE;
  DBUG_PRINT("enter",
             ("name: %s  db_type: %d  db_stat: %d  mode: %d  lock_test: %d",
              name, ht->db_type, table_arg->db_stat, mode, test_if_locked));

  table = table_arg;
  assert(table->s == table_share);
  assert(m_lock_type == F_UNLCK);
  DBUG_PRINT("info", ("old m_lock_type: %d F_UNLCK %d", m_lock_type, F_UNLCK));
  MEM_ROOT *mem_root = (test_if_locked & HA_OPEN_TMP_TABLE)
                           ? &table->s->mem_root
                           : &table->mem_root;
  assert(alloc_root_inited(mem_root));

  if ((error = open(name, mode, test_if_locked, table_def))) {
    if ((error == EACCES || error == EROFS) && mode == O_RDWR &&
        (table->db_stat & HA_TRY_READ_ONLY)) {
      table->db_stat |= HA_READ_ONLY;
      error = open(name, O_RDONLY, test_if_locked, table_def);
    }
  }
  if (error) {
    set_my_errno(error); /* Safeguard */
    DBUG_PRINT("error", ("error: %d  errno: %d", error, errno));
  } else {
    assert(m_psi == nullptr);
    assert(table_share != nullptr);
#ifdef HAVE_PSI_TABLE_INTERFACE
    PSI_table_share *share_psi = ha_table_share_psi(table_share);
    m_psi = PSI_TABLE_CALL(open_table)(share_psi, this);
#endif

    if (table->s->db_options_in_use & HA_OPTION_READ_ONLY_DATA)
      table->db_stat |= HA_READ_ONLY;
    (void)extra(HA_EXTRA_NO_READCHECK);  // Not needed in SQL

    /* ref is already allocated for us if we're called from handler::clone() */
    if (!ref && !(ref = (uchar *)mem_root->Alloc(ALIGN_SIZE(ref_length) * 2))) {
      ha_close();
      error = HA_ERR_OUT_OF_MEM;
    } else
      dup_ref = ref + ALIGN_SIZE(ref_length);

    // Give the table a defined starting cursor, even if it never actually seeks
    // or writes. This is important for things like weedout on const tables
    // (which is a nonsensical combination, but can happen).
    memset(ref, 0, ref_length);
    cached_table_flags = table_flags();
  }

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/histograms/histogram.cc
Function: histograms::lock_for_write
static bool lock_for_write(THD *thd, const MDL_key &mdl_key) {
  DBUG_EXECUTE_IF("histogram_fail_during_lock_for_write", { return true; });

  MDL_request mdl_request;
  MDL_REQUEST_INIT_BY_KEY(&mdl_request, &mdl_key, MDL_EXCLUSIVE,
                          MDL_TRANSACTION);

  // If locking fails, an error has already been flagged.
  return thd->mdl_context.acquire_lock(&mdl_request,
                                       thd->variables.lock_wait_timeout);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/histograms/histogram.cc
Function: histograms::drop_histograms
bool drop_histograms(THD *thd, Table_ref &table, const columns_set &columns,
                     bool needs_lock, results_map &results) {
  dd::cache::Dictionary_client *client = thd->dd_client();
  dd::cache::Dictionary_client::Auto_releaser auto_releaser(client);

  if (needs_lock) {
    /*
      At this point ANALYZE TABLE DROP HISTOGRAM is the only caller of this
      function that requires it to acquire lock on table and individual
      column statistics.

      Error out on temporary table for consistency with update histograms case.
    */
    if (table.table != nullptr && table.table->s->tmp_table != NO_TMP_TABLE) {
      results.emplace("", Message::TEMPORARY_TABLE);
      return true;
    }
    /*
      Acquire shared metadata lock on the table (or check that it is locked
      under LOCK TABLES) so this table and all column statistics for it are
      not dropped under our feet.
    */
    if (thd->locked_tables_mode) {
      if (!find_locked_table(thd->open_tables, table.db, table.table_name)) {
        my_error(ER_TABLE_NOT_LOCKED, MYF(0), table.table_name);
        return true;
      }
    } else {
      if (thd->mdl_context.acquire_lock(&table.mdl_request,
                                        thd->variables.lock_wait_timeout))
        return true;  // error is already reported.
    }
  } else {
    /*
      In this case we assume that caller has acquired exclusive metadata
      lock on table so there is no need to lock individual column statistics.
      It is also caller's responsibility to ensure that table is non-temporary.
    */
    assert(thd->mdl_context.owns_equal_or_stronger_lock(
        MDL_key::TABLE, table.db, table.table_name, MDL_EXCLUSIVE));
  }

  for (const std::string &column_name : columns) {
    if (needs_lock) {
      MDL_key mdl_key;
      dd::Column_statistics::create_mdl_key(
          {table.db, table.db_length},
          {table.table_name, table.table_name_length}, column_name.c_str(),
          &mdl_key);

      if (lock_for_write(thd, mdl_key))
        return true;  // error is already reported.
    }

    dd::String_type dd_name = dd::Column_statistics::create_name(
        {table.db, table.db_length},
        {table.table_name, table.table_name_length}, column_name.c_str());

    // Do we have an existing histogram for this column?
    const dd::Column_statistics *column_statistics = nullptr;
    if (client->acquire(dd_name, &column_statistics)) {
      // error is already reported.
      return true; /* purecov: deadcode */
    }

    if (column_statistics == nullptr) {
      results.emplace(column_name, Message::NO_HISTOGRAM_FOUND);
      continue;
    }

    if (client->drop(column_statistics)) {
      /* purecov: begin inspected */
      my_error(ER_UNABLE_TO_DROP_COLUMN_STATISTICS, MYF(0), column_name.c_str(),
               table.db, table.table_name);
      return true;
      /* purecov: end */
    }

    results.emplace(column_name, Message::HISTOGRAM_DELETED);
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/histograms/histogram.cc
Function: histograms::rename_histograms
bool rename_histograms(THD *thd, const char *old_schema_name,
                       const char *old_table_name, const char *new_schema_name,
                       const char *new_table_name, results_map &results) {
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, old_schema_name,
                   old_table_name, MDL_SHARED_READ_ONLY, MDL_TRANSACTION);

  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    // error has already been reported
    return true; /* purecov: deadcode */
  }

  /*
    We have to look up the new table since it already will be renamed at this
    point.
  */
  const dd::Table *table_def = nullptr;
  if (thd->dd_client()->acquire(new_schema_name, new_table_name, &table_def)) {
    // error has already been reported
    return false; /* purecov: deadcode */
  }

  if (table_def == nullptr) {
    assert(false); /* purecov: deadcode */
    return false;
  }

  for (const auto &col : table_def->columns()) {
    if (rename_histogram(thd, old_schema_name, old_table_name, new_schema_name,
                         new_table_name, col->name().c_str(), results))
      return true; /* purecov: deadcode */
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/lock.cc
Function: mysql_lock_tables
    mysql_lock_tables() will call
    table_handler->external_lock(thd,locktype) for each table.
    This is followed by a call to thr_multi_lock() for all tables.

  - For each statement, we will call table_handler->start_stmt(THD)
    to inform the table handler that we are using the table.

    The tables used can only be tables used in LOCK TABLES or a
    temporary table.

  - When statement is done, we will call ha_commit_stmt(thd);

  - When calling UNLOCK TABLES we call mysql_unlock_tables() for all
    tables used in LOCK TABLES

  If table_handler->external_lock(thd, locktype) fails, we call
  table_handler->external_lock(thd, F_UNLCK) for each table that was locked,
  excluding one that caused failure. That means handler must cleanup itself
  in case external_lock() fails.
*/

#include "sql/lock.h"

#include <fcntl.h>
#include <string.h>
#include <algorithm>
#include <atomic>

#include "lex_string.h"
#include "m_ctype.h"
#include "m_string.h"
#include "my_base.h"
#include "my_dbug.h"
#include "my_inttypes.h"
#include "my_sqlcommand.h"
#include "my_sys.h"
#include "mysql/service_mysql_alloc.h"
#include "mysql_com.h"
#include "mysqld_error.h"
#include "sql/auth/auth_common.h"  // SUPER_ACL
#include "sql/dd/types/event.h"
#include "sql/dd/types/function.h"
#include "sql/dd/types/procedure.h"
#include "sql/dd/types/resource_group.h"
#include "sql/debug_sync.h"
#include "sql/handler.h"
#include "sql/mysqld.h"  // opt_readonly
#include "sql/psi_memory_key.h"
#include "sql/session_tracker.h"
#include "sql/sql_base.h"  // MYSQL_LOCK_LOG_TABLE
#include "sql/sql_class.h"
#include "sql/sql_const.h"
#include "sql/sql_db.h"  // check_schema_readonly
#include "sql/sql_lex.h"
#include "sql/sql_parse.h"  // is_log_table_write_query
#include "sql/system_variables.h"
#include "sql/table.h"
#include "thr_lock.h"

/**
  @defgroup Locking Locking
  @{
*/

/* flags for get_lock_data */
#define GET_LOCK_UNLOCK 1
#define GET_LOCK_STORE_LOCKS 2

static MYSQL_LOCK *get_lock_data(THD *thd, TABLE **table_ptr, size_t count,
                                 uint flags);
static int lock_external(THD *thd, TABLE **table, uint count);
static int unlock_external(THD *thd, TABLE **table, uint count);
static void print_lock_error(int error, const char *);

/* Map the return value of thr_lock to an error from errmsg.txt */
static int thr_lock_errno_to_mysql[] = {0, ER_LOCK_ABORTED,
                                        ER_LOCK_WAIT_TIMEOUT, ER_LOCK_DEADLOCK};

/**
  Perform semantic checks for mysql_lock_tables.
  @param thd The current thread
  @param tables The tables to lock
  @param count The number of tables to lock
  @param flags Lock flags
  @return 0 if all the check passed, non zero if a check failed.
*/
static int lock_tables_check(THD *thd, TABLE **tables, size_t count,
                             uint flags) {
  uint system_count = 0, i = 0;
  /*
    Identifies if the executed sql command can updated either a log
    or rpl info table.
  */
  bool log_table_write_query = false;

  DBUG_TRACE;

  log_table_write_query = is_log_table_write_query(thd->lex->sql_command);

  for (i = 0; i < count; i++) {
    TABLE *t = tables[i];

    /* Protect against 'fake' partially initialized TABLE_SHARE */
    assert(t->s->table_category != TABLE_UNKNOWN_CATEGORY);

    /*
      Table I/O to performance schema tables is performed
      only internally by the server implementation.
      When a user is requesting a lock, the following
      constraints are enforced:
    */
    if (t->s->table_category == TABLE_CATEGORY_LOG &&
        (flags & MYSQL_LOCK_LOG_TABLE) == 0 && !log_table_write_query) {
      /*
        A user should not be able to prevent writes,
        or hold any type of lock in a session,
        since this would be a DOS attack.
      */
      if (t->reginfo.lock_type >= TL_READ_NO_INSERT ||
          thd->lex->sql_command == SQLCOM_LOCK_TABLES) {
        my_error(ER_CANT_LOCK_LOG_TABLE, MYF(0));
        return 1;
      }
    }

    if (t->reginfo.lock_type >= TL_WRITE_ALLOW_WRITE) {
      if (t->s->table_category == TABLE_CATEGORY_SYSTEM) system_count++;

      if (t->db_stat & HA_READ_ONLY) {
        my_error(ER_OPEN_AS_READONLY, MYF(0), t->alias);
        return 1;
      }
    }

    /*
      If we are going to lock a non-temporary table we must own metadata
      lock of appropriate type on it (I.e. for table to be locked for
      write we must own metadata lock of MDL_SHARED_WRITE or stronger
      type. For table to be locked for read we must own metadata lock
      of MDL_SHARED_READ or stronger type).
    */
    assert(t->s->tmp_table ||
           thd->mdl_context.owns_equal_or_stronger_lock(
               MDL_key::TABLE, t->s->db.str, t->s->table_name.str,
               t->reginfo.lock_type >= TL_WRITE_ALLOW_WRITE ? MDL_SHARED_WRITE
                                                            : MDL_SHARED_READ));

    /*
      Prevent modifications to base tables if READ_ONLY is activated.
      In any case, read only does not apply to temporary tables and
      performance_schema tables.
    */
    if (!(flags & MYSQL_LOCK_IGNORE_GLOBAL_READ_ONLY) && !t->s->tmp_table &&
        !is_perfschema_db(t->s->db.str, t->s->db.length)) {
      if (t->reginfo.lock_type >= TL_WRITE_ALLOW_WRITE &&
          (check_readonly(thd, true) ||
           check_schema_readonly(thd, t->s->db.str, t->s))) {
        return 1;
      }
    }
  }

  /*
    Locking of system tables is restricted:
    locking a mix of system and non-system tables in the same lock
    is prohibited, to prevent contention.
  */
  if ((system_count > 0) && (system_count < count)) {
    my_error(ER_WRONG_LOCK_OF_SYSTEM_TABLE, MYF(0));
    return 1;
  }

  return 0;
}

/**
  Reset lock type in lock data

  @param sql_lock Lock structures to reset.

  @note After a locking error we want to quit the locking of the table(s).
        The test case in the bug report for Bug #18544 has the following
        cases: 1. Locking error in lock_external() due to InnoDB timeout.
        2. Locking error in get_lock_data() due to missing write permission.
        3. Locking error in wait_if_global_read_lock() due to lock conflict.

  @note In all these cases we have already set the lock type into the lock
        data of the open table(s). If the table(s) are in the open table
        cache, they could be reused with the non-zero lock type set. This
        could lead to ignoring a different lock type with the next lock.

  @note Clear the lock type of all lock data. This ensures that the next
        lock request will set its lock type properly.
*/

static void reset_lock_data(MYSQL_LOCK *sql_lock) {
  THR_LOCK_DATA **ldata, **ldata_end;
  DBUG_TRACE;

  /* Clear the lock type of all lock data to avoid reusage. */
  for (ldata = sql_lock->locks, ldata_end = ldata + sql_lock->lock_count;
       ldata < ldata_end; ldata++) {
    /* Reset lock type. */
    (*ldata)->type = TL_UNLOCK;
  }
}

/**
  Scan array of tables for access types; update transaction tracker
  accordingly.

   @param thd          The current thread.
   @param tables       An array of pointers to the tables to lock.
   @param count        The number of tables to lock.
*/

static void track_table_access(THD *thd, TABLE **tables, size_t count) {
  TX_TRACKER_GET(tst);
  enum enum_tx_state s;

  while (count--) {
    TABLE *t = tables[count];

    if (t) {
      s = tst->calc_trx_state(t->reginfo.lock_type,
                              t->file->has_transactions());
      tst->add_trx_state(thd, s);
    }
  }
}

/**
  Reset lock type in lock data and free.

  @param mysql_lock Lock structures to reset.

*/

static void reset_lock_data_and_free(MYSQL_LOCK **mysql_lock) {
  reset_lock_data(*mysql_lock);
  my_free(*mysql_lock);
  *mysql_lock = nullptr;
}

/**
   Lock tables.

   @param thd          The current thread.
   @param tables       An array of pointers to the tables to lock.
   @param count        The number of tables to lock.
   @param flags        Options:
                 MYSQL_LOCK_IGNORE_GLOBAL_READ_ONLY Ignore SET GLOBAL READ_ONLY
                 MYSQL_LOCK_IGNORE_TIMEOUT          Use maximum timeout value.

   @retval  A lock structure pointer on success.
   @retval  NULL if an error or if wait on a lock was killed.
*/

MYSQL_LOCK *mysql_lock_tables(THD *thd, TABLE **tables, size_t count,
                              uint flags) {
  int rc;
  MYSQL_LOCK *sql_lock;
  ulong timeout = (flags & MYSQL_LOCK_IGNORE_TIMEOUT)
                      ? LONG_TIMEOUT
                      : thd->variables.lock_wait_timeout;

  DBUG_TRACE;

  if (lock_tables_check(thd, tables, count, flags)) return nullptr;

  if (!(sql_lock = get_lock_data(thd, tables, count, GET_LOCK_STORE_LOCKS)))
    return nullptr;

  if (!(thd->state_flags & Open_tables_state::SYSTEM_TABLES))
    THD_STAGE_INFO(thd, stage_system_lock);

  ulonglong lock_start_usec = my_micro_time();

  DBUG_PRINT("info", ("thd->proc_info %s", thd->proc_info()));
  if (sql_lock->table_count &&
      lock_external(thd, sql_lock->table, sql_lock->table_count)) {
    /* Clear the lock type of all lock data to avoid reusage. */
    reset_lock_data_and_free(&sql_lock);
    goto end;
  }

  /* Copy the lock data array. thr_multi_lock() reorders its contents. */
  memcpy(sql_lock->locks + sql_lock->lock_count, sql_lock->locks,
         sql_lock->lock_count * sizeof(*sql_lock->locks));
  /* Lock on the copied half of the lock data array. */
  rc = thr_lock_errno_to_mysql[(int)thr_multi_lock(
      sql_lock->locks + sql_lock->lock_count, sql_lock->lock_count,
      &thd->lock_info, timeout)];

  DBUG_EXECUTE_IF("mysql_lock_tables_kill_query",
                  thd->killed = THD::KILL_QUERY;);

  if (rc) {
    if (sql_lock->table_count)
      (void)unlock_external(thd, sql_lock->table, sql_lock->table_count);
    reset_lock_data_and_free(&sql_lock);
    if (!thd->killed) my_error(rc, MYF(0));
  }

end:
  if (!(flags & MYSQL_OPEN_IGNORE_KILLED) && thd->killed) {
    thd->send_kill_message();
    if (sql_lock) {
      mysql_unlock_tables(thd, sql_lock);
      sql_lock = nullptr;
    }
  }

  if (thd->variables.session_track_transaction_info > TX_TRACK_NONE)
    track_table_access(thd, tables, count);

  ulonglong lock_end_usec = my_micro_time();
  thd->inc_lock_usec(lock_end_usec - lock_start_usec);

  return sql_lock;
}

static int lock_external(THD *thd, TABLE **tables, uint count) {
  uint i;
  int lock_type, error;
  DBUG_TRACE;

  DBUG_PRINT("info", ("count %d", count));
  for (i = 1; i <= count; i++, tables++) {
    assert((*tables)->reginfo.lock_type >= TL_READ);
    lock_type = F_WRLCK; /* Lock exclusive */
    if ((*tables)->db_stat & HA_READ_ONLY ||
        ((*tables)->reginfo.lock_type >= TL_READ &&
         (*tables)->reginfo.lock_type <= TL_READ_NO_INSERT))
      lock_type = F_RDLCK;

    if ((error = (*tables)->file->ha_external_lock(thd, lock_type))) {
      print_lock_error(error, (*tables)->file->table_type());
      while (--i) {
        tables--;
        (*tables)->file->ha_external_lock(thd, F_UNLCK);
        (*tables)->current_lock = F_UNLCK;
      }
      return error;
    } else {
      (*tables)->db_stat &= ~HA_BLOCK_LOCK;
      (*tables)->current_lock = lock_type;
    }
  }
  return 0;
}

void mysql_unlock_tables(THD *thd, MYSQL_LOCK *sql_lock) {
  DBUG_TRACE;
  if (sql_lock->lock_count)
    thr_multi_unlock(sql_lock->locks, sql_lock->lock_count);
  if (sql_lock->table_count)
    (void)unlock_external(thd, sql_lock->table, sql_lock->table_count);
  my_free(sql_lock);
}

/**
  Unlock some of the tables locked by mysql_lock_tables.

  This will work even if get_lock_data fails (next unlock will free all)
*/

void mysql_unlock_some_tables(THD *thd, TABLE **table, uint count) {
  MYSQL_LOCK *sql_lock;
  if ((sql_lock = get_lock_data(thd, table, count, GET_LOCK_UNLOCK)))
    mysql_unlock_tables(thd, sql_lock);
}

/**
  unlock all tables locked for read.
*/

void mysql_unlock_read_tables(THD *thd, MYSQL_LOCK *sql_lock) {
  uint i, found;
  DBUG_TRACE;

  /* Move all write locks first */
  THR_LOCK_DATA **lock = sql_lock->locks;
  for (i = found = 0; i < sql_lock->lock_count; i++) {
    if (sql_lock->locks[i]->type > TL_WRITE_ALLOW_WRITE) {
      std::swap(*lock, sql_lock->locks[i]);
      lock++;
      found++;
    }
  }
  /* unlock the read locked tables */
  if (i != found) {
    thr_multi_unlock(lock, i - found);
    sql_lock->lock_count = found;
  }

  /* Then do the same for the external locks */
  /* Move all write locked tables first */
  TABLE **table = sql_lock->table;
  for (i = found = 0; i < sql_lock->table_count; i++) {
    assert(sql_lock->table[i]->lock_position == i);
    if ((uint)sql_lock->table[i]->reginfo.lock_type > TL_WRITE_ALLOW_WRITE) {
      std::swap(*table, sql_lock->table[i]);
      table++;
      found++;
    }
  }
  /* Unlock all read locked tables */
  if (i != found) {
    (void)unlock_external(thd, table, i - found);
    sql_lock->table_count = found;
  }
  /* Fix the lock positions in TABLE */
  table = sql_lock->table;
  found = 0;
  for (i = 0; i < sql_lock->table_count; i++) {
    TABLE *tbl = *table;
    tbl->lock_position = (uint)(table - sql_lock->table);
    tbl->lock_data_start = found;
    found += tbl->lock_count;
    table++;
  }
}

/**
  Try to find the table in the list of locked tables.
  In case of success, unlock the table and remove it from this list.
  If a table has more than one lock instance, removes them all.

  @param  thd             thread context
  @param  locked          list of locked tables
  @param  table           the table to unlock
*/

void mysql_lock_remove(THD *thd, MYSQL_LOCK *locked, TABLE *table) {
  if (locked) {
    uint i;
    for (i = 0; i < locked->table_count; i++) {
      if (locked->table[i] == table) {
        uint j, removed_locks, old_tables;
        TABLE *tbl;
        uint lock_data_end;

        assert(table->lock_position == i);

        /* Unlock the table. */
        mysql_unlock_some_tables(thd, &table, /* table count */ 1);

        /* Decrement table_count in advance, making below expressions easier */
        old_tables = --locked->table_count;

        /* The table has 'removed_locks' lock data elements in locked->locks */
        removed_locks = table->lock_count;

        /* Move down all table pointers above 'i'. */
        memmove(reinterpret_cast<char *>(locked->table + i),
                reinterpret_cast<char *>(locked->table + i + 1),
                (old_tables - i) * sizeof(TABLE *));

        lock_data_end = table->lock_data_start + table->lock_count;
        /* Move down all lock data pointers above 'table->lock_data_end-1' */
        memmove(
            reinterpret_cast<char *>(locked->locks + table->lock_data_start),
            reinterpret_cast<char *>(locked->locks + lock_data_end),
            (locked->lock_count - lock_data_end) * sizeof(THR_LOCK_DATA *));

        /*
          Fix moved table elements.
          lock_position is the index in the 'locked->table' array,
          it must be fixed by one.
          table->lock_data_start is pointer to the lock data for this table
          in the 'locked->locks' array, they must be fixed by 'removed_locks',
          the lock data count of the removed table.
        */
        for (j = i; j < old_tables; j++) {
          tbl = locked->table[j];
          tbl->lock_position--;
          assert(tbl->lock_position == j);
          tbl->lock_data_start -= removed_locks;
        }

        /* Finally adjust lock_count. */
        locked->lock_count -= removed_locks;
        break;
      }
    }
  }
}

/**
  Abort one thread / table combination.

  @param thd	   Thread handler
  @param table	   Table that should be removed from lock queue
*/

void mysql_lock_abort_for_thread(THD *thd, TABLE *table) {
  MYSQL_LOCK *locked;
  DBUG_TRACE;

  if ((locked = get_lock_data(thd, &table, 1, GET_LOCK_UNLOCK))) {
    for (uint i = 0; i < locked->lock_count; i++) {
      thr_abort_locks_for_thread(locked->locks[i]->lock,
                                 table->in_use->thread_id());
    }
    my_free(locked);
  }
}

MYSQL_LOCK *mysql_lock_merge(MYSQL_LOCK *a, MYSQL_LOCK *b) {
  MYSQL_LOCK *sql_lock;
  TABLE **table, **end_table;
  DBUG_TRACE;

  if (!(sql_lock = (MYSQL_LOCK *)my_malloc(
            key_memory_MYSQL_LOCK,
            sizeof(*sql_lock) +
                sizeof(THR_LOCK_DATA *) * (a->lock_count + b->lock_count) +
                sizeof(TABLE *) * (a->table_count + b->table_count),
            MYF(MY_WME))))
    return nullptr;  // Fatal error
  sql_lock->lock_count = a->lock_count + b->lock_count;
  sql_lock->table_count = a->table_count + b->table_count;
  sql_lock->locks = (THR_LOCK_DATA **)(sql_lock + 1);
  sql_lock->table = (TABLE **)(sql_lock->locks + sql_lock->lock_count);
  memcpy(sql_lock->locks, a->locks, a->lock_count * sizeof(*a->locks));
  memcpy(sql_lock->locks + a->lock_count, b->locks,
         b->lock_count * sizeof(*b->locks));
  memcpy(sql_lock->table, a->table, a->table_count * sizeof(*a->table));
  memcpy(sql_lock->table + a->table_count, b->table,
         b->table_count * sizeof(*b->table));

  /*
    Now adjust lock_position and lock_data_start for all objects that was
    moved in 'b' (as there is now all objects in 'a' before these).
  */
  for (table = sql_lock->table + a->table_count,
      end_table = table + b->table_count;
       table < end_table; table++) {
    (*table)->lock_position += a->table_count;
    (*table)->lock_data_start += a->lock_count;
  }

  /* Delete old, not needed locks */
  my_free(a);
  my_free(b);

  thr_lock_merge_status(sql_lock->locks, sql_lock->lock_count);
  return sql_lock;
}

/** Unlock a set of external. */

static int unlock_external(THD *thd, TABLE **table, uint count) {
  int error, error_code;
  DBUG_TRACE;

  error_code = 0;
  do {
    if ((*table)->current_lock != F_UNLCK) {
      (*table)->current_lock = F_UNLCK;
      if ((error = (*table)->file->ha_external_lock(thd, F_UNLCK))) {
        error_code = error;
        print_lock_error(error_code, (*table)->file->table_type());
      }
    }
    table++;
  } while (--count);
  return error_code;
}

/**
  Get lock structures from table structs and initialize locks.

  @param thd                Thread handler
  @param table_ptr          Pointer to tables that should be locks
  @param count              Number of tables
  @param flags              One of:
           - GET_LOCK_UNLOCK      : If we should send TL_IGNORE to store lock
           - GET_LOCK_STORE_LOCKS : Store lock info in TABLE
*/

static MYSQL_LOCK *get_lock_data(THD *thd, TABLE **table_ptr, size_t count,
                                 uint flags) {
  uint i, tables, lock_count;
  MYSQL_LOCK *sql_lock;
  THR_LOCK_DATA **locks, **locks_buf, **locks_start;
  TABLE **to, **table_buf;
  DBUG_TRACE;

  assert((flags == GET_LOCK_UNLOCK) || (flags == GET_LOCK_STORE_LOCKS));
  DBUG_PRINT("info", ("count %zu", count));

  for (i = tables = lock_count = 0; i < count; i++) {
    TABLE *t = table_ptr[i];

    if (t->s->tmp_table != NON_TRANSACTIONAL_TMP_TABLE) {
      tables += t->file->lock_count();
      lock_count++;
    }
  }

  /*
    Allocating twice the number of pointers for lock data for use in
    thr_mulit_lock(). This function reorders the lock data, but cannot
    update the table values. So the second part of the array is copied
    from the first part immediately before calling thr_multi_lock().
  */
  if (!(sql_lock = (MYSQL_LOCK *)my_malloc(
            key_memory_MYSQL_LOCK,
            sizeof(*sql_lock) + sizeof(THR_LOCK_DATA *) * tables * 2 +
                sizeof(table_ptr) * lock_count,
            MYF(0))))
    return nullptr;
  locks = locks_buf = sql_lock->locks = (THR_LOCK_DATA **)(sql_lock + 1);
  to = table_buf = sql_lock->table = (TABLE **)(locks + tables * 2);
  sql_lock->table_count = lock_count;

  for (i = 0; i < count; i++) {
    TABLE *table;
    enum thr_lock_type lock_type;
    THR_LOCK_DATA **org_locks = locks;

    if ((table = table_ptr[i])->s->tmp_table == NON_TRANSACTIONAL_TMP_TABLE)
      continue;
    lock_type = table->reginfo.lock_type;
    assert(lock_type != TL_WRITE_DEFAULT && lock_type != TL_READ_DEFAULT &&
           lock_type != TL_WRITE_CONCURRENT_DEFAULT);
    locks_start = locks;
    locks = table->file->store_lock(
        thd, locks, (flags & GET_LOCK_UNLOCK) ? TL_IGNORE : lock_type);
    if (flags & GET_LOCK_STORE_LOCKS) {
      table->lock_position = (uint)(to - table_buf);
      table->lock_data_start = (uint)(locks_start - locks_buf);
      table->lock_count = (uint)(locks - locks_start);
    }
    *to++ = table;
    if (locks) {
      for (; org_locks != locks; org_locks++) {
        (*org_locks)->debug_print_param = (void *)table;
        (*org_locks)->m_psi = table->file->m_psi;
      }
    }
  }
  /*
    We do not use 'tables', because there are cases where store_lock()
    returns less locks than lock_count() claimed. This can happen when
    a FLUSH TABLES tries to abort locks from a MERGE table of another
    thread. When that thread has just opened the table, but not yet
    attached its children, it cannot return the locks. lock_count()
    always returns the number of locks that an attached table has.
    This is done to avoid the reverse situation: If lock_count() would
    return 0 for a non-attached MERGE table, and that table becomes
    attached between the calls to lock_count() and store_lock(), then
    we would have allocated too little memory for the lock data. Now
    we may allocate too much, but better safe than memory overrun.
    And in the FLUSH case, the memory is released quickly anyway.
  */
  sql_lock->lock_count = locks - locks_buf;
  DBUG_PRINT("info", ("sql_lock->table_count %d sql_lock->lock_count %d",
                      sql_lock->table_count, sql_lock->lock_count));
  return sql_lock;
}

/**
  Obtain an exclusive metadata lock on a schema name.

  @param thd         Thread handle.
  @param db          The database name.

  This function cannot be called while holding LOCK_open mutex.
  To avoid deadlocks, we do not try to obtain exclusive metadata
  locks in LOCK TABLES mode, since in this mode there may be
  other metadata locks already taken by the current connection,
  and we must not wait for MDL locks while holding locks.

  @retval false  Success.
  @retval true   Failure: we're in LOCK TABLES mode, or out of memory,
                 or this connection was killed.
*/

bool lock_schema_name(THD *thd, const char *db) {
  MDL_request_list mdl_requests;
  MDL_request global_request;
  MDL_request mdl_request;
  MDL_request backup_lock_request;

  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  if (thd->global_read_lock.can_acquire_protection()) return true;
  MDL_REQUEST_INIT(&global_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  MDL_REQUEST_INIT(&mdl_request, MDL_key::SCHEMA, db, "", MDL_EXCLUSIVE,
                   MDL_TRANSACTION);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);

  mdl_requests.push_front(&mdl_request);
  mdl_requests.push_front(&global_request);
  mdl_requests.push_front(&backup_lock_request);

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(thd, true)) return true;

  /*
    We have an IX lock on the schema name, so we can check the read
    only option of the schema without worrying about a concurrent
    ALTER SCHEMA.
  */
  if (check_schema_readonly(thd, db)) return true;

  DEBUG_SYNC(thd, "after_wait_locked_schema_name");
  return false;
}

/**
  Acquire IX MDL lock each tablespace name from the given set.

  @param thd               - Thread invoking this function.
  @param tablespace_set    - Set of tablespace names to be lock.
  @param lock_wait_timeout - Lock timeout.
  @param mem_root          - Memory root on which MDL_request objects
                             can be allocated.

  @return true - On failure
  @return false - On Success.
*/
bool lock_tablespace_names(THD *thd, Tablespace_hash_set *tablespace_set,
                           ulong lock_wait_timeout, MEM_ROOT *mem_root) {
  // Stop if we have nothing to lock
  if (tablespace_set->empty()) return false;

  // Prepare MDL_request's for all tablespace names.
  MDL_request_list mdl_tablespace_requests;
  for (const std::string &tablespace : *tablespace_set) {
    assert(!tablespace.empty());

    MDL_request *tablespace_request = new (mem_root) MDL_request;
    if (tablespace_request == nullptr) return true;
    MDL_REQUEST_INIT(tablespace_request, MDL_key::TABLESPACE, "",
                     tablespace.c_str(), MDL_INTENTION_EXCLUSIVE,
                     MDL_TRANSACTION);
    mdl_tablespace_requests.push_front(tablespace_request);
  }

  // Finally, acquire IX MDL locks.
  if (thd->mdl_context.acquire_locks(&mdl_tablespace_requests,
                                     lock_wait_timeout))
    return true;

  DEBUG_SYNC(thd, "after_wait_locked_tablespace_name_for_table");

  return false;
}

/**
  Obtain an exclusive metadata lock on an object name.

  @param thd         Thread handle.
  @param mdl_type    Object type (currently functions, procedures
                     and events can be name-locked).
  @param db          The schema the object belongs to.
  @param name        Object name in the schema.

  This function cannot be called while holding LOCK_open_mutex.
  This invariant is enforced by asserts in MDL_context::acquire_locks.
  To avoid deadlocks, we do not try to obtain exclusive metadata
  locks in LOCK TABLES mode, since in this mode there may be
  other metadata locks already taken by the current connection,
  and we must not wait for MDL locks while holding locks.

  @note name is converted to lowercase before the lock is acquired
  since stored routine and event names are case insensitive.

  @retval false  Success.
  @retval true   Failure: we're in LOCK TABLES mode, or out of memory,
                 or this connection was killed.
*/

bool lock_object_name(THD *thd, MDL_key::enum_mdl_namespace mdl_type,
                      const char *db, const char *name) {
  MDL_request_list mdl_requests;
  MDL_request global_request;
  MDL_request schema_request;
  MDL_request mdl_request;
  MDL_request backup_lock_request;
  MDL_key mdl_key;

  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  assert(name);

  switch (mdl_type) {
    case MDL_key::FUNCTION:
      dd::Function::create_mdl_key(db, name, &mdl_key);
      break;
    case MDL_key::PROCEDURE:
      dd::Procedure::create_mdl_key(db, name, &mdl_key);
      break;
    case MDL_key::EVENT:
      dd::Event::create_mdl_key(db, name, &mdl_key);
      break;
    case MDL_key::RESOURCE_GROUPS:
      dd::Resource_group::create_mdl_key(name, &mdl_key);
      break;
    default:
      assert(false);
      return true;
  }

  DEBUG_SYNC(thd, "before_wait_locked_pname");

  if (thd->global_read_lock.can_acquire_protection()) return true;
  MDL_REQUEST_INIT(&global_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, db, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  MDL_REQUEST_INIT_BY_KEY(&mdl_request, &mdl_key, MDL_EXCLUSIVE,
                          MDL_TRANSACTION);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);

  mdl_requests.push_front(&mdl_request);
  mdl_requests.push_front(&schema_request);
  mdl_requests.push_front(&global_request);
  mdl_requests.push_front(&backup_lock_request);

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(thd, true)) return true;

  /*
    We have an IX lock on the schema name, so we can check the read
    only option of the schema without worrying about a concurrent
    ALTER SCHEMA.
  */
  if (check_schema_readonly(thd, db)) return true;

  DEBUG_SYNC(thd, "after_wait_locked_pname");
  return false;
}

static void print_lock_error(int error, const char *table) {
  DBUG_TRACE;

  switch (error) {
    case HA_ERR_LOCK_WAIT_TIMEOUT:
      my_error(ER_LOCK_WAIT_TIMEOUT, MYF(0), error);
      break;
    case HA_ERR_READ_ONLY_TRANSACTION:
      my_error(ER_READ_ONLY_TRANSACTION, MYF(0), error);
      break;
    case HA_ERR_LOCK_DEADLOCK:
      my_error(ER_LOCK_DEADLOCK, MYF(0), error);
      break;
    case HA_ERR_WRONG_COMMAND:
      my_error(ER_ILLEGAL_HA, MYF(0), table);
      break;
    default: {
      char errbuf[MYSYS_STRERROR_SIZE];
      my_error(ER_CANT_LOCK, MYF(0), error,
               my_strerror(errbuf, sizeof(errbuf), error));
    } break;
  }
}

std::atomic<int32> Global_read_lock::m_atomic_active_requests;

/****************************************************************************
  Handling of global read locks

  Global read lock is implemented using metadata lock infrastructure.

  Taking the global read lock is TWO steps (2nd step is optional; without
  it, COMMIT of existing transactions will be allowed):
  lock_global_read_lock() THEN make_global_read_lock_block_commit().

  How blocking of threads by global read lock is achieved: that's
  semi-automatic. We assume that any statement which should be blocked
  by global read lock will either open and acquires write-lock on tables
  or acquires metadata locks on objects it is going to modify. For any
  such statement global IX metadata lock is automatically acquired for
  its duration (in case of LOCK TABLES until end of LOCK TABLES mode).
  And lock_global_read_lock() simply acquires global S metadata lock
  and thus prohibits execution of statements which modify data (unless
  they modify only temporary tables). If deadlock happens it is detected
  by MDL subsystem and resolved in the standard fashion (by backing-off
  metadata locks acquired so far and restarting open tables process
  if possible).

  Why does FLUSH TABLES WITH READ LOCK need to block COMMIT: because it's used
  to read a non-moving SHOW MASTER STATUS, and a COMMIT writes to the binary
  log.

  Why getting the global read lock is two steps and not one. Because FLUSH
  TABLES WITH READ LOCK needs to insert one other step between the two:
  flushing tables. So the order is
  1) lock_global_read_lock() (prevents any new table write locks, i.e. stalls
  all new updates)
  2) close_cached_tables() (the FLUSH TABLES), which will wait for tables
  currently opened and being updated to close (so it's possible that there is
  a moment where all new updates of server are stalled *and* FLUSH TABLES WITH
  READ LOCK is, too).
  3) make_global_read_lock_block_commit().
  If we have merged 1) and 3) into 1), we would have had this deadlock:
  imagine thread 1 and 2, in non-autocommit mode, thread 3, and an InnoDB
  table t.
  thd1: SELECT * FROM t FOR UPDATE;
  thd2: UPDATE t SET a=1; # blocked by row-level locks of thd1
  thd3: FLUSH TABLES WITH READ LOCK; # blocked in close_cached_tables() by the
  table instance of thd2
  thd1: COMMIT; # blocked by thd3.
  thd1 blocks thd2 which blocks thd3 which blocks thd1: deadlock.

  Note that we need to support that one thread does
  FLUSH TABLES WITH READ LOCK; and then COMMIT;
  (that's what innobackup does, for some good reason).
  So in this exceptional case the COMMIT should not be blocked by the FLUSH
  TABLES WITH READ LOCK.

****************************************************************************/

/**
  Acquire protection against the global read lock.

  Acquire an intention exclusive lock to protect against others
  setting the global read lock. We follow the naming used by
  the backup lock help functions when naming this function.

  @param  thd                Thread context.
  @param  lock_wait_timeout  Time to wait for lock acquisition.

  @retval false   No error, meta data lock acquired.
  @retval true    Error, meta data lock not acquired.
*/

bool acquire_shared_global_read_lock(THD *thd,
                                     unsigned long lock_wait_timeout) {
  // If we cannot acquire protection against GRL, err out.
  if (thd->global_read_lock.can_acquire_protection()) return true;

  MDL_request grl_request;
  MDL_REQUEST_INIT(&grl_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);

  if (thd->mdl_context.acquire_lock(&grl_request, lock_wait_timeout))
    return true;

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(thd, true)) return true;

  return false;
}

/**
  Take global read lock, wait if there is protection against lock.

  If the global read lock is already taken by this thread, then nothing is done.

  See also "Handling of global read locks" above.

  @param thd     Reference to thread.

  @retval False  Success, global read lock set, commits are NOT blocked.
  @retval True   Failure, thread was killed.
*/

bool Global_read_lock::lock_global_read_lock(THD *thd) {
  DBUG_TRACE;

  if (!m_state) {
    MDL_request mdl_request;

    assert(!thd->mdl_context.owns_equal_or_stronger_lock(MDL_key::GLOBAL, "",
                                                         "", MDL_SHARED));
    MDL_REQUEST_INIT(&mdl_request, MDL_key::GLOBAL, "", "", MDL_SHARED,
                     MDL_EXPLICIT);

    /* Increment static variable first to signal innodb memcached server
       to release mdl locks held by it */
    Global_read_lock::m_atomic_active_requests++;
    if (thd->mdl_context.acquire_lock(&mdl_request,
                                      thd->variables.lock_wait_timeout)) {
      Global_read_lock::m_atomic_active_requests--;
      return true;
    }

    m_mdl_global_shared_lock = mdl_request.ticket;
    m_state = GRL_ACQUIRED;
  }
  /*
    We DON'T set global_read_lock_blocks_commit now, it will be set after
    tables are flushed (as the present function serves for FLUSH TABLES WITH
    READ LOCK only). Doing things in this order is necessary to avoid
    deadlocks (we must allow COMMIT until all tables are closed; we should not
    forbid it before, or we can have a 3-thread deadlock if 2 do SELECT FOR
    UPDATE and one does FLUSH TABLES WITH READ LOCK).
  */
  return false;
}

/**
  Unlock global read lock.

  Commits may or may not be blocked when this function is called.

  See also "Handling of global read locks" above.

  @param thd    Reference to thread.
*/

void Global_read_lock::unlock_global_read_lock(THD *thd) {
  DBUG_TRACE;

  assert(m_mdl_global_shared_lock && m_state);

  if (m_mdl_blocks_commits_lock) {
    thd->mdl_context.release_lock(m_mdl_blocks_commits_lock);
    m_mdl_blocks_commits_lock = nullptr;
  }
  thd->mdl_context.release_lock(m_mdl_global_shared_lock);
  Global_read_lock::m_atomic_active_requests--;
  m_mdl_global_shared_lock = nullptr;
  m_state = GRL_NONE;
}

/**
  Make global read lock also block commits.

  The scenario is:
   - This thread has the global read lock.
   - Global read lock blocking of commits is not set.

  See also "Handling of global read locks" above.

  @param thd     Reference to thread.

  @retval False  Success, global read lock set, commits are blocked.
  @retval True   Failure, thread was killed.
*/

bool Global_read_lock::make_global_read_lock_block_commit(THD *thd) {
  MDL_request mdl_request;
  DBUG_TRACE;
  /*
    If we didn't succeed lock_global_read_lock(), or if we already succeeded
    make_global_read_lock_block_commit(), do nothing.
  */
  if (m_state != GRL_ACQUIRED) return false;

  MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "", MDL_SHARED,
                   MDL_EXPLICIT);

  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  m_mdl_blocks_commits_lock = mdl_request.ticket;
  m_state = GRL_ACQUIRED_AND_BLOCKS_COMMIT;

  return false;
}

/**
  Set explicit duration for metadata locks which are used to implement GRL.

  @param thd     Reference to thread.
*/

void Global_read_lock::set_explicit_lock_duration(THD *thd) {
  if (m_mdl_global_shared_lock)
    thd->mdl_context.set_lock_duration(m_mdl_global_shared_lock, MDL_EXPLICIT);
  if (m_mdl_blocks_commits_lock)
    thd->mdl_context.set_lock_duration(m_mdl_blocks_commits_lock, MDL_EXPLICIT);
}

/**
  @} (end of group Locking)


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/lock.cc
Function: lock_schema_name
bool lock_schema_name(THD *thd, const char *db) {
  MDL_request_list mdl_requests;
  MDL_request global_request;
  MDL_request mdl_request;
  MDL_request backup_lock_request;

  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  if (thd->global_read_lock.can_acquire_protection()) return true;
  MDL_REQUEST_INIT(&global_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  MDL_REQUEST_INIT(&mdl_request, MDL_key::SCHEMA, db, "", MDL_EXCLUSIVE,
                   MDL_TRANSACTION);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);

  mdl_requests.push_front(&mdl_request);
  mdl_requests.push_front(&global_request);
  mdl_requests.push_front(&backup_lock_request);

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(thd, true)) return true;

  /*
    We have an IX lock on the schema name, so we can check the read
    only option of the schema without worrying about a concurrent
    ALTER SCHEMA.
  */
  if (check_schema_readonly(thd, db)) return true;

  DEBUG_SYNC(thd, "after_wait_locked_schema_name");
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/lock.cc
Function: lock_object_name
bool lock_object_name(THD *thd, MDL_key::enum_mdl_namespace mdl_type,
                      const char *db, const char *name) {
  MDL_request_list mdl_requests;
  MDL_request global_request;
  MDL_request schema_request;
  MDL_request mdl_request;
  MDL_request backup_lock_request;
  MDL_key mdl_key;

  if (thd->locked_tables_mode) {
    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
    return true;
  }

  assert(name);

  switch (mdl_type) {
    case MDL_key::FUNCTION:
      dd::Function::create_mdl_key(db, name, &mdl_key);
      break;
    case MDL_key::PROCEDURE:
      dd::Procedure::create_mdl_key(db, name, &mdl_key);
      break;
    case MDL_key::EVENT:
      dd::Event::create_mdl_key(db, name, &mdl_key);
      break;
    case MDL_key::RESOURCE_GROUPS:
      dd::Resource_group::create_mdl_key(name, &mdl_key);
      break;
    default:
      assert(false);
      return true;
  }

  DEBUG_SYNC(thd, "before_wait_locked_pname");

  if (thd->global_read_lock.can_acquire_protection()) return true;
  MDL_REQUEST_INIT(&global_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, db, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  MDL_REQUEST_INIT_BY_KEY(&mdl_request, &mdl_key, MDL_EXCLUSIVE,
                          MDL_TRANSACTION);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);

  mdl_requests.push_front(&mdl_request);
  mdl_requests.push_front(&schema_request);
  mdl_requests.push_front(&global_request);
  mdl_requests.push_front(&backup_lock_request);

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout))
    return true;

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(thd, true)) return true;

  /*
    We have an IX lock on the schema name, so we can check the read
    only option of the schema without worrying about a concurrent
    ALTER SCHEMA.
  */
  if (check_schema_readonly(thd, db)) return true;

  DEBUG_SYNC(thd, "after_wait_locked_pname");
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/lock.cc
Function: Global_read_lock::lock_global_read_lock
  lock_global_read_lock() THEN make_global_read_lock_block_commit().

  How blocking of threads by global read lock is achieved: that's
  semi-automatic. We assume that any statement which should be blocked
  by global read lock will either open and acquires write-lock on tables
  or acquires metadata locks on objects it is going to modify. For any
  such statement global IX metadata lock is automatically acquired for
  its duration (in case of LOCK TABLES until end of LOCK TABLES mode).
  And lock_global_read_lock() simply acquires global S metadata lock
  and thus prohibits execution of statements which modify data (unless
  they modify only temporary tables). If deadlock happens it is detected
  by MDL subsystem and resolved in the standard fashion (by backing-off
  metadata locks acquired so far and restarting open tables process
  if possible).

  Why does FLUSH TABLES WITH READ LOCK need to block COMMIT: because it's used
  to read a non-moving SHOW MASTER STATUS, and a COMMIT writes to the binary
  log.

  Why getting the global read lock is two steps and not one. Because FLUSH
  TABLES WITH READ LOCK needs to insert one other step between the two:
  flushing tables. So the order is
  1) lock_global_read_lock() (prevents any new table write locks, i.e. stalls
  all new updates)
  2) close_cached_tables() (the FLUSH TABLES), which will wait for tables
  currently opened and being updated to close (so it's possible that there is
  a moment where all new updates of server are stalled *and* FLUSH TABLES WITH
  READ LOCK is, too).
  3) make_global_read_lock_block_commit().
  If we have merged 1) and 3) into 1), we would have had this deadlock:
  imagine thread 1 and 2, in non-autocommit mode, thread 3, and an InnoDB
  table t.
  thd1: SELECT * FROM t FOR UPDATE;
  thd2: UPDATE t SET a=1; # blocked by row-level locks of thd1
  thd3: FLUSH TABLES WITH READ LOCK; # blocked in close_cached_tables() by the
  table instance of thd2
  thd1: COMMIT; # blocked by thd3.
  thd1 blocks thd2 which blocks thd3 which blocks thd1: deadlock.

  Note that we need to support that one thread does
  FLUSH TABLES WITH READ LOCK; and then COMMIT;
  (that's what innobackup does, for some good reason).
  So in this exceptional case the COMMIT should not be blocked by the FLUSH
  TABLES WITH READ LOCK.

****************************************************************************/

/**
  Acquire protection against the global read lock.

  Acquire an intention exclusive lock to protect against others
  setting the global read lock. We follow the naming used by
  the backup lock help functions when naming this function.

  @param  thd                Thread context.
  @param  lock_wait_timeout  Time to wait for lock acquisition.

  @retval false   No error, meta data lock acquired.
  @retval true    Error, meta data lock not acquired.
*/

bool acquire_shared_global_read_lock(THD *thd,
                                     unsigned long lock_wait_timeout) {
  // If we cannot acquire protection against GRL, err out.
  if (thd->global_read_lock.can_acquire_protection()) return true;

  MDL_request grl_request;
  MDL_REQUEST_INIT(&grl_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);

  if (thd->mdl_context.acquire_lock(&grl_request, lock_wait_timeout))
    return true;

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(thd, true)) return true;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/lock.cc
Function: Global_read_lock::make_global_read_lock_block_commit
bool Global_read_lock::make_global_read_lock_block_commit(THD *thd) {
  MDL_request mdl_request;
  DBUG_TRACE;
  /*
    If we didn't succeed lock_global_read_lock(), or if we already succeeded
    make_global_read_lock_block_commit(), do nothing.
  */
  if (m_state != GRL_ACQUIRED) return false;

  MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "", MDL_SHARED,
                   MDL_EXPLICIT);

  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  m_mdl_blocks_commits_lock = mdl_request.ticket;
  m_state = GRL_ACQUIRED_AND_BLOCKS_COMMIT;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_create_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_create_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_create_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_create_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_alter_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_alter_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_alter_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_alter_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_drop_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_drop_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_drop_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: resourcegroups::Sql_cmd_drop_resource_group::execute not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: lock_db_routines
bool lock_db_routines(THD *thd, const dd::Schema &schema) {
  DBUG_TRACE;

  // Vectors for names of stored functions and procedures of the schema.
  std::vector<dd::String_type> func_names, proc_names;

  // Fetch names of stored functions and procedures of the schema.
  if (thd->dd_client()->fetch_schema_component_names<dd::Function>(
          &schema, &func_names) ||
      thd->dd_client()->fetch_schema_component_names<dd::Procedure>(
          &schema, &proc_names))
    return true;

  /*
    If lower_case_table_names == 2 then schema names should be lower cased for
    proper hash key comparisons.
  */
  const char *schema_name = schema.name().c_str();
  char schema_name_buf[NAME_LEN + 1];
  if (lower_case_table_names == 2) {
    my_stpcpy(schema_name_buf, schema_name);
    my_casedn_str(system_charset_info, schema_name_buf);
    schema_name = schema_name_buf;
  }
  const dd::String_type schema_name_str(schema_name);

  /*
    Ensure that we don't hold memory used by MDL_requests after locks have
    been acquired. This reduces memory usage in cases when we have DROP
    DATABASE that needs to drop lots of different objects.
  */
  MEM_ROOT mdl_reqs_root(key_memory_rm_db_mdl_reqs_root, MEM_ROOT_BLOCK_SIZE);

  MDL_request_list mdl_requests;

  auto add_requests_for_names = [&](dd::Routine::enum_routine_type type,
                                    const std::vector<dd::String_type> &names) {
    for (const dd::String_type &name : names) {
      MDL_key mdl_key;
      dd::Routine::create_mdl_key(type, schema_name_str, name, &mdl_key);
      MDL_request *mdl_request = new (&mdl_reqs_root) MDL_request;
      MDL_REQUEST_INIT_BY_KEY(mdl_request, &mdl_key, MDL_EXCLUSIVE,
                              MDL_TRANSACTION);
      mdl_requests.push_front(mdl_request);
    }
  };

  add_requests_for_names(dd::Routine::RT_FUNCTION, func_names);
  add_requests_for_names(dd::Routine::RT_PROCEDURE, proc_names);

  return thd->mdl_context.acquire_locks(&mdl_requests,
                                        thd->variables.lock_wait_timeout);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: lock_routine_name not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: lock_routine_name not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_admin.cc
Function: Sql_cmd_analyze_table::handle_histogram_command
bool Sql_cmd_analyze_table::handle_histogram_command(THD *thd,
                                                     Table_ref *table) {
  // This should not be empty here.
  assert(!get_histogram_fields().empty());

  histograms::results_map results;
  bool res = false;
  if (table->next_local != nullptr) {
    /*
      Only one table can be specified for
      ANALYZE TABLE ... UPDATE/DROP HISTOGRAM
    */
    results.emplace("", histograms::Message::MULTIPLE_TABLES_SPECIFIED);
    res = true;
  } else {
    if (read_only || thd->tx_read_only) {
      // Do not try to update histograms when in read_only mode.
      results.emplace("", histograms::Message::SERVER_READ_ONLY);
      res = false;
    } else {
      Disable_autocommit_guard autocommit_guard(thd);

      /* Prevent intermediate commits to invoke commit order */
      Implicit_substatement_state_guard substatement_guard(
          thd, enum_implicit_substatement_guard_mode ::
                   DISABLE_GTID_AND_SPCO_IF_SPCO_ACTIVE);

      /*
        This statement will be written to the binary log even if it fails. But a
        failing statement calls trans_rollback_stmt which calls
        gtid_state->update_on_rollback, which releases GTID ownership. And GTID
        ownership must be held when the statement is being written to the binary
        log. Therefore, we set this flag before executing the statement. The
        flag tells gtid_state->update_on_rollback to skip releasing ownership.
      */
      Variable_scope_guard<bool> skip_gtid_rollback_guard(
          thd->skip_gtid_rollback);
      if ((thd->variables.gtid_next.type == ASSIGNED_GTID ||
           thd->variables.gtid_next.type == ANONYMOUS_GTID) &&
          (!thd->skip_gtid_rollback))
        thd->skip_gtid_rollback = true;

      dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
      switch (get_histogram_command()) {
        case Histogram_command::UPDATE_HISTOGRAM:
          res = acquire_shared_backup_lock(thd,
                                           thd->variables.lock_wait_timeout) ||
                update_histogram(thd, table, results);
          break;
        case Histogram_command::DROP_HISTOGRAM:
          res = acquire_shared_backup_lock(thd,
                                           thd->variables.lock_wait_timeout) ||
                drop_histogram(thd, table, results);

          if (res) {
            /*
              Do a rollback. We can end up here if query was interrupted
              during drop_histogram.
            */
            trans_rollback_stmt(thd);
            trans_rollback(thd);
          } else {
            res = trans_commit_stmt(thd) || trans_commit(thd);
          }
          break;
        case Histogram_command::NONE:
          assert(false); /* purecov: deadcode */
          break;
      }

      if (!res) {
        /*
          If a histogram was added, updated or removed, we will request the old
          TABLE_SHARE to go away from the table definition cache. This is
          because histogram data is cached in the TABLE_SHARE, so we want new
          transactions to fetch the updated data into the TABLE_SHARE before
          using it again.
        */
        tdc_remove_table(thd, TDC_RT_REMOVE_UNUSED, table->db,
                         table->table_name, false);
      }
    }
  }

  thd->clear_error();
  res = send_histogram_results(thd, results, table);
  thd->get_stmt_da()->reset_condition_info(thd);
  my_eof(thd);
  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_admin.cc
Function: mysql_admin_table
      on it that is left from mysql_admin_table()'s attempt to
      open it. Release the shared metadata lock before trying to
      acquire the exclusive lock to satisfy MDL asserts and avoid
      deadlocks.
    */
    thd->mdl_context.release_transactional_locks();
    /*
      Attempt to do full-blown table open in mysql_admin_table() has failed.
      Let us try to open at least a .FRM for this table.
    */
    MDL_REQUEST_INIT(&table_list->mdl_request, MDL_key::TABLE, table_list->db,
                     table_list->table_name, MDL_EXCLUSIVE, MDL_TRANSACTION);

    if (lock_table_names(thd, table_list, table_list->next_global,
                         thd->variables.lock_wait_timeout, 0))
      return 0;
    has_mdl_lock = true;

    key_length = get_table_def_key(table_list, &key);

    mysql_mutex_lock(&LOCK_open);
    share = get_table_share(thd, table_list->db, table_list->table_name, key,
                            key_length, false);
    mysql_mutex_unlock(&LOCK_open);
    if (share == nullptr) return 0;  // Can't open frm file

    if (open_table_from_share(thd, share, "", 0, 0, 0, &tmp_table, false,
                              nullptr)) {
      mysql_mutex_lock(&LOCK_open);
      release_table_share(share);
      mysql_mutex_unlock(&LOCK_open);
      return 0;  // Out of memory
    }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_admin.cc
Function: std::pair not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_admin.cc
Function: std::pair not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_admin.cc
Function: prepare_for_repair
    and when it was open in prepare_for_repair().
  */

  if (my_rename(from, tmp, MYF(MY_WME))) {
    error = send_check_errmsg(thd, table_list, "repair",
                              "Failed renaming data file");
    goto end;
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/sdi_utils.h
Function: dd::sdi_utils::mdl_lock not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/sdi_utils.h
Function: dd::sdi_utils::mdl_lock not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_alter_instance.cc
Function: Rotate_innodb_master_key::execute
bool Rotate_innodb_master_key::execute() {
  const LEX_CSTRING storage_engine = {STRING_WITH_LEN("innodb")};
  plugin_ref se_plugin;
  handlerton *hton;

  Security_context *sctx = m_thd->security_context();
  if (!sctx->check_access(SUPER_ACL) &&
      !sctx->has_global_grant(STRING_WITH_LEN("ENCRYPTION_KEY_ADMIN")).first) {
    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0),
             "SUPER or ENCRYPTION_KEY_ADMIN");
    return true;
  }

  if ((se_plugin = ha_resolve_by_name(m_thd, &storage_engine, false))) {
    hton = plugin_data<handlerton *>(se_plugin);
  } else {
    my_error(ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE, MYF(0));
    return true;
  }

  if (!hton->rotate_encryption_master_key) {
    my_error(ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE, MYF(0));
    return true;
  }

  /*
    Acquire protection against GRL and check for concurrent change of read_only
    value since encryption key rotation is not allowed in read_only/
    super_read_only mode.
  */
  if (acquire_shared_global_read_lock(m_thd,
                                      m_thd->variables.lock_wait_timeout)) {
    // MDL subsystem has to set an error in Diagnostics Area
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  /*
    Acquire shared backup lock to block concurrent backup. Acquire exclusive
    backup lock to block any concurrent DDL. The fact that we acquire both
    these locks also ensures that concurrent KEY rotation requests are blocked.
  */
  if (acquire_exclusive_backup_lock(m_thd, m_thd->variables.lock_wait_timeout,
                                    true) ||
      acquire_shared_backup_lock(m_thd, m_thd->variables.lock_wait_timeout)) {
    // MDL subsystem has to set an error in Diagnostics Area
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  if (hton->rotate_encryption_master_key()) {
    /* SE should have raised error */
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  if (log_to_binlog()) {
    /*
      Though we failed to write to binlog,
      there is no way we can undo this operation.
      So, convert error to a warning and let user
      know that something went wrong while trying
      to make entry in binlog.
    */
    m_thd->clear_error();
    m_thd->get_stmt_da()->reset_diagnostics_area();

    push_warning(m_thd, Sql_condition::SL_WARNING,
                 ER_MASTER_KEY_ROTATION_BINLOG_FAILED,
                 ER_THD(m_thd, ER_MASTER_KEY_ROTATION_BINLOG_FAILED));
  }

  my_ok(m_thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_alter_instance.cc
Function: Innodb_redo_log::execute
bool Rotate_innodb_master_key::execute() {
  const LEX_CSTRING storage_engine = {STRING_WITH_LEN("innodb")};
  plugin_ref se_plugin;
  handlerton *hton;

  Security_context *sctx = m_thd->security_context();
  if (!sctx->check_access(SUPER_ACL) &&
      !sctx->has_global_grant(STRING_WITH_LEN("ENCRYPTION_KEY_ADMIN")).first) {
    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0),
             "SUPER or ENCRYPTION_KEY_ADMIN");
    return true;
  }

  if ((se_plugin = ha_resolve_by_name(m_thd, &storage_engine, false))) {
    hton = plugin_data<handlerton *>(se_plugin);
  } else {
    my_error(ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE, MYF(0));
    return true;
  }

  if (!hton->rotate_encryption_master_key) {
    my_error(ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE, MYF(0));
    return true;
  }

  /*
    Acquire protection against GRL and check for concurrent change of read_only
    value since encryption key rotation is not allowed in read_only/
    super_read_only mode.
  */
  if (acquire_shared_global_read_lock(m_thd,
                                      m_thd->variables.lock_wait_timeout)) {
    // MDL subsystem has to set an error in Diagnostics Area
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  /*
    Acquire shared backup lock to block concurrent backup. Acquire exclusive
    backup lock to block any concurrent DDL. The fact that we acquire both
    these locks also ensures that concurrent KEY rotation requests are blocked.
  */
  if (acquire_exclusive_backup_lock(m_thd, m_thd->variables.lock_wait_timeout,
                                    true) ||
      acquire_shared_backup_lock(m_thd, m_thd->variables.lock_wait_timeout)) {
    // MDL subsystem has to set an error in Diagnostics Area
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  if (hton->rotate_encryption_master_key()) {
    /* SE should have raised error */
    assert(m_thd->get_stmt_da()->is_error());
    return true;
  }

  if (log_to_binlog()) {
    /*
      Though we failed to write to binlog,
      there is no way we can undo this operation.
      So, convert error to a warning and let user
      know that something went wrong while trying
      to make entry in binlog.
    */
    m_thd->clear_error();
    m_thd->get_stmt_da()->reset_diagnostics_area();

    push_warning(m_thd, Sql_condition::SL_WARNING,
                 ER_MASTER_KEY_ROTATION_BINLOG_FAILED,
                 ER_THD(m_thd, ER_MASTER_KEY_ROTATION_BINLOG_FAILED));
  }

  my_ok(m_thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_backup_lock.cc
Function: Sql_cmd_lock_instance::execute
bool Sql_cmd_lock_instance::execute(THD *thd) {
  if (check_backup_admin_privilege(thd) ||
      acquire_exclusive_backup_lock(
          thd,
          DBUG_EVALUATE_IF("stop_replica_dont_release_backup_lock", 5,
                           thd->variables.lock_wait_timeout),
          false))
    return true;

  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_srs.cc
Function: Sql_cmd_drop_srs::execute
bool Sql_cmd_create_srs::execute(THD *thd) {
  if (!(thd->security_context()->check_access(SUPER_ACL))) {
    my_error(ER_CMD_NEED_SUPER, MYF(0),
             m_or_replace ? "CREATE OR REPLACE SPATIAL REFERENCE SYSTEM"
                          : "CREATE SPATIAL REFERENCE SYSTEM");
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard dag(thd);
  dd::cache::Dictionary_client *dd_client = thd->dd_client();
  dd::cache::Dictionary_client::Auto_releaser releaser(dd_client);
  auto rollback_guard = create_scope_guard([thd]() {
    if (rollback(thd)) assert(false); /* purecov: deadcode */
  });
  Srs_fetcher fetcher(thd);
  dd::Spatial_reference_system *srs = nullptr;
  if (fetcher.acquire_for_modification(m_srid, &srs))
    return true; /* purecov: inspected */

  if (srs != nullptr) {
    if (m_if_not_exists) {
      push_warning_printf(thd, Sql_condition::SL_WARNING,
                          ER_WARN_SRS_ID_ALREADY_EXISTS,
                          ER_THD(thd, ER_WARN_SRS_ID_ALREADY_EXISTS), m_srid);
      my_ok(thd);
      return false;
    }
    if (!m_or_replace) {
      my_error(ER_SRS_ID_ALREADY_EXISTS, MYF(0), m_srid);
      return true;
    }

    if (fill_srs(srs)) return true;  // Error has already been flagged.

    const dd::Spatial_reference_system *old_srs = nullptr;
    if (fetcher.acquire(m_srid, &old_srs)) return true; /* purecov: inspected */
    assert(old_srs != nullptr);
    if (srs_is_used(m_srid, thd) && !old_srs->can_be_modified_to(*srs)) {
      my_error(ER_CANT_MODIFY_SRS_USED_BY_COLUMN, MYF(0), m_srid);
      return true;
    }

    warn_if_in_reserved_range(m_srid, thd);

    if (dd_client->update(srs)) return true;  // Error has already been flagged.

    rollback_guard.commit();
    if (commit(thd)) return true; /* purecov: inspected */
    my_ok(thd);
    return false;
  }

  std::unique_ptr<dd::Spatial_reference_system> new_srs(
      dd::create_object<dd::Spatial_reference_system>());
  static_cast<dd::Spatial_reference_system_impl *>(new_srs.get())
      ->set_id(m_srid);
  if (fill_srs(new_srs.get())) return true;  // Error has already been flagged.

  warn_if_in_reserved_range(m_srid, thd);

  if (thd->dd_client()->store(new_srs.get())) return true;

  rollback_guard.commit();
  if (commit(thd)) return true; /* purecov: inspected */
  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_srs.cc
Function: Sql_cmd_create_srs::execute
bool Sql_cmd_create_srs::execute(THD *thd) {
  if (!(thd->security_context()->check_access(SUPER_ACL))) {
    my_error(ER_CMD_NEED_SUPER, MYF(0),
             m_or_replace ? "CREATE OR REPLACE SPATIAL REFERENCE SYSTEM"
                          : "CREATE SPATIAL REFERENCE SYSTEM");
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard dag(thd);
  dd::cache::Dictionary_client *dd_client = thd->dd_client();
  dd::cache::Dictionary_client::Auto_releaser releaser(dd_client);
  auto rollback_guard = create_scope_guard([thd]() {
    if (rollback(thd)) assert(false); /* purecov: deadcode */
  });
  Srs_fetcher fetcher(thd);
  dd::Spatial_reference_system *srs = nullptr;
  if (fetcher.acquire_for_modification(m_srid, &srs))
    return true; /* purecov: inspected */

  if (srs != nullptr) {
    if (m_if_not_exists) {
      push_warning_printf(thd, Sql_condition::SL_WARNING,
                          ER_WARN_SRS_ID_ALREADY_EXISTS,
                          ER_THD(thd, ER_WARN_SRS_ID_ALREADY_EXISTS), m_srid);
      my_ok(thd);
      return false;
    }
    if (!m_or_replace) {
      my_error(ER_SRS_ID_ALREADY_EXISTS, MYF(0), m_srid);
      return true;
    }

    if (fill_srs(srs)) return true;  // Error has already been flagged.

    const dd::Spatial_reference_system *old_srs = nullptr;
    if (fetcher.acquire(m_srid, &old_srs)) return true; /* purecov: inspected */
    assert(old_srs != nullptr);
    if (srs_is_used(m_srid, thd) && !old_srs->can_be_modified_to(*srs)) {
      my_error(ER_CANT_MODIFY_SRS_USED_BY_COLUMN, MYF(0), m_srid);
      return true;
    }

    warn_if_in_reserved_range(m_srid, thd);

    if (dd_client->update(srs)) return true;  // Error has already been flagged.

    rollback_guard.commit();
    if (commit(thd)) return true; /* purecov: inspected */
    my_ok(thd);
    return false;
  }

  std::unique_ptr<dd::Spatial_reference_system> new_srs(
      dd::create_object<dd::Spatial_reference_system>());
  static_cast<dd::Spatial_reference_system_impl *>(new_srs.get())
      ->set_id(m_srid);
  if (fill_srs(new_srs.get())) return true;  // Error has already been flagged.

  warn_if_in_reserved_range(m_srid, thd);

  if (thd->dd_client()->store(new_srs.get())) return true;

  rollback_guard.commit();
  if (commit(thd)) return true; /* purecov: inspected */
  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_import.cc
Function: Sql_cmd_import_table::execute
bool Sql_cmd_import_table::execute(THD *thd) {
  assert(!m_sdi_patterns.empty());

  auto rbgrd = dd::sdi_utils::make_guard(thd, [&](THD *) {
    trans_rollback_stmt(thd);
    trans_rollback(thd);
  });

  // Need to keep this alive until after commit/rollback has been done
  dd::cache::Dictionary_client::Auto_releaser ar{thd->dd_client()};

  if (check_access(thd, FILE_ACL, nullptr, nullptr, nullptr, false, false)) {
    return true;
  }

  // Convert supplied sdi patterns into path,in_datadir pairs
  dd::sdi_file::Paths_type paths{key_memory_DD_import};
  paths.reserve(m_sdi_patterns.size());
  for (auto &pattern : m_sdi_patterns) {
    if (thd->charset() == files_charset_info) {
      if (dd::sdi_file::expand_pattern(thd, pattern, &paths)) {
        return true;
      }
      continue;
    }

    LEX_STRING converted;
    if (thd->convert_string(&converted, files_charset_info, pattern.str,
                            pattern.length, thd->charset())) {
      return true;
    }

    if (dd::sdi_file::expand_pattern(thd, converted, &paths)) {
      return true;
    }
  }

  Targets_type targets{key_memory_DD_import};

  auto tgtgrd = dd::sdi_utils::make_guard(thd, [&](THD *) {
    for (auto &tgt : targets) {
      tgt.rollback();
    }
  });

  for (auto &p : paths) {
    // Move the path string from paths to avoid copy - paths is now
    // empty shell
    targets.emplace_back(std::move(p.first), p.second);
  }
  // Have a valid list of sdi files to import

  dd::String_type shared_buffer;
  MDL_request_list mdl_requests;
  for (auto &t : targets) {
    if (t.load(thd, &shared_buffer)) {
      return true;
    }

    if (check_privileges(thd, t)) {
      return true;
    }

    mdl_requests.push_front(mdl_request(t, thd->mem_root));
  }
  // Table objects and their schema names have been loaded, privileges
  // checked and EXCLUSIVE MDL requests for the tables been added to
  // mdl_requests.

  std::vector<dd::String_type> schema_names;
  schema_names.reserve(targets.size());
  for (auto &t : targets) {
    schema_names.push_back(*t.can_schema_name());
  }
  std::sort(schema_names.begin(), schema_names.end());
  auto uniq_end = std::unique(schema_names.begin(), schema_names.end());
  schema_names.erase(uniq_end, schema_names.end());

  for (auto &sn : schema_names) {
    MDL_request *r = new (thd->mem_root) MDL_request;
    MDL_REQUEST_INIT(r, MDL_key::SCHEMA, sn.c_str(), "",
                     MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
    mdl_requests.push_front(r);
  }

  MDL_request *mdl_request_for_backup_lock = new (thd->mem_root) MDL_request;
  MDL_REQUEST_INIT(mdl_request_for_backup_lock, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  mdl_requests.push_front(mdl_request_for_backup_lock);

  // If we cannot acquire protection against GRL, err out.
  if (thd->global_read_lock.can_acquire_protection()) return true;

  MDL_request *mdl_request_for_grl = new (thd->mem_root) MDL_request;
  MDL_REQUEST_INIT(mdl_request_for_grl, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_TRANSACTION);
  mdl_requests.push_front(mdl_request_for_grl);

  if (thd->mdl_context.acquire_locks(&mdl_requests,
                                     thd->variables.lock_wait_timeout)) {
    return true;
  }

  // Now when we have protection against concurrent change of read_only
  // option we can safely re-check its value.
  if (check_readonly(thd, true)) return true;

  // Loop over schema names and check schema read only.
  for (auto &sn : schema_names) {
    if (check_schema_readonly(thd, sn.c_str())) return true;
  }

  // Now we have MDL on all schemas and tables involved

  for (auto &t : targets) {
    if (t.store_in_dd(thd)) {
      return true;
    }
  }

  rbgrd.release();
  tgtgrd.release();

  // Downgrade failing delete_file errors to warning, and
  // allow the transaction to commit.
  dd::sdi_utils::handle_errors(
      thd,
      [](uint, const char *, Sql_condition::enum_severity_level *level,
         const char *) {
        (*level) = Sql_condition::SL_WARNING;
        return false;
      },
      [&]() {
        for (auto &tgt : targets) {
          (void)tgt.commit();
        }
        return false;
      });

  my_ok(thd);
  return trans_commit_stmt(thd) || trans_commit(thd);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_insert.cc
Function: Query_result_create::send_eof
bool Query_result_insert::send_eof(THD *thd) {
  ulonglong id, row_count;
  bool changed [[maybe_unused]];
  THD::killed_state killed_status = thd->killed;
  DBUG_TRACE;
  DBUG_PRINT("enter",
             ("trans_table=%d, table_type='%s'",
              table->file->has_transactions(), table->file->table_type()));

  int error = 0;

  if (bulk_insert_started) {
    error = table->file->ha_end_bulk_insert();
    if (!error && thd->is_error()) error = thd->get_stmt_da()->mysql_errno();
    bulk_insert_started = false;
  }

  changed = (info.stats.copied || info.stats.deleted || info.stats.updated);

  /*
    INSERT ... SELECT on non-transactional table which changes any rows
    must be marked as unsafe to rollback.
  */
  assert(table->file->has_transactions() || !changed ||
         thd->get_transaction()->cannot_safely_rollback(Transaction_ctx::STMT));

  /*
    Write to binlog before committing transaction.  No statement will
    be written by the binlog_query() below in RBR mode.  All the
    events are in the transaction cache and will be written when
    ha_autocommit_or_rollback() is issued below.
  */
  if (mysql_bin_log.is_open() &&
      (!error ||
       thd->get_transaction()->cannot_safely_rollback(Transaction_ctx::STMT))) {
    int errcode = 0;
    if (!error)
      thd->clear_error();
    else
      errcode = query_error_code(thd, killed_status == THD::NOT_KILLED);
    if (thd->binlog_query(THD::ROW_QUERY_TYPE, thd->query().str,
                          thd->query().length, stmt_binlog_is_trans(), false,
                          false, errcode)) {
      table->file->ha_release_auto_increment();
      return true;
    }
  }
  table->file->ha_release_auto_increment();

  if (error) {
    myf error_flags = MYF(0);
    if (table->file->is_fatal_error(my_errno())) error_flags |= ME_FATALERROR;

    table->file->print_error(my_errno(), error_flags);
    return true;
  }

  /*
    For the strict_mode call of push_warning above results to set
    error in Diagnostic_area. Therefore it is necessary to check whether
    the error was set and leave method if it is true. If we didn't do
    so we would failed later when my_ok is called.
  */
  if (thd->get_stmt_da()->is_error()) return true;

  char buff[160];
  if (thd->lex->is_ignore())
    snprintf(buff, sizeof(buff), ER_THD(thd, ER_INSERT_INFO),
             (long)info.stats.records,
             (long)(info.stats.records - info.stats.copied),
             (long)thd->get_stmt_da()->current_statement_cond_count());
  else
    snprintf(buff, sizeof(buff), ER_THD(thd, ER_INSERT_INFO),
             (long)info.stats.records,
             (long)(info.stats.deleted + info.stats.updated),
             (long)thd->get_stmt_da()->current_statement_cond_count());
  row_count = info.stats.copied + info.stats.deleted +
              (thd->get_protocol()->has_client_capability(CLIENT_FOUND_ROWS)
                   ? info.stats.touched
                   : info.stats.updated);
  id = (thd->first_successful_insert_id_in_cur_stmt > 0)
           ? thd->first_successful_insert_id_in_cur_stmt
           : (thd->arg_of_last_insert_id_function
                  ? thd->first_successful_insert_id_in_prev_stmt
                  : (info.stats.copied ? autoinc_value_of_last_inserted_row
                                       : 0));
  my_ok(thd, row_count, id, buff);

  /*
    If we have inserted into a VIEW, and the base table has
    AUTO_INCREMENT column, but this column is not accessible through
    a view, then we should restore LAST_INSERT_ID to the value it
    had before the statement.
  */
  if (table_list != nullptr && table_list->is_view() &&
      !table_list->contain_auto_increment)
    thd->first_successful_insert_id_in_cur_stmt =
        thd->first_successful_insert_id_in_prev_stmt;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_insert.cc
Function: create_table_from_items not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_insert.cc
Function: create_table_from_items not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_partition_admin.cc
Function: Sql_cmd_alter_table_truncate_partition::execute
bool Sql_cmd_alter_table_exchange_partition::execute(THD *thd) {
  /* Moved from mysql_execute_command */
  LEX *lex = thd->lex;
  /* first Query_block (have special meaning for many of non-SELECTcommands) */
  Query_block *query_block = lex->query_block;
  /* first table of first Query_block */
  Table_ref *first_table = query_block->get_table_list();
  /*
    Code in mysql_alter_table() may modify its HA_CREATE_INFO argument,
    so we have to use a copy of this structure to make execution
    prepared statement- safe. A shallow copy is enough as no memory
    referenced from this structure will be modified.
    @todo move these into constructor...
  */
  HA_CREATE_INFO create_info(*lex->create_info);
  Alter_info alter_info(*m_alter_info, thd->mem_root);
  ulong priv_needed = ALTER_ACL | DROP_ACL | INSERT_ACL | CREATE_ACL;

  DBUG_TRACE;

  if (thd->is_fatal_error()) /* out of memory creating a copy of alter_info */
    return true;

  /* also check the table to be exchanged with the partition */
  assert(alter_info.flags & Alter_info::ALTER_EXCHANGE_PARTITION);

  if (check_access(thd, priv_needed, first_table->db,
                   &first_table->grant.privilege,
                   &first_table->grant.m_internal, false, false) ||
      check_access(thd, priv_needed, first_table->next_local->db,
                   &first_table->next_local->grant.privilege,
                   &first_table->next_local->grant.m_internal, false, false))
    return true;

  if (check_grant(thd, priv_needed, first_table, false, UINT_MAX, false))
    return true;

  /* Not allowed with EXCHANGE PARTITION */
  assert(!create_info.data_file_name && !create_info.index_file_name);

  thd->enable_slow_log = opt_log_slow_admin_statements;
  return exchange_partition(thd, first_table, &alter_info);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_truncate.cc
Function: Sql_cmd_truncate_table::lock_table
bool Sql_cmd_truncate_table::lock_table(THD *thd, Table_ref *table_ref) {
  TABLE *table = nullptr;
  DBUG_TRACE;

  /* Lock types are set in the parser. */
  assert(table_ref->lock_descriptor().type == TL_WRITE);
  /* The handler truncate protocol dictates a exclusive lock. */
  assert(table_ref->mdl_request.type == MDL_EXCLUSIVE);

  /*
    Before doing anything else, acquire a metadata lock on the table,
    or ensure we have one.  We don't use open_and_lock_tables()
    right away because we want to be able to truncate (and recreate)
    corrupted tables, those that we can't fully open.

    MySQL manual documents that TRUNCATE can be used to repair a
    damaged table, i.e. a table that can not be fully "opened".
    In particular MySQL manual says: As long as the table format
    file tbl_name.frm is valid, the table can be re-created as
    an empty table with TRUNCATE TABLE, even if the data or index
    files have become corrupted.
  */
  if (thd->locked_tables_mode) {
    if (!(table = find_table_for_mdl_upgrade(thd, table_ref->db,
                                             table_ref->table_name, false)))
      return true;

    if (acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
      return true;

    table_ref->mdl_request.ticket = table->mdl_ticket;

    /*
      A storage engine can recreate or truncate the table only if there
      are no references to it from anywhere, i.e. no cached TABLE in the
      table cache.
    */
    DEBUG_SYNC(thd, "upgrade_lock_for_truncate");
    /* To remove the table from the cache we need an exclusive lock. */
    if (wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN))
      return true;
    m_ticket_downgrade = table->mdl_ticket;
    /* Close if table is going to be recreated. */
    if (table->s->db_type()->flags & HTON_CAN_RECREATE)
      close_all_tables_for_name(thd, table->s, false, nullptr);

    return false;
  }  //  if (thd->locked_tables_mode)
  assert(!thd->locked_tables_mode);

  /* Acquire an exclusive lock. */
  assert(table_ref->next_global == nullptr);
  if (lock_table_names(thd, table_ref, nullptr,
                       thd->variables.lock_wait_timeout, 0))
    return true;

  /* Table is already locked exclusively. Remove cached instances. */
  tdc_remove_table(thd, TDC_RT_REMOVE_ALL, table_ref->db, table_ref->table_name,
                   false);

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/xa/sql_xa_prepare.cc
Function: Sql_cmd_xa_prepare::trans_xa_prepare
bool Sql_cmd_xa_prepare::trans_xa_prepare(THD *thd) {
  DBUG_TRACE;

  auto tran = thd->get_transaction();
  auto xid_state = tran->xid_state();

  DBUG_PRINT("xa", ("trans_xa_prepare: formatID:%ld",
                    xid_state->get_xid()->get_format_id()));

  if (!xid_state->has_state(XID_STATE::XA_IDLE)) {
    my_error(ER_XAER_RMFAIL, MYF(0), xid_state->state_name());
    return true;
  }

  if (!xid_state->has_same_xid(m_xid)) {
    my_error(ER_XAER_NOTA, MYF(0));
    return true;
  }

  if (thd->slave_thread && is_transaction_empty(thd)) {
    my_error(ER_XA_REPLICATION_FILTERS,
             MYF(0));  // Empty XA transactions not allowed
    return true;
  }

  auto rollback_xa_tran = create_scope_guard([&]() {
#ifdef HAVE_PSI_TRANSACTION_INTERFACE
    assert(thd->m_transaction_psi == nullptr);
#endif

    // Reset rm_error in case ha_xa_prepare() returned error,
    // so thd->transaction.xid structure gets reset
    // by THD::transaction::cleanup().
    xid_state->reset_error();
    cleanup_trans_state(thd);
    xid_state->reset();
    tran->cleanup();
    my_error(ER_XA_RBROLLBACK, MYF(0));
  });

  /*
    Acquire metadata lock which will ensure that XA PREPARE is blocked
    by active FLUSH TABLES WITH READ LOCK (and vice versa PREPARE in
    progress blocks FTWRL). This is to avoid binlog and redo entries
    while a backup is in progress.
  */
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  if (DBUG_EVALUATE_IF("xaprep_mdl_fail", true, false) ||
      thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    // Rollback the transaction if lock failed.
    ha_rollback_trans(thd, true);
    return true;
  }

  // For ha_xa_prepare() failure scenarios, transaction is already
  // rolled back by ha_xa_prepare().
  if (DBUG_EVALUATE_IF("xaprep_ha_xa_prepare_fail",
                       (ha_rollback_trans(thd, true), true), false) ||
      ::process_xa_prepare(thd))
    return true;

  xid_state->set_state(XID_STATE::XA_PREPARED);
  MYSQL_SET_TRANSACTION_XA_STATE(thd->m_transaction_psi,
                                 (int)xid_state->get_state());
  if (thd->rpl_thd_ctx.session_gtids_ctx().notify_after_xa_prepare(thd))
    LogErr(WARNING_LEVEL, ER_TRX_GTID_COLLECT_REJECT);

  // Use old style prepare unless xa_detach_on_prepare==true
  if (!is_xa_tran_detached_on_prepare(thd)) {
    rollback_xa_tran.commit();
    return thd->is_error();
  }
  // If xa_detach_on_prepare==true, detach the transaction and clean-up session
  if (::detach_xa_transaction(thd)) return true;
  rollback_xa_tran.commit();
  ::reset_xa_connection(thd);

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/xa/sql_xa_rollback.cc
Function: Sql_cmd_xa_rollback::process_attached_xa_rollback
bool Sql_cmd_xa_rollback::process_attached_xa_rollback(THD *thd) const {
  DBUG_TRACE;
  auto xid_state = thd->get_transaction()->xid_state();

  if (xid_state->has_state(XID_STATE::XA_NOTR) ||
      xid_state->has_state(XID_STATE::XA_ACTIVE)) {
    my_error(ER_XAER_RMFAIL, MYF(0), xid_state->state_name());
    return true;
  }

  /*
    Acquire metadata lock which will ensure that XA ROLLBACK is blocked
    by active FLUSH TABLES WITH READ LOCK (and vice versa ROLLBACK in
    progress blocks FTWRL). This is to avoid binlog and redo entries
    while a backup is in progress.
  */
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::COMMIT, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_STATEMENT);
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    /*
      We can't rollback an XA transaction on lock failure due to
      Innodb redo log and bin log update is involved in rollback.
      Return error to user for a retry.
    */
    my_error(ER_XAER_RMERR, MYF(0));
    return true;
  }

  bool gtid_error = false;
  bool need_clear_owned_gtid = false;
  std::tie(gtid_error, need_clear_owned_gtid) = commit_owned_gtids(thd, true);
  CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP("before_rollback_xa_trx");
  bool res = xa_trans_force_rollback(thd) || gtid_error;
  gtid_state_commit_or_rollback(thd, need_clear_owned_gtid, !gtid_error);
  // todo: report a bug in that the raised rm_error in this branch
  //       is masked unlike the detached rollback branch above.
  DBUG_EXECUTE_IF("simulate_xa_rm_error", {
    my_error(ER_XA_RBROLLBACK, MYF(0));
    res = true;
  });

  cleanup_trans_state(thd);

  xid_state->set_state(XID_STATE::XA_NOTR);
  xid_state->unset_binlogged();
  trans_track_end_trx(thd);
  /* The transaction should be marked as complete in P_S. */
  assert(thd->m_transaction_psi == nullptr);
  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/event_scheduler.cc
Function: pre_init_event_thread
    pre_init_event_thread()
      thd  The THD of the thread. Has to be allocated by the caller.

  NOTES
    1. The host of the thead is my_localhost
    2. thd->net is initted with NULL - no communication.
*/

void pre_init_event_thread(THD *thd) {
  DBUG_TRACE;
  thd->security_context()->set_master_access(0);
  thd->security_context()->cache_current_db_access(0);
  thd->security_context()->set_host_or_ip_ptr(my_localhost,
                                              strlen(my_localhost));
  thd->get_protocol_classic()->init_net(nullptr);
  thd->security_context()->set_user_ptr(STRING_WITH_LEN("event_scheduler"));
  thd->get_protocol_classic()->get_net()->read_timeout = replica_net_timeout;
  thd->slave_thread = false;
  thd->variables.option_bits |= OPTION_AUTO_IS_NULL;
  thd->get_protocol_classic()->set_client_capabilities(CLIENT_MULTI_RESULTS);

  thd->set_new_thread_id();

  /*
    Guarantees that we will see the thread in SHOW PROCESSLIST though its
    vio is NULL.
  */

  thd->set_proc_info("Initialized");
  thd->set_time();

  /* Do not use user-supplied timeout value for system threads. */
  thd->variables.lock_wait_timeout = LONG_TIMEOUT;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/event_scheduler.cc
Function: Event_worker_thread::run
    Event_worker_thread::run()
      thd    Thread context
      event  The Event_queue_element_for_exec object to be processed
*/

void Event_worker_thread::run(THD *thd, Event_queue_element_for_exec *event) {
  /* needs to be first for thread_stack */
  char my_stack;
  Event_job_data job_data;
  bool res;

  assert(thd->m_digest == nullptr);

  thd->thread_stack = &my_stack;  // remember where our stack is
  res = post_init_event_thread(thd);

  DBUG_TRACE;
  DBUG_PRINT("info", ("Time is %ld, THD: %p", (long)time(nullptr), thd));

  if (res) {
    delete event;
    deinit_event_thread(thd);
    return;
  }

  mysql_thread_set_secondary_engine(false);

#ifdef HAVE_PSI_STATEMENT_INTERFACE
  PSI_thread *thread = thd_get_psi(thd);
  if (thread != nullptr) {
    PSI_THREAD_CALL(detect_telemetry)(thread);
  }

  PSI_statement_locker_state state;
  assert(thd->m_statement_psi == nullptr);
  thd->m_statement_psi = MYSQL_START_STATEMENT(
      &state, event->get_psi_info()->m_key, event->dbname.str,
      event->dbname.length, thd->charset(), nullptr);
#endif
  /*
    We must make sure the schema is released and unlocked in the right
    order. Fail if we are unable to get a meta data lock on the schema
    name. Separate scope so that the Schema_MDL_locker dtor is run before
    thd is deleted.
  */
  {
    dd::Schema_MDL_locker mdl_handler(thd);
    if (mdl_handler.ensure_locked(event->dbname.str)) goto end;

    MDL_key mdl_key;
    dd::Event::create_mdl_key(event->dbname.str, event->name.str, &mdl_key);

    MDL_request event_mdl_request;
    MDL_REQUEST_INIT_BY_KEY(&event_mdl_request, &mdl_key, MDL_SHARED,
                            MDL_EXPLICIT);
    if (thd->mdl_context.acquire_lock(&event_mdl_request,
                                      thd->variables.lock_wait_timeout)) {
      DBUG_PRINT("error", ("Got error in getting MDL locks"));
      goto end;
    }

    if ((res = Event_db_repository::load_named_event(thd, event->dbname,
                                                     event->name, &job_data))) {
      DBUG_PRINT("error", ("Got error from load_named_event"));
      thd->mdl_context.release_lock(event_mdl_request.ticket);
      goto end;
    }
    thd->mdl_context.release_lock(event_mdl_request.ticket);
  }  // End scope so that schema metadata lock is released.

  thd->enable_slow_log = true;

  res = job_data.execute(thd, event->dropped);

  print_warnings(thd, &job_data);

  if (res)
    LogErr(INFORMATION_LEVEL, ER_EVENT_EXECUTION_FAILED, job_data.m_definer.str,
           job_data.m_schema_name.str, job_data.m_event_name.str);

end:
#ifdef HAVE_PSI_STATEMENT_INTERFACE
  MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());
  thd->m_statement_psi = nullptr;
#endif

  assert(thd->m_digest == nullptr);

  DBUG_PRINT("info",
             ("Done with Event %s.%s", event->dbname.str, event->name.str));

  delete event;
  deinit_event_thread(thd);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/server_component/mysql_system_variable_update_imp.cc
Function: prepare_thread_and_validate not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/server_component/mysql_system_variable_update_imp.cc
Function: prepare_thread_and_validate not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_locks_acquire_exclusive
bool Ndb_dd_client::mdl_locks_acquire_exclusive(const char *schema_name,
                                                const char *table_name,
                                                bool custom_lock_wait,
                                                ulong lock_wait_timeout) {
  MDL_request_list mdl_requests;
  MDL_request schema_request;
  MDL_request mdl_request;
  MDL_request backup_lock_request;
  MDL_request grl_request;

  // If we cannot acquire protection against GRL, err out early.
  if (m_thd->global_read_lock.can_acquire_protection()) return false;

  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, schema_name, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, schema_name, table_name,
                   MDL_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&grl_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);

  mdl_requests.push_front(&schema_request);
  mdl_requests.push_front(&mdl_request);
  mdl_requests.push_front(&backup_lock_request);
  mdl_requests.push_front(&grl_request);

  if (!custom_lock_wait) {
    lock_wait_timeout = m_thd->variables.lock_wait_timeout;
  }

  if (!mdl_locks_acquire(mdl_requests, lock_wait_timeout)) {
    return false;
  }

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(m_thd, true)) return false;

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_table
bool Ndb_dd_client::mdl_lock_table(const char *schema_name,
                                   const char *table_name) {
  MDL_request_list mdl_requests;
  MDL_request schema_request;
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, schema_name, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, schema_name, table_name,
                   MDL_SHARED, MDL_EXPLICIT);

  mdl_requests.push_front(&schema_request);
  mdl_requests.push_front(&mdl_request);

  if (!mdl_locks_acquire(mdl_requests, m_thd->variables.lock_wait_timeout)) {
    return false;
  }

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_schema_exclusive
bool Ndb_dd_client::mdl_lock_schema_exclusive(const char *schema_name,
                                              bool custom_lock_wait,
                                              ulong lock_wait_timeout) {
  MDL_request_list mdl_requests;
  MDL_request schema_request;
  MDL_request backup_lock_request;
  MDL_request grl_request;

  // If protection against GRL can't be acquired, err out early.
  if (m_thd->global_read_lock.can_acquire_protection()) {
    return false;
  }

  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, schema_name, "",
                   MDL_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&grl_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);

  mdl_requests.push_front(&schema_request);
  mdl_requests.push_front(&backup_lock_request);
  mdl_requests.push_front(&grl_request);

  if (!custom_lock_wait) {
    lock_wait_timeout = m_thd->variables.lock_wait_timeout;
  }

  if (!mdl_locks_acquire(mdl_requests, lock_wait_timeout)) {
    return false;
  }

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_schema
bool Ndb_dd_client::mdl_lock_schema(const char *schema_name) {
  MDL_request_list mdl_requests;
  MDL_request schema_request;

  MDL_REQUEST_INIT(&schema_request, MDL_key::SCHEMA, schema_name, "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  mdl_requests.push_front(&schema_request);

  if (!mdl_locks_acquire(mdl_requests, m_thd->variables.lock_wait_timeout)) {
    return false;
  }

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(m_thd, true)) return false;

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_logfile_group_exclusive
bool Ndb_dd_client::mdl_lock_logfile_group_exclusive(
    const char *logfile_group_name, bool custom_lock_wait,
    ulong lock_wait_timeout) {
  MDL_request_list mdl_requests;
  MDL_request logfile_group_request;
  MDL_request backup_lock_request;
  MDL_request grl_request;

  // If protection against GRL can't be acquired, err out early.
  if (m_thd->global_read_lock.can_acquire_protection()) {
    return false;
  }

  MDL_REQUEST_INIT(&logfile_group_request, MDL_key::TABLESPACE, "",
                   logfile_group_name, MDL_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&grl_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);

  mdl_requests.push_front(&logfile_group_request);
  mdl_requests.push_front(&backup_lock_request);
  mdl_requests.push_front(&grl_request);

  if (!custom_lock_wait) {
    lock_wait_timeout = m_thd->variables.lock_wait_timeout;
  }

  if (!mdl_locks_acquire(mdl_requests, lock_wait_timeout)) {
    return false;
  }

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(m_thd, true)) return false;

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_logfile_group
bool Ndb_dd_client::mdl_lock_logfile_group(const char *logfile_group_name,
                                           bool intention_exclusive) {
  MDL_request_list mdl_requests;
  MDL_request logfile_group_request;

  enum_mdl_type mdl_type =
      intention_exclusive ? MDL_INTENTION_EXCLUSIVE : MDL_SHARED_READ;
  MDL_REQUEST_INIT(&logfile_group_request, MDL_key::TABLESPACE, "",
                   logfile_group_name, mdl_type, MDL_EXPLICIT);

  mdl_requests.push_front(&logfile_group_request);

  if (!mdl_locks_acquire(mdl_requests, m_thd->variables.lock_wait_timeout)) {
    return false;
  }

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_tablespace_exclusive
bool Ndb_dd_client::mdl_lock_tablespace_exclusive(const char *tablespace_name,
                                                  bool custom_lock_wait,
                                                  ulong lock_wait_timeout) {
  MDL_request_list mdl_requests;
  MDL_request tablespace_request;
  MDL_request backup_lock_request;
  MDL_request grl_request;

  // If protection against GRL can't be acquired, err out early.
  if (m_thd->global_read_lock.can_acquire_protection()) {
    return false;
  }

  MDL_REQUEST_INIT(&tablespace_request, MDL_key::TABLESPACE, "",
                   tablespace_name, MDL_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&backup_lock_request, MDL_key::BACKUP_LOCK, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);
  MDL_REQUEST_INIT(&grl_request, MDL_key::GLOBAL, "", "",
                   MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);

  mdl_requests.push_front(&tablespace_request);
  mdl_requests.push_front(&backup_lock_request);
  mdl_requests.push_front(&grl_request);

  if (!custom_lock_wait) {
    lock_wait_timeout = m_thd->variables.lock_wait_timeout;
  }

  if (!mdl_locks_acquire(mdl_requests, lock_wait_timeout)) {
    return false;
  }

  /*
    Now when we have protection against concurrent change of read_only
    option we can safely re-check its value.
  */
  if (check_readonly(m_thd, true)) return false;

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ndb_dd_client.cc
Function: Ndb_dd_client::mdl_lock_tablespace
bool Ndb_dd_client::mdl_lock_tablespace(const char *tablespace_name,
                                        bool intention_exclusive) {
  MDL_request_list mdl_requests;
  MDL_request tablespace_request;

  enum_mdl_type mdl_type =
      intention_exclusive ? MDL_INTENTION_EXCLUSIVE : MDL_SHARED_READ;
  MDL_REQUEST_INIT(&tablespace_request, MDL_key::TABLESPACE, "",
                   tablespace_name, mdl_type, MDL_EXPLICIT);

  mdl_requests.push_front(&tablespace_request);

  if (!mdl_locks_acquire(mdl_requests, m_thd->variables.lock_wait_timeout)) {
    return false;
  }

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_geofunc_internal.cc
Function: Srs_fetcher::lock
bool Srs_fetcher::lock(gis::srid_t srid, enum_mdl_type lock_type) {
  DBUG_TRACE;
  assert(srid != 0);

  char id_str[11];  // uint32 => max 10 digits + \0
  longlong10_to_str(srid, id_str, 10);

  MDL_request mdl_request;
  mdl_request.init_with_source(MDL_key::SRID, "", id_str, lock_type,
                               MDL_TRANSACTION, __FILE__, __LINE__);
  if (m_thd->mdl_context.acquire_lock(&mdl_request,
                                      m_thd->variables.lock_wait_timeout)) {
    /* purecov: begin inspected */
    // If locking fails, an error has already been flagged.
    return true;
    /* purecov: end */
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_rli.cc
Function: MDL_lock_guard::lock
bool MDL_lock_guard::lock(MDL_key::enum_mdl_namespace namespace_arg,
                          enum_mdl_type mdl_type_arg, bool blocking) {
  DBUG_TRACE;
  if (this->m_target != nullptr &&
      !this->m_target->mdl_context.has_locks(namespace_arg)) {
    MDL_REQUEST_INIT(&this->m_request, namespace_arg, "", "", mdl_type_arg,
                     MDL_EXPLICIT);

    if (blocking)
      this->m_target->mdl_context.acquire_lock(
          &this->m_request, this->m_target->variables.lock_wait_timeout);
    else
      this->m_target->mdl_context.try_acquire_lock(&this->m_request);

    return !this->is_locked();
  }
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: init_replica_thread
  init_replica_thread()
*/

int init_replica_thread(THD *thd, SLAVE_THD_TYPE thd_type) {
  DBUG_TRACE;
#if !defined(NDEBUG)
  int simulate_error = 0;
#endif
  thd->system_thread = (thd_type == SLAVE_THD_WORKER)
                           ? SYSTEM_THREAD_SLAVE_WORKER
                           : (thd_type == SLAVE_THD_SQL)
                                 ? SYSTEM_THREAD_SLAVE_SQL
                                 : SYSTEM_THREAD_SLAVE_IO;
  thd->get_protocol_classic()->init_net(nullptr);
  thd->slave_thread = true;
  thd->enable_slow_log = opt_log_slow_replica_statements;
  set_slave_thread_options(thd);

  /*
    Replication threads are:
    - background threads in the server, not user sessions,
    - yet still assigned a PROCESSLIST_ID,
      for historical reasons (displayed in SHOW PROCESSLIST).
  */
  thd->set_new_thread_id();

#ifdef HAVE_PSI_THREAD_INTERFACE
  /*
    Populate the PROCESSLIST_ID in the instrumentation.
  */
  struct PSI_thread *psi = PSI_THREAD_CALL(get_thread)();
  PSI_THREAD_CALL(set_thread_id)(psi, thd->thread_id());
#endif /* HAVE_PSI_THREAD_INTERFACE */

  DBUG_EXECUTE_IF("simulate_io_replica_error_on_init",
                  simulate_error |= (1 << SLAVE_THD_IO););
  DBUG_EXECUTE_IF("simulate_sql_replica_error_on_init",
                  simulate_error |= (1 << SLAVE_THD_SQL););
  thd->store_globals();
#if !defined(NDEBUG)
  if (simulate_error & (1 << thd_type)) {
    return -1;
  }
#endif

  if (thd_type == SLAVE_THD_SQL) {
    THD_STAGE_INFO(thd, stage_waiting_for_the_next_event_in_relay_log);
    thd->set_command(
        COM_QUERY);  // the SQL thread does not use the server protocol
  } else {
    THD_STAGE_INFO(thd, stage_waiting_for_source_update);
  }
  thd->set_time();
  /* Do not use user-supplied timeout value for system threads. */
  thd->variables.lock_wait_timeout = LONG_TIMEOUT;
  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/dd_schema.cc
Function: dd::mdl_lock_schema
bool mdl_lock_schema(THD *thd, const char *schema_name,
                     enum_mdl_duration duration, MDL_ticket **ticket) {
  /*
    Make sure we have at least an IX lock on the schema name.
    Acquire a lock unless we already have it.
  */
  char name_buf[NAME_LEN + 1];
  const char *converted_name = schema_name;
  if (lower_case_table_names == 2) {
    // Lower case table names == 2 is tested on OSX.
    /* purecov: begin tested */
    my_stpcpy(name_buf, converted_name);
    my_casedn_str(&my_charset_utf8mb3_tolower_ci, name_buf);
    converted_name = name_buf;
    /* purecov: end */
  }

  // If we do not already have one, acquire a new lock.
  if (thd->mdl_context.owns_equal_or_stronger_lock(
          MDL_key::SCHEMA, converted_name, "", MDL_INTENTION_EXCLUSIVE)) {
    return false;
  }

  // Create a request for an IX_lock on the converted schema name.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::SCHEMA, converted_name, "",
                   MDL_INTENTION_EXCLUSIVE, duration);

  /*
    Acquire the lock request created above, and check if
    acquisition fails (e.g. timeout or deadlock).
  */
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    assert(thd->is_system_thread() || thd->killed || thd->is_error());
    return true;
  }
  if (ticket != nullptr) {
    *ticket = mdl_request.ticket;
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_shared_table_mdl
bool acquire_shared_table_mdl(THD *thd, const char *schema_name,
                              const char *table_name, bool no_wait,
                              MDL_ticket **out_mdl_ticket) {
  return acquire_shared_mdl(thd, MDL_key::TABLE, schema_name, table_name,
                            no_wait, thd->variables.lock_wait_timeout,
                            MDL_EXPLICIT, out_mdl_ticket);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_exclusive_tablespace_mdl
bool acquire_exclusive_tablespace_mdl(THD *thd, const char *tablespace_name,
                                      bool no_wait, MDL_ticket **ticket,
                                      bool for_trx) {
  enum_mdl_duration duration = (for_trx ? MDL_TRANSACTION : MDL_EXPLICIT);
  return acquire_exclusive_mdl(thd, MDL_key::TABLESPACE, "", tablespace_name,
                               no_wait, thd->variables.lock_wait_timeout,
                               duration, ticket);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_shared_tablespace_mdl
bool acquire_shared_tablespace_mdl(THD *thd, const char *tablespace_name,
                                   bool no_wait, MDL_ticket **ticket,
                                   bool for_trx) {
  // When requesting a tablespace name lock, we leave the schema name empty.
  enum_mdl_duration duration = (for_trx ? MDL_TRANSACTION : MDL_EXPLICIT);
  return acquire_shared_mdl(thd, MDL_key::TABLESPACE, "", tablespace_name,
                            no_wait, thd->variables.lock_wait_timeout, duration,
                            ticket);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_exclusive_table_mdl
bool acquire_exclusive_table_mdl(THD *thd, const char *schema_name,
                                 const char *table_name, bool no_wait,
                                 MDL_ticket **out_mdl_ticket) {
  return acquire_exclusive_mdl(thd, MDL_key::TABLE, schema_name, table_name,
                               no_wait, thd->variables.lock_wait_timeout,
                               MDL_TRANSACTION, out_mdl_ticket);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::acquire_exclusive_schema_mdl
bool acquire_exclusive_schema_mdl(THD *thd, const char *schema_name,
                                  bool no_wait, MDL_ticket **out_mdl_ticket) {
  return acquire_exclusive_mdl(thd, MDL_key::SCHEMA, schema_name, "", no_wait,
                               thd->variables.lock_wait_timeout, MDL_EXPLICIT,
                               out_mdl_ticket);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::create_native_table
bool create_native_table(THD *thd, const Plugin_table *pt) {
  if (dd::get_dictionary()->is_dd_table_name(pt->get_schema_name(),
                                             pt->get_name())) {
    my_error(ER_NO_SYSTEM_TABLE_ACCESS, MYF(0),
             ER_THD_NONCONST(thd, dd::get_dictionary()->table_type_error_code(
                                      pt->get_schema_name(), pt->get_name())),
             pt->get_schema_name(), pt->get_name());

    return true;
  }

  // Acquire MDL on new native table that we would create.
  bool error = false;
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, pt->get_schema_name(),
                   pt->get_name(), MDL_EXCLUSIVE, MDL_TRANSACTION);
  dd::Schema_MDL_locker mdl_locker(thd);
  if (mdl_locker.ensure_locked(pt->get_schema_name()) ||
      thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  /*
    1. Mark that we are executing a special DDL during
    plugin initialization. This will enable DDL to not be
    committed or binlogged. The called of this API would commit
    the transaction.

    2. Remove metadata of native table if already exists. This could
    happen if server was crashed and restarted.

    3. Create native table.

    4. Undo 1.
  */
  dd::cache::Dictionary_client *client = thd->dd_client();
  const dd::Table *table_def = nullptr;
  if (client->acquire(pt->get_schema_name(), pt->get_name(), &table_def))
    return true;

  thd->mark_plugin_fake_ddl(true);
  ulong master_access = thd->security_context()->master_access();
  thd->security_context()->set_master_access(~(ulong)0);
  {
    Disable_binlog_guard guard(thd);

    // Drop the table and related dynamic statistics too.
    if (table_def) {
      error =
          client->drop(table_def) || client->remove_table_dynamic_statistics(
                                         pt->get_schema_name(), pt->get_name());
    }

    if (!error) error = dd::execute_query(thd, pt->get_ddl());
  }

  thd->security_context()->set_master_access(master_access);
  thd->mark_plugin_fake_ddl(false);

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::drop_native_table
bool drop_native_table(THD *thd, const char *schema_name,
                       const char *table_name) {
  if (dd::get_dictionary()->is_dd_table_name(schema_name, table_name)) {
    my_error(ER_NO_SYSTEM_TABLE_ACCESS, MYF(0),
             ER_THD_NONCONST(thd, dd::get_dictionary()->table_type_error_code(
                                      schema_name, table_name)),
             schema_name, table_name);

    return true;
  }

  // Acquire MDL on schema and table.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, schema_name, table_name,
                   MDL_EXCLUSIVE, MDL_TRANSACTION);
  dd::Schema_MDL_locker mdl_locker(thd);
  if (mdl_locker.ensure_locked(schema_name) ||
      thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  dd::cache::Dictionary_client *client = thd->dd_client();
  const dd::Table *table_def = nullptr;
  if (client->acquire(schema_name, table_name, &table_def)) {
    // Error is reported by the dictionary subsystem.
    return true;
  }

  // Not error is reported if table is not present.
  if (!table_def) return false;

  // Drop the table and related dynamic statistics too.
  return client->drop(table_def) ||
         client->remove_table_dynamic_statistics(schema_name, table_name);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/cache/shared_multi_map.cc
Function: dd::cache::Shared_multi_map not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/upgrade/server.cc
Function: dd::upgrade::
  if (should_log_error(error))
    LogEvent()
        .type(LOG_TYPE_ERROR)
        .subsys(LOG_SUBSYSTEM_TAG)
        .prio(ERROR_LEVEL)
        .errcode(ER_ERROR_INFO_FROM_DA)
        .verbatim(str);
}

void Bootstrap_error_handler::set_abort_on_error(uint error) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/info_schema/metadata.cc
Function: dd::info_schema::remove_I_S_view_metadata
bool remove_I_S_view_metadata(THD *thd, const dd::String_type &view_name) {
  // Make sure you have lock on I_S schema.
  Schema_MDL_locker mdl_locker(thd);
  if (mdl_locker.ensure_locked(INFORMATION_SCHEMA_NAME.str)) return true;

  // Acquire exclusive lock on it before dropping.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, INFORMATION_SCHEMA_NAME.str,
                   view_name.c_str(), MDL_EXCLUSIVE, MDL_TRANSACTION);
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return (true);

  // Acquire the object.
  const dd::Abstract_table *at = nullptr;
  if (thd->dd_client()->acquire(INFORMATION_SCHEMA_NAME.str, view_name.c_str(),
                                &at))
    return (true);

  assert(at->type() == dd::enum_table_type::SYSTEM_VIEW);

  // Remove view from DD tables.
  Implicit_substatement_state_guard substatement_guard(thd);
  if (thd->dd_client()->drop(at)) {
    assert(thd->is_system_thread() || thd->killed || thd->is_error());
    return (true);
  }

  return (false);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/info_schema/table_stats.cc
Function: dd::info_schema::Table_statistics::read_stat_from_SE
ulonglong Table_statistics::read_stat_from_SE(
    THD *thd, const String &schema_name_ptr, const String &table_name_ptr,
    const String &index_name_ptr, const String &column_name_ptr,
    uint index_ordinal_position, uint column_ordinal_position,
    Object_id se_private_id, const char *ts_se_private_data,
    const char *tbl_se_private_data, enum_table_stats_type stype,
    handlerton *hton) {
  DBUG_TRACE;

  ulonglong return_value = 0;

  DBUG_EXECUTE_IF("information_schema_fetch_table_stats",
                  assert(strncmp(table_name_ptr.ptr(), "fts", 3)););

  // No engines implement these statistics retrieval. We always return zero.
  if (stype == enum_table_stats_type::CHECK_TIME ||
      stype == enum_table_stats_type::CHECKSUM)
    return 0;

  //
  // Get statistics from SE
  //
  ha_statistics ha_stat;
  uint error = 0;

  // Acquire MDL_EXPLICIT lock on table.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, schema_name_ptr.ptr(),
                   table_name_ptr.ptr(), MDL_SHARED_HIGH_PRIO, MDL_EXPLICIT);

  // Push deadlock error handler
  Info_schema_error_handler info_schema_error_handler(thd, &schema_name_ptr,
                                                      &table_name_ptr);
  thd->push_internal_handler(&info_schema_error_handler);
  if (thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout)) {
    error = -1;
  }
  thd->pop_internal_handler();

  DEBUG_SYNC(thd, "after_acquiring_mdl_shared_to_fetch_stats");

  if (error == 0) {
    error = -1;

    // Prepare dd::Properties objects for se_private_data and send it to SE.
    std::unique_ptr<dd::Properties> ts_se_private_data_obj(
        dd::Properties::parse_properties(ts_se_private_data ? ts_se_private_data
                                                            : ""));
    std::unique_ptr<dd::Properties> tbl_se_private_data_obj(
        dd::Properties::parse_properties(
            tbl_se_private_data ? tbl_se_private_data : ""));

    assert(tbl_se_private_data_obj.get() && ts_se_private_data_obj.get());

    //
    // Read statistics from SE
    //
    return_value = -1;

    if (stype == enum_table_stats_type::INDEX_COLUMN_CARDINALITY &&
        !hton->get_index_column_cardinality(
            schema_name_ptr.ptr(), table_name_ptr.ptr(), index_name_ptr.ptr(),
            index_ordinal_position, column_ordinal_position, se_private_id,
            &return_value)) {
      error = 0;
    } else if (!hton->get_table_statistics(
                   schema_name_ptr.ptr(), table_name_ptr.ptr(), se_private_id,
                   *ts_se_private_data_obj.get(),
                   *tbl_se_private_data_obj.get(),
                   HA_STATUS_VARIABLE | HA_STATUS_TIME |
                       HA_STATUS_VARIABLE_EXTRA | HA_STATUS_AUTO,
                   &ha_stat)) {
      error = 0;
    }

    // Release the lock we got
    thd->mdl_context.release_lock(mdl_request.ticket);
  }

  // Cache and return the statistics
  if (error == 0) {
    if (stype != enum_table_stats_type::INDEX_COLUMN_CARDINALITY) {
      cache_stats_in_mem(schema_name_ptr, table_name_ptr, ha_stat);

      /*
        Update table statistics in the cache.
        All engines return ZERO for checksum, we hardcode it here.
      */
      if (can_persist_I_S_dynamic_statistics(thd, schema_name_ptr.ptr(),
                                             nullptr) &&
          persist_i_s_table_stats(thd, m_stats, schema_name_ptr, table_name_ptr,
                                  0)) {
        error = -1;
      } else
        return_value = get_stat(ha_stat, stype);

    }
    /*
      Only cardinality is not stored in the cache.
      Update index statistics in the mysql.index_stats.
    */
    else if (can_persist_I_S_dynamic_statistics(thd, schema_name_ptr.ptr(),
                                                nullptr) &&
             persist_i_s_index_stats(thd, schema_name_ptr, table_name_ptr,
                                     index_name_ptr, column_name_ptr,
                                     return_value)) {
      error = -1;
    }

    if (error == 0) return return_value;
  }

  // If we have a error, push a warning and clear the DA.
  if (thd->is_error()) {
    /*
      Hide error for a non-existing table.
      For example, this error can occur when we use a where condition
      with a db name and table, but the table does not exist.
     */
    if (!(thd->get_stmt_da()->mysql_errno() == ER_NO_SUCH_TABLE) &&
        !(thd->get_stmt_da()->mysql_errno() == ER_WRONG_OBJECT))
      push_warning(thd, Sql_condition::SL_WARNING,
                   thd->get_stmt_da()->mysql_errno(),
                   thd->get_stmt_da()->message_text());

    store_error_message(schema_name_ptr, table_name_ptr, nullptr,
                        thd->get_stmt_da()->message_text());
    thd->clear_error();
  }

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/info_schema/tablespace_stats.cc
Function: dd::info_schema::Tablespace_statistics::read_stat_from_SE
bool Tablespace_statistics::read_stat_from_SE(THD *thd,
                                              const String &tablespace_name_ptr,
                                              const String &file_name_ptr,
                                              const String &engine_name_ptr,
                                              const char *ts_se_private_data) {
  DBUG_TRACE;

  //
  // Get statistics from the SE
  //
  ha_tablespace_statistics ha_tablespace_stat;

  // Acquire MDL_EXPLICIT lock on table.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLESPACE, "",
                   tablespace_name_ptr.ptr(), MDL_SHARED, MDL_EXPLICIT);

  // Push deadlock error handler
  bool error = false;
  Info_schema_error_handler info_schema_error_handler(thd,
                                                      &tablespace_name_ptr);
  thd->push_internal_handler(&info_schema_error_handler);

  // Check if engine supports fetching tablespace statistics.
  plugin_ref tmp_plugin = ha_resolve_by_name_raw(
      thd, lex_cstring_handle(dd::String_type(engine_name_ptr.ptr())));
  handlerton *hton = nullptr;
  if (!tmp_plugin) {
    my_error(ER_UNKNOWN_STORAGE_ENGINE, MYF(0), engine_name_ptr.ptr());
    error = true;
  } else if (!(hton = plugin_data<handlerton *>(tmp_plugin)) ||
             !hton->get_tablespace_statistics) {
    assert(!hton->get_tablespace_statistics);
    my_error(ER_NOT_IMPLEMENTED_GET_TABLESPACE_STATISTICS, MYF(0),
             engine_name_ptr.ptr());
    error = true;
  }

  error = error || thd->mdl_context.acquire_lock(
                       &mdl_request, thd->variables.lock_wait_timeout);
  thd->pop_internal_handler();

  if (!error) {
    // Prepare dd::Properties object for se_private_data and send it to SE.
    std::unique_ptr<dd::Properties> ts_se_private_data_obj(
        dd::Properties::parse_properties(ts_se_private_data ? ts_se_private_data
                                                            : ""));

    assert(ts_se_private_data_obj.get());

    //
    // Read statistics from SE
    //

    error = hton->get_tablespace_statistics(
        tablespace_name_ptr.ptr(), file_name_ptr.ptr(),
        *ts_se_private_data_obj.get(), &ha_tablespace_stat);

    // Release the lock we got
    thd->mdl_context.release_lock(mdl_request.ticket);
  }

  if (!error) {
    // Cache statistics.
    cache_stats(tablespace_name_ptr, file_name_ptr, ha_tablespace_stat);
  }

  if (thd->is_error()) {
    push_warning(thd, Sql_condition::SL_WARNING,
                 thd->get_stmt_da()->mysql_errno(),
                 thd->get_stmt_da()->message_text());
    thd->clear_error();
    mark_as_error_found(tablespace_name_ptr, file_name_ptr);
  }

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/upgrade_57/table.cc
Function: dd::upgrade_57::Upgrade_MDL_guard::acquire_lock_tablespace
  bool acquire_lock_tablespace(Tablespace_hash_set *tablespace_names) {
    m_tablespace_lock = true;
    return lock_tablespace_names(m_thd, tablespace_names,
                                 m_thd->variables.lock_wait_timeout,
                                 m_thd->mem_root);
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/dict/dict0dd.cc
Function: dd_tablespace_get_mdl
bool dd_tablespace_get_mdl(const char *space_name, MDL_ticket **mdl_ticket,
                           bool foreground) {
  THD *thd = current_thd;
  /* Safeguard in release mode if background thread doesn't have THD. */
  if (thd == nullptr) {
    ut_d(ut_error);
    ut_o(return true);
  }
  /* Explicit duration for background threads. */
  bool trx_duration = foreground;

  /* Background thread should not block on MDL lock. */
  ulong timeout = foreground ? thd->variables.lock_wait_timeout : 0;
  bool result = acquire_shared_backup_lock(thd, timeout, trx_duration);

  if (!result) {
    result = dd::acquire_exclusive_tablespace_mdl(thd, space_name, false,
                                                  mdl_ticket, trx_duration);
    if (result) {
      release_backup_lock(thd);
    }
  }

  /* For background thread, clear timeout error. */
  if (result && !foreground && thd->is_error()) {
    thd->clear_error();
  }
  return result;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_schema_event_handler::Lock_wait_timeout_guard::Lock_wait_timeout_guard
    Lock_wait_timeout_guard(THD *thd, ulong lock_wait_timeout)
        : m_thd(thd),
          m_save_lock_wait_timeout(thd->variables.lock_wait_timeout) {
      m_thd->variables.lock_wait_timeout = lock_wait_timeout;
    }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_schema_event_handler::Lock_wait_timeout_guard::
  Copyright (c) 2006, 2023, Oracle and/or its affiliates.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License, version 2.0,
   as published by the Free Software Foundation.

   This program is also distributed with certain software (including
   but not limited to OpenSSL) that is licensed under separate terms,
   as designated in a particular file or component or in included license
   documentation.  The authors of MySQL hereby grant you an additional
   permission to link the program and your derivative works with the
   separately licensed software that they have included with MySQL.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License, version 2.0, for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
*/

#include "storage/ndb/plugin/ha_ndbcluster_binlog.h"

#include <unordered_map>

#include "my_config.h"  // WORDS_BIGENDIAN
#include "my_dbug.h"
#include "my_thread.h"
#include "mysql/plugin.h"
#include "sql/auth/acl_change_notification.h"
#include "sql/binlog.h"
#include "sql/dd/types/abstract_table.h"  // dd::enum_table_type
#include "sql/dd/types/tablespace.h"      // dd::Tablespace
#include "sql/debug_sync.h"               // debug_sync_set_action, DEBUG_SYNC
#include "sql/derror.h"                   // ER_THD
#include "sql/mysqld.h"                   // opt_bin_log
#include "sql/mysqld_thd_manager.h"       // Global_THD_manager
#include "sql/protocol_classic.h"
#include "sql/rpl_injector.h"
#include "sql/sql_base.h"
#include "sql/sql_lex.h"
#include "sql/sql_rewrite.h"
#include "sql/sql_thd_internal_api.h"
#include "sql/thd_raii.h"
#include "sql/transaction.h"
#include "storage/ndb/include/ndbapi/NdbDictionary.hpp"
#include "storage/ndb/include/ndbapi/ndb_cluster_connection.hpp"
#include "storage/ndb/plugin/ha_ndbcluster_connection.h"
#include "storage/ndb/plugin/ndb_anyvalue.h"
#include "storage/ndb/plugin/ndb_apply_status_table.h"
#include "storage/ndb/plugin/ndb_binlog_client.h"
#include "storage/ndb/plugin/ndb_binlog_extra_row_info.h"
#include "storage/ndb/plugin/ndb_binlog_thread.h"
#include "storage/ndb/plugin/ndb_bitmap.h"
#include "storage/ndb/plugin/ndb_blobs_buffer.h"
#include "storage/ndb/plugin/ndb_conflict.h"
#include "storage/ndb/plugin/ndb_dd.h"
#include "storage/ndb/plugin/ndb_dd_client.h"
#include "storage/ndb/plugin/ndb_dd_disk_data.h"
#include "storage/ndb/plugin/ndb_dd_sync.h"  // Ndb_dd_sync
#include "storage/ndb/plugin/ndb_dd_table.h"
#include "storage/ndb/plugin/ndb_event_data.h"
#include "storage/ndb/plugin/ndb_global_schema_lock_guard.h"
#include "storage/ndb/plugin/ndb_index_stat_head_table.h"
#include "storage/ndb/plugin/ndb_index_stat_sample_table.h"
#include "storage/ndb/plugin/ndb_local_connection.h"
#include "storage/ndb/plugin/ndb_log.h"
#include "storage/ndb/plugin/ndb_mysql_services.h"
#include "storage/ndb/plugin/ndb_name_util.h"
#include "storage/ndb/plugin/ndb_ndbapi_errors.h"
#include "storage/ndb/plugin/ndb_ndbapi_util.h"
#include "storage/ndb/plugin/ndb_repl_tab.h"
#include "storage/ndb/plugin/ndb_require.h"
#include "storage/ndb/plugin/ndb_retry.h"
#include "storage/ndb/plugin/ndb_schema_dist.h"
#include "storage/ndb/plugin/ndb_schema_dist_table.h"
#include "storage/ndb/plugin/ndb_schema_object.h"
#include "storage/ndb/plugin/ndb_schema_result_table.h"
#include "storage/ndb/plugin/ndb_share.h"
#include "storage/ndb/plugin/ndb_sleep.h"
#include "storage/ndb/plugin/ndb_stored_grants.h"
#include "storage/ndb/plugin/ndb_table_guard.h"
#include "storage/ndb/plugin/ndb_table_map.h"
#include "storage/ndb/plugin/ndb_tdc.h"
#include "storage/ndb/plugin/ndb_thd.h"
#include "storage/ndb/plugin/ndb_thd_ndb.h"
#include "storage/ndb/plugin/ndb_upgrade_util.h"

typedef NdbDictionary::Event NDBEVENT;
typedef NdbDictionary::Table NDBTAB;

extern bool opt_ndb_log_orig;
extern bool opt_ndb_log_bin;
extern bool opt_ndb_log_empty_epochs;
extern bool opt_ndb_log_update_as_write;
extern bool opt_ndb_log_updated_only;
extern bool opt_ndb_log_update_minimal;
extern bool opt_ndb_log_binlog_index;
extern bool opt_ndb_log_apply_status;
extern bool opt_ndb_log_transaction_id;
extern bool opt_ndb_log_trx_compression;
extern uint opt_ndb_log_trx_compression_level_zstd;
extern bool opt_ndb_log_empty_update;
extern bool opt_ndb_clear_apply_status;
extern bool opt_ndb_log_fail_terminate;
extern bool opt_ndb_log_trans_dependency;
extern int opt_ndb_schema_dist_timeout;
extern ulong opt_ndb_schema_dist_lock_wait_timeout;
extern ulong opt_ndb_report_thresh_binlog_epoch_slip;
extern ulong opt_ndb_report_thresh_binlog_mem_usage;
extern ulonglong opt_ndb_eventbuffer_max_alloc;
extern uint opt_ndb_eventbuffer_free_percent;

void ndb_index_stat_restart();

extern Ndb_cluster_connection *g_ndb_cluster_connection;

/*
  Timeout for syncing schema events between
  mysql servers, and between mysql server and the binlog
*/
static const int DEFAULT_SYNC_TIMEOUT = 120;

/* Column numbers in the ndb_binlog_index table */
enum Ndb_binlog_index_cols {
  NBICOL_START_POS = 0,
  NBICOL_START_FILE = 1,
  NBICOL_EPOCH = 2,
  NBICOL_NUM_INSERTS = 3,
  NBICOL_NUM_UPDATES = 4,
  NBICOL_NUM_DELETES = 5,
  NBICOL_NUM_SCHEMAOPS = 6
  /* Following columns in schema 'v2' */
  ,
  NBICOL_ORIG_SERVERID = 7,
  NBICOL_ORIG_EPOCH = 8,
  NBICOL_GCI = 9
  /* Following columns in schema 'v3' */
  ,
  NBICOL_NEXT_POS = 10,
  NBICOL_NEXT_FILE = 11
};


