-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/derror.cc
Function: ER_THD
const char *ER_THD(const THD *thd, int mysql_errno) {
  return thd->variables.lc_messages->errmsgs->lookup(mysql_errno);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/derror.cc
Function: ER_THD_NONCONST
const char *ER_THD_NONCONST(const THD *thd, int mysql_errno) {
  return thd->variables.lc_messages->errmsgs->lookup(mysql_errno);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/derror.cc
Function: error_message_for_client
const char *error_message_for_client(int mysql_errno) {
  if (current_thd) return ER_THD_NONCONST(current_thd, mysql_errno);

  return error_message_fetch(mysql_errno);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partitioning/partition_handler.cc
Function: Partition_helper::print_partition_error
bool Partition_helper::print_partition_error(int error) {
  THD *thd = get_thd();
  DBUG_TRACE;

  /* Should probably look for my own errors first */
  DBUG_PRINT("enter", ("error: %d", error));

  if ((error == HA_ERR_NO_PARTITION_FOUND) &&
      (thd->lex->alter_info == nullptr ||
       !(thd->lex->alter_info->flags & Alter_info::ALTER_TRUNCATE_PARTITION))) {
    m_part_info->print_no_partition_found(thd, m_table);
    // print_no_partition_found() reports an error, so we can just return here.
    return false;
  } else if (error == HA_ERR_ROW_IN_WRONG_PARTITION) {
    /*
      Should only happen on DELETE or UPDATE!
      Or in ALTER TABLE REBUILD/REORGANIZE where there are a misplaced
      row that needed to move to an old partition (not in the given set).
    */
    assert(thd_sql_command(thd) == SQLCOM_DELETE ||
           thd_sql_command(thd) == SQLCOM_DELETE_MULTI ||
           thd_sql_command(thd) == SQLCOM_UPDATE ||
           thd_sql_command(thd) == SQLCOM_UPDATE_MULTI ||
           thd_sql_command(thd) == SQLCOM_ALTER_TABLE);
    assert(m_err_rec);
    if (m_err_rec) {
      size_t max_length;
      char buf[MAX_KEY_LENGTH];
      String str(buf, sizeof(buf), system_charset_info);
      uint32 part_id;
      assert(m_last_part < m_tot_parts);
      str.length(0);
      if (thd_sql_command(thd) == SQLCOM_ALTER_TABLE) {
        str.append("from REBUILD/REORGANIZED partition: ");
        str.append_ulonglong(m_last_part);
        str.append(" to non included partition (new definition): ");
      } else {
        str.append_ulonglong(m_last_part);
        str.append(". Correct is ");
      }
      if (get_part_for_delete(m_err_rec, m_table->record[0], m_part_info,
                              &part_id)) {
        str.append("?");
      } else {
        str.append_ulonglong(part_id);
      }
      append_row_to_str(str, m_err_rec, m_table);

      /* Log this error, so the DBA can notice it and fix it! */
      LogErr(ERROR_LEVEL, ER_ROW_IN_WRONG_PARTITION_PLEASE_REPAIR,
             m_table->s->table_name.str, str.c_ptr_safe());

      max_length =
          (MYSQL_ERRMSG_SIZE - strlen(ER_THD(thd, ER_ROW_IN_WRONG_PARTITION)));
      if (str.length() >= max_length) {
        str.length(max_length - 4);
        str.append(STRING_WITH_LEN("..."));
      }
      my_error(ER_ROW_IN_WRONG_PARTITION, MYF(0), str.c_ptr_safe());
      m_err_rec = nullptr;
      return false;
    }
  }

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/persisted_variable.cc
Function: Persisted_variables_cache::reset_persisted_variables
  reset_persisted_variables() does a lookup into persist_variables and remove
  the variable from the hash if present and flush the hash to file.

  @param [in] thd                     Pointer to connection handle.
  @param [in] name                    Name of variable to remove, if NULL all
                                      variables are removed from config file.
  @param [in] if_exists               Bool value when set to true reports
                                      warning else error if variable is not
                                      present in the config file.

  @return 0 Success
  @return 1 Failure
*/
bool Persisted_variables_cache::reset_persisted_variables(THD *thd,
                                                          const char *name,
                                                          bool if_exists) {
  bool result = false, found = false;
  bool reset_all = (name ? 0 : 1);
  /* update on m_persisted_dynamic_variables/m_persisted_static_variables must
   * be thread safe */
  lock();

  if (reset_all) {
    /* check for necessary privileges */
    if ((!m_persisted_dynamic_variables.empty() ||
         !m_persisted_dynamic_parse_early_variables.empty() ||
         !m_persisted_dynamic_sensitive_variables.empty()) &&
        check_priv(thd, false))
      goto end;

    if ((!m_persisted_static_parse_early_variables.empty() ||
         !m_persisted_static_variables.empty() ||
         !m_persisted_static_sensitive_variables.empty()) &&
        check_priv(thd, true))
      goto end;

    auto clear_one = [&found](auto &variables) {
      if (!variables.empty()) {
        variables.clear();
        found = true;
      }
    };

    clear_one(m_persisted_dynamic_variables);
    clear_one(m_persisted_dynamic_parse_early_variables);
    clear_one(m_persisted_dynamic_sensitive_variables);
    clear_one(m_persisted_static_variables);
    clear_one(m_persisted_static_sensitive_variables);
    clear_one(m_persisted_static_parse_early_variables);
    clear_one(m_persisted_dynamic_plugin_variables);
    clear_one(m_persisted_static_sensitive_variables);
  } else {
    auto erase_variable = [&](const char *name_cptr) -> bool {
      string name_str{tolower_varname(name_cptr)};

      auto checkvariable = [&name_str](st_persist_var const &s) -> bool {
        return s.key == name_str;
      };

      auto update_unordered_set = [&thd, &found,
                                   &checkvariable](auto &variables) -> bool {
        if (variables.size()) {
          auto it =
              std::find_if(variables.begin(), variables.end(), checkvariable);
          if (it != variables.end()) {
            /* if variable is present in config file remove it */
            if (check_priv(thd, false)) return true;
            variables.erase(it);
            found = true;
          }
        }
        return false;
      };

      if (update_unordered_set(m_persisted_dynamic_variables) ||
          update_unordered_set(m_persisted_dynamic_parse_early_variables) ||
          update_unordered_set(m_persisted_dynamic_plugin_variables) ||
          update_unordered_set(m_persisted_dynamic_sensitive_variables) ||
          update_unordered_set(m_persisted_dynamic_sensitive_plugin_variables))
        return true;

      auto update_map = [&thd, &found, &name_str](auto &variables) -> bool {
        auto it = variables.find(name_str);
        if (it != variables.end()) {
          if (check_priv(thd, true)) return true;
          variables.erase(it);
          found = true;
        }
        return false;
      };

      if (update_map(m_persisted_static_variables) ||
          update_map(m_persisted_static_parse_early_variables) ||
          update_map(m_persisted_static_sensitive_variables))
        return true;

      return false;
    };

    // Erase the named variable
    if (erase_variable(name)) goto end;

    // If the variable has an alias, erase that too.
    std::string alias_name;
    mysql_mutex_assert_not_owner(&LOCK_plugin);
    mysql_rwlock_rdlock(&LOCK_system_variables_hash);
    { alias_name = get_variable_alias(name); }
    mysql_rwlock_unlock(&LOCK_system_variables_hash);
    if (!alias_name.empty() && erase_variable(alias_name.c_str())) goto end;

    if (!found) {
      /* if not present and if exists is specified, report warning */
      if (if_exists) {
        push_warning_printf(thd, Sql_condition::SL_WARNING,
                            ER_VAR_DOES_NOT_EXIST,
                            ER_THD(thd, ER_VAR_DOES_NOT_EXIST), name);
      } else {
        /* without IF EXISTS, report error */
        my_error(ER_VAR_DOES_NOT_EXIST, MYF(0), name);
        result = true;
      }
    }
  }
  unlock();
  if (found) flush_to_file();

  return result;

end:
  unlock();
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/persisted_variable.cc
Function: Persisted_variables_cache::set_variable
bool Persisted_variables_cache::set_variable(THD *thd, set_var *setvar) {
  auto f = [this, thd, setvar](const System_variable_tracker &,
                               sys_var *system_var) -> bool {
    char val_buf[1024] = {0};
    String utf8_str;
    bool is_null = false;

    std::string var_name{tolower_varname(setvar->m_var_tracker.get_var_name())};

    // 1. Fetch value into local variable var_value.

    const char *var_value = val_buf;
    if (setvar->type == OPT_PERSIST_ONLY) {
      String str(val_buf, sizeof(val_buf), system_charset_info), *res;
      const CHARSET_INFO *tocs = &my_charset_utf8mb4_bin;
      uint dummy_err;
      String bool_str;
      if (setvar->value) {
        res = setvar->value->val_str(&str);
        if (system_var->get_var_type() == GET_BOOL) {
          if (res == nullptr ||
              check_boolean_value(res->c_ptr_quick(), bool_str)) {
            my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), var_name.c_str(),
                     (res ? res->c_ptr_quick() : "null"));
            return true;
          } else {
            res = &bool_str;
          }
        }
        if (res && res->length()) {
          /*
            value held by Item class can be of different charset,
            so convert to utf8mb4
          */
          utf8_str.copy(res->ptr(), res->length(), res->charset(), tocs,
                        &dummy_err);
          var_value = utf8_str.c_ptr_quick();
        }
      } else {
        /* persist default value */
        system_var->save_default(thd, setvar);
        system_var->saved_value_to_string(thd, setvar, str.ptr());
        res = &str;
        if (system_var->get_var_type() == GET_BOOL) {
          check_boolean_value(res->c_ptr_quick(), bool_str);
          res = &bool_str;
        }
        utf8_str.copy(res->ptr(), res->length(), res->charset(), tocs,
                      &dummy_err);
        var_value = utf8_str.c_ptr_quick();
      }
    } else {
      Persisted_variables_cache::get_variable_value(thd, system_var, &utf8_str,
                                                    &is_null);
      var_value = utf8_str.c_ptr_quick();
    }

    // 2. Store local variable var_value into member st_persist_var object.

    auto assign_value = [&](const char *name) -> bool {
      struct st_persist_var tmp_var(thd);
      bool is_sensitive = system_var->is_sensitive();

      if (is_sensitive && !m_keyring_support_available) {
        if (!opt_persist_sensitive_variables_in_plaintext) {
          my_error(ER_CANNOT_PERSIST_SENSITIVE_VARIABLES, MYF(0), name);
          return true;
        } else {
          push_warning_printf(
              thd, Sql_condition::SL_WARNING,
              ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES,
              ER_THD(thd, ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES),
              name);
        }
      }

      tmp_var.key = string(name);
      tmp_var.value = var_value;
      tmp_var.is_null = is_null;

      /* modification to in-memory must be thread safe */
      lock();
      DEBUG_SYNC(thd, "in_set_persist_variables");
      if ((setvar->type == OPT_PERSIST_ONLY && system_var->is_readonly()) ||
          system_var->is_persist_readonly()) {
        /* if present update variable with new value else insert into hash */
        if (system_var->is_parse_early()) {
          m_persisted_static_parse_early_variables[tmp_var.key] = tmp_var;
        } else {
          auto &variables = is_sensitive
                                ? m_persisted_static_sensitive_variables
                                : m_persisted_static_variables;
          variables[tmp_var.key] = tmp_var;
          /**
            If server was upgraded, it is possible that persisted variables were
            initially read from an old format file. If so, all RO variables:
            PARSE_EARLY or otherwise, persisted before the upgrade may be
            present in m_persisted_static_parse_early_variables container.

            This SET PERSIST/SET PERSIST_ONLY call may be setting one of those
            variables. If so, remove those values from
            m_persisted_static_parse_early_variables.
          */
          auto it = m_persisted_static_parse_early_variables.find(name);
          if (it != m_persisted_static_parse_early_variables.end()) {
            m_persisted_static_parse_early_variables.erase(it);
          }
        }
      } else {
        /*
       if element is present remove it and insert
       it again with new value.
        */
        if (system_var->is_parse_early()) {
          m_persisted_dynamic_parse_early_variables.erase(tmp_var);
          m_persisted_dynamic_parse_early_variables.insert(tmp_var);
          /*
            If server was upgraded, it is possible that persisted variables were
            initially read from an old format file. If so, all variables:
            PARSE_EARLY or otherwise, persisted before the upgrade may be
            present in m_persisted_dynamic_variables container.

            This SET PERSIST/SET PERSIST_ONLY call may be setting one of those
            variables. If so, remove those values from
            m_persisted_dynamic_variables.
          */
          m_persisted_dynamic_variables.erase(tmp_var);
        } else {
          auto &variables = is_sensitive
                                ? m_persisted_dynamic_sensitive_variables
                                : m_persisted_dynamic_variables;
          variables.erase(tmp_var);
          variables.insert(tmp_var);
          /*
            for plugin variables update m_persisted_dynamic_plugin_variables
            or m_persisted_dynamic_sensitive_plugin_variables
          */
          if (system_var->cast_pluginvar()) {
            auto &plugin_variables =
                system_var->is_sensitive()
                    ? m_persisted_dynamic_sensitive_plugin_variables
                    : m_persisted_dynamic_plugin_variables;
            plugin_variables.erase(tmp_var);
            plugin_variables.insert(tmp_var);
          }
        }
      }

      if (setvar->type != OPT_PERSIST_ONLY) {
        setvar->update_source_user_host_timestamp(thd, system_var);
      }
      unlock();
      return false;
    };

    if (assign_value(var_name.c_str())) return true;

    const char *alias_var_name = get_variable_alias(system_var);

    if (alias_var_name) assign_value(alias_var_name);

    return false;
  };

  return setvar->m_var_tracker.access_system_variable<bool>(thd, f).value_or(
      true);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/internal.h
Function: Range_optimizer_error_handler::handle_condition
  bool handle_condition(THD *thd, uint sql_errno, const char *,
                        Sql_condition::enum_severity_level *level,
                        const char *) override {
    if (*level == Sql_condition::SL_ERROR) {
      m_has_errors = true;
      /* Out of memory error is reported only once. Return as handled */
      if (m_is_mem_error && sql_errno == EE_CAPACITY_EXCEEDED) return true;
      if (sql_errno == EE_CAPACITY_EXCEEDED) {
        m_is_mem_error = true;
        /* Convert the error into a warning. */
        *level = Sql_condition::SL_WARNING;
        push_warning_printf(
            thd, Sql_condition::SL_WARNING, ER_CAPACITY_EXCEEDED,
            ER_THD(thd, ER_CAPACITY_EXCEEDED),
            (ulonglong)thd->variables.range_optimizer_max_mem_size,
            "range_optimizer_max_mem_size",
            ER_THD(thd, ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER));
        return true;
      }
    }
    return false;
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/set_var.cc
Function: throw_bounds_warning
bool throw_bounds_warning(THD *thd, const char *name, bool fixed,
                          bool is_unsigned, longlong v) {
  if (fixed) {
    char buf[22];

    if (is_unsigned)
      ullstr((ulonglong)v, buf);
    else
      llstr(v, buf);

    if (thd->variables.sql_mode & MODE_STRICT_ALL_TABLES) {
      my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), name, buf);
      return true;
    }
    push_warning_printf(thd, Sql_condition::SL_WARNING,
                        ER_TRUNCATED_WRONG_VALUE,
                        ER_THD(thd, ER_TRUNCATED_WRONG_VALUE), name, buf);
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/set_var.cc
Function: sys_var::do_deprecated_warning
void sys_var::do_deprecated_warning(THD *thd) {
  if (deprecation_substitute != nullptr) {
    char buf1[NAME_CHAR_LEN + 3];
    strxnmov(buf1, sizeof(buf1) - 1, "@@", name.str, 0);

    /*
       if deprecation_substitute is an empty string,
       there is no replacement for the syntax
    */
    uint errmsg = deprecation_substitute[0] == '\0'
                      ? ER_DEPRECATE_MSG_NO_REPLACEMENT
                      : ER_DEPRECATE_MSG_WITH_REPLACEMENT;
    if (thd)
      push_warning_printf(
          thd, Sql_condition::SL_WARNING, ER_WARN_DEPRECATED_SYNTAX,
          ER_THD_NONCONST(thd, errmsg), buf1, deprecation_substitute);
    else
      LogErr(WARNING_LEVEL, errmsg, buf1, deprecation_substitute);
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp_rcontext.cc
Function: sp_cursor::fetch
bool sp_cursor::fetch(List<sp_variable> *vars) {
  if (m_server_side_cursor == nullptr) {
    my_error(ER_SP_CURSOR_NOT_OPEN, MYF(0));
    return true;
  }

  if (vars->elements != m_result.get_field_count()) {
    my_error(ER_SP_WRONG_NO_OF_FETCH_ARGS, MYF(0));
    return true;
  }

  DBUG_EXECUTE_IF(
      "bug23032_emit_warning",
      push_warning(current_thd, Sql_condition::SL_WARNING, ER_UNKNOWN_ERROR,
                   ER_THD(current_thd, ER_UNKNOWN_ERROR)););

  m_result.set_spvar_list(vars);

  /* Attempt to fetch one row */
  if (m_server_side_cursor->is_open()) {
    if (m_server_side_cursor->fetch(1)) return true;
  }

  /*
    If the cursor was pointing after the last row, the fetch will
    close it instead of sending any rows.
  */
  if (!m_server_side_cursor->is_open()) {
    my_error(ER_SP_FETCH_NO_DATA, MYF(0));
    return true;
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: open_tables
                read lock in open_tables(), then we need to check
                if we have really requested lock and then unlock.
               */
              if (table->file->get_lock_type() != F_UNLCK)
                table->file->ha_external_lock(thd, F_UNLCK);
              close_thread_table(thd, prev);
              continue;
            }
          }
        }
        prev = &table->next;
      }  // End of for
    }

    /* Ensure we are calling ha_reset() for all used tables */
    mark_used_tables_as_free_for_reuse(thd, thd->open_tables);

    /*
      Mark this statement as one that has "unlocked" its tables.
      For purposes of Query_tables_list::lock_tables_state we treat
      any statement which passed through close_thread_tables() as
      such.
    */
    thd->lex->lock_tables_state = Query_tables_list::LTS_NOT_LOCKED;

    /*
      We are under simple LOCK TABLES or we're inside a sub-statement
      of a prelocked statement, so should not do anything else.

      Note that even if we are in LTM_LOCK_TABLES mode and statement
      requires prelocking (e.g. when we are closing tables after
      failing to "open" all tables required for statement execution)
      we will exit this function a few lines below.
    */
    if (!thd->lex->requires_prelocking()) return;

    /*
      We are in the top-level statement of a prelocked statement,
      so we have to leave the prelocked mode now with doing implicit
      UNLOCK TABLES if needed.
    */
    if (thd->locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES)
      thd->locked_tables_mode = LTM_LOCK_TABLES;

    if (thd->locked_tables_mode == LTM_LOCK_TABLES) return;

    thd->leave_locked_tables_mode();

    /* Fallthrough */
  }

  if (thd->lock) {
    /*
      For RBR we flush the pending event just before we unlock all the
      tables.  This means that we are at the end of a topmost
      statement, so we ensure that the STMT_END_F flag is set on the
      pending event.  For statements that are *inside* stored
      functions, the pending event will not be flushed: that will be
      handled either before writing a query log event (inside
      binlog_query()) or when preparing a pending event.
     */
    (void)thd->binlog_flush_pending_rows_event(true);
    mysql_unlock_tables(thd, thd->lock);
    thd->lock = nullptr;
  }

  thd->lex->lock_tables_state = Query_tables_list::LTS_NOT_LOCKED;

  /*
    Closing a MERGE child before the parent would be fatal if the
    other thread tries to abort the MERGE lock in between.
  */
  if (thd->open_tables) close_open_tables(thd);
}

/**
  Helper function which returns TABLE to Table Cache or closes if
  table is marked as needing re-open.
*/
static void release_or_close_table(THD *thd, TABLE *table) {
  Table_cache *tc = table_cache_manager.get_cache(thd);

  tc->lock();

  if (table->s->has_old_version() || table->has_invalid_dict() ||
      table->has_invalid_stats() || table_def_shutdown_in_progress) {
    tc->remove_table(table);
    mysql_mutex_lock(&LOCK_open);
    intern_close_table(table);
    mysql_mutex_unlock(&LOCK_open);
  } else
    tc->release_table(thd, table);

  tc->unlock();
}

/* move one table to free list */

void close_thread_table(THD *thd, TABLE **table_ptr) {
  TABLE *table = *table_ptr;
  DBUG_TRACE;
  assert(table->key_read == 0);
  assert(!table->file || table->file->inited == handler::NONE);
  mysql_mutex_assert_not_owner(&LOCK_open);
  /*
    The metadata lock must be released after giving back
    the table to the table cache.
  */
  assert(thd->mdl_context.owns_equal_or_stronger_lock(
      MDL_key::TABLE, table->s->db.str, table->s->table_name.str, MDL_SHARED));
  table->mdl_ticket = nullptr;
  table->pos_in_table_list = nullptr;

  mysql_mutex_lock(&thd->LOCK_thd_data);
  *table_ptr = table->next;
  mysql_mutex_unlock(&thd->LOCK_thd_data);

  /*
    It is not safe to call the below code for TABLE objects for which
    handler::open() has not been called (for example, we use such objects
    while updating information about views which depend on table being
    ALTERed). Another possibly unsafe case is when TABLE/handler object
    has been marked as invalid (for example, it is unsafe to call
    handler::reset() for partitioned InnoDB tables after in-place ALTER
    TABLE API commit phase).
  */
  if (!table->has_invalid_dict()) {
    /* Avoid having MERGE tables with attached children in unused_tables. */
    table->file->ha_extra(HA_EXTRA_DETACH_CHILDREN);
    /* Free memory and reset for next loop. */
    free_blob_buffers_and_reset(table, MAX_TDC_BLOB_SIZE);
    table->file->ha_reset();
  }

  /* Do this *before* entering the LOCK_open critical section. */
  if (table->file != nullptr) table->file->unbind_psi();

  release_or_close_table(thd, table);
}

/* close_temporary_tables' internal, 4 is due to uint4korr definition */
static inline uint tmpkeyval(TABLE *table) {
  return uint4korr(table->s->table_cache_key.str +
                   table->s->table_cache_key.length - 4);
}

/*
  Close all temporary tables created by 'CREATE TEMPORARY TABLE' for thread
  creates one DROP TEMPORARY TABLE binlog event for each pseudo-thread.

  TODO: In future, we should have temporary_table= 0 and
        replica_open_temp_tables.fetch_add() at one place instead of repeating
        it all across the function. An alternative would be to use
        close_temporary_table() instead of close_temporary() that maintains
        the correct invariant regarding empty list of temporary tables
        and zero replica_open_temp_tables already.
*/

bool close_temporary_tables(THD *thd) {
  DBUG_TRACE;
  TABLE *table;
  TABLE *next = nullptr;
  TABLE *prev_table;
  /* Assume thd->variables.option_bits has OPTION_QUOTE_SHOW_CREATE */
  bool was_quote_show = true;
  bool error = false;
  int slave_closed_temp_tables = 0;

  if (!thd->temporary_tables) return false;

  assert(!thd->slave_thread ||
         thd->system_thread != SYSTEM_THREAD_SLAVE_WORKER);

  /*
    Ensure we don't have open HANDLERs for tables we are about to close.
    This is necessary when close_temporary_tables() is called as part
    of execution of BINLOG statement (e.g. for format description event).
  */
  mysql_ha_rm_temporary_tables(thd);
  if (!mysql_bin_log.is_open()) {
    TABLE *tmp_next;
    for (TABLE *t = thd->temporary_tables; t; t = tmp_next) {
      tmp_next = t->next;
      mysql_lock_remove(thd, thd->lock, t);
      /*
        We should not meet temporary tables created by ALTER TABLE here.
        It is responsibility of ALTER statement to close them. Otherwise
        it might be necessary to remove them from DD as well.
      */
      assert(t->s->tmp_table_def);
      close_temporary(thd, t, true, true);
      slave_closed_temp_tables++;
    }

    thd->temporary_tables = nullptr;
    if (thd->slave_thread) {
      atomic_replica_open_temp_tables -= slave_closed_temp_tables;
      thd->rli_slave->get_c_rli()->atomic_channel_open_temp_tables -=
          slave_closed_temp_tables;
    }

    return false;
  }

  /*
    We are about to generate DROP TEMPORARY TABLE statements for all
    the left out temporary tables. If GTID_NEXT is set (e.g. if user
    did SET GTID_NEXT just before disconnecting the client), we must
    ensure that it will be able to generate GTIDs for the statements
    with this server's UUID. Therefore we set gtid_next to
    AUTOMATIC_GTID.
  */
  gtid_state->update_on_rollback(thd);
  thd->variables.gtid_next.set_automatic();

  /*
    We must separate transactional temp tables and
    non-transactional temp tables in two distinct DROP statements
    to avoid the splitting if a slave server reads from this binlog.
  */

  /* Better add "if exists", in case a RESET MASTER has been done */
  const char stub[] = "DROP /*!40005 TEMPORARY */ TABLE IF EXISTS ";
  uint stub_len = sizeof(stub) - 1;
  char buf_trans[256], buf_non_trans[256];
  String s_query_trans =
      String(buf_trans, sizeof(buf_trans), system_charset_info);
  String s_query_non_trans =
      String(buf_non_trans, sizeof(buf_non_trans), system_charset_info);
  bool found_user_tables = false;
  bool found_trans_table = false;
  bool found_non_trans_table = false;

  memcpy(buf_trans, stub, stub_len);
  memcpy(buf_non_trans, stub, stub_len);

  /*
    Insertion sort of temp tables by pseudo_thread_id to build ordered list
    of sublists of equal pseudo_thread_id
  */

  for (prev_table = thd->temporary_tables, table = prev_table->next; table;
       prev_table = table, table = table->next) {
    TABLE *prev_sorted /* same as for prev_table */, *sorted;
    /*
      We should not meet temporary tables created by ALTER TABLE here.
      It is responsibility of ALTER statement to close them. Otherwise
      it might be necessary to remove them from DD as well.
    */
    assert(table->s->tmp_table_def);
    if (is_user_table(table)) {
      if (!found_user_tables) found_user_tables = true;
      for (prev_sorted = nullptr, sorted = thd->temporary_tables;
           sorted != table; prev_sorted = sorted, sorted = sorted->next) {
        if (!is_user_table(sorted) || tmpkeyval(sorted) > tmpkeyval(table)) {
          /* move into the sorted part of the list from the unsorted */
          prev_table->next = table->next;
          table->next = sorted;
          if (prev_sorted) {
            prev_sorted->next = table;
          } else {
            thd->temporary_tables = table;
          }
          table = prev_table;
          break;
        }
      }
    }
  }

  /* We always quote db,table names though it is slight overkill */
  if (found_user_tables && !(was_quote_show = (thd->variables.option_bits &
                                               OPTION_QUOTE_SHOW_CREATE))) {
    thd->variables.option_bits |= OPTION_QUOTE_SHOW_CREATE;
  }

  /*
    Make LEX consistent with DROP TEMPORARY TABLES statement which we
    are going to log. This is important for the binary logging code.
  */
  LEX *lex = thd->lex;
  enum_sql_command sav_sql_command = lex->sql_command;
  bool sav_drop_temp = lex->drop_temporary;
  lex->sql_command = SQLCOM_DROP_TABLE;
  lex->drop_temporary = true;

  /* scan sorted tmps to generate sequence of DROP */
  for (table = thd->temporary_tables; table; table = next) {
    if (is_user_table(table) && table->should_binlog_drop_if_temp()) {
      bool save_thread_specific_used = thd->thread_specific_used;
      my_thread_id save_pseudo_thread_id = thd->variables.pseudo_thread_id;
      /* Set pseudo_thread_id to be that of the processed table */
      thd->variables.pseudo_thread_id = tmpkeyval(table);
      String db;
      db.append(table->s->db.str);
      /* Loop forward through all tables that belong to a common database
         within the sublist of common pseudo_thread_id to create single
         DROP query
      */
      for (s_query_trans.length(stub_len), s_query_non_trans.length(stub_len),
           found_trans_table = false, found_non_trans_table = false;
           table && is_user_table(table) &&
           tmpkeyval(table) == thd->variables.pseudo_thread_id &&
           table->s->db.length == db.length() &&
           strcmp(table->s->db.str, db.ptr()) == 0;
           table = next) {
        /* Separate transactional from non-transactional temp tables */
        if (table->should_binlog_drop_if_temp()) {
          /* Separate transactional from non-transactional temp tables */
          if (table->s->tmp_table == TRANSACTIONAL_TMP_TABLE) {
            found_trans_table = true;
            /*
              We are going to add ` around the table names and possible more
              due to special characters
            */
            append_identifier(thd, &s_query_trans, table->s->table_name.str,
                              strlen(table->s->table_name.str));
            s_query_trans.append(',');
          } else if (table->s->tmp_table == NON_TRANSACTIONAL_TMP_TABLE) {
            found_non_trans_table = true;
            /*
              We are going to add ` around the table names and possible more
              due to special characters
            */
            append_identifier(thd, &s_query_non_trans, table->s->table_name.str,
                              strlen(table->s->table_name.str));
            s_query_non_trans.append(',');
          }
        }

        next = table->next;
        mysql_lock_remove(thd, thd->lock, table);
        close_temporary(thd, table, true, true);
        slave_closed_temp_tables++;
      }
      thd->clear_error();
      const CHARSET_INFO *cs_save = thd->variables.character_set_client;
      thd->variables.character_set_client = system_charset_info;
      thd->thread_specific_used = true;

      if (found_trans_table) {
        Query_log_event qinfo(thd, s_query_trans.ptr(),
                              s_query_trans.length() - 1, false, true, false,
                              0);
        qinfo.db = db.ptr();
        qinfo.db_len = db.length();
        thd->variables.character_set_client = cs_save;

        thd->get_stmt_da()->set_overwrite_status(true);
        if ((error = (mysql_bin_log.write_event(&qinfo) ||
                      mysql_bin_log.commit(thd, true) || error))) {
          /*
            If we're here following THD::cleanup, thence the connection
            has been closed already. So lets print a message to the
            error log instead of pushing yet another error into the
            Diagnostics_area.

            Also, we keep the error flag so that we propagate the error
            up in the stack. This way, if we're the SQL thread we notice
            that close_temporary_tables failed. (Actually, the SQL
            thread only calls close_temporary_tables while applying old
            Start_log_event_v3 events.)
          */
          LogErr(ERROR_LEVEL, ER_BINLOG_FAILED_TO_WRITE_DROP_FOR_TEMP_TABLES);
        }
        thd->get_stmt_da()->set_overwrite_status(false);
      }

      if (found_non_trans_table) {
        Query_log_event qinfo(thd, s_query_non_trans.ptr(),
                              s_query_non_trans.length() - 1, false, true,
                              false, 0);
        qinfo.db = db.ptr();
        qinfo.db_len = db.length();
        thd->variables.character_set_client = cs_save;

        thd->get_stmt_da()->set_overwrite_status(true);
        if ((error = (mysql_bin_log.write_event(&qinfo) ||
                      mysql_bin_log.commit(thd, true) || error))) {
          /*
            If we're here following THD::cleanup, thence the connection
            has been closed already. So lets print a message to the
            error log instead of pushing yet another error into the
            Diagnostics_area.

            Also, we keep the error flag so that we propagate the error
            up in the stack. This way, if we're the SQL thread we notice
            that close_temporary_tables failed. (Actually, the SQL
            thread only calls close_temporary_tables while applying old
            Start_log_event_v3 events.)
          */
          LogErr(ERROR_LEVEL, ER_BINLOG_FAILED_TO_WRITE_DROP_FOR_TEMP_TABLES);
        }
        thd->get_stmt_da()->set_overwrite_status(false);
      }

      thd->variables.pseudo_thread_id = save_pseudo_thread_id;
      thd->thread_specific_used = save_thread_specific_used;
    } else {
      next = table->next;
      /*
        This is for those cases when we have acquired lock but drop temporary
        table will not be logged.
      */
      mysql_lock_remove(thd, thd->lock, table);
      close_temporary(thd, table, true, true);
      slave_closed_temp_tables++;
    }
  }
  lex->drop_temporary = sav_drop_temp;
  lex->sql_command = sav_sql_command;

  if (!was_quote_show)
    thd->variables.option_bits &=
        ~OPTION_QUOTE_SHOW_CREATE; /* restore option */

  thd->temporary_tables = nullptr;
  if (thd->slave_thread) {
    atomic_replica_open_temp_tables -= slave_closed_temp_tables;
    thd->rli_slave->get_c_rli()->atomic_channel_open_temp_tables -=
        slave_closed_temp_tables;
  }

  return error;
}

/**
  Find table in global list.

  @param table          Pointer to table list
  @param db_name        Data base name
  @param table_name     Table name

  @returns Pointer to found table.
  @retval NULL  Table not found
*/

Table_ref *find_table_in_global_list(Table_ref *table, const char *db_name,
                                     const char *table_name) {
  for (; table; table = table->next_global) {
    if ((table->table == nullptr ||
         table->table->s->tmp_table == NO_TMP_TABLE) &&
        strcmp(table->db, db_name) == 0 &&
        strcmp(table->table_name, table_name) == 0)
      break;
  }
  return table;
}

/**
  Test that table is unique (It's only exists once in the table list)

  @param  table        table to be checked (must be updatable base table)
  @param  table_list   list of tables
  @param  check_alias  whether to check tables' aliases

  NOTE: to exclude derived tables from check we use following mechanism:
    a) during derived table processing set THD::derived_tables_processing
    b) Query_block::prepare set SELECT::exclude_from_table_unique_test if
       THD::derived_tables_processing set. (we can't use JOIN::execute
       because for PS we perform only Query_block::prepare, but we can't set
       this flag in Query_block::prepare if we are not sure that we are in
       derived table processing loop, because multi-update call fix_fields()
       for some its items (which mean Query_block::prepare for subqueries)
       before unique_table call to detect which tables should be locked for
       write).
    c) find_dup_table skip all tables which belong to SELECT with
       SELECT::exclude_from_table_unique_test set.
    Also SELECT::exclude_from_table_unique_test used to exclude from check
    tables of main SELECT of multi-delete and multi-update

    We also skip tables with Table_ref::prelocking_placeholder set,
    because we want to allow SELECTs from them, and their modification
    will rise the error anyway.

    TODO: when we will have table/view change detection we can do this check
          only once for PS/SP

  @retval !=0  found duplicate
  @retval 0 if table is unique
*/

static Table_ref *find_dup_table(const Table_ref *table, Table_ref *table_list,
                                 bool check_alias) {
  Table_ref *res;
  const char *d_name, *t_name, *t_alias;
  DBUG_TRACE;
  DBUG_PRINT("enter", ("table alias: %s", table->alias));

  assert(table == table->updatable_base_table());
  /*
    If this function called for CREATE command that we have not opened table
    (table->table equal to 0) and right names is in current Table_ref
    object.
  */
  if (table->table) {
    /* All MyISAMMRG children are plain MyISAM tables. */
    assert(table->table->file->ht->db_type != DB_TYPE_MRG_MYISAM);

    /* temporary table is always unique */
    if (table->table->s->tmp_table != NO_TMP_TABLE) return nullptr;
  }

  d_name = table->db;
  t_name = table->table_name;
  t_alias = table->alias;

  DBUG_PRINT("info", ("real table: %s.%s", d_name, t_name));
  for (;;) {
    /*
      Table is unique if it is present only once in the global list
      of tables and once in the list of table locks.
    */
    if (!(res = find_table_in_global_list(table_list, d_name, t_name))) break;

    /* Skip if same underlying table. */
    if (res->table && (res->table == table->table)) goto next;

    /* Skip if table alias does not match. */
    if (check_alias) {
      if (lower_case_table_names
              ? my_strcasecmp(files_charset_info, t_alias, res->alias)
              : strcmp(t_alias, res->alias))
        goto next;
    }

    /*
      Skip if marked to be excluded (could be a derived table) or if
      entry is a prelocking placeholder.
    */
    if (res->query_block && !res->query_block->exclude_from_table_unique_test &&
        !res->prelocking_placeholder)
      break;

    /*
      If we found entry of this table or table of SELECT which already
      processed in derived table or top select of multi-update/multi-delete
      (exclude_from_table_unique_test) or prelocking placeholder.
    */
  next:
    table_list = res->next_global;
    DBUG_PRINT("info",
               ("found same copy of table or table which we should skip"));
  }
  return res;
}

/**
  Test that the subject table of INSERT/UPDATE/DELETE/CREATE
  or (in case of MyISAMMRG) one of its children are not used later
  in the query.

  For MyISAMMRG tables, it is assumed that all the underlying
  tables of @c table (if any) are listed right after it and that
  their @c parent_l field points at the main table.

  @param  table      table to be checked (must be updatable base table)
  @param  table_list List of tables to check against
  @param  check_alias whether to check tables' aliases

  @retval non-NULL The table list element for the table that
                   represents the duplicate.
  @retval NULL     No duplicates found.
*/

Table_ref *unique_table(const Table_ref *table, Table_ref *table_list,
                        bool check_alias) {
  assert(table == table->updatable_base_table());

  Table_ref *dup;
  if (table->table && table->table->file->ht->db_type == DB_TYPE_MRG_MYISAM) {
    Table_ref *child;
    dup = nullptr;
    /* Check duplicates of all merge children. */
    for (child = table->next_global; child && child->parent_l == table;
         child = child->next_global) {
      if ((dup = find_dup_table(child, child->next_global, check_alias))) break;
    }
  } else
    dup = find_dup_table(table, table_list, check_alias);
  return dup;
}

/**
  Issue correct error message in case we found 2 duplicate tables which
  prevent some update operation

  @param update      table which we try to update
  @param operation   name of update operation
  @param duplicate   duplicate table which we found

  @note here we hide view underlying tables if we have them.
*/

void update_non_unique_table_error(Table_ref *update, const char *operation,
                                   Table_ref *duplicate) {
  update = update->top_table();
  duplicate = duplicate->top_table();
  if (!update->is_view() || !duplicate->is_view() ||
      update->view_query() == duplicate->view_query() ||
      update->table_name_length != duplicate->table_name_length ||
      update->db_length != duplicate->db_length ||
      my_strcasecmp(table_alias_charset, update->table_name,
                    duplicate->table_name) != 0 ||
      my_strcasecmp(table_alias_charset, update->db, duplicate->db) != 0) {
    /*
      it is not the same view repeated (but it can be parts of the same copy
      of view), so we have to hide underlying tables.
    */
    if (update->is_view()) {
      // Issue the ER_NON_INSERTABLE_TABLE error for an INSERT
      if (duplicate->is_view() &&
          update->view_query() == duplicate->view_query())
        my_error(!strncmp(operation, "INSERT", 6) ? ER_NON_INSERTABLE_TABLE
                                                  : ER_NON_UPDATABLE_TABLE,
                 MYF(0), update->alias, operation);
      else
        my_error(ER_VIEW_PREVENT_UPDATE, MYF(0),
                 (duplicate->is_view() ? duplicate->alias : update->alias),
                 operation, update->alias);
      return;
    }
    if (duplicate->is_view()) {
      my_error(ER_VIEW_PREVENT_UPDATE, MYF(0), duplicate->alias, operation,
               update->alias);
      return;
    }
  }
  my_error(ER_UPDATE_TABLE_USED, MYF(0), update->alias);
}

/**
  Find temporary table specified by database and table names in the
  THD::temporary_tables list.

  @return TABLE instance if a temporary table has been found; NULL otherwise.
*/

TABLE *find_temporary_table(THD *thd, const char *db, const char *table_name) {
  char key[MAX_DBKEY_LENGTH];
  size_t key_length = create_table_def_key_tmp(thd, db, table_name, key);
  return find_temporary_table(thd, key, key_length);
}

/**
  Find a temporary table specified by Table_ref instance in the
  THD::temporary_tables list.

  @return TABLE instance if a temporary table has been found; NULL otherwise.
*/

TABLE *find_temporary_table(THD *thd, const Table_ref *tl) {
  const char *key;
  size_t key_length;
  char key_suffix[TMP_TABLE_KEY_EXTRA];
  TABLE *table;

  key_length = get_table_def_key(tl, &key);

  int4store(key_suffix, thd->server_id);
  int4store(key_suffix + 4, thd->variables.pseudo_thread_id);

  for (table = thd->temporary_tables; table; table = table->next) {
    if ((table->s->table_cache_key.length ==
         key_length + TMP_TABLE_KEY_EXTRA) &&
        !memcmp(table->s->table_cache_key.str, key, key_length) &&
        !memcmp(table->s->table_cache_key.str + key_length, key_suffix,
                TMP_TABLE_KEY_EXTRA))
      return table;
  }
  return nullptr;
}

/**
  Find a temporary table specified by a key in the THD::temporary_tables list.

  @return TABLE instance if a temporary table has been found; NULL otherwise.
*/

static TABLE *find_temporary_table(THD *thd, const char *table_key,
                                   size_t table_key_length) {
  for (TABLE *table = thd->temporary_tables; table; table = table->next) {
    if (table->s->table_cache_key.length == table_key_length &&
        !memcmp(table->s->table_cache_key.str, table_key, table_key_length)) {
      return table;
    }
  }

  return nullptr;
}

/**
  Drop a temporary table.

  - If the table is locked with LOCK TABLES or by prelocking,
    unlock it and remove it from the list of locked tables
    (THD::lock). Currently only transactional temporary tables
    are locked.
  - Close the temporary table.
  - Remove the table from the list of temporary tables.
*/

void drop_temporary_table(THD *thd, Table_ref *table_list) {
  DBUG_TRACE;
  DBUG_PRINT("tmptable", ("closing table: '%s'.'%s'", table_list->db,
                          table_list->table_name));

  assert(is_temporary_table(table_list));

  TABLE *table = table_list->table;

  assert(!table->query_id || table->query_id == thd->query_id);

  /*
    If LOCK TABLES list is not empty and contains this table,
    unlock the table and remove the table from this list.
  */
  mysql_lock_remove(thd, thd->lock, table);
  close_temporary_table(thd, table, true, true);
  table_list->table = nullptr;
}

/*
  unlink from thd->temporary tables and close temporary table
*/

void close_temporary_table(THD *thd, TABLE *table, bool free_share,
                           bool delete_table) {
  DBUG_TRACE;
  DBUG_PRINT("tmptable",
             ("closing table: '%s'.'%s' %p  alias: '%s'", table->s->db.str,
              table->s->table_name.str, table, table->alias));

  if (table->prev) {
    table->prev->next = table->next;
    if (table->prev->next) table->next->prev = table->prev;
  } else {
    /* removing the item from the list */
    assert(table == thd->temporary_tables);
    /*
      slave must reset its temporary list pointer to zero to exclude
      passing non-zero value to end_slave via rli->save_temporary_tables
      when no temp tables opened, see an invariant below.
    */
    thd->temporary_tables = table->next;
    if (thd->temporary_tables) table->next->prev = nullptr;
  }
  if (thd->slave_thread) {
    /* natural invariant of temporary_tables */
    assert(thd->rli_slave->get_c_rli()->atomic_channel_open_temp_tables ||
           !thd->temporary_tables);
    --atomic_replica_open_temp_tables;
    --thd->rli_slave->get_c_rli()->atomic_channel_open_temp_tables;
  }
  close_temporary(thd, table, free_share, delete_table);
}

/*
  Close and delete a temporary table

  NOTE
    This doesn't unlink table from thd->temporary
    If this is needed, use close_temporary_table()
*/

void close_temporary(THD *thd, TABLE *table, bool free_share,
                     bool delete_table) {
  handlerton *table_type = table->s->db_type();
  DBUG_TRACE;
  DBUG_PRINT("tmptable", ("closing table: '%s'.'%s'", table->s->db.str,
                          table->s->table_name.str));

  free_io_cache(table);
  closefrm(table, false);
  if (delete_table) {
    assert(thd);
    rm_temporary_table(thd, table_type, table->s->path.str,
                       table->s->tmp_table_def);
  }

  if (free_share) {
    free_table_share(table->s);
    destroy(table);
    my_free(table);
  }
}

/*
  Used by ALTER TABLE when the table is a temporary one. It changes something
  only if the ALTER contained a RENAME clause (otherwise, table_name is the old
  name).
  Prepares a table cache key, which is the concatenation of db, table_name and
  thd->slave_proxy_id, separated by '\0'.
*/

bool rename_temporary_table(THD *thd, TABLE *table, const char *db,
                            const char *table_name) {
  char *key;
  size_t key_length;
  TABLE_SHARE *share = table->s;
  DBUG_TRACE;

  if (!(key = (char *)share->mem_root.Alloc(MAX_DBKEY_LENGTH)))
    return true; /* purecov: inspected */

  key_length = create_table_def_key_tmp(thd, db, table_name, key);
  share->set_table_cache_key(key, key_length);
  /* Also update table name in DD object. Database name is kept reset. */
  share->tmp_table_def->set_name(table_name);
  return false;
}

/**
   Force all other threads to stop using the table by upgrading
   metadata lock on it and remove unused TABLE instances from cache.

   @param thd      Thread handler
   @param table    Table to remove from cache
   @param function HA_EXTRA_PREPARE_FOR_DROP if table is to be deleted
                   HA_EXTRA_FORCE_REOPEN if table is not be used
                   HA_EXTRA_PREPARE_FOR_RENAME if table is to be renamed

   @note When returning, the table will be unusable for other threads
         until metadata lock is downgraded.

   @retval false Success.
   @retval true  Failure (e.g. because thread was killed).
*/

bool wait_while_table_is_used(THD *thd, TABLE *table,
                              enum ha_extra_function function) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("table: '%s'  share: %p  db_stat: %u  version: %lu",
                       table->s->table_name.str, table->s, table->db_stat,
                       table->s->version()));

  if (thd->mdl_context.upgrade_shared_lock(table->mdl_ticket, MDL_EXCLUSIVE,
                                           thd->variables.lock_wait_timeout))
    return true;

  tdc_remove_table(thd, TDC_RT_REMOVE_NOT_OWN, table->s->db.str,
                   table->s->table_name.str, false);
  /* extra() call must come only after all instances above are closed */
  (void)table->file->ha_extra(function);
  return false;
}

/**
    Check that table exists in data-dictionary or in some storage engine.

    @param       thd     Thread context
    @param       table   Table list element
    @param[out]  exists  Out parameter which is set to true if table
                         exists and to false otherwise.

    @note If there is no table in data-dictionary but it exists in one
          of engines (e.g. it was created on another node of NDB cluster)
          this function will fetch and add proper table description to
          the data-dictionary.

    @retval  true   Some error occurred
    @retval  false  No error. 'exists' out parameter set accordingly.
*/

static bool check_if_table_exists(THD *thd, Table_ref *table, bool *exists) {
  DBUG_TRACE;

  *exists = true;

  assert(thd->mdl_context.owns_equal_or_stronger_lock(
      MDL_key::TABLE, table->db, table->table_name, MDL_SHARED));

  if (dd::table_exists(thd->dd_client(), table->db, table->table_name, exists))
    return true;  // Error is already reported.

  if (*exists) goto end;

  /* Table doesn't exist. Check if some engine can provide it. */
  if (ha_check_if_table_exists(thd, table->db, table->table_name, exists)) {
    my_printf_error(ER_OUT_OF_RESOURCES,
                    "Failed to open '%-.64s', error while "
                    "unpacking from engine",
                    MYF(0), table->table_name);
    return true;
  }
end:
  return false;
}

/**
  An error handler which converts, if possible, ER_LOCK_DEADLOCK error
  that can occur when we are trying to acquire a metadata lock to
  a request for back-off and re-start of open_tables() process.
*/

class MDL_deadlock_handler : public Internal_error_handler {
 public:
  MDL_deadlock_handler(Open_table_context *ot_ctx_arg)
      : m_ot_ctx(ot_ctx_arg), m_is_active(false) {}

  bool handle_condition(THD *, uint sql_errno, const char *,
                        Sql_condition::enum_severity_level *,
                        const char *) override {
    if (!m_is_active && sql_errno == ER_LOCK_DEADLOCK) {
      /* Disable the handler to avoid infinite recursion. */
      m_is_active = true;
      (void)m_ot_ctx->request_backoff_action(
          Open_table_context::OT_BACKOFF_AND_RETRY, nullptr);
      m_is_active = false;
      /*
        If the above back-off request failed, a new instance of
        ER_LOCK_DEADLOCK error was emitted. Thus the current
        instance of error condition can be treated as handled.
      */
      return true;
    }
    return false;
  }

 private:
  /** Open table context to be used for back-off request. */
  Open_table_context *m_ot_ctx;
  /**
    Indicates that we are already in the process of handling
    ER_LOCK_DEADLOCK error. Allows to re-emit the error from
    the error handler without falling into infinite recursion.
  */
  bool m_is_active;
};

/**
  Try to acquire an MDL lock for a table being opened.

  @param[in,out] thd      Session context, to report errors.
  @param[out]    ot_ctx   Open table context, to hold the back off
                          state. If we failed to acquire a lock
                          due to a lock conflict, we add the
                          failed request to the open table context.
  @param[in,out] table_list Table list element for the table being opened.
                            Its "mdl_request" member specifies the MDL lock
                            to be requested. If we managed to acquire a
                            ticket (no errors or lock conflicts occurred),
                            Table_ref::mdl_request contains a reference
                            to it on return. However, is not modified if
                            MDL lock type- modifying flags were provided.
                            We also use Table_ref::lock_type member to
                            detect cases when MDL_SHARED_WRITE_LOW_PRIO
                            lock should be acquired instead of the normal
                            MDL_SHARED_WRITE lock.
  @param[in]    flags flags MYSQL_OPEN_FORCE_SHARED_MDL,
                          MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL or
                          MYSQL_OPEN_FAIL_ON_MDL_CONFLICT
                          @sa open_table().
  @param[out]   mdl_ticket Only modified if there was no error.
                          If we managed to acquire an MDL
                          lock, contains a reference to the
                          ticket, otherwise is set to NULL.

  @retval true  An error occurred.
  @retval false No error, but perhaps a lock conflict, check mdl_ticket.
*/

static bool open_table_get_mdl_lock(THD *thd, Open_table_context *ot_ctx,
                                    Table_ref *table_list, uint flags,
                                    MDL_ticket **mdl_ticket) {
  MDL_request *mdl_request = &table_list->mdl_request;
  MDL_request new_mdl_request;

  if (flags &
      (MYSQL_OPEN_FORCE_SHARED_MDL | MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL)) {
    /*
      MYSQL_OPEN_FORCE_SHARED_MDL flag means that we are executing
      PREPARE for a prepared statement and want to override
      the type-of-operation aware metadata lock which was set
      in the parser/during view opening with a simple shared
      metadata lock.
      This is necessary to allow concurrent execution of PREPARE
      and LOCK TABLES WRITE statement against the same table.

      MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL flag means that we open
      the table in order to get information about it for one of I_S
      queries and also want to override the type-of-operation aware
      shared metadata lock which was set earlier (e.g. during view
      opening) with a high-priority shared metadata lock.
      This is necessary to avoid unnecessary waiting and extra
      ER_WARN_I_S_SKIPPED_TABLE warnings when accessing I_S tables.

      These two flags are mutually exclusive.
    */
    assert(!(flags & MYSQL_OPEN_FORCE_SHARED_MDL) ||
           !(flags & MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL));

    MDL_REQUEST_INIT_BY_KEY(&new_mdl_request, &mdl_request->key,
                            (flags & MYSQL_OPEN_FORCE_SHARED_MDL)
                                ? MDL_SHARED
                                : MDL_SHARED_HIGH_PRIO,
                            MDL_TRANSACTION);
    mdl_request = &new_mdl_request;
  } else if (thd->variables.low_priority_updates &&
             mdl_request->type == MDL_SHARED_WRITE &&
             (table_list->lock_descriptor().type == TL_WRITE_DEFAULT ||
              table_list->lock_descriptor().type ==
                  TL_WRITE_CONCURRENT_DEFAULT)) {
    /*
      We are in @@low_priority_updates=1 mode and are going to acquire
      SW metadata lock on a table which for which neither LOW_PRIORITY nor
      HIGH_PRIORITY clauses were used explicitly.
      To keep compatibility with THR_LOCK locks and to avoid starving out
      concurrent LOCK TABLES READ statements, we need to acquire the low-prio
      version of SW lock instead of a normal SW lock in this case.
    */
    MDL_REQUEST_INIT_BY_KEY(&new_mdl_request, &mdl_request->key,
                            MDL_SHARED_WRITE_LOW_PRIO, MDL_TRANSACTION);
    mdl_request = &new_mdl_request;
  }

  if (flags & MYSQL_OPEN_FAIL_ON_MDL_CONFLICT) {
    /*
      When table is being open in order to get data for I_S table,
      we might have some tables not only open but also locked (e.g. when
      this happens under LOCK TABLES or in a stored function).
      As a result by waiting on a conflicting metadata lock to go away
      we may create a deadlock which won't entirely belong to the
      MDL subsystem and thus won't be detectable by this subsystem's
      deadlock detector.
      To avoid such situation we skip the trouble-making table if
      there is a conflicting lock.
    */
    if (thd->mdl_context.try_acquire_lock(mdl_request)) return true;
    if (mdl_request->ticket == nullptr) {
      my_error(ER_WARN_I_S_SKIPPED_TABLE, MYF(0), mdl_request->key.db_name(),
               mdl_request->key.name());
      return true;
    }
  } else {
    /*
      We are doing a normal table open. Let us try to acquire a metadata
      lock on the table. If there is a conflicting lock, acquire_lock()
      will wait for it to go away. Sometimes this waiting may lead to a
      deadlock, with the following results:
      1) If a deadlock is entirely within MDL subsystem, it is
         detected by the deadlock detector of this subsystem.
         ER_LOCK_DEADLOCK error is produced. Then, the error handler
         that is installed prior to the call to acquire_lock() attempts
         to request a back-off and retry. Upon success, ER_LOCK_DEADLOCK
         error is suppressed, otherwise propagated up the calling stack.
      2) Otherwise, a deadlock may occur when the wait-for graph
         includes edges not visible to the MDL deadlock detector.
         One such example is a wait on an InnoDB row lock, e.g. when:
         conn C1 gets SR MDL lock on t1 with SELECT * FROM t1
         conn C2 gets a row lock on t2 with  SELECT * FROM t2 FOR UPDATE
         conn C3 gets in and waits on C1 with DROP TABLE t0, t1
         conn C2 continues and blocks on C3 with SELECT * FROM t0
         conn C1 deadlocks by waiting on C2 by issuing SELECT * FROM
         t2 LOCK IN SHARE MODE.
         Such circular waits are currently only resolved by timeouts,
         e.g. @@innodb_lock_wait_timeout or @@lock_wait_timeout.

      Note that we want to force DML deadlock weight for our context
      when acquiring locks in this place. This is done to avoid situation
      when LOCK TABLES statement, which acquires strong SNRW and SRO locks
      on implicitly used tables, deadlocks with a concurrent DDL statement
      and the DDL statement is aborted since it is chosen as a deadlock
      victim. It is better to choose LOCK TABLES as a victim in this case
      as a deadlock can be easily caught here and handled by back-off and retry,
      without reporting any error to the user.
      We still have a few weird cases, like FLUSH TABLES <table-list> WITH
      READ LOCK, where we use "strong" metadata locks and open_tables() is
      called with some metadata locks pre-acquired. In these cases we still
      want to use DDL deadlock weight as back-off is not possible.
    */
    MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);

    thd->push_internal_handler(&mdl_deadlock_handler);
    thd->mdl_context.set_force_dml_deadlock_weight(ot_ctx->can_back_off());

    bool result =
        thd->mdl_context.acquire_lock(mdl_request, ot_ctx->get_timeout());

    thd->mdl_context.set_force_dml_deadlock_weight(false);
    thd->pop_internal_handler();

    if (result && !ot_ctx->can_recover_from_failed_open()) return true;
  }
  *mdl_ticket = mdl_request->ticket;
  return false;
}

/**
  Check if table's share is being removed from the table definition
  cache and, if yes, wait until the flush is complete.

  @param thd             Thread context.
  @param db              Database name.
  @param table_name      Table name.
  @param wait_timeout    Timeout for waiting.
  @param deadlock_weight Weight of this wait for deadlock detector.

  @retval false   Success. Share is up to date or has been flushed.
  @retval true    Error (OOM, our was killed, the wait resulted
                  in a deadlock or timeout). Reported.
*/

static bool tdc_wait_for_old_version(THD *thd, const char *db,
                                     const char *table_name, ulong wait_timeout,
                                     uint deadlock_weight) {
  TABLE_SHARE *share;
  bool res = false;

  mysql_mutex_lock(&LOCK_open);
  if ((share = get_cached_table_share(db, table_name)) &&
      share->has_old_version()) {
    struct timespec abstime;
    set_timespec(&abstime, wait_timeout);
    res = share->wait_for_old_version(thd, &abstime, deadlock_weight);
  }
  mysql_mutex_unlock(&LOCK_open);
  return res;
}

/**
  Add a dummy LEX object for a view.

  @param  thd         Thread context
  @param  table_list  The list of tables in the view

  @retval  true   error occurred
  @retval  false  view place holder successfully added
*/

bool add_view_place_holder(THD *thd, Table_ref *table_list) {
  Prepared_stmt_arena_holder ps_arena_holder(thd);
  LEX *lex_obj = new (thd->mem_root) st_lex_local;
  if (lex_obj == nullptr) return true;
  table_list->set_view_query(lex_obj);
  // Create empty list of view_tables.
  table_list->view_tables =
      new (thd->mem_root) mem_root_deque<Table_ref *>(thd->mem_root);
  if (table_list->view_tables == nullptr) return true;
  return false;
}

/**
  Open a base table.

  @param thd            Thread context.
  @param table_list     Open first table in list.
  @param ot_ctx         Context with flags which modify how open works
                        and which is used to recover from a failed
                        open_table() attempt.
                        Some examples of flags:
                        MYSQL_OPEN_IGNORE_FLUSH - Open table even if
                        someone has done a flush. No version number
                        checking is done.
                        MYSQL_OPEN_HAS_MDL_LOCK - instead of acquiring
                        metadata locks rely on that caller already has
                        appropriate ones.

  Uses a cache of open tables to find a TABLE instance not in use.

  If Table_ref::open_strategy is set to OPEN_IF_EXISTS, the table is
  opened only if it exists. If the open strategy is OPEN_STUB, the
  underlying table is never opened. In both cases, metadata locks are
  always taken according to the lock strategy.

  @retval true  Open failed. "action" parameter may contain type of action
                needed to remedy problem before retrying again.
  @retval false Success. Members of Table_ref structure are filled
  properly (e.g.  Table_ref::table is set for real tables and
                Table_ref::view is set for views).
*/

bool open_table(THD *thd, Table_ref *table_list, Open_table_context *ot_ctx) {
  TABLE *table = nullptr;
  TABLE_SHARE *share = nullptr;
  const char *key;
  size_t key_length;
  const char *alias = table_list->alias;
  uint flags = ot_ctx->get_flags();
  MDL_ticket *mdl_ticket = nullptr;
  int error = 0;

  DBUG_TRACE;

  // Temporary tables and derived tables are not allowed:
  assert(!is_temporary_table(table_list) && !table_list->is_derived());

  /*
    The table must not be opened already. The table can be pre-opened for
    some statements if it is a temporary table.

    open_temporary_table() must be used to open temporary tables.
    A derived table cannot be opened with this.
  */
  assert(table_list->is_view() || table_list->table == nullptr);

  /* an open table operation needs a lot of the stack space */
  if (check_stack_overrun(thd, STACK_MIN_SIZE_FOR_OPEN, (uchar *)&alias))
    return true;

  // New DD- In current_thd->is_strict_mode() mode we call open_table
  // on new DD tables like mysql.tables/* when CREATE fails and we
  // try to abort the operation and invoke quick_rm_table().
  // Currently, we ignore deleting table in strict mode. Need to fix this.
  // TODO.

  DBUG_EXECUTE_IF("kill_query_on_open_table_from_tz_find", {
    /*
      When on calling my_tz_find the following
      tables are opened in specified order: time_zone_name,
      time_zone, time_zone_transition_type,
      time_zone_transition. Emulate killing a query
      on opening the second table in the list.
    */
    if (!strcmp("time_zone", table_list->table_name))
      thd->killed = THD::KILL_QUERY;
  });

  if (!(flags & MYSQL_OPEN_IGNORE_KILLED) && thd->killed) return true;

  /*
    Check if we're trying to take a write lock in a read only transaction.

    Note that we allow write locks on log tables as otherwise logging
    to general/slow log would be disabled in read only transactions.
  */
  if (table_list->mdl_request.is_write_lock_request() && thd->tx_read_only &&
      !(flags & (MYSQL_LOCK_LOG_TABLE | MYSQL_OPEN_HAS_MDL_LOCK))) {
    my_error(ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION, MYF(0));
    return true;
  }

  /*
    FLUSH TABLES is ignored for DD, I_S and P_S tables/views.
    Hence setting MYSQL_OPEN_IGNORE_FLUSH flag.
  */
  if (table_list->is_system_view || belongs_to_dd_table(table_list) ||
      belongs_to_p_s(table_list))
    flags |= MYSQL_OPEN_IGNORE_FLUSH;

  key_length = get_table_def_key(table_list, &key);

  // If a table in a secondary storage engine has been requested,
  // adjust the key to refer to the secondary table.
  std::string secondary_key;
  if ((flags & MYSQL_OPEN_SECONDARY_ENGINE) != 0) {
    secondary_key = create_table_def_key_secondary(
        table_list->get_db_name(), table_list->get_table_name());
    key = secondary_key.data();
    key_length = secondary_key.length();
  }

  /*
    If we're in pre-locked or LOCK TABLES mode, let's try to find the
    requested table in the list of pre-opened and locked tables. If the
    table is not there, return an error - we can't open not pre-opened
    tables in pre-locked/LOCK TABLES mode.

    There is a special case where we allow opening not pre-opened tables
    in LOCK TABLES mode for new DD tables. The reason is as following.
    With new DD, IS system views need to be accessible in LOCK TABLE
    mode without user explicitly calling LOCK TABLE on IS view or its
    underlying DD tables. This is required to keep the old behavior the
    MySQL server had without new DD.

    In case user executes IS system view under LOCK TABLE mode
    (LTM and not prelocking), then MySQL server implicitly opens system
    view and related DD tables. Such DD tables are then implicitly closed
    upon end of statement execution.

    Our goal is to hide DD tables from users, so there is no possibility of
    explicit locking DD table using LOCK TABLE. In case user does LOCK TABLE
    on IS system view explicitly, MySQL server throws a error.

    TODO: move this block into a separate function.
  */
  if (thd->locked_tables_mode && !(flags & MYSQL_OPEN_GET_NEW_TABLE) &&
      !(in_LTM(thd) &&
        (table_list->is_system_view || belongs_to_dd_table(table_list) ||
         belongs_to_p_s(table_list)))) {  // Using table locks
    TABLE *best_table = nullptr;
    int best_distance = INT_MIN;
    for (table = thd->open_tables; table; table = table->next) {
      if (table->s->table_cache_key.length == key_length &&
          !memcmp(table->s->table_cache_key.str, key, key_length)) {
        if (!my_strcasecmp(system_charset_info, table->alias, alias) &&
            table->query_id != thd->query_id && /* skip tables already used */
            (thd->locked_tables_mode == LTM_LOCK_TABLES ||
             table->query_id == 0)) {
          int distance = ((int)table->reginfo.lock_type -
                          (int)table_list->lock_descriptor().type);

          /*
            Find a table that either has the exact lock type requested,
            or has the best suitable lock. In case there is no locked
            table that has an equal or higher lock than requested,
            we us the closest matching lock to be able to produce an error
            message about wrong lock mode on the table. The best_table
            is changed if bd < 0 <= d or bd < d < 0 or 0 <= d < bd.

            distance <  0 - No suitable lock found
            distance >  0 - we have lock mode higher then we require
            distance == 0 - we have lock mode exactly which we need
          */
          if ((best_distance < 0 && distance > best_distance) ||
              (distance >= 0 && distance < best_distance)) {
            best_distance = distance;
            best_table = table;
            if (best_distance == 0) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: set_non_locking_read_for_ACL_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_base.cc
Function: set_non_locking_read_for_ACL_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::convert_string
bool THD::convert_string(LEX_STRING *to, const CHARSET_INFO *to_cs,
                         const char *from, size_t from_length,
                         const CHARSET_INFO *from_cs, bool report_error) {
  DBUG_TRACE;
  size_t new_length = to_cs->mbmaxlen * from_length;
  if (!(to->str = (char *)alloc(new_length + 1))) {
    to->length = 0;  // Safety fix
    return true;     // EOM
  }
  uint errors = 0;
  to->length = copy_and_convert(to->str, new_length, to_cs, from, from_length,
                                from_cs, &errors);
  to->str[to->length] = 0;  // Safety
  if (errors != 0) {
    char printable_buff[32];
    convert_to_printable(printable_buff, sizeof(printable_buff), from,
                         from_length, from_cs, 6);
    if (report_error) {
      my_error(ER_CANNOT_CONVERT_STRING, MYF(0), printable_buff,
               from_cs->csname, to_cs->csname);
      return true;
    } else {
      push_warning_printf(this, Sql_condition::SL_WARNING,
                          ER_INVALID_CHARACTER_STRING,
                          ER_THD(this, ER_CANNOT_CONVERT_STRING),
                          printable_buff, from_cs->csname, to_cs->csname);
    }
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::vsyntax_error_at
  vsyntax_error_at(m_parser_state->m_lip.get_tok_start(),
                   ER_THD_NONCONST(this, mysql_errno), args);
  va_end(args);
}

/**
  Push a syntax error message into MySQL diagnostic area with line
  and position information.

  This function provides semantic action implementers with a way
  to push the famous "You have a syntax error near..." error
  message into the diagnostic area, which is normally produced only if
  a parse error is discovered internally by the Bison generated
  parser.

  @note Parse-time only function!

  @param location       YYSTYPE object: error position.
  @param format         Error format message. NULL means ER(ER_SYNTAX_ERROR).
*/

void THD::syntax_error_at(const YYLTYPE &location, const char *format, ...) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::raise_error
void THD::raise_error(uint sql_errno) {
  const char *msg = ER_THD_NONCONST(this, sql_errno);
  (void)raise_condition(sql_errno, nullptr, Sql_condition::SL_ERROR, msg);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::raise_condition not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::raise_condition not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::raise_error_printf
void THD::raise_error_printf(uint sql_errno, ...) {
  va_list args;
  char ebuff[MYSQL_ERRMSG_SIZE];
  DBUG_TRACE;
  DBUG_PRINT("my", ("nr: %d  errno: %d", sql_errno, errno));
  const char *format = ER_THD_NONCONST(this, sql_errno);
  va_start(args, sql_errno);
  vsnprintf(ebuff, sizeof(ebuff), format, args);
  va_end(args);
  (void)raise_condition(sql_errno, nullptr, Sql_condition::SL_ERROR, ebuff);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::raise_warning
void THD::raise_warning(uint sql_errno) {
  const char *msg = ER_THD_NONCONST(this, sql_errno);
  (void)raise_condition(sql_errno, nullptr, Sql_condition::SL_WARNING, msg);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::raise_warning_printf
void THD::raise_warning_printf(uint sql_errno, ...) {
  va_list args;
  char ebuff[MYSQL_ERRMSG_SIZE];
  DBUG_TRACE;
  DBUG_PRINT("enter", ("warning: %u", sql_errno));
  const char *format = ER_THD_NONCONST(this, sql_errno);
  va_start(args, sql_errno);
  vsnprintf(ebuff, sizeof(ebuff), format, args);
  va_end(args);
  (void)raise_condition(sql_errno, nullptr, Sql_condition::SL_WARNING, ebuff);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::raise_note
void THD::raise_note(uint sql_errno) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("code: %d", sql_errno));
  if (!(variables.option_bits & OPTION_SQL_NOTES)) return;
  const char *msg = ER_THD_NONCONST(this, sql_errno);
  (void)raise_condition(sql_errno, nullptr, Sql_condition::SL_NOTE, msg);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::raise_note_printf
void THD::raise_note_printf(uint sql_errno, ...) {
  va_list args;
  char ebuff[MYSQL_ERRMSG_SIZE];
  DBUG_TRACE;
  DBUG_PRINT("enter", ("code: %u", sql_errno));
  if (!(variables.option_bits & OPTION_SQL_NOTES)) return;
  const char *format = ER_THD_NONCONST(this, sql_errno);
  va_start(args, sql_errno);
  vsnprintf(ebuff, sizeof(ebuff), format, args);
  va_end(args);
  (void)raise_condition(sql_errno, nullptr, Sql_condition::SL_NOTE, ebuff);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::syntax_error
void THD::syntax_error(const char *format, ...) {
  va_list args;
  va_start(args, format);
  vsyntax_error_at(m_parser_state->m_lip.get_tok_start(), format, args);
  va_end(args);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_class.cc
Function: THD::syntax_error_at
  Unlike the syntax_error_at() function, the error position points to the last
  parsed token.

  @note Parse-time only function!

  @param format         Error format message. NULL means ER(ER_SYNTAX_ERROR).
*/
void THD::syntax_error(const char *format, ...) {
  va_list args;
  va_start(args, format);
  vsyntax_error_at(m_parser_state->m_lip.get_tok_start(), format, args);
  va_end(args);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_db.cc
Function: mysql_create_db
bool mysql_create_db(THD *thd, const char *db, HA_CREATE_INFO *create_info) {
  DBUG_TRACE;

  /*
    Use Auto_releaser to keep uncommitted object for database until
    trans_commit() call.
  */
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  // Reject creation of the system schema except for system threads.
  if (!thd->is_dd_system_thread() &&
      dd::get_dictionary()->is_dd_schema_name(db) &&
      !(create_info->options & HA_LEX_CREATE_IF_NOT_EXISTS)) {
    my_error(ER_NO_SYSTEM_SCHEMA_ACCESS, MYF(0), db);
    return true;
  }

  if (ha_check_reserved_db_name(db)) {
    my_error(ER_WRONG_DB_NAME, MYF(0), db);
    return true;
  }

  /*
    Check if user has permission to alter database, if encryption type
    provided differ from global 'default_table_encryption' setting.
    We use 'default_table_encryption' value if encryption is not supplied
    by user.
  */
  bool encrypt_schema = false;
  if (create_info->encrypt_type.str) {
    encrypt_schema = dd::is_encrypted(create_info->encrypt_type);
  } else {
    encrypt_schema = thd->variables.default_table_encryption;
  }
  if (opt_table_encryption_privilege_check &&
      encrypt_schema != thd->variables.default_table_encryption &&
      check_table_encryption_admin_access(thd)) {
    my_error(ER_CANNOT_SET_DATABASE_ENCRYPTION, MYF(0));
    return true;
  }

  /*
    When creating the schema, we must lock the schema name without case (for
    correct MDL locking) when l_c_t_n == 2.
  */
  char name_buf[NAME_LEN + 1];
  const char *lock_db_name = db;
  if (lower_case_table_names == 2) {
    my_stpcpy(name_buf, db);
    my_casedn_str(&my_charset_utf8mb3_tolower_ci, name_buf);
    lock_db_name = name_buf;
  }
  if (lock_schema_name(thd, lock_db_name)) return true;

  dd::cache::Dictionary_client &dc = *thd->dd_client();
  dd::String_type schema_name{db};
  const dd::Schema *existing_schema = nullptr;
  if (dc.acquire(schema_name, &existing_schema)) {
    return true;
  }

  bool store_in_dd = true;
  bool if_not_exists = (create_info->options & HA_LEX_CREATE_IF_NOT_EXISTS);
  if (existing_schema != nullptr) {
    if (if_not_exists == false) {
      my_error(ER_DB_CREATE_EXISTS, MYF(0), db);
      return true;
    }
    push_warning_printf(thd, Sql_condition::SL_NOTE, ER_DB_CREATE_EXISTS,
                        ER_THD(thd, ER_DB_CREATE_EXISTS), db);

    store_in_dd = false;
  }

  /* Check directory */
  char path[FN_REFLEN + 16];
  bool was_truncated;
  size_t path_len = build_table_filename(path, sizeof(path) - 1, db, "", "", 0,
                                         &was_truncated);
  if (was_truncated) {
    my_error(ER_IDENT_CAUSES_TOO_LONG_PATH, MYF(0), sizeof(path) - 1, path);
    return true;
  }
  path[path_len - 1] = 0;  // Remove last '/' from path

  // If we are creating the system schema, then we create it physically
  // only during first time server initialization. During ordinary restart,
  // we still execute the CREATE statement to initialize the meta data, but
  // the physical representation of the schema is not re-created since it
  // already exists.
  MY_STAT stat_info;
  bool schema_dir_exists =
      (mysql_file_stat(key_file_misc, path, &stat_info, MYF(0)) != nullptr);
  if (thd->is_dd_system_thread() &&
      (!opt_initialize || dd::upgrade_57::in_progress()) &&
      dd::get_dictionary()->is_dd_schema_name(db)) {
    /*
      CREATE SCHEMA statement is being executed from bootstrap thread.
      Server should either be in restart mode or upgrade mode to create only
      dd::Schema object for the dictionary cache.
    */
    if (!schema_dir_exists) {
      my_printf_error(ER_BAD_DB_ERROR,
                      "System schema directory does not exist.", MYF(0));
      return true;
    }
  } else if (store_in_dd) {
    if (schema_dir_exists) {
      my_error(ER_SCHEMA_DIR_EXISTS, MYF(0), path);
      return true;
    }

    // Don't create folder inside data directory in case we are upgrading.
    if (my_errno() != ENOENT) {
      char errbuf[MYSYS_STRERROR_SIZE];
      my_error(EE_STAT, MYF(0), path, my_errno(),
               my_strerror(errbuf, sizeof(errbuf), my_errno()));
      return true;
    }
    if (my_mkdir(path, 0777, MYF(0)) < 0) {
      char errbuf[MYSQL_ERRMSG_SIZE];
      my_error(ER_SCHEMA_DIR_CREATE_FAILED, MYF(0), db, my_errno(),
               my_strerror(errbuf, MYSQL_ERRMSG_SIZE, my_errno()));
      return true;
    }
  }

  /*
    Create schema in DD. This is done even when initializing the server
    and creating the system schema. In that case, the shared cache will
    store the object without storing it to disk. When the DD tables have
    been created, the cached objects will be stored persistently.
  */

  if (store_in_dd) {
    set_db_default_charset(thd, create_info);

    if (dd::create_schema(thd, db, create_info->default_table_charset,
                          encrypt_schema)) {
      /*
        We could be here due an deadlock or some error reported
        by DD API framework. We remove the database directory
        which we just created above.

        It is expected that rm_dir_w_symlink() would not fail as
        we already old MDL lock on database and no parallel
        thread can remove the table before the current create
        database operation. Even if the call fails due to some
        other error we ignore the error as we anyway return
        failure (true) here.
      */
      if (!schema_dir_exists) rm_dir_w_symlink(path, true);
      return true;
    }
  }

  // Log the query in the handler's binlog
  ha_binlog_log_query(thd, nullptr, LOGCOM_CREATE_DB, thd->query().str,
                      thd->query().length, db, "");

  /*
    If we have not added database to the data-dictionary we don't have
    active transaction at this point. In this case we can't use
    binlog's trx cache, which requires transaction with valid XID.
  */
  if (write_db_cmd_to_binlog(thd, db, store_in_dd)) {
    if (!schema_dir_exists) rm_dir_w_symlink(path, true);
    return true;
  }

  /*
    Do commit locally instead of relying on caller in order to be
    able to remove directory in case of failure.
  */
  if (trans_commit_stmt(thd) || trans_commit(thd)) {
    if (!schema_dir_exists) rm_dir_w_symlink(path, true);
    return true;
  }

  my_ok(thd, 1);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_db.cc
Function: mysql_rm_db
bool mysql_rm_db(THD *thd, const LEX_CSTRING &db, bool if_exists) {
  ulong deleted_tables = 0;
  bool error = false;
  char path[2 * FN_REFLEN + 16];
  Table_ref *tables = nullptr;
  Table_ref *table;
  Drop_table_error_handler err_handler;
  bool dropped_non_atomic = false;
  std::set<handlerton *> post_ddl_htons;
  Foreign_key_parents_invalidator fk_invalidator;

  DBUG_TRACE;

  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  // Reject dropping the system schema except for system threads.
  if (!thd->is_dd_system_thread() &&
      dd::get_dictionary()->is_dd_schema_name(dd::String_type(db.str))) {
    my_error(ER_NO_SYSTEM_SCHEMA_ACCESS, MYF(0), db.str);
    return true;
  }

  if (lock_schema_name(thd, db.str)) return true;

  build_table_filename(path, sizeof(path) - 1, db.str, "", "", 0);

  DEBUG_SYNC(thd, "before_acquire_in_drop_schema");
  const dd::Schema *schema = nullptr;
  if (thd->dd_client()->acquire(db.str, &schema)) return true;

  DBUG_EXECUTE_IF("pretend_no_schema_in_drop_schema", { schema = nullptr; });

  /* See if the directory exists */
  MY_DIR *schema_dirp = my_dir(path, MYF(MY_DONT_SORT));

  auto dirender = [](MY_DIR *dirp) { my_dirend(dirp); };
  std::unique_ptr<MY_DIR, decltype(dirender)> grd{schema_dirp, dirender};

  if (schema == nullptr)  // Schema not found in DD
  {
    if (schema_dirp != nullptr)  // Schema directory exists
    {
      // This is always an error, even when if_exists is true
      my_error(ER_SCHEMA_DIR_UNKNOWN, MYF(0), db.str, path);
      return true;
    }

    if (!if_exists)  // IF EXISTS not given
    {
      my_error(ER_DB_DROP_EXISTS, MYF(0), db.str);
      return true;
    }
    push_warning_printf(thd, Sql_condition::SL_NOTE, ER_DB_DROP_EXISTS,
                        ER_THD(thd, ER_DB_DROP_EXISTS), db.str);

    /*
      We don't have active transaction at this point so we can't use
      binlog's trx cache, which requires transaction with valid XID.
    */
    if (write_db_cmd_to_binlog(thd, db.str, false)) return true;

    if (trans_commit_stmt(thd) || trans_commit_implicit(thd)) return true;

    /* Fall-through to resetting current database in connection. */
  } else  // Schema found in DD
  {
    /* Database directory does not exist. */
    if (schema_dirp == nullptr) {
      if (!if_exists) {
        my_error(ER_SCHEMA_DIR_MISSING, MYF(0), path);
        return true;
      }
      push_warning_printf(thd, Sql_condition::SL_NOTE, ER_SCHEMA_DIR_MISSING,
                          ER_THD(thd, ER_SCHEMA_DIR_MISSING), path);
    } else {
      if (find_unknown_and_remove_deletable_files(thd, schema_dirp, path)) {
        return true;
      }
    }

    if (find_db_tables(thd, *schema, db.str, &tables)) {
      return true;
    }

    /* Lock all tables and stored routines about to be dropped. */
    if (lock_table_names(thd, tables, nullptr, thd->variables.lock_wait_timeout,
                         0) ||
        rm_table_do_discovery_and_lock_fk_tables(thd, tables) ||
        lock_check_constraint_names(thd, tables) ||
        Events::lock_schema_events(thd, *schema) ||
        lock_db_routines(thd, *schema) || lock_trigger_names(thd, tables))
      return true;

    /* mysql_ha_rm_tables() requires a non-null Table_ref. */
    if (tables) mysql_ha_rm_tables(thd, tables);

    for (table = tables; table; table = table->next_local) {
      deleted_tables++;
    }

    if (thd->killed) return true;

    thd->push_internal_handler(&err_handler);
    if (tables)
      error = mysql_rm_table_no_locks(thd, tables, true, false, true,
                                      &dropped_non_atomic, &post_ddl_htons,
                                      &fk_invalidator, nullptr);

    DBUG_EXECUTE_IF("rm_db_fail_after_dropping_tables", {
      my_error(ER_UNKNOWN_ERROR, MYF(0));
      error = true;
    });

    if (!error) {
      /*
        We temporarily disable the binary log while dropping SPs
        in the database. Since the DROP DATABASE statement is always
        replicated as a statement, execution of it will drop all objects
        in the database on the slave as well, so there is no need to
        replicate the removal of the individual objects in the database
        as well.

        This is more of a safety precaution, since normally no objects
        should be dropped while the database is being cleaned, but in
        the event that a change in the code to remove other objects is
        made, these drops should still not be logged.

        Notice that the binary log have to be enabled over the call to
        ha_drop_database(), since NDB otherwise detects the binary log
        as disabled and will not log the drop database statement on any
        other connected server.
      */

      ha_drop_database(path);
      thd->clear_error(); /* @todo Do not ignore errors */
      Disable_binlog_guard binlog_guard(thd);
      error = Events::drop_schema_events(thd, *schema);
      error = (error || sp_drop_db_routines(thd, *schema));
    }
    thd->pop_internal_handler();

    if (!error) error = thd->dd_client()->drop(schema);

    /*
      If database exists and there was no error we should
      write statement to binary log and remove DD entry.
    */
    if (!error) error = write_db_cmd_to_binlog(thd, db.str, true);

    if (!error) error = trans_commit_stmt(thd) || trans_commit(thd);

    /*
      In case of error rollback the transaction in order to revert
      changes which are possible to rollback (e.g. removal of tables
      in SEs supporting atomic DDL, events and routines).
    */
    if (error) {
      trans_rollback_stmt(thd);
      /*
        Play safe to be sure that THD::transaction_rollback_request is
        cleared before work-around code below is run. This also necessary
        to synchronize state of data-dicitionary on disk and in cache (to
        clear cache of uncommitted objects).
      */
      trans_rollback_implicit(thd);
    }

    /*
      Call post-DDL handlerton hook. For engines supporting atomic DDL
      tables' files are removed from disk on this step.
    */
    for (handlerton *hton : post_ddl_htons) hton->post_ddl(thd);

    fk_invalidator.invalidate(thd);

    /*
      Now we can try removing database directory.

      If the directory is a symbolic link, remove the link first, then
      remove the directory the symbolic link pointed at.

      This can happen only after post-DDL handlerton hook removes files
      from the directory.

      Since the statement is committed already, we do not report unlikely
      failure to remove the directory as an error. Instead we report it
      as a warning, which is sent to user and written to server error log.
    */
    if (!error && schema_dirp != nullptr) {
      Rmdir_error_handler rmdir_handler;
      thd->push_internal_handler(&rmdir_handler);
      (void)rm_dir_w_symlink(path, true);
      thd->pop_internal_handler();
    }

    if (error) {
      if (mysql_bin_log.is_open()) {
        /*
          If GTID_NEXT=='UUID:NUMBER', we must not log an incomplete
          statement.  However, the incomplete DROP has already 'committed'
          (some tables were removed).  So we generate an error and let
          user fix the situation.
        */
        if (thd->variables.gtid_next.type == ASSIGNED_GTID &&
            dropped_non_atomic) {
          char gtid_buf[Gtid::MAX_TEXT_LENGTH + 1];
          thd->variables.gtid_next.gtid.to_string(global_sid_map, gtid_buf,
                                                  true);
          my_error(ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID, MYF(0), path,
                   gtid_buf, db.str);
          return true;
        }
      }
      return true;
    }
  }

  /*
    If this database was the client's selected database, we silently
    change the client's selected database to nothing (to have an empty
    SELECT DATABASE() in the future). For this we free() thd->db and set
    it to 0.
  */
  if (thd->db().str && !strcmp(thd->db().str, db.str)) {
    mysql_change_db_impl(thd, NULL_CSTR, 0, thd->variables.collation_server);
    /*
      Check if current database tracker is enabled. If so, set the 'changed'
      flag.
    */
    if (thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)
            ->is_enabled()) {
      thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)
          ->mark_as_changed(thd, {});
    }
  }

  thd->server_status |= SERVER_STATUS_DB_DROPPED;
  my_ok(thd, deleted_tables);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_db.cc
Function: Rmdir_error_handler::handle_condition
  bool handle_condition(THD *thd, uint, const char *,
                        Sql_condition::enum_severity_level *,
                        const char *msg) override {
    if (!m_is_active) {
      /* Disable the handler to avoid infinite recursion. */
      m_is_active = true;
      push_warning_printf(thd, Sql_condition::SL_WARNING, ER_DB_DROP_RMDIR2,
                          ER_THD(thd, ER_DB_DROP_RMDIR2), msg);
      LogErr(WARNING_LEVEL, ER_DROP_DATABASE_FAILED_RMDIR_MANUALLY, msg);
      m_is_active = false;
      return true;
    }
    return false;
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_db.cc
Function: mysql_change_db
bool mysql_change_db(THD *thd, const LEX_CSTRING &new_db_name,
                     bool force_switch) {
  LEX_STRING new_db_file_name;
  LEX_CSTRING new_db_file_name_cstr;

  Security_context *sctx = thd->security_context();
  ulong db_access = sctx->current_db_access();
  const CHARSET_INFO *db_default_cl = nullptr;

  // We must make sure the schema is released and unlocked in the right order.
  dd::Schema_MDL_locker mdl_handler(thd);
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  const dd::Schema *schema = nullptr;

  DBUG_TRACE;
  DBUG_PRINT("enter", ("name: '%s'", new_db_name.str));

  if (new_db_name.str == nullptr || new_db_name.length == 0) {
    if (force_switch) {
      /*
        This can happen only if we're switching the current database back
        after loading stored program. The thing is that loading of stored
        program can happen when there is no current database.

        TODO: actually, new_db_name and new_db_name->str seem to be always
        non-NULL. In case of stored program, new_db_name->str == "" and
        new_db_name->length == 0.
      */

      mysql_change_db_impl(thd, NULL_CSTR, 0, thd->variables.collation_server);

      goto done;
    } else {
      my_error(ER_NO_DB_ERROR, MYF(0));

      return true;
    }
  }

  if (is_infoschema_db(new_db_name.str, new_db_name.length)) {
    /* Switch the current database to INFORMATION_SCHEMA. */

    mysql_change_db_impl(thd, INFORMATION_SCHEMA_NAME, SELECT_ACL,
                         system_charset_info);
    goto done;
  }

  /*
    Now we need to make a copy because check_db_name requires a
    non-constant argument. Actually, it takes database file name.

    TODO: fix check_db_name().
  */

  new_db_file_name.str = my_strndup(key_memory_THD_db, new_db_name.str,
                                    new_db_name.length, MYF(MY_WME));
  new_db_file_name.length = new_db_name.length;

  if (new_db_file_name.str == nullptr) return true; /* the error is set */

  /*
    NOTE: if check_db_name() fails, we should throw an error in any case,
    even if we are called from sp_head::execute().

    It's next to impossible however to get this error when we are called
    from sp_head::execute(). But let's switch the current database to NULL
    in this case to be sure.
  */

  if (check_and_convert_db_name(&new_db_file_name, false) !=
      Ident_name_check::OK) {
    my_free(new_db_file_name.str);

    if (force_switch)
      mysql_change_db_impl(thd, NULL_CSTR, 0, thd->variables.collation_server);
    return true;
  }
  new_db_file_name_cstr.str = new_db_file_name.str;
  new_db_file_name_cstr.length = new_db_file_name.length;
  DBUG_PRINT("info", ("Use database: %s", new_db_file_name.str));

  if (sctx->get_active_roles()->size() == 0) {
    db_access =
        sctx->check_access(DB_OP_ACLS, new_db_file_name.str)
            ? DB_OP_ACLS
            : acl_get(thd, sctx->host().str, sctx->ip().str,
                      sctx->priv_user().str, new_db_file_name.str, false) |
                  sctx->master_access(new_db_file_name.str);
  } else {
    db_access = sctx->db_acl(new_db_file_name_cstr) |
                sctx->master_access(new_db_file_name.str);
  }

  if (!force_switch && !(db_access & DB_OP_ACLS) &&
      check_grant_db(thd, new_db_file_name.str, true)) {
    my_error(ER_DBACCESS_DENIED_ERROR, MYF(0), sctx->priv_user().str,
             sctx->priv_host().str, new_db_file_name.str);
    query_logger.general_log_print(
        thd, COM_INIT_DB, ER_DEFAULT(ER_DBACCESS_DENIED_ERROR),
        sctx->priv_user().str, sctx->priv_host().str, new_db_file_name.str);
    my_free(new_db_file_name.str);
    return true;
  }

  if (mdl_handler.ensure_locked(new_db_file_name.str) ||
      thd->dd_client()->acquire(new_db_file_name.str, &schema)) {
    my_free(new_db_file_name.str);
    return true;
  }

  DEBUG_SYNC(thd, "acquired_schema_while_getting_collation");

  if (schema == nullptr) {
    if (force_switch) {
      /* Throw a warning and free new_db_file_name. */

      push_warning_printf(thd, Sql_condition::SL_NOTE, ER_BAD_DB_ERROR,
                          ER_THD(thd, ER_BAD_DB_ERROR), new_db_file_name.str);

      my_free(new_db_file_name.str);

      /* Change db to NULL. */
      mysql_change_db_impl(thd, NULL_CSTR, 0, thd->variables.collation_server);

      /* The operation succeed. */
      goto done;
    } else {
      /* Report an error and free new_db_file_name. */

      my_error(ER_BAD_DB_ERROR, MYF(0), new_db_file_name.str);
      my_free(new_db_file_name.str);

      /* The operation failed. */

      return true;
    }
  }

  if (get_default_db_collation(*schema, &db_default_cl)) {
    my_free(new_db_file_name.str);
    assert(thd->is_error() || thd->killed);
    return true;
  }

  db_default_cl = db_default_cl ? db_default_cl : thd->collation();
  /*
    NOTE: in mysql_change_db_impl() new_db_file_name is assigned to THD
    attributes and will be freed in THD::~THD().
  */
  mysql_change_db_impl(thd, new_db_file_name_cstr, db_access, db_default_cl);

done:
  /*
    Check if current database tracker is enabled. If so, set the 'changed' flag.
  */
  if (thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)->is_enabled()) {
    thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)
        ->mark_as_changed(thd, {});
  }
  if (thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
          ->is_enabled())
    thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
        ->mark_as_changed(thd, {});
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_error.cc
Function: push_deprecated_warn
void push_deprecated_warn(THD *thd, const char *old_syntax,
                          const char *new_syntax) {
  if (thd != nullptr)
    push_warning_printf(
        thd, Sql_condition::SL_WARNING, ER_WARN_DEPRECATED_SYNTAX,
        ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX), old_syntax, new_syntax);
  else
    LogErr(WARNING_LEVEL, ER_DEPRECATED_SYNTAX_WITH_REPLACEMENT, old_syntax,
           new_syntax);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_error.cc
Function: push_deprecated_warn_no_replacement
void push_deprecated_warn_no_replacement(THD *thd, const char *old_syntax) {
  if (thd != nullptr)
    push_warning_printf(thd, Sql_condition::SL_WARNING,
                        ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
                        ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT),
                        old_syntax);
  else
    LogErr(WARNING_LEVEL, ER_DEPRECATED_SYNTAX_NO_REPLACEMENT, old_syntax);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_error.cc
Function: warn_on_deprecated_collation
void warn_on_deprecated_collation(THD *thd, const CHARSET_INFO *collation,
                                  const char *option) {
  if (my_charset_same(collation, &my_charset_utf8mb3_general_ci)) {
    if (option == nullptr)
      push_warning_printf(thd, Sql_condition::SL_WARNING,
                          ER_WARN_DEPRECATED_UTF8MB3_COLLATION,
                          ER_THD(thd, ER_WARN_DEPRECATED_UTF8MB3_COLLATION),
                          collation->m_coll_name);
    else
      LogErr(WARNING_LEVEL, ER_WARN_DEPRECATED_UTF8MB3_COLLATION_OPTION, option,
             collation->m_coll_name);
  } else if (is_deprecated(collation->csname)) {
    if (option == nullptr)
      push_warning_printf(thd, Sql_condition::SL_WARNING,
                          ER_WARN_DEPRECATED_COLLATION,
                          ER_THD(thd, ER_WARN_DEPRECATED_COLLATION),
                          collation->m_coll_name, collation->csname, "utf8mb4");
    else
      LogErr(WARNING_LEVEL, ER_WARN_DEPRECATED_COLLATION_OPTION, option,
             collation->m_coll_name, collation->csname, "utf8mb4");
  }
  if (!(collation->state & MY_CS_COMPILED)) {
    if (option == nullptr) {
      push_warning_printf(
          thd, Sql_condition::SL_WARNING,
          ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS,
          ER_THD(thd, ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS),
          collation->m_coll_name);
    } else {
      LogErr(WARNING_LEVEL, ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS_OPTION,
             option, collation->m_coll_name);
    }
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_error.cc
Function: check_deprecated_datetime_format
void check_deprecated_datetime_format(THD *thd, const CHARSET_INFO *cs,
                                      MYSQL_TIME_STATUS &status) {
  if (status.m_deprecation.m_kind == MYSQL_TIME_STATUS::DEPRECATION::DP_NONE)
    return;

  // Before printing, sanitize the delimiter seen and the datetime string it
  // occurs in.
  char delim[10];
  const char c = status.m_deprecation.m_delim_seen;
  static constexpr char spaces[] = "\n\t\f\r\v";
  static constexpr char space_sym[] = "ntfrv";

  if (std::isprint(static_cast<unsigned char>(c))) {
    delim[0] = c;
    delim[1] = '\0';
  } else if (strchr(spaces, c) != nullptr) {
    // Escape with backslash the control characters NEWLINE, TAB, FORM FEED,
    // CARRIAGE RETURN and VERTICAL TAB.
    delim[0] = '\\';
    delim[1] = space_sym[strchr(spaces, c) - spaces];
    delim[2] = '\0';
  } else {
    assert(false);
    snprintf(delim, sizeof(delim), "\\%#02x",
             (unsigned int)status.m_deprecation.m_delim_seen & 0xff);
  }

  ErrConvString argument(status.m_deprecation.m_arg,
                         strlen(status.m_deprecation.m_arg), cs);
  char warn_buff[MYSQL_ERRMSG_SIZE];
  CHARSET_INFO *sys_cs = system_charset_info;

  switch (status.m_deprecation.m_kind) {
    case MYSQL_TIME_STATUS::DEPRECATION::DP_WRONG_KIND:
    case MYSQL_TIME_STATUS::DEPRECATION::DP_WRONG_SPACE:
      sys_cs->cset->snprintf(
          sys_cs, warn_buff, sizeof(warn_buff),
          ER_THD(thd, ER_WARN_DEPRECATED_DATETIME_DELIMITER), delim,
          status.m_deprecation.m_position, argument.ptr(),
          static_cast<int>(thd->get_stmt_da()->current_row_for_condition()),
          status.m_deprecation.m_kind ==
                  MYSQL_TIME_STATUS::DEPRECATION::DP_WRONG_SPACE
              ? ' '
              : (status.m_deprecation.m_colon ? ':' : '-'));
      push_warning(thd, Sql_condition::SL_WARNING,
                   ER_WARN_DEPRECATED_DATETIME_DELIMITER, warn_buff);
      break;
    case MYSQL_TIME_STATUS::DEPRECATION::DP_SUPERFLUOUS:
      sys_cs->cset->snprintf(
          sys_cs, warn_buff, sizeof(warn_buff),
          ER_THD(thd, ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER), delim,
          status.m_deprecation.m_position, argument.ptr(),
          static_cast<int>(thd->get_stmt_da()->current_row_for_condition()));
      push_warning(thd, Sql_condition::SL_WARNING,
                   ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER, warn_buff);
      break;
    default:
      break;
  }
  status.m_deprecation.m_kind = MYSQL_TIME_STATUS::DEPRECATION::DP_NONE;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_error.cc
Function: Diagnostics_area::set_error_status
void Diagnostics_area::set_error_status(THD *thd, uint mysql_errno) {
  set_error_status(mysql_errno, ER_THD_NONCONST(thd, mysql_errno),
                   mysql_errno_to_sqlstate(mysql_errno));
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_error.cc
Function: push_warning_printf
void push_warning_printf(THD *thd, Sql_condition::enum_severity_level severity,
                         uint code, const char *format, ...) {
  va_list args;
  char warning[MYSQL_ERRMSG_SIZE];
  DBUG_TRACE;
  DBUG_PRINT("enter", ("warning: %u", code));

  assert(code != 0);
  if (format == nullptr) format = ER_THD_NONCONST(thd, code);

  va_start(args, format);
  vsnprintf(warning, sizeof(warning), format, args);
  va_end(args);
  push_warning(thd, severity, code, warning);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.cc
Function: HINT_PARSER_error
void HINT_PARSER_error(THD *thd [[maybe_unused]], Hint_scanner *scanner,
                       PT_hint_list **, const char *msg) {
  if (strcmp(msg, "syntax error") == 0)
    msg = ER_THD(thd, ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR);
  scanner->syntax_warning(msg);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_lex_hints.cc
Function: Hint_scanner::syntax_warning
void Hint_scanner::syntax_warning(const char *msg) const {
  /* Push an error into the error stack */
  ErrConvString err(raw_yytext, input_buf_end - raw_yytext,
                    thd->variables.character_set_client);

  push_warning_printf(thd, Sql_condition::SL_WARNING, ER_PARSE_ERROR,
                      ER_THD(thd, ER_PARSE_ERROR), msg, err.ptr(),
                      static_cast<int>(lineno));
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_locale.cc
Function: my_locale_by_name
MY_LOCALE *my_locale_by_name(THD *thd, const char *name, size_t length) {
  MY_LOCALE *locale;

  if ((locale = my_locale_by_name(my_locales, name, length))) {
    // Check that locale is on its correct position in the array
    assert(locale == my_locales[locale->number]);
    return locale;
  } else if ((locale =
                  my_locale_by_name(my_locales_deprecated, name, length))) {
    /*
      Replace the deprecated locale to the corresponding
      'fresh' locale with the same ID.
    */
    locale = my_locales[locale->number];
    if (thd) {
      // Send a warning to the client
      push_warning_printf(
          thd, Sql_condition::SL_WARNING, ER_WARN_DEPRECATED_SYNTAX,
          ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX), name, locale->name);
    } else {
      // Send a warning to mysqld error log
      LogErr(WARNING_LEVEL, ER_DEPRECATE_MSG_WITH_REPLACEMENT, name,
             locale->name);
    }
  }
  return locale;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: hton_fill_schema_table
static int hton_fill_schema_table(THD *thd, Table_ref *tables, Item *cond) {
  DBUG_TRACE;

  struct run_hton_fill_schema_table_args args;
  args.tables = tables;
  args.cond = cond;

  /* INFORMATION_SCHEMA.TABLESPACES is deprecated in 8.0 by WL#14064.
   * This should be removed in 9.0 (or next GA) by WL#14065 */
  if (!my_strcasecmp(system_charset_info, tables->table_name, "TABLESPACES"))
    push_warning_printf(thd, Sql_condition::SL_WARNING,
                        ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
                        ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT),
                        "INFORMATION_SCHEMA.TABLESPACES");

  plugin_foreach(thd, run_hton_fill_schema_table, MYSQL_STORAGE_ENGINE_PLUGIN,
                 &args);

  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: Show_create_error_handler::handle_condition
  bool handle_condition(THD *thd, uint sql_errno, const char *,
                        Sql_condition::enum_severity_level *,
                        const char *msg) override {
    /*
       The handler does not handle the errors raised by itself.
       At this point we know if top_view is really a view.
    */
    if (m_handling || !m_top_view->is_view()) return false;

    m_handling = true;

    bool is_handled;

    switch (sql_errno) {
      case ER_TABLEACCESS_DENIED_ERROR:
        if (!strcmp(get_view_access_denied_message(thd), msg)) {
          /* Access to top view is not granted, don't interfere. */
          is_handled = false;
          break;
        }
        [[fallthrough]];
      case ER_COLUMNACCESS_DENIED_ERROR:
      // ER_VIEW_NO_EXPLAIN cannot happen here.
      case ER_PROCACCESS_DENIED_ERROR:
        is_handled = true;
        break;

      case ER_BAD_FIELD_ERROR:
        /*
          Established behavior: warn if column of underlying table is altered.
        */
      case ER_NO_SUCH_TABLE:
        /* Established behavior: warn if underlying tables are missing. */
      case ER_SP_DOES_NOT_EXIST:
        /* Established behavior: warn if underlying functions are missing. */
        push_warning_printf(thd, Sql_condition::SL_WARNING, ER_VIEW_INVALID,
                            ER_THD(thd, ER_VIEW_INVALID),
                            m_top_view->get_db_name(),
                            m_top_view->get_table_name());
        is_handled = true;
        break;
      default:
        is_handled = false;
    }

    m_handling = false;
    return is_handled;
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_show.cc
Function: Show_create_error_handler::get_view_access_denied_message
  const char *get_view_access_denied_message(THD *thd [[maybe_unused]]) {
    if (!m_view_access_denied_message_ptr) {
      m_view_access_denied_message_ptr = m_view_access_denied_message;
      snprintf(m_view_access_denied_message, MYSQL_ERRMSG_SIZE,
               ER_THD(thd, ER_TABLEACCESS_DENIED_ERROR), "SHOW VIEW",
               m_sctx->priv_user().str, m_sctx->host_or_ip().str,
               m_top_view->get_table_name());
    }
    return m_view_access_denied_message_ptr;
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: make_truncated_value_warning
bool make_truncated_value_warning(THD *thd,
                                  Sql_condition::enum_severity_level level,
                                  const ErrConvString &val,
                                  enum_mysql_timestamp_type time_type,
                                  const char *field_name) {
  char warn_buff[MYSQL_ERRMSG_SIZE];
  const char *type_str;
  CHARSET_INFO *cs = system_charset_info;

  switch (time_type) {
    case MYSQL_TIMESTAMP_DATE:
      type_str = "date";
      break;
    case MYSQL_TIMESTAMP_TIME:
      type_str = "time";
      break;
    case MYSQL_TIMESTAMP_DATETIME:  // FALLTHROUGH
    default:
      type_str = "datetime";
      break;
  }
  if (field_name)
    cs->cset->snprintf(
        cs, warn_buff, sizeof(warn_buff),
        ER_THD(thd, ER_TRUNCATED_WRONG_VALUE_FOR_FIELD), type_str, val.ptr(),
        field_name,
        static_cast<long>(thd->get_stmt_da()->current_row_for_condition()));
  else {
    if (time_type > MYSQL_TIMESTAMP_ERROR)
      cs->cset->snprintf(cs, warn_buff, sizeof(warn_buff),
                         ER_THD(thd, ER_TRUNCATED_WRONG_VALUE), type_str,
                         val.ptr());
    else
      cs->cset->snprintf(cs, warn_buff, sizeof(warn_buff),
                         ER_THD(thd, ER_WRONG_VALUE), type_str, val.ptr());
  }
  push_warning(thd, level, ER_TRUNCATED_WRONG_VALUE, warn_buff);

  // strict mode can convert warning to error. Check for error while returning.
  return thd->is_error();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_time.cc
Function: propagate_datetime_overflow_helper
void propagate_datetime_overflow_helper(THD *thd, int *warnings) {
  if (warnings && (*warnings & MYSQL_TIME_WARN_DATETIME_OVERFLOW) != 0) {
    push_warning_printf(thd, Sql_condition::SL_WARNING,
                        ER_DATETIME_FUNCTION_OVERFLOW,
                        ER_THD(thd, ER_DATETIME_FUNCTION_OVERFLOW), "datetime");
    *warnings &= ~(MYSQL_TIME_WARN_DATETIME_OVERFLOW);
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_trigger.cc
Function: get_table_for_trigger
bool get_table_for_trigger(THD *thd, const LEX_CSTRING &db_name,
                           const LEX_STRING &trigger_name,
                           bool continue_if_not_exist, Table_ref **table) {
  DBUG_TRACE;
  LEX *lex = thd->lex;
  *table = nullptr;

  // We must lock the schema when this function is called directly from
  // mysql_execute_command.
  dd::Schema_MDL_locker mdl_locker(thd);
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  const dd::Schema *sch_obj = nullptr;
  if (mdl_locker.ensure_locked(db_name.str) ||
      thd->dd_client()->acquire(db_name.str, &sch_obj))
    return true;

  if (sch_obj == nullptr) {
    if (continue_if_not_exist) {
      push_warning(thd, Sql_condition::SL_NOTE, ER_BAD_DB_ERROR,
                   ER_THD(thd, ER_BAD_DB_ERROR));
      return false;
    }

    my_error(ER_BAD_DB_ERROR, MYF(0), db_name.str);
    return true;
  }

  dd::String_type table_name;
  if (thd->dd_client()->get_table_name_by_trigger_name(
          *sch_obj, trigger_name.str, &table_name))
    return true;

  if (table_name == "") {
    if (continue_if_not_exist) {
      push_warning(thd, Sql_condition::SL_NOTE, ER_TRG_DOES_NOT_EXIST,
                   ER_THD(thd, ER_TRG_DOES_NOT_EXIST));
      return false;
    }

    my_error(ER_TRG_DOES_NOT_EXIST, MYF(0));
    return true;
  }

  char lc_table_name[NAME_LEN + 1];
  const char *table_name_ptr = table_name.c_str();
  if (lower_case_table_names == 2) {
    my_stpncpy(lc_table_name, table_name.c_str(), NAME_LEN);
    my_casedn_str(files_charset_info, lc_table_name);
    lc_table_name[NAME_LEN] = '\0';
    table_name_ptr = lc_table_name;
  }

  size_t table_name_length = strlen(table_name_ptr);

  *table = new (thd->mem_root) Table_ref(
      thd->strmake(db_name.str, db_name.length), db_name.length,
      thd->strmake(table_name_ptr, table_name_length), table_name_length,
      thd->mem_strdup(table_name_ptr), TL_IGNORE, MDL_SHARED_NO_WRITE);

  if (*table == nullptr) return true;

  (*table)->query_block = lex->current_query_block();
  (*table)->cacheable_table = true;

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_udf.cc
Function: mysql_create_function
bool mysql_create_function(THD *thd, udf_func *udf, bool if_not_exists) {
  bool error = true;
  void *dl = nullptr;
  int new_dl = 0;
  TABLE *table;

  DBUG_TRACE;

  if (!initialized) {
    if (opt_noacl)
      my_error(ER_CANT_INITIALIZE_UDF, MYF(0), udf->name.str,
               "UDFs are unavailable with the --skip-grant-tables option");
    else
      my_error(ER_OUT_OF_RESOURCES, MYF(0));
    return error;
  }

  /* must not be dynamically registered */
  assert(udf->dl);

  /*
    Ensure that the .dll doesn't have a path
    This is done to ensure that only approved dll from the system
    directories are used (to make this even remotely secure).
  */
  if (check_valid_path(udf->dl, strlen(udf->dl))) {
    my_error(ER_UDF_NO_PATHS, MYF(0));
    return error;
  }
  LEX_CSTRING udf_name_cstr = {udf->name.str, udf->name.length};
  if (check_string_char_length(udf_name_cstr, "", NAME_CHAR_LEN,
                               system_charset_info, true)) {
    my_error(ER_TOO_LONG_IDENT, MYF(0), udf->name.str);
    return error;
  }

  /*
    Acquire MDL SNRW for TL_WRITE type so that deadlock and
    timeout errors are avoided from the Storage Engine.
  */
  Table_ref tables("mysql", "func", TL_WRITE, MDL_SHARED_NO_READ_WRITE);

  if (open_and_lock_tables(thd, &tables, MYSQL_LOCK_IGNORE_TIMEOUT))
    return error;
  table = tables.table;

  /*
    System table mysql.func is supported by only InnoDB engine. Changing system
    table's engine is not allowed. But to support logical upgrade creating
    system table is allowed in MyISAM engine. CREATE FUNCTION operation is
    *not* allowed in this case.
  */
  if ((table->file->ht->is_supported_system_table != nullptr) &&
      !table->file->ht->is_supported_system_table(tables.db, tables.table_name,
                                                  true)) {
    my_error(ER_UNSUPPORTED_ENGINE, MYF(0),
             ha_resolve_storage_engine_name(table->file->ht), tables.db,
             tables.table_name);
    return error;
  }

  // CREATE FUNCTION operation is *not* allowed if table structure is changed.
  System_table_intact table_intact(thd);
  if (table_intact.check(thd, table, &mysql_udf_table_def)) return error;

  /*
    Turn off row binlogging of this statement and use statement-based
    so that all supporting tables are updated for CREATE FUNCTION command.
  */
  Save_and_Restore_binlog_format_state binlog_format_state(thd);

  mysql_rwlock_rdlock(&THR_LOCK_udf);
  if (udf_hash->count(to_string(udf->name)) != 0) {
    mysql_rwlock_unlock(&THR_LOCK_udf);

    // UDF with the same name already exists
    if (if_not_exists) {
      push_warning_printf(thd, Sql_condition::SL_NOTE, ER_UDF_EXISTS,
                          ER_THD(thd, ER_UDF_EXISTS), udf->name.str);
      error = (write_bin_log(thd, true, thd->query().str, thd->query().length,
                             false) != 0);
      if (error) error = udf_end_transaction(thd, error, nullptr, false);

    } else {
      my_error(ER_UDF_EXISTS, MYF(0), udf->name.str);
    }
    return error;
  }
  dl = find_udf_dl(udf->dl);
  mysql_rwlock_unlock(&THR_LOCK_udf);

  if (dl == nullptr) {
    char dlpath[FN_REFLEN];
    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, "/", udf->dl, NullS);
    (void)unpack_filename(dlpath, dlpath);

    if (!(dl = dlopen(dlpath, RTLD_NOW))) {
      const char *errmsg;
      int error_number = dlopen_errno;
      DLERROR_GENERATE(errmsg, error_number);

      DBUG_PRINT("error", ("dlopen of %s failed, error: %d (%s)", udf->dl,
                           error_number, errmsg));
      my_error(ER_CANT_OPEN_LIBRARY, MYF(0), udf->dl, error_number, errmsg);
      return error;
    }
    new_dl = 1;
  }
  udf->dlhandle = dl;
  {
    char buf[NAME_LEN + 16], *missing;
    if ((missing = init_syms(udf, buf))) {
      my_error(ER_CANT_FIND_DL_ENTRY, MYF(0), missing);
      if (new_dl) dlclose(dl);
      return error;
    }
  }

  // create entry in mysql.func table

  table->use_all_columns();
  restore_record(table, s->default_values);  // Default values for fields
  table->field[0]->store(udf->name.str, udf->name.length, system_charset_info);
  table->field[1]->store((longlong)udf->returns, true);
  table->field[2]->store(udf->dl, strlen(udf->dl), system_charset_info);
  if (table->s->fields >= 4)  // If not old func format
    table->field[3]->store((longlong)udf->type, true);
  error = (table->file->ha_write_row(table->record[0]) != 0);

  // Binlog the create function.
  if (!error)
    error = (write_bin_log(thd, true, thd->query().str, thd->query().length,
                           true) != 0);

  error = udf_end_transaction(thd, error, udf, true);

  if (error) {
    char errbuf[MYSYS_STRERROR_SIZE];
    my_error(ER_ERROR_ON_WRITE, MYF(0), "mysql.func", error,
             my_strerror(errbuf, sizeof(errbuf), error));
    if (new_dl) dlclose(dl);
  }
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: Sys_var_gtid_mode::global_update
bool Sys_var_charptr::global_update(THD *, set_var *var) {
  char *new_val, *ptr = var->save_result.string_value.str;
  size_t len = var->save_result.string_value.length;
  if (ptr) {
    new_val = (char *)my_memdup(key_memory_Sys_var_charptr_value, ptr, len + 1,
                                MYF(MY_WME));
    if (!new_val) return true;
    new_val[len] = 0;
  } else
    new_val = nullptr;
  if (flags & ALLOCATED) my_free(global_var(char *));
  flags |= ALLOCATED;
  global_var(char *) = new_val;
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: Sys_var_enforce_gtid_consistency::global_update
bool Sys_var_charptr::global_update(THD *, set_var *var) {
  char *new_val, *ptr = var->save_result.string_value.str;
  size_t len = var->save_result.string_value.length;
  if (ptr) {
    new_val = (char *)my_memdup(key_memory_Sys_var_charptr_value, ptr, len + 1,
                                MYF(MY_WME));
    if (!new_val) return true;
    new_val[len] = 0;
  } else
    new_val = nullptr;
  if (flags & ALLOCATED) my_free(global_var(char *));
  flags |= ALLOCATED;
  global_var(char *) = new_val;
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: update_deprecated
static bool update_deprecated(sys_var *self, THD *thd, enum_var_type) {
  push_warning_printf(
      thd, Sql_condition::SL_WARNING, ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
      ER_THD(thd, ER_WARN_DEPRECATED_SYSVAR_UPDATE), self->name.str);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_value_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_value_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_value_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_value_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_value_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_value_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: replica_parallel_workers_update not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: replica_parallel_workers_update not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_slave_skip_counter
static bool check_slave_skip_counter(sys_var *, THD *thd, set_var *var) {
  /*
    @todo: move this check into the set function and hold the lock on
    Gtid_mode::lock until the operation has completed, so that we are
    sure a concurrent connection does not change gtid_mode between
    check and fix.
  */
  if (global_gtid_mode.get() == Gtid_mode::ON &&
      var->save_result.ulonglong_value > 0)
    push_warning(
        thd, Sql_condition::SL_WARNING,
        ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON,
        ER_THD(thd, ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON));
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: fix_replica_net_timeout
static bool fix_replica_net_timeout(sys_var *, THD *thd, enum_var_type) {
  DEBUG_SYNC(thd, "fix_replica_net_timeout");
  Master_info *mi;

  /* @TODO: slave net timeout is for all channels, but does this make
           sense?
   */

  /*
   Here we have lock on LOCK_global_system_variables and we need
    lock on channel_map lock. In START_SLAVE handler, we take these
    two locks in different order. This can lead to DEADLOCKs. See
    BUG#14236151 for more details.
   So we release lock on LOCK_global_system_variables before acquiring
    lock on channel_map lock. But this could lead to isolation issues
    between multiple setters. Hence introducing secondary guard
    for this global variable and releasing the lock here and acquiring
    locks back again at the end of this function.
   */
  mysql_mutex_unlock(&LOCK_replica_net_timeout);
  mysql_mutex_unlock(&LOCK_global_system_variables);
  channel_map.wrlock();

  for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();
       it++) {
    mi = it->second;

    DBUG_PRINT("info",
               ("replica_net_timeout=%u mi->heartbeat_period=%.3f",
                replica_net_timeout, (mi ? mi->heartbeat_period : 0.0)));
    if (mi != nullptr && replica_net_timeout < mi->heartbeat_period)
      push_warning(thd, Sql_condition::SL_WARNING,
                   ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX,
                   ER_THD(thd, ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX));
  }

  channel_map.unlock();
  mysql_mutex_lock(&LOCK_global_system_variables);
  mysql_mutex_lock(&LOCK_replica_net_timeout);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_slow_log_extra
static bool check_slow_log_extra(sys_var *, THD *thd, set_var *) {
  // If FILE is not one of the log-targets, succeed but warn!
  if (!(log_output_options & LOG_FILE))
    push_warning(
        thd, Sql_condition::SL_WARNING,
        ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE,
        ER_THD(thd, ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE));

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: update_deprecated_with_removal_message not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: update_deprecated_with_removal_message not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_sql_mode
static bool check_sql_mode(sys_var *, THD *thd, set_var *var) {
  sql_mode_t candidate_mode =
      expand_sql_mode(var->save_result.ulonglong_value, thd);

  if (candidate_mode & ~(MODE_ALLOWED_MASK | MODE_IGNORED_MASK)) {
    my_error(ER_UNSUPPORTED_SQL_MODE, MYF(0),
             candidate_mode & ~(MODE_ALLOWED_MASK | MODE_IGNORED_MASK));
    return true;  // mode seems never supported before
  }

  if (candidate_mode & ~MODE_ALLOWED_MASK) {
    if (thd->variables.pseudo_replica_mode &&  // (1)
        thd->lex->sphead == nullptr) {         // (2)
      /*
        (1): catch the auto-generated SET SQL_MODE calls in the output of
             mysqlbinlog,
        (2): but ignore the other ones (e.g. nested SET SQL_MODE calls in
             SBR-invoked trigger calls).
      */
      push_warning_printf(
          thd, Sql_condition::SL_WARNING, ER_WARN_REMOVED_SQL_MODE,
          ER_THD(thd, ER_WARN_REMOVED_SQL_MODE),
          static_cast<uint>(candidate_mode & ~MODE_ALLOWED_MASK));
      // ignore obsolete mode flags in case this is an old mysqlbinlog:
      candidate_mode &= MODE_ALLOWED_MASK;
    } else {
      my_error(ER_UNSUPPORTED_SQL_MODE, MYF(0),
               candidate_mode & ~MODE_ALLOWED_MASK);
      return true;  // error on obsolete mode flags
    }
  }

  if (candidate_mode & MODE_PAD_CHAR_TO_FULL_LENGTH) {
    push_warning_printf(
        thd, Sql_condition::SL_WARNING, ER_WARN_DEPRECATED_SQLMODE,
        ER_THD(thd, ER_WARN_DEPRECATED_SQLMODE), "PAD_CHAR_TO_FULL_LENGTH");
  }

  var->save_result.ulonglong_value = candidate_mode;
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_optimizer_switch not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_optimizer_switch not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_net_buffer_length
static bool check_net_buffer_length(sys_var *self, THD *thd, set_var *var) {
  longlong val;
  if (session_readonly(self, thd, var)) return true;

  val = var->save_result.ulonglong_value;
  if (val > (longlong)global_system_variables.max_allowed_packet) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_OPTION_BELOW_LIMIT,
                        ER_THD(thd, WARN_OPTION_BELOW_LIMIT),
                        "max_allowed_packet", "net_buffer_length");
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_max_allowed_packet
static bool check_max_allowed_packet(sys_var *self, THD *thd, set_var *var) {
  longlong val;
  if (session_readonly(self, thd, var)) return true;

  val = var->save_result.ulonglong_value;
  if (val < (longlong)global_system_variables.net_buffer_length) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_OPTION_BELOW_LIMIT,
                        ER_THD(thd, WARN_OPTION_BELOW_LIMIT),
                        "max_allowed_packet", "net_buffer_length");
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_log_error_suppression_list not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_log_error_suppression_list not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_log_error_services
static bool check_log_error_services(sys_var *self, THD *thd, set_var *var) {
  // test whether syntax is OK and services exist
  size_t pos;
  log_error_stack_error ret;

  if (var->save_result.string_value.str == nullptr) return true;

  ret = log_builtins_error_stack(var->save_result.string_value.str, true, &pos);

  if (strlen(var->save_result.string_value.str) < 1) {
    push_warning_printf(
        thd, Sql_condition::SL_WARNING, ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE,
        ER_THD(thd, ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE), self->name.str);
  } else if (ret != LOG_ERROR_STACK_SUCCESS) {
    int err_code = 0;
    switch (ret) {
      case LOG_ERROR_STACK_NO_PFS_SUPPORT:
        err_code = ER_DA_ERROR_LOG_TABLE_DISABLED;
        break;
      case LOG_ERROR_STACK_NO_LOG_PARSER:
        err_code = ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED;
        break;
      case LOG_ERROR_MULTIPLE_FILTERS:
        err_code = ER_DA_ERROR_LOG_MULTIPLE_FILTERS;
        break;
      default:
        push_warning_printf(
            thd, Sql_condition::SL_WARNING, ER_CANT_SET_ERROR_LOG_SERVICE,
            ER_THD(thd, ER_CANT_SET_ERROR_LOG_SERVICE), self->name.str,
            &((char *)var->save_result.string_value.str)[pos]);
        return true;
    }

    push_warning(thd, Sql_condition::SL_NOTE, err_code,
                 ER_THD_NONCONST(thd, err_code));
    return false;
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: fix_log_error_services not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: fix_log_error_services not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_log_bin_use_v1_row_events
static bool check_log_bin_use_v1_row_events(sys_var *, THD *thd, set_var *var) {
  if (var->save_result.ulonglong_value == 1 &&
      global_system_variables.binlog_row_value_options != 0)
    push_warning_printf(thd, Sql_condition::SL_WARNING,
                        ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED,
                        ER_THD(thd, ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED),
                        "binlog_row_value_options=PARTIAL_JSON");
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_explicit_defaults_for_timestamp not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_explicit_defaults_for_timestamp not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_image not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_binlog_row_image not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: binlog_format_check
static bool binlog_format_check(sys_var *self, THD *thd, set_var *var) {
  if (check_session_admin(self, thd, var)) return true;

  if (var->type == OPT_GLOBAL || var->type == OPT_PERSIST) {
    /*
      SET @@global.binlog_format and SET @@persist.binlog_format must be
      disallowed if any replication channel has open temporary table(s).
      Otherwise DROP TEMPORARY TABLE is written into binary log on slave
      (which disobeys the simple rule: When @@session.binlog_format=
       ROW/MIXED, the server must not write CREATE/DROP TEMPORARY TABLE
      to the binary log) in the following case:
        slave> SET @@global.binlog_format=STATEMENT;
        slave> START SLAVE;
        master> CREATE TEMPORARY TABLE t1(a INT);
        slave> [wait for t1 to replicate]
        slave> STOP SLAVE;
        slave> SET @@global.binlog_format=ROW / SET @@persist.binlog_format=ROW
        master> DROP TEMPORARY TABLE t1;
        slave> START SLAVE;
      Note: SET @@persist_only.binlog_format is not disallowed if any
      replication channel has temporary table(s), since unlike PERSIST,
      PERSIST_ONLY does not modify the runtime global system variable value.

      SET @@global.binlog_format and SET @@persist.binlog_format must be
      disallowed if any replication channel applier is running, because
      SET @@global.binlog_format does not take effect when any replication
      channel applier is running. SET @@global.binlog_format takes effect
      on the channel until its applier is (re)starting.
      Note: SET @@persist_only.binlog_format is not disallowed if any
      replication channel applier is running, since unlike PERSIST,
      PERSIST_ONLY does not modify the runtime global system variable value.
    */
    enum_slave_channel_status slave_channel_status =
        has_any_slave_channel_open_temp_table_or_is_its_applier_running();
    if (slave_channel_status == SLAVE_CHANNEL_APPLIER_IS_RUNNING) {
      my_error(ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT, MYF(0));
      return true;
    } else if (slave_channel_status == SLAVE_CHANNEL_HAS_OPEN_TEMPORARY_TABLE) {
      my_error(ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT, MYF(0));
      return true;
    }
  }

  if (!var->is_global_persist()) {
    /*
      SET @@session.binlog_format must be disallowed if the session has open
      temporary table(s). Otherwise DROP TEMPORARY TABLE is written into
      binary log (which disobeys the simple rule: When
      @@session.binlog_format=ROW/MIXED, the server must not write
      CREATE/DROP TEMPORARY TABLE to the binary log) in the following case:
        SET @@session.binlog_format=STATEMENT;
        CREATE TEMPORARY TABLE t1 (a INT);
        SET @@session.binlog_format=ROW;
        DROP TEMPORARY TABLE t1;
      And more, if binlog_format=ROW/MIXED and the session has open temporary
      table(s), these CREATE TEMPORARY TABLE are not written into the binlog,
      so we can not switch to STATEMENT.
    */
    if (thd->temporary_tables) {
      my_error(ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT, MYF(0));
      return true;
    }

    /*
      if in a stored function/trigger, it's too late to change mode
    */
    if (thd->in_sub_stmt) {
      my_error(ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT, MYF(0));
      return true;
    }
    /*
      Make the session variable 'binlog_format' read-only inside a transaction.
    */
    if (thd->in_active_multi_stmt_transaction()) {
      my_error(ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT, MYF(0));
      return true;
    }
  }

  /*
    If moving to statement format, and binlog_row_value_options is set,
    generate a warning.
  */
  if (var->save_result.ulonglong_value == BINLOG_FORMAT_STMT) {
    if ((var->is_global_persist() &&
         global_system_variables.binlog_row_value_options != 0) ||
        (!var->is_global_persist() &&
         thd->variables.binlog_row_value_options != 0)) {
      push_warning_printf(thd, Sql_condition::SL_WARNING,
                          ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED,
                          ER_THD(thd, ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED),
                          "binlog_format=STATEMENT", "PARTIAL_JSON");
    }
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: performance_schema_show_processlist_update not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: performance_schema_show_processlist_update not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: issue_deprecation_warnings_gtid_mode not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: issue_deprecation_warnings_gtid_mode not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: check_sub_modes_of_strict_mode
static void check_sub_modes_of_strict_mode(sql_mode_t &sql_mode, THD *thd) {
  const sql_mode_t strict_modes =
      (MODE_STRICT_TRANS_TABLES | MODE_STRICT_ALL_TABLES);

  const sql_mode_t new_strict_submodes =
      (MODE_NO_ZERO_IN_DATE | MODE_NO_ZERO_DATE |
       MODE_ERROR_FOR_DIVISION_BY_ZERO);

  const sql_mode_t strict_modes_set = (sql_mode & strict_modes);
  const sql_mode_t new_strict_submodes_set = (sql_mode & new_strict_submodes);

  if (((strict_modes_set | new_strict_submodes_set) != 0) &&
      ((new_strict_submodes_set != new_strict_submodes) ||
       (strict_modes_set == 0))) {
    if (thd)
      push_warning(thd, Sql_condition::SL_WARNING, ER_SQL_MODE_MERGED,
                   ER_THD(thd, ER_SQL_MODE_MERGED));
    else
      LogErr(WARNING_LEVEL, ER_SQL_MODE_MERGED_WITH_STRICT_MODE);
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sys_vars.cc
Function: event_scheduler_restart
static void event_scheduler_restart(THD *thd) {
  /*
    Restart event scheduler if needed.

    At present, turning on SUPER_READ_ONLY means that we
    can no longer acquire an MDL to update mysql.*.
    As a result of this, updating the "last run at ..."
    timestamp of events fails, and the event scheduler
    shuts down when trying to do so.

    As a convenience, we restart the event scheduler when
    [SUPER_]READ_ONLY is turned off while the scheduler is
    enabled (in the settings), but not actually running.
  */
  if (Events::opt_event_scheduler == Events::EVENTS_ON) {
    bool evsched_error;       // Did we fail to start the event scheduler?
    int evsched_errcode = 0;  // If we failed, what was the actual error code?

    /*
      We must not hold the lock while starting the event scheduler,
      as that will internally try to take the lock while creating a THD.
    */
    mysql_mutex_unlock(&LOCK_global_system_variables);
    evsched_error = Events::start(&evsched_errcode);
    mysql_mutex_lock(&LOCK_global_system_variables);

    if (evsched_error) {
      /*
        The user requested a change of super_read_only.
        That change succeeded, so we do not signal a failure here,
        since it is only the side-effect/convenience of restarting
        the event scheduler that failed.
        We do however notify them of that failure, since we're
        just that nice.
        We also do not modify opt_event_scheduler, since user
        intent has not changed. If this policy ever changes,
        opt_event_scheduler should probably be unset when the
        event scheduler shuts down.
      */
      push_warning_printf(thd, Sql_condition::SL_WARNING,
                          ER_EVENT_SET_VAR_ERROR,
                          ER_THD(thd, ER_EVENT_SET_VAR_ERROR), evsched_errcode);
    }
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: View_creation_ctx::create
View_creation_ctx *View_creation_ctx::create(THD *thd) {
  View_creation_ctx *ctx = new (thd->mem_root) View_creation_ctx(thd);

  return ctx;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: Table_check_intact::check
bool Table_check_intact::check(THD *thd [[maybe_unused]], TABLE *table,
                               const TABLE_FIELD_DEF *table_def) {
  uint i;
  bool error = false;
  const TABLE_FIELD_TYPE *field_def = table_def->field;
  DBUG_TRACE;
  DBUG_PRINT("info",
             ("table: %s  expected_count: %d", table->alias, table_def->count));

  /* Whether the table definition has already been validated. */
  if (table->s->table_field_def_cache == table_def) goto end;

  if (table->s->fields != table_def->count) {
    DBUG_PRINT("info", ("Column count has changed, checking the definition"));

    /* previous MySQL version */
    if (MYSQL_VERSION_ID > table->s->mysql_version) {
      report_error(ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2,
                   ER_THD(thd, ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2),
                   table->s->db.str, table->alias, table_def->count,
                   table->s->fields, static_cast<int>(table->s->mysql_version),
                   MYSQL_VERSION_ID);
      return true;
    } else if (MYSQL_VERSION_ID == table->s->mysql_version) {
      report_error(ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2,
                   ER_THD(thd, ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2),
                   table->s->db.str, table->s->table_name.str, table_def->count,
                   table->s->fields);
      return true;
    }
    /*
      Something has definitely changed, but we're running an older
      version of MySQL with new system tables.
      Let's check column definitions. If a column was added at
      the end of the table, then we don't care much since such change
      is backward compatible.
    */
  }
  char buffer[STRING_BUFFER_USUAL_SIZE];
  for (i = 0; i < table_def->count; i++, field_def++) {
    String sql_type(buffer, sizeof(buffer), system_charset_info);
    sql_type.length(0);
    if (i < table->s->fields) {
      Field *field = table->field[i];

      if (strncmp(field->field_name, field_def->name.str,
                  field_def->name.length)) {
        /*
          Name changes are not fatal, we use ordinal numbers to access columns.
          Still this can be a sign of a tampered table, output an error
          to the error log.
        */
        report_error(0,
                     "Incorrect definition of table %s.%s: "
                     "expected column '%s' at position %d, found '%s'.",
                     table->s->db.str, table->alias, field_def->name.str, i,
                     field->field_name);
      }
      field->sql_type(sql_type);
      /*
        Generally, if column types don't match, then something is
        wrong.

        However, we only compare column definitions up to the
        length of the original definition, since we consider the
        following definitions compatible:

        1. DATETIME and DATETIM
        2. INT(11) and INT(11
        3. SET('one', 'two') and SET('one', 'two', 'more')

        For SETs or ENUMs, if the same prefix is there it's OK to
        add more elements - they will get higher ordinal numbers and
        the new table definition is backward compatible with the
        original one.
       */
      if (strncmp(sql_type.c_ptr_safe(), field_def->type.str,
                  field_def->type.length - 1)) {
        report_error(ER_CANNOT_LOAD_FROM_TABLE_V2,
                     "Incorrect definition of "
                     "table %s.%s: expected column '%s' at position %d to "
                     "have type %s, found type %s.",
                     table->s->db.str, table->alias, field_def->name.str, i,
                     field_def->type.str, sql_type.c_ptr_safe());
        error = true;
      } else if (field_def->cset.str && !field->has_charset()) {
        report_error(ER_CANNOT_LOAD_FROM_TABLE_V2,
                     "Incorrect definition of "
                     "table %s.%s: expected the type of column '%s' at "
                     "position %d to have character set '%s' but the type "
                     "has no character set.",
                     table->s->db.str, table->alias, field_def->name.str, i,
                     field_def->cset.str);
        error = true;
      } else if (field_def->cset.str &&
                 strcmp(field->charset()->csname, field_def->cset.str)) {
        report_error(ER_CANNOT_LOAD_FROM_TABLE_V2,
                     "Incorrect definition of "
                     "table %s.%s: expected the type of column '%s' at "
                     "position %d to have character set '%s' but found "
                     "character set '%s'.",
                     table->s->db.str, table->alias, field_def->name.str, i,
                     field_def->cset.str, field->charset()->csname);
        error = true;
      }
    } else {
      report_error(ER_CANNOT_LOAD_FROM_TABLE_V2,
                   "Incorrect definition of "
                   "table %s.%s: expected column '%s' at position %d to "
                   "have type %s but the column is not found.",
                   table->s->db.str, table->alias, field_def->name.str, i,
                   field_def->type.str);
      error = true;
    }
  }

  if (!error) table->s->table_field_def_cache = table_def;

end:

  if (has_keys && !error && !table->key_info) {
    my_error(ER_MISSING_KEY, MYF(0), table->s->db.str,
             table->s->table_name.str);
    error = true;
  }

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: Table_ref::prepare_view_security_context
bool Table_ref::prepare_view_security_context(THD *thd) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("table: %s", alias));

  assert(!prelocking_placeholder && view);
  if (view_suid) {
    DBUG_PRINT("info", ("This table is suid view => load contest"));
    assert(view && view_sctx);
    if (acl_getroot(thd, view_sctx, definer.user.str, definer.host.str,
                    definer.host.str, thd->db().str)) {
      if ((thd->lex->sql_command == SQLCOM_SHOW_CREATE) ||
          (thd->lex->sql_command == SQLCOM_SHOW_FIELDS)) {
        push_warning_printf(thd, Sql_condition::SL_NOTE, ER_NO_SUCH_USER,
                            ER_THD(thd, ER_NO_SUCH_USER), definer.user.str,
                            definer.host.str);
      } else {
        if (thd->security_context()->check_access(SUPER_ACL)) {
          my_error(ER_NO_SUCH_USER, MYF(0), definer.user.str, definer.host.str);

        } else {
          if (thd->password == 2)
            my_error(ER_ACCESS_DENIED_NO_PASSWORD_ERROR, MYF(0),
                     thd->security_context()->priv_user().str,
                     thd->security_context()->priv_host().str);
          else
            my_error(
                ER_ACCESS_DENIED_ERROR, MYF(0),
                thd->security_context()->priv_user().str,
                thd->security_context()->priv_host().str,
                (thd->password ? ER_THD(thd, ER_YES) : ER_THD(thd, ER_NO)));
        }
        return true;
      }
    }
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: LEX_USER::init
void TABLE::init(THD *thd, Table_ref *tl) {
#ifndef NDEBUG
  if (s->tmp_table == NO_TMP_TABLE) {
    mysql_mutex_lock(&LOCK_open);
    assert(s->ref_count() > 0);
    mysql_mutex_unlock(&LOCK_open);
  }
#endif

  if (thd->lex->need_correct_ident())
    alias_name_used =
        my_strcasecmp(table_alias_charset, s->table_name.str, tl->alias);
  else
    alias_name_used = false;

  /* Fix alias if table name changes. */
  if (strcmp(alias, tl->alias)) {
    size_t length = strlen(tl->alias) + 1;
    alias = static_cast<char *>(my_realloc(
        key_memory_TABLE, const_cast<char *>(alias), length, MYF(MY_WME)));
    memcpy(const_cast<char *>(alias), tl->alias, length);
  }

  /*
    TABLE objects are recycled, ensure that optimization and execution state
    was reset correctly in previous use. These fields should be reset by
    calling TABLE::reset().
  */
  assert(!const_table && !nullable && !force_index && !force_index_order);
  assert(!force_index_group && insert_values == nullptr);
  assert(file->ft_handler == nullptr && !reginfo.impossible_range);
  assert(pos_in_table_list == nullptr);
  assert(!key_read);
  assert(merge_keys.is_clear_all() && possible_quick_keys.is_clear_all());
  assert(!autoinc_field_has_explicit_non_null_value);

  covering_keys = s->keys_for_keyread;

  set_not_started();

  pos_in_table_list = tl;
  tl->table = this;

  clear_column_bitmaps();

  /* Tables may be reused in a sub statement. */
  assert(!db_stat || !file->ha_extra(HA_EXTRA_IS_ATTACHED_CHILDREN));

  /*
    Do not call bind_value_generators_to_fields() for tables which are not
    directly used by the statement (i.e. used by the substatements of routines
    or triggers to be invoked by the statement).

    Firstly, there will be call to bind_value_generators_to_fields() at the
    start of execution of substatement which directly uses this table anyway.
    Secondly, cleanup of generated column (call to
    cleanup_value_generator_items()) for the table will be done only at the
    end of execution of substatement which uses it. Because of this call to
    bind_value_generators_to_fields() for prelocking
    placeholder will miss corresponding call to cleanup_value_generator_items()
    if substatement which uses the table is not executed for some reason.
  */
  if (!pos_in_table_list->prelocking_placeholder) {
    bind_value_generators_to_fields();
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: make_field_from_frm not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: make_field_from_frm not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: make_field_from_frm not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table.cc
Function: make_field_from_frm not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/table_trigger_dispatcher.cc
Function: Table_trigger_dispatcher::create_trigger
bool Table_trigger_dispatcher::create_trigger(
    THD *thd, String *binlog_create_trigger_stmt, bool if_not_exists,
    bool &already_exists) {
  assert(m_subject_table);
  assert(!already_exists);
  LEX *lex = thd->lex;
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

  // If this table has broken triggers, CREATE TRIGGER is not allowed.
  if (check_for_broken_triggers()) return true;

  // Check that the new trigger is in the same schema as the base table.
  if (my_strcasecmp(table_alias_charset, m_subject_table->s->db.str,
                    lex->spname->m_db.str)) {
    my_error(ER_TRG_IN_WRONG_SCHEMA, MYF(0));
    return true;
  }

  // Check if a trigger with the same name already exist in this schema.
  const dd::Schema *sch_obj = nullptr;
  if (thd->dd_client()->acquire(lex->spname->m_db.str, &sch_obj)) return true;

  // The table is already open, so the schema must exist.
  assert(sch_obj != nullptr);

  dd::String_type table_name;
  if (thd->dd_client()->get_table_name_by_trigger_name(
          *sch_obj, lex->spname->m_name.str, &table_name))
    return true;

  // Make sure DEFINER clause is specified.
  if (!lex->definer) {
    /*
      DEFINER-clause is missing.

      If we are in slave thread, this means that we received CREATE TRIGGER
      from the master, that does not support definer in triggers. So, we
      should mark this trigger as non-SUID. Note that this does not happen
      when we parse triggers' definitions during reading metadata from
      the Data Dictionary. LEX::definer is ignored in that case.

      Otherwise, we should use CURRENT_USER() as definer.

      NOTE: when CREATE TRIGGER statement is allowed to be executed in PS/SP,
      it will be required to create the definer below in persistent MEM_ROOT
      of PS/SP.

      NOTE: here we allocate lex->definer on THD->mem_root. Later it will be
      copied into the base table mem-root to be used inside Trigger.
    */

    if (!thd->slave_thread) {
      if (!(lex->definer = create_default_definer(thd))) return true;
    } else {
      my_error(ER_TRG_NO_DEFINER, MYF(0), m_subject_table->s->db.str,
               lex->spname->m_name.str);
      return true;
    }
  }

  if (table_name != "") {
    // Trigger with the same name already exists in this schema.
    if (if_not_exists) {
      /*
        IF NOT EXISTS clause is only supported for triggers associated with the
        same table.
      */
      if (my_strcasecmp(table_alias_charset, m_subject_table->s->table_name.str,
                        table_name.c_str())) {
        my_error(ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE,
                 MYF(0), m_subject_table->s->db.str, lex->spname->m_name.str);
        return true;
      }

      // Trigger with the same name already exists on the same table.
      already_exists = true;

      push_warning_printf(
          thd, Sql_condition::SL_NOTE, ER_WARN_TRG_ALREADY_EXISTS,
          ER_THD(thd, ER_WARN_TRG_ALREADY_EXISTS), lex->spname->m_name.str,
          m_subject_table->s->db.str, table_name.c_str());

      /* SUID trigger is only supported (DEFINER is specified by the user). */
      return (Trigger::construct_create_trigger_stmt_with_definer(
          thd, binlog_create_trigger_stmt, lex->definer->user,
          lex->definer->host));
    }
    my_error(ER_TRG_ALREADY_EXISTS, MYF(0));
    return true;
  }

  /*
    If the specified definer differs from the current user, we should check
    that the current user has SUPER privilege (in order to create trigger
    under another user one must have SUPER privilege).
  */
  Security_context *sctx = thd->security_context();
  if (lex->definer &&
      (strcmp(lex->definer->user.str, sctx->priv_user().str) ||
       my_strcasecmp(system_charset_info, lex->definer->host.str,
                     sctx->priv_host().str))) {
    if (!sctx->check_access(SUPER_ACL) &&
        !sctx->has_global_grant(STRING_WITH_LEN("SET_USER_ID")).first) {
      my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "SUPER or SET_USER_ID");
      return true;
    }
    if (sctx->can_operate_with({lex->definer}, consts::system_user, true))
      return true;
  }

  if (lex->definer &&
      !is_acl_user(thd, lex->definer->host.str, lex->definer->user.str)) {
    push_warning_printf(thd, Sql_condition::SL_NOTE, ER_NO_SUCH_USER,
                        ER_THD(thd, ER_NO_SUCH_USER), lex->definer->user.str,
                        lex->definer->host.str);

    if (thd->get_stmt_da()->is_error()) return true;
  }

  /*
    Check if all references to fields in OLD/NEW-rows in this trigger are valid.

    NOTE: Setting m_old_field / m_new_field here is required because of
    Item_trigger_field::fix_fields() later.

    NOTE: We do it here more from ease of use standpoint. We still have to
    do some checks on each execution. E.g. we can catch privilege changes
    only during execution. Also in near future, when we will allow access
    to other tables from trigger we won't be able to catch changes in other
    tables...

    Since we don't plan to access to contents of the fields it does not
    matter that we choose for both OLD and NEW values the same versions
    of Field objects here.
   */

  m_old_field = m_subject_table->field;
  m_new_field = m_subject_table->field;

  if (lex->sphead->setup_trigger_fields(thd, this, nullptr, true)) return true;

  m_old_field = nullptr;
  m_new_field = nullptr;

  // Create new trigger.

  Trigger *t = Trigger::create_from_parser(thd, m_subject_table,
                                           binlog_create_trigger_stmt);

  if (!t) return true;

  // Create trigger chain.

  Trigger_chain *tc = create_trigger_chain(
      &m_subject_table->mem_root, t->get_event(), t->get_action_time());

  if (!tc) {
    destroy(t);
    return true;
  }

  // Add the newly created trigger to the chain.

  if (tc->add_trigger(&m_subject_table->mem_root, t,
                      lex->sphead->m_trg_chistics.ordering_clause,
                      lex->sphead->m_trg_chistics.anchor_trigger_name)) {
    destroy(t);
    return true;
  }

  return dd::create_trigger(thd, t, lex->sphead->m_trg_chistics.ordering_clause,
                            lex->sphead->m_trg_chistics.anchor_trigger_name);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/trigger.cc
Function: Deprecated_trigger_syntax_handler::handle_condition
  bool handle_condition(THD *thd, uint sql_errno, const char *,
                        Sql_condition::enum_severity_level *,
                        const char *message) override {
    if (sql_errno != EE_OUTOFMEMORY && sql_errno != ER_OUT_OF_RESOURCES) {
      if (thd->lex->spname) m_trigger_name = &thd->lex->spname->m_name;
      if (m_trigger_name)
        snprintf(m_message, sizeof(m_message),
                 ER_THD(thd, ER_ERROR_IN_TRIGGER_BODY), m_trigger_name->str,
                 message);
      else
        snprintf(m_message, sizeof(m_message),
                 ER_THD(thd, ER_ERROR_IN_UNKNOWN_TRIGGER_BODY), message);
      return true;
    }
    return false;
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/trigger.cc
Function: Trigger::print_upgrade_warning
void Trigger::print_upgrade_warning(THD *thd) {
  if (!is_created_timestamp_null()) return;

  push_warning_printf(
      thd, Sql_condition::SL_WARNING, ER_WARN_TRIGGER_DOESNT_HAVE_CREATED,
      ER_THD(thd, ER_WARN_TRIGGER_DOESNT_HAVE_CREATED), get_db_name().str,
      get_subject_table_name().str, get_trigger_name().str);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/trigger_creation_ctx.cc
Function: Trigger_creation_ctx::create not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/trigger_creation_ctx.cc
Function: Trigger_creation_ctx::create not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: Json_wrapper::make_sort_key
  Json_wrapper::make_sort_key(). Types with lower identifiers sort
  before types with higher identifiers.
  See also note for Json_dom::enum_json_type.
*/
constexpr uchar JSON_KEY_NULL = '\x00';
constexpr uchar JSON_KEY_NUMBER_NEG = '\x01';
constexpr uchar JSON_KEY_NUMBER_ZERO = '\x02';
constexpr uchar JSON_KEY_NUMBER_POS = '\x03';
constexpr uchar JSON_KEY_STRING = '\x04';
constexpr uchar JSON_KEY_OBJECT = '\x05';
constexpr uchar JSON_KEY_ARRAY = '\x06';
constexpr uchar JSON_KEY_FALSE = '\x07';
constexpr uchar JSON_KEY_TRUE = '\x08';
constexpr uchar JSON_KEY_DATE = '\x09';
constexpr uchar JSON_KEY_TIME = '\x0A';
constexpr uchar JSON_KEY_DATETIME = '\x0B';
constexpr uchar JSON_KEY_OPAQUE = '\x0C';

}  // namespace

/*
  Max char position to pad numeric sort keys to. Includes max precision +
  sort key len.
*/
#define MAX_NUMBER_SORT_PAD \
  (std::max(DBL_DIG, DECIMAL_MAX_POSSIBLE_PRECISION) + VARLEN_PREFIX + 3)

/**
  Make a sort key for a JSON numeric value from its string representation. The
  input string could be either on scientific format (such as 1.234e2) or on
  plain format (such as 12.34).

  The sort key will have the following parts:

  1) One byte that is JSON_KEY_NUMBER_NEG, JSON_KEY_NUMBER_ZERO or
  JSON_KEY_NUMBER_POS if the number is positive, zero or negative,
  respectively.

  2) Two bytes that represent the decimal exponent of the number (log10 of the
  number, truncated to an integer).

  3) All the digits of the number, without leading zeros.

  4) Padding to ensure that equal numbers sort equal even if they have a
  different number of trailing zeros.

  If the number is zero, parts 2, 3 and 4 are skipped.

  For negative numbers, the values in parts 2, 3 and 4 need to be inverted so
  that bigger negative numbers sort before smaller negative numbers.

  @param[in]     from     the string representation of the number
  @param[in]     len      the length of the input string
  @param[in]     negative true if the number is negative, false otherwise
  @param[in,out] to       the target sort key
*/
static void make_json_numeric_sort_key(const char *from, size_t len,
                                       bool negative, Wrapper_sort_key *to) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: wrapper_to_string
  Helper function for wrapper_to_string() which adds a newline and indentation
  up to the specified level.

  @param[in,out] buffer  the buffer to write to
  @param[in]     level   how many nesting levels to add indentation for
  @retval false on success
  @retval true on error
*/
static bool newline_and_indent(String *buffer, size_t level) {
  // Append newline and two spaces per indentation level.
  return buffer->append('\n') ||
         buffer->fill(buffer->length() + level * 2, ' ');
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: handle_coercion_error not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql-common/json_dom.cc
Function: handle_coercion_error not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/event_data_objects.cc
Function: Event_timed::fill_event_info
bool Event_job_data::fill_event_info(THD *thd, const dd::Event &event_obj,
                                     const char *schema_name) {
  DBUG_TRACE;

  m_schema_name = make_lex_cstring(&mem_root, schema_name);
  m_event_name = make_lex_cstring(&mem_root, event_obj.name());

  dd::String_type tmp(event_obj.definer_user());
  tmp.append("@");
  tmp.append(event_obj.definer_host());
  m_definer = make_lex_cstring(&mem_root, tmp);

  String str(event_obj.time_zone().c_str(), &my_charset_latin1);
  m_time_zone = my_tz_find(thd, &str);

  m_definition = make_lex_string(&mem_root, event_obj.definition());

  if (m_time_zone == nullptr) return true;

  Event_creation_ctx::create_event_creation_ctx(event_obj, &m_creation_ctx);
  if (m_creation_ctx == nullptr) return true;

  m_definer_user = make_lex_cstring(&mem_root, event_obj.definer_user());
  m_definer_host = make_lex_cstring(&mem_root, event_obj.definer_host());

  m_sql_mode = event_obj.sql_mode();

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/auth/sql_mfa.cc
Function: Multi_factor_auth_list::validate_against_authentication_policy
bool Multi_factor_auth_list::validate_against_authentication_policy(THD *thd) {
  bool policy_priv_exist =
      thd->security_context()
          ->has_global_grant(STRING_WITH_LEN("AUTHENTICATION_POLICY_ADMIN"))
          .first;
  uint nth_factor = 1;
  mysql_mutex_lock(&LOCK_authentication_policy);
  std::vector<std::string> &list = authentication_policy_list;
  mysql_mutex_unlock(&LOCK_authentication_policy);
  auto acl_it = m_factor.begin();
  auto policy_list = list.begin();
  /* skip first factor plugin name in policy list */
  policy_list++;
  for (; (acl_it != m_factor.end() && policy_list != list.end());
       ++policy_list, ++acl_it) {
    Multi_factor_auth_info *acl_factor =
        (*acl_it)->get_multi_factor_auth_info();
    nth_factor = acl_factor->get_nth_factor();
    /* mfa plugin method is optional so allow */
    if (policy_list->length() == 0) continue;
    /* mfa plugin method can be anything so allow */
    if (policy_list->compare("*") == 0) continue;
    /* mfa plugin method does not match against policy */
    if (policy_list->compare(acl_factor->get_plugin_str())) goto error;
  }
  nth_factor++;
  /* if more plugin exists in policy check that its optional only */
  while (policy_list != list.end()) {
    if (policy_list->length()) goto error;
    policy_list++;
  }
  return false;
error:
  if (policy_priv_exist) {
    push_warning_printf(
        thd, Sql_condition::SL_WARNING, ER_AUTHENTICATION_POLICY_MISMATCH,
        ER_THD(thd, ER_AUTHENTICATION_POLICY_MISMATCH), nth_factor);
    return false;
  }
  my_error(ER_AUTHENTICATION_POLICY_MISMATCH, MYF(0), nth_factor);
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/check_stack.cc
Function: check_stack_overrun
bool check_stack_overrun(const THD *thd, long margin, unsigned char *buf) {
  assert(thd == current_thd);
  assert(stack_direction == -1 || stack_direction == 1);

#if defined(HAVE_ASAN)
  // Stack grows upward, but our address computations do not work with
  // the "fake stack" of ASAN. Just return OK.
  // With ASAN_OPTIONS=detect_stack_use_after_return=true
  // any test which deliberately runs out of stack
  // (expects ER_STACK_OVERRUN_NEED_MORE) will most likely crash.
  if (stack_direction == 1) {
    return false;
  }
#endif

  long stack_used =
      used_stack(thd->thread_stack, reinterpret_cast<char *>(&stack_used));
  if (stack_used >= static_cast<long>(my_thread_stack_size - margin) ||
      DBUG_EVALUATE_IF("simulate_stack_overrun", true, false)) {
    // Touch the buffer, so that it is not optimized away by -flto.
    if (buf != nullptr) buf[0] = '\0';

    /*
      Do not use stack for the message buffer to ensure correct
      behaviour in cases we have close to no stack left.
    */
    char *ebuff = new (std::nothrow) char[MYSQL_ERRMSG_SIZE];
    if (ebuff) {
      snprintf(ebuff, MYSQL_ERRMSG_SIZE,
               ER_THD(thd, ER_STACK_OVERRUN_NEED_MORE), stack_used,
               my_thread_stack_size, margin);
      my_message(ER_STACK_OVERRUN_NEED_MORE, ebuff, MYF(ME_FATALERROR));
      delete[] ebuff;
    }
    return true;
  }
#ifndef NDEBUG
  max_stack_used = std::max(max_stack_used.load(), stack_used);
#endif
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/create_field.cc
Function: Create_field::init
bool Create_field::init(
    THD *thd, const char *fld_name, enum_field_types fld_type,
    const char *display_width_in_codepoints, const char *fld_decimals,
    uint fld_type_modifier, Item *fld_default_value, Item *fld_on_update_value,
    const LEX_CSTRING *fld_comment, const char *fld_change,
    List<String> *fld_interval_list, const CHARSET_INFO *fld_charset,
    bool has_explicit_collation, uint fld_geom_type,
    Value_generator *fld_gcol_info, Value_generator *fld_default_val_expr,
    std::optional<gis::srid_t> srid, dd::Column::enum_hidden_type hidden,
    bool is_array_arg) {
  uint sign_len, allowed_type_modifier = 0;
  ulong max_field_charlength = MAX_FIELD_CHARLENGTH;

  DBUG_TRACE;

  assert(!(has_explicit_collation && fld_charset == nullptr));

  field = nullptr;
  field_name = fld_name;
  flags = fld_type_modifier;
  is_explicit_collation = (fld_charset != nullptr);

  if (!has_explicit_collation && fld_charset == &my_charset_utf8mb4_0900_ai_ci)
    charset = thd->variables.default_collation_for_utf8mb4;
  else
    charset = fld_charset;

  auto_flags = Field::NONE;
  is_nullable = !(fld_type_modifier & NOT_NULL_FLAG);
  this->hidden = hidden;
  is_array = is_array_arg;

  if (fld_default_value != nullptr &&
      fld_default_value->type() == Item::FUNC_ITEM) {
    // We have a function default for insertions.
    constant_default = nullptr;
    auto_flags |= Field::DEFAULT_NOW;
  } else {
    // No function default for insertions. Either NULL or a constant.
    constant_default = fld_default_value;
  }

  // ON UPDATE CURRENT_TIMESTAMP
  if (fld_on_update_value != nullptr &&
      fld_on_update_value->type() == Item::FUNC_ITEM)
    auto_flags |= Field::ON_UPDATE_NOW;

  // Automatic increment.
  if (fld_type_modifier & AUTO_INCREMENT_FLAG) auto_flags |= Field::NEXT_NUMBER;

  decimals = fld_decimals ? (uint)atoi(fld_decimals) : 0;
  if (is_temporal_real_type(fld_type)) {
    flags |= BINARY_FLAG;
    charset = &my_charset_numeric;
    if (decimals > DATETIME_MAX_DECIMALS) {
      my_error(ER_TOO_BIG_PRECISION, MYF(0), decimals, fld_name,
               DATETIME_MAX_DECIMALS);
      return true;
    }
  } else if (decimals >= DECIMAL_NOT_SPECIFIED) {
    my_error(ER_TOO_BIG_SCALE, MYF(0), decimals, fld_name,
             static_cast<ulong>(DECIMAL_NOT_SPECIFIED - 1));
    return true;
  }

  sql_type = fld_type;
  change = fld_change;
  interval = nullptr;
  geom_type = static_cast<Field::geometry_type>(fld_geom_type);
  interval_list.clear();

  comment = *fld_comment;
  gcol_info = fld_gcol_info;
  stored_in_db = true;
  m_srid = srid;

  if (fld_default_val_expr) {
    constant_default = nullptr;
    auto_flags |= Field::GENERATED_FROM_EXPRESSION;
    m_default_val_expr = fld_default_val_expr;
  }

  // Initialize data for a virtual field or default value expression
  if (gcol_info || m_default_val_expr) {
    if (gcol_info) {
      assert(gcol_info->expr_item);
      stored_in_db = gcol_info->get_field_stored();

      /*
        Make a field created for the real type.
        Note that "real" and generated fields differ from each other
        only by Field::gcol_info, which is always 0 for normal columns.
        gcol_info is updated for fields later in procedure open_binary_frm.
      */
      sql_type = fld_type = gcol_info->get_real_type();
      if (pre_validate_value_generator_expr(gcol_info->expr_item, field_name,
                                            VGS_GENERATED_COLUMN))
        return true;
    } else {
      if (pre_validate_value_generator_expr(m_default_val_expr->expr_item,
                                            field_name, VGS_DEFAULT_EXPRESSION))
        return true;
    }
  }

  /*
    Set NO_DEFAULT_VALUE_FLAG if this field doesn't have a default value
    or an expression to generate the default value and
    it is NOT NULL and not an AUTO_INCREMENT field.
  */
  if (!fld_default_value && !fld_default_val_expr &&
      (fld_type_modifier & NOT_NULL_FLAG) &&
      !(fld_type_modifier & AUTO_INCREMENT_FLAG)) {
    /*
      TIMESTAMP columns get implicit DEFAULT value when
      explicit_defaults_for_timestamp is not set.
    */
    if (thd->variables.explicit_defaults_for_timestamp ||
        !is_timestamp_type(fld_type)) {
      flags |= NO_DEFAULT_VALUE_FLAG;
    }
  }

  if (display_width_in_codepoints != nullptr) {
    errno = 0;
    const ulonglong ull_length =
        my_strtoull(display_width_in_codepoints, nullptr, 10);
    if ((errno != 0) || (ull_length > MAX_FIELD_BLOBLENGTH)) {
      my_error(ER_TOO_BIG_DISPLAYWIDTH, MYF(0), fld_name,
               static_cast<unsigned long>(MAX_FIELD_BLOBLENGTH));
      return true;
    }
    m_max_display_width_in_codepoints = static_cast<size_t>(ull_length);
    m_explicit_display_width = true;

    if (m_max_display_width_in_codepoints == 0)
      display_width_in_codepoints = nullptr; /* purecov: inspected */
  }

  sign_len = fld_type_modifier & UNSIGNED_FLAG ? 0 : 1;

  switch (fld_type) {
    case MYSQL_TYPE_TINY:
      if (!display_width_in_codepoints)
        m_max_display_width_in_codepoints = MAX_TINYINT_WIDTH + sign_len;
      allowed_type_modifier = AUTO_INCREMENT_FLAG;
      break;
    case MYSQL_TYPE_SHORT:
      if (!display_width_in_codepoints)
        m_max_display_width_in_codepoints = MAX_SMALLINT_WIDTH + sign_len;
      allowed_type_modifier = AUTO_INCREMENT_FLAG;
      break;
    case MYSQL_TYPE_INT24:
      if (!display_width_in_codepoints)
        m_max_display_width_in_codepoints = MAX_MEDIUMINT_WIDTH + sign_len;
      allowed_type_modifier = AUTO_INCREMENT_FLAG;
      break;
    case MYSQL_TYPE_LONG:
      if (!display_width_in_codepoints)
        m_max_display_width_in_codepoints = MAX_INT_WIDTH + sign_len;
      allowed_type_modifier = AUTO_INCREMENT_FLAG;
      break;
    case MYSQL_TYPE_LONGLONG:
      if (!display_width_in_codepoints)
        m_max_display_width_in_codepoints = MAX_BIGINT_WIDTH;
      allowed_type_modifier = AUTO_INCREMENT_FLAG;
      break;
    case MYSQL_TYPE_NULL:
    case MYSQL_TYPE_INVALID:
    case MYSQL_TYPE_BOOL:
      break;
    case MYSQL_TYPE_NEWDECIMAL: {
      ulong precision = static_cast<ulong>(m_max_display_width_in_codepoints);
      my_decimal_trim(&precision, &decimals);
      m_max_display_width_in_codepoints = precision;
    }
      if (m_max_display_width_in_codepoints > DECIMAL_MAX_PRECISION) {
        my_error(ER_TOO_BIG_PRECISION, MYF(0),
                 static_cast<int>(m_max_display_width_in_codepoints), fld_name,
                 static_cast<ulong>(DECIMAL_MAX_PRECISION));
        return true;
      }
      if (m_max_display_width_in_codepoints < decimals) {
        my_error(ER_M_BIGGER_THAN_D, MYF(0), fld_name);
        return true;
      }
      m_max_display_width_in_codepoints = my_decimal_precision_to_length(
          m_max_display_width_in_codepoints, decimals,
          fld_type_modifier & UNSIGNED_FLAG);
      break;
    case MYSQL_TYPE_VARCHAR:
      // Note that VARCHAR fields with a long length may be converted to blob
      // types in prepare_blob_field()
      max_field_charlength = MAX_FIELD_VARCHARLENGTH;
      break;
    case MYSQL_TYPE_STRING:
      break;
    case MYSQL_TYPE_BLOB:
    case MYSQL_TYPE_TINY_BLOB:
    case MYSQL_TYPE_LONG_BLOB:
    case MYSQL_TYPE_MEDIUM_BLOB:
    case MYSQL_TYPE_JSON:
      if (fld_default_value) {
        /* Allow empty as default value. */
        String str, *res;
        res = fld_default_value->val_str(&str);
        /*
          A default other than '' is always an error, and any non-NULL
          specified default is an error in strict mode.
        */
        if (res->length() || thd->is_strict_mode()) {
          my_error(ER_BLOB_CANT_HAVE_DEFAULT, MYF(0),
                   fld_name); /* purecov: inspected */
          return true;
        } else {
          /*
            Otherwise a default of '' is just a warning.
          */
          push_warning_printf(thd, Sql_condition::SL_WARNING,
                              ER_BLOB_CANT_HAVE_DEFAULT,
                              ER_THD(thd, ER_BLOB_CANT_HAVE_DEFAULT), fld_name);
        }
        constant_default = nullptr;
      }

      flags |= BLOB_FLAG;
      break;
    case MYSQL_TYPE_GEOMETRY:
      if (fld_default_value) {
        my_error(ER_BLOB_CANT_HAVE_DEFAULT, MYF(0), fld_name);
        return true;
      }
      flags |= BLOB_FLAG;
      break;
    case MYSQL_TYPE_YEAR:
      if (!display_width_in_codepoints ||
          m_max_display_width_in_codepoints != 4)
        m_max_display_width_in_codepoints = 4; /* Default length */
      flags |= ZEROFILL_FLAG | UNSIGNED_FLAG;
      break;
    case MYSQL_TYPE_FLOAT:
      /* change FLOAT(precision) to FLOAT or DOUBLE */
      allowed_type_modifier = AUTO_INCREMENT_FLAG;
      if (display_width_in_codepoints && !fld_decimals) {
        size_t tmp_length = m_max_display_width_in_codepoints;
        if (tmp_length > PRECISION_FOR_DOUBLE) {
          my_error(ER_WRONG_FIELD_SPEC, MYF(0), fld_name);
          return true;
        } else if (tmp_length > PRECISION_FOR_FLOAT) {
          sql_type = MYSQL_TYPE_DOUBLE;
          m_max_display_width_in_codepoints = MAX_DOUBLE_STR_LENGTH;
        } else
          m_max_display_width_in_codepoints = MAX_FLOAT_STR_LENGTH;
        decimals = DECIMAL_NOT_SPECIFIED;
        break;
      }
      if (!display_width_in_codepoints && !fld_decimals) {
        m_max_display_width_in_codepoints = MAX_FLOAT_STR_LENGTH;
        decimals = DECIMAL_NOT_SPECIFIED;
      }
      if (m_max_display_width_in_codepoints < decimals &&
          decimals != DECIMAL_NOT_SPECIFIED) {
        my_error(ER_M_BIGGER_THAN_D, MYF(0), fld_name);
        return true;
      }
      break;
    case MYSQL_TYPE_DOUBLE:
      allowed_type_modifier = AUTO_INCREMENT_FLAG;
      if (!display_width_in_codepoints && !fld_decimals) {
        m_max_display_width_in_codepoints = DBL_DIG + 7;
        decimals = DECIMAL_NOT_SPECIFIED;
      }
      if (m_max_display_width_in_codepoints < decimals &&
          decimals != DECIMAL_NOT_SPECIFIED) {
        my_error(ER_M_BIGGER_THAN_D, MYF(0), fld_name);
        return true;
      }
      break;
    case MYSQL_TYPE_TIMESTAMP:
      /* Add flags for TIMESTAMP for 4.0 MYD and 4.0 InnoDB compatibility */
      flags |= ZEROFILL_FLAG | UNSIGNED_FLAG;
      [[fallthrough]];
    case MYSQL_TYPE_TIMESTAMP2:
      if (display_width_in_codepoints == nullptr) {
        m_max_display_width_in_codepoints =
            MAX_DATETIME_WIDTH + (decimals ? (1 + decimals) : 0);
      } else if (m_max_display_width_in_codepoints != MAX_DATETIME_WIDTH) {
        /*
          We support only even TIMESTAMP lengths less or equal than 14
          and 19 as length of 4.1 compatible representation.  Silently
          shrink it to MAX_DATETIME_COMPRESSED_WIDTH.
        */
        if (m_max_display_width_in_codepoints !=
            UINT_MAX) /* avoid overflow; is safe because of min() */
          m_max_display_width_in_codepoints =
              ((m_max_display_width_in_codepoints + 1) / 2) * 2;
        m_max_display_width_in_codepoints = std::min<size_t>(
            m_max_display_width_in_codepoints, MAX_DATETIME_COMPRESSED_WIDTH);
      }

      /*
        Since we silently rewrite down to MAX_DATETIME_COMPRESSED_WIDTH bytes,
        the parser should not raise errors unless bizzarely large.
       */
      max_field_charlength = UINT_MAX;

      break;
    case MYSQL_TYPE_DATE:
      /* Old date type. */
      sql_type = MYSQL_TYPE_NEWDATE;
      [[fallthrough]];
    case MYSQL_TYPE_NEWDATE:
      m_max_display_width_in_codepoints = MAX_DATE_WIDTH;
      break;
    case MYSQL_TYPE_TIME:
    case MYSQL_TYPE_TIME2:
      m_max_display_width_in_codepoints =
          MAX_TIME_WIDTH + (decimals ? (1 + decimals) : 0);
      break;
    case MYSQL_TYPE_DATETIME:
    case MYSQL_TYPE_DATETIME2:
      m_max_display_width_in_codepoints =
          MAX_DATETIME_WIDTH + (decimals ? (1 + decimals) : 0);
      break;
    case MYSQL_TYPE_SET:
    case MYSQL_TYPE_ENUM: {
      for (String &it : *fld_interval_list) {
        interval_list.push_back(&it);
      }
      break;
    }
    case MYSQL_TYPE_VAR_STRING:
      assert(0); /* Impossible. */
      break;
    case MYSQL_TYPE_BIT: {
      if (!display_width_in_codepoints) {
        my_error(ER_INVALID_FIELD_SIZE, MYF(0), fld_name);
        return true;
      }
      if (m_max_display_width_in_codepoints > MAX_BIT_FIELD_LENGTH) {
        my_error(ER_TOO_BIG_DISPLAYWIDTH, MYF(0), fld_name,
                 static_cast<ulong>(MAX_BIT_FIELD_LENGTH));
        return true;
      }
      break;
    }
    case MYSQL_TYPE_DECIMAL:
    default:
      assert(0); /* Was obsolete */
  }

  if (!(flags & BLOB_FLAG) &&
      ((m_max_display_width_in_codepoints > max_field_charlength &&
        fld_type != MYSQL_TYPE_SET && fld_type != MYSQL_TYPE_ENUM &&
        (fld_type != MYSQL_TYPE_VARCHAR || fld_default_value)) ||
       ((m_max_display_width_in_codepoints == 0 && m_explicit_display_width) &&
        fld_type != MYSQL_TYPE_STRING && fld_type != MYSQL_TYPE_VARCHAR &&
        fld_type != MYSQL_TYPE_GEOMETRY))) {
    my_error((fld_type == MYSQL_TYPE_VAR_STRING ||
              fld_type == MYSQL_TYPE_VARCHAR || fld_type == MYSQL_TYPE_STRING)
                 ? ER_TOO_BIG_FIELDLENGTH
                 : ER_TOO_BIG_DISPLAYWIDTH,
             MYF(0), fld_name, max_field_charlength); /* purecov: inspected */
    return true;
  }
  fld_type_modifier &= AUTO_INCREMENT_FLAG;
  if ((~allowed_type_modifier) & fld_type_modifier) {
    my_error(ER_WRONG_FIELD_SPEC, MYF(0), fld_name);
    return true;
  }

  /*
    After all checks were carried out we should be able guarantee that column
    can't have AUTO_INCREMENT and DEFAULT/ON UPDATE CURRENT_TIMESTAMP at the
    same time.
  */
  assert(!((auto_flags & (Field::DEFAULT_NOW | Field::ON_UPDATE_NOW |
                          Field::GENERATED_FROM_EXPRESSION)) != 0 &&
           (auto_flags & Field::NEXT_NUMBER) != 0));

  return false; /* success */
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: push_view_warning_or_error not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: push_view_warning_or_error not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: push_view_warning_or_error not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd_sql_view.cc
Function: push_view_warning_or_error not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: Functional_index_error_handler::handle_condition
  Implementation of Drop_table_error_handler::handle_condition().
  The reason in having this implementation is to silence technical low-level
  warnings during DROP TABLE operation. Currently we don't want to expose
  the following warnings during DROP TABLE:
    - Some of table files are missed or invalid (the table is going to be
      deleted anyway, so why bother that something was missed).
    - The table is using an invalid collation.

  @return true if the condition is handled.
*/
bool Drop_table_error_handler::handle_condition(
    THD *, uint sql_errno, const char *, Sql_condition::enum_severity_level *,
    const char *) {
  return (sql_errno == ER_UNKNOWN_COLLATION) ||
         (sql_errno == ER_PLUGIN_IS_NOT_LOADED) ||
         (sql_errno == EE_DELETE && my_errno() == ENOENT);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: report_error
    report_error(m_thd, res_errno, *level, m_functional_index_name.c_str(),
                 m_thd->get_stmt_da()->current_row_for_condition());
  return true;
}

/**
  This internal handler is used to trap ER_NO_SUCH_TABLE and
  ER_WRONG_MRG_TABLE errors during CHECK/REPAIR TABLE for MERGE
  tables.
*/

class Repair_mrg_table_error_handler : public Internal_error_handler {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/error_handler.cc
Function: bool not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field::set_warning
bool Field::set_warning(Sql_condition::enum_severity_level level, uint code,
                        int truncate_increment, const char *view_db_name,
                        const char *view_name) {
  /*
    If this field was created only for type conversion purposes it
    will have table == NULL.
  */

  THD *thd = current_thd;

  if (!thd->check_for_truncated_fields)
    return level >= Sql_condition::SL_WARNING;

  thd->num_truncated_fields += truncate_increment;

  if (thd->lex->sql_command != SQLCOM_INSERT &&
      thd->lex->sql_command != SQLCOM_INSERT_SELECT &&
      thd->lex->sql_command != SQLCOM_REPLACE &&
      thd->lex->sql_command != SQLCOM_REPLACE_SELECT) {
    // We aggregate warnings from only INSERT and REPLACE statements.

    push_warning_printf(thd, level, code, ER_THD_NONCONST(thd, code),
                        field_name,
                        thd->get_stmt_da()->current_row_for_condition());

    return false;
  }

  unsigned int current_warning_mask = 0;

  if (code == ER_BAD_NULL_ERROR)
    current_warning_mask = BAD_NULL_ERROR_PUSHED;
  else if (code == ER_NO_DEFAULT_FOR_FIELD)
    current_warning_mask = NO_DEFAULT_FOR_FIELD_PUSHED;

  if (current_warning_mask) {
    if (!(m_warnings_pushed & current_warning_mask)) {
      push_warning_printf(thd, level, code, ER_THD_NONCONST(thd, code),
                          field_name,
                          thd->get_stmt_da()->current_row_for_condition());
      m_warnings_pushed |= current_warning_mask;
    }
  } else if (code == ER_NO_DEFAULT_FOR_VIEW_FIELD) {
    if (!(m_warnings_pushed & NO_DEFAULT_FOR_VIEW_FIELD_PUSHED)) {
      push_warning_printf(
          thd, Sql_condition::SL_WARNING, ER_NO_DEFAULT_FOR_VIEW_FIELD,
          ER_THD(thd, ER_NO_DEFAULT_FOR_VIEW_FIELD), view_db_name, view_name);
      m_warnings_pushed |= NO_DEFAULT_FOR_VIEW_FIELD_PUSHED;
    }
  } else {
    push_warning_printf(thd, level, code, ER_THD_NONCONST(thd, code),
                        field_name,
                        thd->get_stmt_da()->current_row_for_condition());
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_new_decimal::store
type_conversion_status Field::store(const char *to, size_t length,
                                    const CHARSET_INFO *cs,
                                    enum_check_fields check_level) {
  THD *thd = current_thd;
  enum_check_fields old_check_level = thd->check_for_truncated_fields;
  thd->check_for_truncated_fields = check_level;
  const type_conversion_status res = store(to, length, cs);
  thd->check_for_truncated_fields = old_check_level;
  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_longstr::check_string_copy_error
type_conversion_status Field_longstr::check_string_copy_error(
    const char *well_formed_error_pos, const char *cannot_convert_error_pos,
    const char *from_end_pos, const char *end, bool count_spaces,
    const CHARSET_INFO *cs) {
  const char *pos;
  char tmp[32];
  THD *thd = current_thd;

  if (!(pos = well_formed_error_pos) && !(pos = cannot_convert_error_pos))
    return report_if_important_data(from_end_pos, end, count_spaces);

  convert_to_printable(tmp, sizeof(tmp), pos, (end - pos), cs, 6);

  push_warning_printf(
      thd, Sql_condition::SL_WARNING, ER_TRUNCATED_WRONG_VALUE_FOR_FIELD,
      ER_THD(thd, ER_TRUNCATED_WRONG_VALUE_FOR_FIELD), "string", tmp,
      field_name, thd->get_stmt_da()->current_row_for_condition());

  if (well_formed_error_pos != nullptr) return TYPE_WARN_INVALID_STRING;

  return TYPE_WARN_TRUNCATED;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_num::check_int
type_conversion_status Field_num::check_int(const CHARSET_INFO *cs,
                                            const char *str, size_t length,
                                            const char *int_end, int error) {
  /* Test if we get an empty string or wrong integer */
  if (str == int_end || error == MY_ERRNO_EDOM) {
    THD *thd = current_thd;
    ErrConvString err(str, length, cs);
    push_warning_printf(
        thd, Sql_condition::SL_WARNING, ER_TRUNCATED_WRONG_VALUE_FOR_FIELD,
        ER_THD(thd, ER_TRUNCATED_WRONG_VALUE_FOR_FIELD), "integer", err.ptr(),
        field_name, thd->get_stmt_da()->current_row_for_condition());
    return TYPE_ERR_BAD_VALUE;
  }
  /* Test if we have garbage at the end of the given string. */
  if (test_if_important_data(cs, int_end, str + length)) {
    set_warning(Sql_condition::SL_WARNING, WARN_DATA_TRUNCATED, 1);
    return TYPE_WARN_TRUNCATED;
  }
  return TYPE_OK;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_double::val_int
longlong Field_decimal::val_int() const {
  ASSERT_COLUMN_MARKED_FOR_READ;
  int not_used;
  if (is_unsigned())
    return my_strntoull(&my_charset_bin, pointer_cast<const char *>(ptr),
                        field_length, 10, NULL, &not_used);
  return my_strntoll(&my_charset_bin, pointer_cast<const char *>(ptr),
                     field_length, 10, NULL, &not_used);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::val_real
double Field_decimal::val_real() const {
  ASSERT_COLUMN_MARKED_FOR_READ;
  int not_used;
  const char *end_not_used;
  return my_strntod(&my_charset_bin, pointer_cast<const char *>(ptr),
                    field_length, &end_not_used, &not_used);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::val_int
longlong Field_decimal::val_int() const {
  ASSERT_COLUMN_MARKED_FOR_READ;
  int not_used;
  if (is_unsigned())
    return my_strntoull(&my_charset_bin, pointer_cast<const char *>(ptr),
                        field_length, 10, NULL, &not_used);
  return my_strntoll(&my_charset_bin, pointer_cast<const char *>(ptr),
                     field_length, 10, NULL, &not_used);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::val_decimal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: Field_string::val_decimal not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: set_decimal_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: set_decimal_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/field.cc
Function: push_numerical_conversion_warning
    push_numerical_conversion_warning(current_thd, (char *)ptr + length_bytes,
                                      length, cs, "DOUBLE",
                                      ER_TRUNCATED_WRONG_VALUE);
  }
  return result;
}

longlong Field_varstring::val_int() const {
  ASSERT_COLUMN_MARKED_FOR_READ;
  int error;
  const char *end;
  const CHARSET_INFO *cs = charset();

  uint length = data_length();
  longlong result =
      my_strntoll(cs, (char *)ptr + length_bytes, length, 10, &end, &error);

  if ((error || (length != (uint)(end - (char *)ptr + length_bytes) &&
                 !check_if_only_end_space(
                     cs, end, (char *)ptr + length_bytes + length)))) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/handler.cc
Function: print_keydup_error
void print_keydup_error(TABLE *table, KEY *key, const char *msg, myf errflag,
                        const char *org_table_name) {
  /* Write the duplicated key in the error message */
  char key_buff[MAX_KEY_LENGTH];
  String str(key_buff, sizeof(key_buff), system_charset_info);
  std::string key_name;

  if (key == nullptr) {
    /* Key is unknown */
    key_name = "*UNKNOWN*";
    str.copy("", 0, system_charset_info);

  } else {
    /* Table is opened and defined at this point */
    key_unpack(&str, table, key);
    size_t max_length = MYSQL_ERRMSG_SIZE - strlen(msg);
    if (str.length() >= max_length) {
      str.length(max_length - 4);
      str.append(STRING_WITH_LEN("..."));
    }
    str[str.length()] = 0;
    if (org_table_name != nullptr)
      key_name = org_table_name;
    else
      key_name = table->s->table_name.str;
    key_name += ".";

    key_name += key->name;
  }

  my_printf_error(ER_DUP_ENTRY, msg, errflag, str.c_ptr(), key_name.c_str());
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_typecast_decimal::val_decimal
my_decimal *Item_func::val_decimal(my_decimal *decimal_value) {
  assert(fixed);
  longlong nr = val_int();
  if (null_value) return nullptr; /* purecov: inspected */
  int2my_decimal(E_DEC_FATAL_ERROR, nr, unsigned_flag, decimal_value);
  return decimal_value;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_func::signal_divide_by_null
void Item_func::signal_divide_by_null() {
  THD *thd = current_thd;
  if (thd->variables.sql_mode & MODE_ERROR_FOR_DIVISION_BY_ZERO)
    push_warning(thd, Sql_condition::SL_WARNING, ER_DIVISION_BY_ZERO,
                 ER_THD(thd, ER_DIVISION_BY_ZERO));
  null_value = true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_func::signal_invalid_argument_for_log
void Item_func::signal_invalid_argument_for_log() {
  THD *thd = current_thd;
  push_warning(thd, Sql_condition::SL_WARNING,
               ER_INVALID_ARGUMENT_FOR_LOGARITHM,
               ER_THD(thd, ER_INVALID_ARGUMENT_FOR_LOGARITHM));
  null_value = true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: unsupported_json_comparison
void unsupported_json_comparison(size_t arg_count, Item **args,
                                 const char *msg) {
  for (size_t i = 0; i < arg_count; ++i) {
    if (args[i]->result_type() == STRING_RESULT &&
        args[i]->data_type() == MYSQL_TYPE_JSON) {
      push_warning_printf(current_thd, Sql_condition::SL_WARNING,
                          ER_NOT_SUPPORTED_YET,
                          ER_THD(current_thd, ER_NOT_SUPPORTED_YET), msg);
      break;
    }
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_func_benchmark::val_int
longlong Item_func_connection_id::val_int() {
  assert(fixed);
  return current_thd->variables.pseudo_thread_id;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_func_sleep::val_int
longlong Item_func_connection_id::val_int() {
  assert(fixed);
  return current_thd->variables.pseudo_thread_id;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_source_pos_wait::val_int
longlong Item_func_connection_id::val_int() {
  assert(fixed);
  return current_thd->variables.pseudo_thread_id;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_func_found_rows::itemize
bool Item_func::itemize(Parse_context *pc, Item **res) {
  if (skip_itemize(res)) return false;
  if (Item_result_field::itemize(pc, res)) return true;
  const bool no_named_params = !may_have_named_parameters();
  for (size_t i = 0; i < arg_count; i++) {
    add_accum_properties(args[i]);
    if (args[i]->itemize(pc, &args[i])) return true;
    if (no_named_params && !args[i]->item_name.is_autogenerated()) {
      my_error(functype() == FUNC_SP ? ER_WRONG_PARAMETERS_TO_STORED_FCT
                                     : ER_WRONG_PARAMETERS_TO_NATIVE_FCT,
               MYF(0), func_name());
      return true;
    }
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_func.cc
Function: Item_func_internal_is_mandatory_role::val_int
longlong Item_func_connection_id::val_int() {
  assert(fixed);
  return current_thd->variables.pseudo_thread_id;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_md5::val_str_ascii
  For the Items which have only val_str_ascii() method
  and don't have their own "native" val_str(),
  we provide a "wrapper" method to convert from ASCII
  to Item character set when it's necessary.
  Conversion happens only in case of "tricky" Item character set (e.g. UCS2).
  Normally conversion does not happen, and val_str_ascii() is immediately
  returned instead.
*/
String *Item_str_func::val_str_from_val_str_ascii(String *str, String *str2) {
  assert(fixed == 1);

  if (my_charset_is_ascii_based(collation.collation)) {
    String *res = val_str_ascii(str);
    if (res) res->set_charset(collation.collation);
    return res;
  }

  assert(str != str2);

  uint errors;
  String *res = val_str_ascii(str);
  if (!res) return nullptr;

  if ((null_value = str2->copy(res->ptr(), res->length(), &my_charset_latin1,
                               collation.collation, &errors)))
    return nullptr;

  return str2;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_sha2::val_str_ascii
  For the Items which have only val_str_ascii() method
  and don't have their own "native" val_str(),
  we provide a "wrapper" method to convert from ASCII
  to Item character set when it's necessary.
  Conversion happens only in case of "tricky" Item character set (e.g. UCS2).
  Normally conversion does not happen, and val_str_ascii() is immediately
  returned instead.
*/
String *Item_str_func::val_str_from_val_str_ascii(String *str, String *str2) {
  assert(fixed == 1);

  if (my_charset_is_ascii_based(collation.collation)) {
    String *res = val_str_ascii(str);
    if (res) res->set_charset(collation.collation);
    return res;
  }

  assert(str != str2);

  uint errors;
  String *res = val_str_ascii(str);
  if (!res) return nullptr;

  if ((null_value = str2->copy(res->ptr(), res->length(), &my_charset_latin1,
                               collation.collation, &errors)))
    return nullptr;

  return str2;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_sha2::resolve_type
bool Item_func_md5::resolve_type(THD *thd) {
  if (param_type_is_default(thd, 0, -1)) return true;
  CHARSET_INFO *cs = get_checksum_charset(args[0]->collation.collation->csname);
  args[0]->collation.set(cs, DERIVATION_COERCIBLE);
  set_data_type_string(32, default_charset());
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_str_func::push_packet_overflow_warning
    return push_packet_overflow_warning(
        thd, m_cast_cs == &my_charset_bin ? "cast_as_binary" : func_name());
  }

  String *res = args[0]->val_str(str);
  if (res == nullptr) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_aes_encrypt::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: iv_argument::retrieve_iv_ptr not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: iv_argument::retrieve_iv_ptr not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_format::get_locale
MY_LOCALE *Item_func_format::get_locale(Item *) {
  assert(arg_count == 3);
  THD *thd = current_thd;
  String tmp, *locale_name = args[2]->val_str_ascii(&tmp);
  MY_LOCALE *lc;
  if (!locale_name || !(lc = my_locale_by_name(thd, locale_name->ptr(),
                                               locale_name->length()))) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, ER_UNKNOWN_LOCALE,
                        ER_THD(thd, ER_UNKNOWN_LOCALE),
                        locale_name ? locale_name->c_ptr_safe() : "NULL");
    lc = &my_locale_en_US;
  }
  return lc;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_conv::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_unhex::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_charset_conversion::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_uncompressed_length::val_int
longlong Item_func_elt::val_int() {
  assert(fixed == 1);
  uint tmp;
  null_value = true;
  if ((tmp = (uint)args[0]->val_int()) == 0 || args[0]->null_value ||
      tmp >= arg_count)
    return 0;

  longlong result = args[tmp]->val_int();
  null_value = args[tmp]->null_value;
  return result;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_compress::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_uncompress::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_strfunc.cc
Function: Item_func_internal_get_mandatory_roles_json::val_str
String *Item_func_aes_encrypt::val_str(String *str) {
  assert(fixed == 1);
  char key_buff[80]{'\0'};
  String tmp_key_value(key_buff, sizeof(key_buff), system_charset_info);
  THD *thd = current_thd;
  iv_argument iv_arg;
  DBUG_TRACE;

  String *sptr = args[0]->val_str(str);  // String to encrypt
  if (sptr == nullptr) return error_str();

  String *key = args[1]->val_str(&tmp_key_value);  // key
  if (key == nullptr) return error_str();

  my_aes_opmode aes_opmode =
      static_cast<my_aes_opmode>(thd->variables.my_aes_mode);
  assert(aes_opmode <= MY_AES_END);

  const unsigned char *iv_str = iv_arg.retrieve_iv_ptr(
      aes_opmode, arg_count, args, func_name(), thd, &null_value);
  if (null_value) return error_str();

  vector<string> kdf_options;
  kdf_argument kdf_arg;
  kdf_options =
      kdf_arg.retrieve_kdf_options(arg_count, args, func_name(), &null_value);
  if (null_value) return error_str();

  // Calculate result length
  int aes_length = my_aes_get_size(sptr->length(), aes_opmode);

  tmp_value.set_charset(&my_charset_bin);
  const uint rkey_size = my_aes_opmode_key_sizes[aes_opmode] / 8;
  uint key_size = key->length();
  if ((key_size > rkey_size) && (kdf_options.size() == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_AES_KEY_SIZE,
                        ER_THD(thd, WARN_AES_KEY_SIZE), rkey_size);
  }
  if (tmp_value.alloc(aes_length)) return error_str();

  // Finally encrypt directly to allocated buffer.
  if (my_aes_encrypt(pointer_cast<unsigned char *>(sptr->ptr()), sptr->length(),
                     pointer_cast<unsigned char *>(tmp_value.ptr()),
                     pointer_cast<unsigned char *>(key->ptr()), key->length(),
                     aes_opmode, iv_str, true,
                     (kdf_options.size() > 0) ? &kdf_options : nullptr) ==
      aes_length) {
    // We got the expected result length
    tmp_value.length(static_cast<size_t>(aes_length));
    return &tmp_value;
  }
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_typecast_year::val_int
longlong Item_func_period_add::val_int() {
  assert(fixed == 1);
  longlong period = args[0]->val_int();
  if ((null_value = args[0]->null_value)) return 0;
  longlong months = args[1]->val_int();
  if ((null_value = args[1]->null_value)) return 0;

  if (!valid_period(period)) {
    my_error(ER_WRONG_ARGUMENTS, MYF(0), func_name());
    return error_int();
  }
  return convert_month_to_period(convert_period_to_month(period) + months);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_from_days::get_date
bool Item_temporal_hybrid_func::get_date(MYSQL_TIME *ltime,
                                         my_time_flags_t fuzzy_date) {
  MYSQL_TIME tm;
  if (val_datetime(&tm, fuzzy_date)) {
    assert(null_value == true);
    return true;
  }
  if (data_type() == MYSQL_TYPE_TIME || tm.time_type == MYSQL_TIMESTAMP_TIME)
    time_to_datetime(current_thd, &tm, ltime);
  else
    *ltime = tm;
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_date_add_interval::get_date_internal
bool Item_date_add_interval::get_date_internal(MYSQL_TIME *ltime,
                                               my_time_flags_t) {
  Interval interval;

  if (args[0]->get_date(ltime, TIME_NO_ZERO_DATE)) return (null_value = true);

  if (get_interval_value(args[1], m_interval_type, &value, &interval)) {
    // Do not warn about "overflow" for NULL
    if (!args[1]->null_value) {
      push_warning_printf(
          current_thd, Sql_condition::SL_WARNING, ER_DATETIME_FUNCTION_OVERFLOW,
          ER_THD(current_thd, ER_DATETIME_FUNCTION_OVERFLOW), func_name());
    }
    return (null_value = true);
  }

  if (m_subtract) interval.neg = !interval.neg;

  /*
    Make sure we return proper time_type.
    It's important for val_str().
  */
  if (data_type() == MYSQL_TYPE_DATE &&
      ltime->time_type == MYSQL_TIMESTAMP_DATETIME)
    datetime_to_date(ltime);
  else if (data_type() == MYSQL_TYPE_DATETIME &&
           ltime->time_type == MYSQL_TIMESTAMP_DATE)
    date_to_datetime(ltime);

  if ((null_value = date_add_interval_with_warn(current_thd, ltime,
                                                m_interval_type, interval)))
    return true;
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_date_add_interval::get_time_internal
bool Item_date_add_interval::get_time_internal(MYSQL_TIME *ltime) {
  Interval interval;

  null_value = args[0]->get_time(ltime) ||
               get_interval_value(args[1], m_interval_type, &value, &interval);
  if (null_value) {
    return true;
  }
  if (m_subtract) interval.neg = !interval.neg;

  assert(!check_time_range_quick(*ltime));

  longlong usec1 =
      ((((ltime->day * 24 + ltime->hour) * 60 + ltime->minute) * 60 +
        ltime->second) *
           1000000LL +
       ltime->second_part) *
      (ltime->neg ? -1 : 1);
  longlong usec2 =
      ((((interval.day * 24 + interval.hour) * 60 + interval.minute) * 60 +
        interval.second) *
           1000000LL +
       interval.second_part) *
      (interval.neg ? -1 : 1);

  // Possible overflow adding date and interval values below.
  if ((usec1 > 0 && usec2 > 0) || (usec1 < 0 && usec2 < 0)) {
    lldiv_t usec2_as_seconds;
    usec2_as_seconds.quot = usec2 / 1000000;
    usec2_as_seconds.rem = 0;
    MYSQL_TIME unused;
    if ((null_value = sec_to_time(usec2_as_seconds, &unused))) {
      push_warning_printf(
          current_thd, Sql_condition::SL_WARNING, ER_DATETIME_FUNCTION_OVERFLOW,
          ER_THD(current_thd, ER_DATETIME_FUNCTION_OVERFLOW), "time");
      return true;
    }
  }

  longlong diff = usec1 + usec2;
  lldiv_t seconds;
  seconds.quot = diff / 1000000;
  seconds.rem = diff % 1000000 * 1000; /* time->second_part= lldiv.rem / 1000 */
  if ((null_value =
           (interval.year || interval.month || sec_to_time(seconds, ltime)))) {
    push_warning_printf(
        current_thd, Sql_condition::SL_WARNING, ER_DATETIME_FUNCTION_OVERFLOW,
        ER_THD(current_thd, ER_DATETIME_FUNCTION_OVERFLOW), "time");
    return true;
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_add_time::val_datetime
bool Item_date_add_interval::val_datetime(MYSQL_TIME *ltime,
                                          my_time_flags_t fuzzy_date) {
  if (data_type() != MYSQL_TYPE_TIME)
    return get_date_internal(ltime, fuzzy_date | TIME_NO_ZERO_DATE);
  return get_time_internal(ltime);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: Item_func_str_to_date::val_datetime
bool Item_date_add_interval::val_datetime(MYSQL_TIME *ltime,
                                          my_time_flags_t fuzzy_date) {
  if (data_type() != MYSQL_TYPE_TIME)
    return get_date_internal(ltime, fuzzy_date | TIME_NO_ZERO_DATE);
  return get_time_internal(ltime);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_timefunc.cc
Function: extract_date_time
    specifiers supported by extract_date_time() function.
*/
void Item_func_str_to_date::fix_from_format(const char *format, size_t length) {
  const char *time_part_frms = "HISThiklrs";
  const char *date_part_frms = "MVUXYWabcjmvuxyw";
  bool date_part_used = false, time_part_used = false, frac_second_used = false;
  const char *val = format;
  const char *end = format + length;

  for (; val != end; val++) {
    if (*val == '%' && val + 1 != end) {
      val++;
      if (*val == 'f')
        frac_second_used = time_part_used = true;
      else if (!time_part_used && strchr(time_part_frms, *val))
        time_part_used = true;
      else if (!date_part_used && strchr(date_part_frms, *val))
        date_part_used = true;
      if (date_part_used && frac_second_used) {
        /*
          frac_second_used implies time_part_used, and thus we already
          have all types of date-time components and can end our search.
        */
        cached_timestamp_type = MYSQL_TIMESTAMP_DATETIME;
        set_data_type_datetime(DATETIME_MAX_DECIMALS);
        return;
      }
    }
  }

  /* We don't have all three types of date-time components */
  if (frac_second_used) /* TIME with microseconds */
  {
    cached_timestamp_type = MYSQL_TIMESTAMP_TIME;
    set_data_type_time(DATETIME_MAX_DECIMALS);
  } else if (time_part_used) {
    if (date_part_used) /* DATETIME, no microseconds */
    {
      cached_timestamp_type = MYSQL_TIMESTAMP_DATETIME;
      set_data_type_datetime(0);
    } else /* TIME, no microseconds */
    {
      cached_timestamp_type = MYSQL_TIMESTAMP_TIME;
      set_data_type_time(0);
    }
  } else /* DATE */
  {
    cached_timestamp_type = MYSQL_TIMESTAMP_DATE;
    set_data_type_date();
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_inetfunc.cc
Function: Item_func_inet_aton::val_int
longlong Item_func_inet_aton::val_int() {
  assert(fixed);
  assert(arg_count == 1);
  null_value = true;

  uint byte_result = 0;
  ulonglong result = 0;
  const char *p, *end;
  char c = '.';  // we mark c to indicate invalid IP in case length is 0
  char buff[36];
  int dot_count = 0;

  String tmp(buff, sizeof(buff), &my_charset_latin1);
  String *s = args[0]->val_str_ascii(&tmp);

  if (!s)  // If NULL input value, don't emit warning
    return 0;

  p = s->ptr();
  end = p + s->length();
  while (p < end) {
    c = *p++;
    int digit = (int)(c - '0');
    if (digit >= 0 && digit <= 9) {
      byte_result = byte_result * 10 + digit;
      if (byte_result > 255) goto err;  // Wrong address
    } else if (c == '.') {
      dot_count++;
      result = (result << 8) + (ulonglong)byte_result;
      byte_result = 0;
    } else
      goto err;  // Invalid character
  }
  if (c != '.')  // IP number can't end on '.'
  {
    /*
      Attempt to support short forms of IP-addresses. It's however pretty
      basic one comparing to the BSD support.
      Examples:
        127     -> 0.0.0.127
        127.255 -> 127.0.0.255
        127.256 -> NULL (should have been 127.0.1.0)
        127.2.1 -> 127.2.0.1
    */
    switch (dot_count) {
      case 1:
        result <<= 8;
        [[fallthrough]];
      case 2:
        result <<= 8;
    }
    if (dot_count > 3)  // Too many groups
      goto err;
    null_value = false;
    return (result << 8) + (ulonglong)byte_result;
  }

err:
  char buf[256];
  String err(buf, sizeof(buf), system_charset_info);
  err.length(0);
  args[0]->print(current_thd, &err, QT_NO_DATA_EXPANSION);
  push_warning_printf(current_thd, Sql_condition::SL_WARNING,
                      ER_WRONG_VALUE_FOR_TYPE,
                      ER_THD(current_thd, ER_WRONG_VALUE_FOR_TYPE), "string",
                      err.c_ptr_safe(), func_name());

  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_inetfunc.cc
Function: Item_func_inet_ntoa::val_str
String *Item_func_inet_ntoa::val_str(String *str) {
  assert(fixed);
  assert(arg_count == 1);
  null_value = true;
  ulonglong n = (ulonglong)args[0]->val_int();

  /*
    We do not know if args[0] is NULL until we have called
    some val function on it if args[0] is not a constant!

    Also return null if n > 255.255.255.255
  */
  if (args[0]->null_value) return nullptr;
  if (n > (ulonglong)4294967295LL) {
    char buf[256];
    String err(buf, sizeof(buf), system_charset_info);
    err.length(0);
    args[0]->print(current_thd, &err, QT_NO_DATA_EXPANSION);
    push_warning_printf(current_thd, Sql_condition::SL_WARNING,
                        ER_WRONG_VALUE_FOR_TYPE,
                        ER_THD(current_thd, ER_WRONG_VALUE_FOR_TYPE), "integer",
                        err.c_ptr_safe(), func_name());
    return nullptr;
  }
  null_value = false;

  str->set_charset(collation.collation);
  str->length(0);

  uchar buf[8];
  int4store(buf, static_cast<uint32>(n));

  /* Now we can assume little endian. */

  char num[4];
  num[3] = '.';

  for (uchar *p = buf + 4; p-- > buf;) {
    uint c = *p;
    uint n1, n2;   // Try to avoid divisions
    n1 = c / 100;  // 100 digits
    c -= n1 * 100;
    n2 = c / 10;   // 10 digits
    c -= n2 * 10;  // last digit
    num[0] = (char)n1 + '0';
    num[1] = (char)n2 + '0';
    num[2] = (char)c + '0';
    uint length = (n1 ? 4 : n2 ? 3 : 2);  // Remove pre-zero
    uint dot_length = (p <= buf) ? 1 : 0;

    str->append(num + 4 - length, length - dot_length, &my_charset_latin1);
  }

  return str;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_inetfunc.cc
Function: Item_func_inet_str_base::val_str_ascii
String *Item_func_inet_str_base::val_str_ascii(String *buffer) {
  assert(fixed);
  assert(arg_count == 1);
  null_value = true;
  String *arg_str;

  /*
    (1) Out-of-memory happened (the error has been reported),
    or the argument is NULL.
    (2) String argument expected.
  */
  if (!(arg_str = args[0]->val_str(buffer)) ||  // (1)
      args[0]->result_type() != STRING_RESULT)  // (2)
  {
    // NULL value can be checked only after calling a val_* func
    if (args[0]->null_value) return nullptr;
    goto err;
  }

  if (calc_value(arg_str, buffer)) {
    null_value = false;
    return buffer;
  }

err:
  char buf[256];
  String err(buf, sizeof(buf), system_charset_info);
  err.length(0);
  args[0]->print(current_thd, &err, QT_NO_DATA_EXPANSION);
  push_warning_printf(current_thd, Sql_condition::SL_WARNING,
                      ER_WRONG_VALUE_FOR_TYPE,
                      ER_THD(current_thd, ER_WRONG_VALUE_FOR_TYPE), "string",
                      err.c_ptr_safe(), func_name());
  return error_str();
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log.cc
Function: reopen_error_log
bool reopen_error_log() {
  int component_failures;
  bool result = false;

  assert(error_log_initialized);

  // call flush function in all logging services
  if ((component_failures = log_builtins_error_stack_flush()) < 0) {
    // If flushing failed and there is a user session, alert the user.
    if (current_thd)
      push_warning_printf(
          current_thd, Sql_condition::SL_WARNING,
          ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED,
          ER_THD(current_thd, ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED),
          -component_failures);

    // Log failure to error-log.
    LogErr(ERROR_LEVEL, ER_LOG_COMPONENT_FLUSH_FAILED, -component_failures);
  }

  if (error_log_file) {
    mysql_mutex_lock(&LOCK_error_log);
    result = open_error_log(error_log_file, true);
    mysql_mutex_unlock(&LOCK_error_log);

    /*
      This may in theory get bounced to the error log if no session
      is attached to this thread (e.g. when flush/reload is called
      by SIGHUP). That's OK though as we don't hold an X-lock on
      THR_LOCK_log_stack here the way we did during
      log_builtins_error_stack_flush() above.
    */
    if (result)
      my_error(ER_DA_CANT_OPEN_ERROR_LOG, MYF(0), error_log_file, ".",
               ""); /* purecov: inspected */
  }

  return result;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/my_decimal.cc
Function: my_decimal::check_result
int my_decimal::check_result(uint mask, int result) const {
  if (result & mask) {
    int length = DECIMAL_MAX_STR_LENGTH + 1;
    char strbuff[DECIMAL_MAX_STR_LENGTH + 2];

    switch (result) {
      case E_DEC_TRUNCATED:
        // "Data truncated for column \'%s\' at row %ld"
        push_warning_printf(current_thd, Sql_condition::SL_WARNING,
                            WARN_DATA_TRUNCATED,
                            ER_THD(current_thd, WARN_DATA_TRUNCATED), "", -1L);
        break;
      case E_DEC_OVERFLOW:
        // "Truncated incorrect %-.32s value: \'%-.128s\'"
        decimal2string(this, strbuff, &length);
        push_warning_printf(
            current_thd, Sql_condition::SL_WARNING, ER_TRUNCATED_WRONG_VALUE,
            ER_THD(current_thd, ER_TRUNCATED_WRONG_VALUE), "DECIMAL", strbuff);
        break;
      case E_DEC_DIV_ZERO:
        // "Division by 0"
        push_warning(current_thd, Sql_condition::SL_WARNING,
                     ER_DIVISION_BY_ZERO,
                     ER_THD(current_thd, ER_DIVISION_BY_ZERO));
        break;
      case E_DEC_BAD_NUM:
        // "Incorrect %-.32s value: \'%-.128s\' for column \'%.192s\' at row
        // %ld"
        decimal2string(this, strbuff, &length);
        push_warning_printf(
            current_thd, Sql_condition::SL_WARNING,
            ER_TRUNCATED_WRONG_VALUE_FOR_FIELD,
            ER_THD(current_thd, ER_TRUNCATED_WRONG_VALUE_FOR_FIELD), "DECIMAL",
            strbuff, "", -1L);
        break;
      case E_DEC_OOM:
        my_error(ER_OUT_OF_RESOURCES, MYF(0));
        break;
      default:
        assert(0);
    }
  }
  return result;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/parse_tree_hints.cc
Function: PT_hint::print_warn
void PT_hint::print_warn(THD *thd, uint err_code,
                         const LEX_CSTRING *qb_name_arg,
                         LEX_CSTRING *table_name_arg, LEX_CSTRING *key_name_arg,
                         PT_hint *hint) const {
  String str;

  /* Append hint name */
  if (!state) str.append(STRING_WITH_LEN("NO_"));
  str.append(opt_hint_info[hint_type].hint_name);

  /* ER_WARN_UNKNOWN_QB_NAME with two arguments */
  if (err_code == ER_WARN_UNKNOWN_QB_NAME) {
    String qb_name_str;
    append_identifier(thd, &qb_name_str, qb_name_arg->str, qb_name_arg->length);
    push_warning_printf(thd, Sql_condition::SL_WARNING, err_code,
                        ER_THD(thd, ER_WARN_UNKNOWN_QB_NAME),
                        qb_name_str.c_ptr_safe(), str.c_ptr_safe());
    return;
  }

  /* ER_WARN_CONFLICTING_HINT with one argument */
  str.append('(');

  /* Append table name */
  if (table_name_arg && table_name_arg->length > 0)
    append_identifier(thd, &str, table_name_arg->str, table_name_arg->length);

  /* Append QB name */
  if (qb_name_arg && qb_name_arg->length > 0) {
    str.append(STRING_WITH_LEN("@"));
    append_identifier(thd, &str, qb_name_arg->str, qb_name_arg->length);
  }

  /* Append key name */
  if (key_name_arg && key_name_arg->length > 0) {
    str.append(' ');
    append_identifier(thd, &str, key_name_arg->str, key_name_arg->length);
  }

  /* Append additional hint arguments if they exist */
  if (hint) {
    if (qb_name_arg || table_name_arg || key_name_arg) str.append(' ');

    hint->append_args(thd, &str);
  }

  str.append(')');

  push_warning_printf(thd, Sql_condition::SL_WARNING, err_code,
                      ER_THD_NONCONST(thd, err_code), str.c_ptr_safe());
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/parse_tree_hints.cc
Function: PT_hint_max_execution_time::contextualize
bool PT_qb_level_hint::contextualize(Parse_context *pc) {
  if (super::contextualize(pc)) return true;

  Opt_hints_qb *qb = find_qb_hints(pc, &qb_name, this);
  if (qb == nullptr) return false;  // TODO: Should this generate a warning?

  bool no_warn = false;   // If true, do not print a warning
  bool conflict = false;  // true if this hint conflicts with a previous hint
  switch (type()) {
    case SEMIJOIN_HINT_ENUM:
      if (qb->subquery_hint)
        conflict = true;
      else if (!qb->semijoin_hint)
        qb->semijoin_hint = this;
      break;
    case SUBQUERY_HINT_ENUM:
      if (qb->semijoin_hint)
        conflict = true;
      else if (!qb->subquery_hint)
        qb->subquery_hint = this;
      break;
    case JOIN_PREFIX_HINT_ENUM:
    case JOIN_SUFFIX_HINT_ENUM:
      if (qb->get_switch(type()) || qb->get_switch(JOIN_FIXED_ORDER_HINT_ENUM))
        conflict = true;
      else
        qb->register_join_order_hint(this);
      break;
    case JOIN_ORDER_HINT_ENUM:
      if (qb->get_switch(JOIN_FIXED_ORDER_HINT_ENUM))
        conflict = true;
      else {
        /*
          Don't print 'conflicting hint' warning since
          it could be several JOIN_ORDER hints at the
          same time.
        */
        no_warn = true;
        qb->register_join_order_hint(this);
      }
      break;
    case JOIN_FIXED_ORDER_HINT_ENUM:
      if (qb->get_switch(JOIN_PREFIX_HINT_ENUM) ||
          qb->get_switch(JOIN_SUFFIX_HINT_ENUM) ||
          qb->get_switch(JOIN_ORDER_HINT_ENUM))
        conflict = true;
      else
        pc->select->add_base_options(SELECT_STRAIGHT_JOIN);
      break;
    default:
      assert(0);
  }

  if (conflict ||
      // Set hint or detect if hint has been set before
      (qb->set_switch(switch_on(), type(), false) && !no_warn))
    print_warn(pc->thd, ER_WARN_CONFLICTING_HINT, &qb_name, nullptr, nullptr,
               this);

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/parse_tree_hints.cc
Function: PT_hint_sys_var::contextualize
bool PT_qb_level_hint::contextualize(Parse_context *pc) {
  if (super::contextualize(pc)) return true;

  Opt_hints_qb *qb = find_qb_hints(pc, &qb_name, this);
  if (qb == nullptr) return false;  // TODO: Should this generate a warning?

  bool no_warn = false;   // If true, do not print a warning
  bool conflict = false;  // true if this hint conflicts with a previous hint
  switch (type()) {
    case SEMIJOIN_HINT_ENUM:
      if (qb->subquery_hint)
        conflict = true;
      else if (!qb->semijoin_hint)
        qb->semijoin_hint = this;
      break;
    case SUBQUERY_HINT_ENUM:
      if (qb->semijoin_hint)
        conflict = true;
      else if (!qb->subquery_hint)
        qb->subquery_hint = this;
      break;
    case JOIN_PREFIX_HINT_ENUM:
    case JOIN_SUFFIX_HINT_ENUM:
      if (qb->get_switch(type()) || qb->get_switch(JOIN_FIXED_ORDER_HINT_ENUM))
        conflict = true;
      else
        qb->register_join_order_hint(this);
      break;
    case JOIN_ORDER_HINT_ENUM:
      if (qb->get_switch(JOIN_FIXED_ORDER_HINT_ENUM))
        conflict = true;
      else {
        /*
          Don't print 'conflicting hint' warning since
          it could be several JOIN_ORDER hints at the
          same time.
        */
        no_warn = true;
        qb->register_join_order_hint(this);
      }
      break;
    case JOIN_FIXED_ORDER_HINT_ENUM:
      if (qb->get_switch(JOIN_PREFIX_HINT_ENUM) ||
          qb->get_switch(JOIN_SUFFIX_HINT_ENUM) ||
          qb->get_switch(JOIN_ORDER_HINT_ENUM))
        conflict = true;
      else
        pc->select->add_base_options(SELECT_STRAIGHT_JOIN);
      break;
    default:
      assert(0);
  }

  if (conflict ||
      // Set hint or detect if hint has been set before
      (qb->set_switch(switch_on(), type(), false) && !no_warn))
    print_warn(pc->thd, ER_WARN_CONFLICTING_HINT, &qb_name, nullptr, nullptr,
               this);

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partition_info.cc
Function: partition_info::print_no_partition_found
    print_no_partition_found()
    thd                          Thread handle
    table                        Table object

  RETURN VALUES
*/

void partition_info::print_no_partition_found(THD *thd, TABLE *table_arg) {
  char buf[100];
  const char *buf_ptr = buf;
  Table_ref table_list;

  table_list.db = table_arg->s->db.str;
  table_list.table_name = table_arg->s->table_name.str;

  if (check_single_table_access(thd, SELECT_ACL, &table_list, true)) {
    my_message(ER_NO_PARTITION_FOR_GIVEN_VALUE,
               ER_THD(thd, ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT), MYF(0));
  } else {
    if (column_list)
      buf_ptr = "from column_list";
    else {
      my_bitmap_map *old_map =
          dbug_tmp_use_all_columns(table_arg, table_arg->read_set);
      if (part_expr->null_value)
        buf_ptr = "NULL";
      else
        longlong10_to_str(err_value, buf, part_expr->unsigned_flag ? 10 : -10);
      dbug_tmp_restore_column_map(table_arg->read_set, old_map);
    }
    my_error(ER_NO_PARTITION_FOR_GIVEN_VALUE, MYF(0), buf_ptr);
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/partition_info.cc
Function: warn_if_dir_in_part_elem
static void warn_if_dir_in_part_elem(THD *thd, partition_element *part_elem) {
  if (thd->variables.sql_mode & MODE_NO_DIR_IN_CREATE) {
    if (part_elem->data_file_name)
      push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_OPTION_IGNORED,
                          ER_THD(thd, WARN_OPTION_IGNORED), "DATA DIRECTORY");
    if (part_elem->index_file_name)
      push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_OPTION_IGNORED,
                          ER_THD(thd, WARN_OPTION_IGNORED), "INDEX DIRECTORY");
    part_elem->data_file_name = part_elem->index_file_name = nullptr;
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_admin.cc
Function: Alter_instance_reload_tls::execute
bool Sql_cmd_analyze_table::execute(THD *thd) {
  Table_ref *first_table = thd->lex->query_block->get_table_list();
  bool res = true;
  thr_lock_type lock_type = TL_READ_NO_INSERT;
  DBUG_TRACE;

  if (check_table_access(thd, SELECT_ACL | INSERT_ACL, first_table, false,
                         UINT_MAX, false))
    goto error;

  DBUG_EXECUTE_IF("simulate_analyze_table_lock_wait_timeout_error", {
    my_error(ER_LOCK_WAIT_TIMEOUT, MYF(0));
    return true;
  });

  thd->enable_slow_log = opt_log_slow_admin_statements;

  if (get_histogram_command() != Histogram_command::NONE) {
    res = handle_histogram_command(thd, first_table);
  } else {
    res = mysql_admin_table(thd, first_table, &thd->lex->check_opt, "analyze",
                            lock_type, true, false, 0, nullptr,
                            &handler::ha_analyze, 0, m_alter_info, true);
  }

  /* ! we write after unlocking the table */
  if (!res && !thd->lex->no_write_to_binlog) {
    /*
      Presumably, ANALYZE and binlog writing doesn't require synchronization
    */
    res = write_bin_log(thd, true, thd->query().str, thd->query().length);
  }
  thd->lex->query_block->m_table_list.first = first_table;
  thd->lex->query_tables = first_table;

error:
  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_admin.cc
Function: mysql_admin_table
      on it that is left from mysql_admin_table()'s attempt to
      open it. Release the shared metadata lock before trying to
      acquire the exclusive lock to satisfy MDL asserts and avoid
      deadlocks.
    */
    thd->mdl_context.release_transactional_locks();
    /*
      Attempt to do full-blown table open in mysql_admin_table() has failed.
      Let us try to open at least a .FRM for this table.
    */
    MDL_REQUEST_INIT(&table_list->mdl_request, MDL_key::TABLE, table_list->db,
                     table_list->table_name, MDL_EXCLUSIVE, MDL_TRANSACTION);

    if (lock_table_names(thd, table_list, table_list->next_global,
                         thd->variables.lock_wait_timeout, 0))
      return 0;
    has_mdl_lock = true;

    key_length = get_table_def_key(table_list, &key);

    mysql_mutex_lock(&LOCK_open);
    share = get_table_share(thd, table_list->db, table_list->table_name, key,
                            key_length, false);
    mysql_mutex_unlock(&LOCK_open);
    if (share == nullptr) return 0;  // Can't open frm file

    if (open_table_from_share(thd, share, "", 0, 0, 0, &tmp_table, false,
                              nullptr)) {
      mysql_mutex_lock(&LOCK_open);
      release_table_share(share);
      mysql_mutex_unlock(&LOCK_open);
      return 0;  // Out of memory
    }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_ddl_table.cc
Function: Sql_cmd_create_table::execute
bool Sql_cmd_create_table::execute(THD *thd) {
  LEX *const lex = thd->lex;
  Query_block *const query_block = lex->query_block;
  Query_expression *const query_expression = lex->unit;
  Table_ref *const create_table = lex->query_tables;
  partition_info *part_info = lex->part_info;

  /*
    Code below (especially in mysql_create_table() and Query_result_create
    methods) may modify HA_CREATE_INFO structure in LEX, so we have to
    use a copy of this structure to make execution prepared statement-
    safe. A shallow copy is enough as this code won't modify any memory
    referenced from this structure.
  */
  HA_CREATE_INFO create_info(*lex->create_info);
  /*
    We need to copy alter_info for the same reasons of re-execution
    safety, only in case of Alter_info we have to do (almost) a deep
    copy.
  */
  Alter_info alter_info(*m_alter_info, thd->mem_root);

  if (thd->is_error()) {
    /* If out of memory when creating a copy of alter_info. */
    return true;
  }

  if (((lex->create_info->used_fields & HA_CREATE_USED_DATADIR) != 0 ||
       (lex->create_info->used_fields & HA_CREATE_USED_INDEXDIR) != 0) &&
      check_access(thd, FILE_ACL, any_db, nullptr, nullptr, false, false)) {
    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "FILE");
    return true;
  }

  if (!thd->is_plugin_fake_ddl()) {
    if (create_table_precheck(thd, query_expression_tables, create_table))
      return true;
  }

  /* Might have been updated in create_table_precheck */
  create_info.alias = create_table->alias;

  /*
    If no engine type was given, work out the default now
    rather than at parse-time.
  */
  if (!(create_info.used_fields & HA_CREATE_USED_ENGINE))
    create_info.db_type = create_info.options & HA_LEX_CREATE_TMP_TABLE
                              ? ha_default_temp_handlerton(thd)
                              : ha_default_handlerton(thd);

  assert(create_info.db_type != nullptr);
  if ((m_alter_info->flags & Alter_info::ANY_ENGINE_ATTRIBUTE) != 0 &&
      ((create_info.db_type->flags & HTON_SUPPORTS_ENGINE_ATTRIBUTE) == 0 &&
       DBUG_EVALUATE_IF("simulate_engine_attribute_support", false, true))) {
    my_error(ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED, MYF(0),
             ha_resolve_storage_engine_name(create_info.db_type));
    return true;
  }

  /*
    Assign target tablespace name to enable locking in lock_table_names().
    Reject invalid names.
  */
  if (create_info.tablespace) {
    if (validate_tablespace_name_length(create_info.tablespace) ||
        validate_tablespace_name(TS_CMD_NOT_DEFINED, create_info.tablespace,
                                 create_info.db_type))
      return true;

    if (lex_string_strmake(thd->mem_root, &create_table->target_tablespace_name,
                           create_info.tablespace,
                           strlen(create_info.tablespace)))
      return true;
  }

  // Reject invalid tablespace names specified for partitions.
  if (validate_partition_tablespace_name_lengths(part_info) ||
      validate_partition_tablespace_names(part_info, create_info.db_type))
    return true;

  /* Fix names if symlinked or relocated tables */
  if (prepare_index_and_data_dir_path(thd, &create_info.data_file_name,
                                      &create_info.index_file_name,
                                      create_table->table_name))
    return true;

  {
    partition_info *part = thd->lex->part_info;
    if (part != nullptr && has_external_data_or_index_dir(*part) &&
        check_access(thd, FILE_ACL, any_db, nullptr, nullptr, false, false)) {
      return true;
    }
    if (part && !(part = thd->lex->part_info->get_clone(thd, true)))
      return true;
    thd->work_part_info = part;
  }

  if (part_info != nullptr && part_info->part_expr &&
      part_info->part_expr->fixed) {  // @todo Code may be redundant
    part_info->fixed = true;
  }
  bool res = false;

  if (!query_block->field_list_is_empty())  // With select
  {
    /*
      CREATE TABLE...IGNORE/REPLACE SELECT... can be unsafe, unless
      ORDER BY PRIMARY KEY clause is used in SELECT statement. We therefore
      use row based logging if mixed or row based logging is available.
      TODO: Check if the order of the output of the select statement is
      deterministic. Waiting for BUG#42415
    */
    if (lex->is_ignore())
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_CREATE_IGNORE_SELECT);

    if (lex->duplicates == DUP_REPLACE)
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_CREATE_REPLACE_SELECT);

    /**
      Disallow creation of foreign keys if,

      - SE supports atomic DDL's.
      - The binlogging is enabled.
      - The binlog format is ROW.

      This is done to avoid complications involved in locking,
      updating and invalidation (in case of rollback) of DD cache
      for parent table.
    */
    if ((alter_info.flags & Alter_info::ADD_FOREIGN_KEY) &&
        (create_info.db_type->flags & HTON_SUPPORTS_ATOMIC_DDL) &&
        mysql_bin_log.is_open() &&
        (thd->variables.option_bits & OPTION_BIN_LOG) &&
        thd->variables.binlog_format == BINLOG_FORMAT_ROW) {
      my_error(ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT, MYF(0));
      return true;
    }

    // Reject request to CREATE TABLE AS SELECT with START TRANSACTION.
    if (create_info.m_transactional_ddl) {
      my_error(ER_NOT_ALLOWED_WITH_START_TRANSACTION, MYF(0),
               "with CREATE TABLE ... AS SELECT statement.");
      return true;
    }

    /*
      If:
      a) we inside an SP and there was NAME_CONST substitution,
      b) binlogging is on (STMT mode),
      c) we log the SP as separate statements
      raise a warning, as it may cause problems
      (see 'NAME_CONST issues' in 'Binary Logging of Stored Programs')
     */
    if (thd->query_name_consts && mysql_bin_log.is_open() &&
        thd->variables.binlog_format == BINLOG_FORMAT_STMT &&
        !mysql_bin_log.is_query_in_union(thd, thd->query_id)) {
      uint splocal_refs = 0;
      /* Count SP local vars in the top-level SELECT list */
      for (Item *item : query_block->visible_fields()) {
        if (item->is_splocal()) splocal_refs++;
      }
      /*
        If it differs from number of NAME_CONST substitution applied,
        we may have a SOME_FUNC(NAME_CONST()) in the SELECT list,
        that may cause a problem with binary log (see BUG#35383),
        raise a warning.
      */
      if (splocal_refs != thd->query_name_consts)
        push_warning(
            thd, Sql_condition::SL_WARNING, ER_UNKNOWN_ERROR,
            "Invoked routine ran a statement that may cause problems with "
            "binary log, see 'NAME_CONST issues' in 'Binary Logging of Stored "
            "Programs' "
            "section of the manual.");
    }

    /*
      Disable non-empty MERGE tables with CREATE...SELECT. Too
      complicated. See Bug #26379. Empty MERGE tables are read-only
      and don't allow CREATE...SELECT anyway.
    */
    if (create_info.used_fields & HA_CREATE_USED_UNION) {
      my_error(ER_WRONG_OBJECT, MYF(0), create_table->db,
               create_table->table_name, "BASE TABLE");
      return true;
    }

    if (query_expression->is_prepared()) {
      cleanup(thd);
    }
    auto cleanup_se_guard = create_scope_guard(
        [lex] { lex->set_secondary_engine_execution_context(nullptr); });
    if (open_tables_for_query(thd, lex->query_tables, false)) return true;

    /* The table already exists */
    if (create_table->table || create_table->is_view()) {
      if (create_info.options & HA_LEX_CREATE_IF_NOT_EXISTS) {
        push_warning_printf(thd, Sql_condition::SL_NOTE, ER_TABLE_EXISTS_ERROR,
                            ER_THD(thd, ER_TABLE_EXISTS_ERROR),
                            create_info.alias);
        my_ok(thd);
        return false;
      } else {
        my_error(ER_TABLE_EXISTS_ERROR, MYF(0), create_info.alias);
        return false;
      }
    }

    /*
      Remove target table from main select and name resolution
      context. This can't be done earlier as it will break view merging in
      statements like "CREATE TABLE IF NOT EXISTS existing_view SELECT".
    */
    bool link_to_local;
    lex->unlink_first_table(&link_to_local);

    /* Updating any other table is prohibited in CTS statement */
    for (Table_ref *table = lex->query_tables; table;
         table = table->next_global) {
      if (table->lock_descriptor().type >= TL_WRITE_ALLOW_WRITE) {
        lex->link_first_table_back(create_table, link_to_local);

        my_error(ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT, MYF(0),
                 table->table_name, create_info.alias);
        return true;
      }
    }

    Query_result_create *result;
    if (!query_expression->is_prepared()) {
      const Prepare_error_tracker tracker(thd);
      Prepared_stmt_arena_holder ps_arena_holder(thd);
      result = new (thd->mem_root)
          Query_result_create(create_table, &query_block->fields,
                              lex->duplicates, query_expression_tables);
      if (result == nullptr) {
        lex->link_first_table_back(create_table, link_to_local);
        return true;
      }

      // Use the hypergraph optimizer for the SELECT statement, if enabled.
      lex->set_using_hypergraph_optimizer(
          thd->optimizer_switch_flag(OPTIMIZER_SWITCH_HYPERGRAPH_OPTIMIZER));

      if (query_expression->prepare(thd, result, nullptr, SELECT_NO_UNLOCK,
                                    0)) {
        lex->link_first_table_back(create_table, link_to_local);
        return true;
      }
      if (!thd->stmt_arena->is_regular() && lex->save_cmd_properties(thd)) {
        lex->link_first_table_back(create_table, link_to_local);
        return true;
      }
    } else {
      result = down_cast<Query_result_create *>(
          query_expression->query_result() != nullptr
              ? query_expression->query_result()
              : query_block->query_result());
      // Restore prepared statement properties, bind table and field information
      lex->restore_cmd_properties();
      bind_fields(thd->stmt_arena->item_list());
    }
    if (validate_use_secondary_engine(lex)) return true;

    result->set_two_fields(&create_info, &alter_info);

    // For objects acquired during table creation.
    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());

    Ignore_error_handler ignore_handler;
    Strict_error_handler strict_handler;
    if (lex->is_ignore())
      thd->push_internal_handler(&ignore_handler);
    else if (thd->is_strict_mode())
      thd->push_internal_handler(&strict_handler);

    res = populate_table(thd, lex);

    // Count the number of statements offloaded to a secondary storage engine.
    if (using_secondary_storage_engine() && lex->unit->is_executed())
      ++thd->status_var.secondary_engine_execution_count;

    if (lex->is_ignore() || thd->is_strict_mode()) thd->pop_internal_handler();
    lex->cleanup(false);
    thd->clear_current_query_costs();
    lex->clear_values_map();

    // Abort the result set if execution ended in error
    if (res) result->abort_result_set(thd);

    result->cleanup();

    lex->link_first_table_back(create_table, link_to_local);
    THD_STAGE_INFO(thd, stage_end);
  } else {
    Strict_error_handler strict_handler;
    /* Push Strict_error_handler */
    if (!lex->is_ignore() && thd->is_strict_mode())
      thd->push_internal_handler(&strict_handler);
    /* regular create */
    if (create_info.options & HA_LEX_CREATE_TABLE_LIKE) {
      /* CREATE TABLE ... LIKE ... */
      res = mysql_create_like_table(thd, create_table, query_expression_tables,
                                    &create_info);
    } else {
      /* Regular CREATE TABLE */
      res = mysql_create_table(thd, create_table, &create_info, &alter_info);
    }
    /* Pop Strict_error_handler */
    if (!lex->is_ignore() && thd->is_strict_mode()) thd->pop_internal_handler();
    if (!res) {
      /* in case of create temp tables if @@session_track_state_change is
         ON then send session state notification in OK packet */
      if (create_info.options & HA_LEX_CREATE_TMP_TABLE &&
          thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
              ->is_enabled())
        thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)
            ->mark_as_changed(thd, {});
      my_ok(thd);
    }
  }
  // The following code is required to make CREATE TABLE re-execution safe.
  // @todo Consider refactoring this code.
  if (part_info != nullptr) {
    if (part_info->part_expr != nullptr &&
        part_info->part_expr->type() == Item::FIELD_ITEM)
      down_cast<Item_field *>(part_info->part_expr)->reset_field();

    if (part_info->subpart_expr != nullptr &&
        part_info->subpart_expr->type() == Item::FIELD_ITEM)
      down_cast<Item_field *>(part_info->subpart_expr)->reset_field();
  }
  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_srs.cc
Function: Sql_cmd_drop_srs::execute
bool Sql_cmd_create_srs::execute(THD *thd) {
  if (!(thd->security_context()->check_access(SUPER_ACL))) {
    my_error(ER_CMD_NEED_SUPER, MYF(0),
             m_or_replace ? "CREATE OR REPLACE SPATIAL REFERENCE SYSTEM"
                          : "CREATE SPATIAL REFERENCE SYSTEM");
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard dag(thd);
  dd::cache::Dictionary_client *dd_client = thd->dd_client();
  dd::cache::Dictionary_client::Auto_releaser releaser(dd_client);
  auto rollback_guard = create_scope_guard([thd]() {
    if (rollback(thd)) assert(false); /* purecov: deadcode */
  });
  Srs_fetcher fetcher(thd);
  dd::Spatial_reference_system *srs = nullptr;
  if (fetcher.acquire_for_modification(m_srid, &srs))
    return true; /* purecov: inspected */

  if (srs != nullptr) {
    if (m_if_not_exists) {
      push_warning_printf(thd, Sql_condition::SL_WARNING,
                          ER_WARN_SRS_ID_ALREADY_EXISTS,
                          ER_THD(thd, ER_WARN_SRS_ID_ALREADY_EXISTS), m_srid);
      my_ok(thd);
      return false;
    }
    if (!m_or_replace) {
      my_error(ER_SRS_ID_ALREADY_EXISTS, MYF(0), m_srid);
      return true;
    }

    if (fill_srs(srs)) return true;  // Error has already been flagged.

    const dd::Spatial_reference_system *old_srs = nullptr;
    if (fetcher.acquire(m_srid, &old_srs)) return true; /* purecov: inspected */
    assert(old_srs != nullptr);
    if (srs_is_used(m_srid, thd) && !old_srs->can_be_modified_to(*srs)) {
      my_error(ER_CANT_MODIFY_SRS_USED_BY_COLUMN, MYF(0), m_srid);
      return true;
    }

    warn_if_in_reserved_range(m_srid, thd);

    if (dd_client->update(srs)) return true;  // Error has already been flagged.

    rollback_guard.commit();
    if (commit(thd)) return true; /* purecov: inspected */
    my_ok(thd);
    return false;
  }

  std::unique_ptr<dd::Spatial_reference_system> new_srs(
      dd::create_object<dd::Spatial_reference_system>());
  static_cast<dd::Spatial_reference_system_impl *>(new_srs.get())
      ->set_id(m_srid);
  if (fill_srs(new_srs.get())) return true;  // Error has already been flagged.

  warn_if_in_reserved_range(m_srid, thd);

  if (thd->dd_client()->store(new_srs.get())) return true;

  rollback_guard.commit();
  if (commit(thd)) return true; /* purecov: inspected */
  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_srs.cc
Function: Sql_cmd_create_srs::execute
bool Sql_cmd_create_srs::execute(THD *thd) {
  if (!(thd->security_context()->check_access(SUPER_ACL))) {
    my_error(ER_CMD_NEED_SUPER, MYF(0),
             m_or_replace ? "CREATE OR REPLACE SPATIAL REFERENCE SYSTEM"
                          : "CREATE SPATIAL REFERENCE SYSTEM");
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard dag(thd);
  dd::cache::Dictionary_client *dd_client = thd->dd_client();
  dd::cache::Dictionary_client::Auto_releaser releaser(dd_client);
  auto rollback_guard = create_scope_guard([thd]() {
    if (rollback(thd)) assert(false); /* purecov: deadcode */
  });
  Srs_fetcher fetcher(thd);
  dd::Spatial_reference_system *srs = nullptr;
  if (fetcher.acquire_for_modification(m_srid, &srs))
    return true; /* purecov: inspected */

  if (srs != nullptr) {
    if (m_if_not_exists) {
      push_warning_printf(thd, Sql_condition::SL_WARNING,
                          ER_WARN_SRS_ID_ALREADY_EXISTS,
                          ER_THD(thd, ER_WARN_SRS_ID_ALREADY_EXISTS), m_srid);
      my_ok(thd);
      return false;
    }
    if (!m_or_replace) {
      my_error(ER_SRS_ID_ALREADY_EXISTS, MYF(0), m_srid);
      return true;
    }

    if (fill_srs(srs)) return true;  // Error has already been flagged.

    const dd::Spatial_reference_system *old_srs = nullptr;
    if (fetcher.acquire(m_srid, &old_srs)) return true; /* purecov: inspected */
    assert(old_srs != nullptr);
    if (srs_is_used(m_srid, thd) && !old_srs->can_be_modified_to(*srs)) {
      my_error(ER_CANT_MODIFY_SRS_USED_BY_COLUMN, MYF(0), m_srid);
      return true;
    }

    warn_if_in_reserved_range(m_srid, thd);

    if (dd_client->update(srs)) return true;  // Error has already been flagged.

    rollback_guard.commit();
    if (commit(thd)) return true; /* purecov: inspected */
    my_ok(thd);
    return false;
  }

  std::unique_ptr<dd::Spatial_reference_system> new_srs(
      dd::create_object<dd::Spatial_reference_system>());
  static_cast<dd::Spatial_reference_system_impl *>(new_srs.get())
      ->set_id(m_srid);
  if (fill_srs(new_srs.get())) return true;  // Error has already been flagged.

  warn_if_in_reserved_range(m_srid, thd);

  if (thd->dd_client()->store(new_srs.get())) return true;

  rollback_guard.commit();
  if (commit(thd)) return true; /* purecov: inspected */
  my_ok(thd);
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_cmd_srs.cc
Function: warn_if_in_reserved_range
static void warn_if_in_reserved_range(gis::srid_t srid, THD *thd) {
  gis::srid_t min = 0;
  gis::srid_t max = 0;

  if (srid <= 32767) {
    // Reserved by EPSG, cf. OGP Publication 373-7-1 Geomatics Guidance Note
    // number 7, part 1 - August 2012, Sect 5.9.
    min = 0;
    max = 32767;
  } else if (srid >= 60000000 && srid <= 69999999) {
    // Reserved by EPSG, cf. OGP Publication 373-7-1 Geomatics Guidance Note
    // number 7, part 1 - August 2012, Sect 5.9.
    min = 60000000;
    max = 69999999;
  } else if (srid >= 2000000000 && srid <= 2147483647) {
    // Reserved by MySQL.
    min = 2000000000;
    max = 2147483647;
  }

  if (!(min == 0 && max == 0)) {
    push_warning_printf(thd, Sql_condition::SL_WARNING,
                        ER_WARN_RESERVED_SRID_RANGE,
                        ER_THD(thd, ER_WARN_RESERVED_SRID_RANGE), min, max);
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_load.cc
Function: Sql_cmd_load_table::execute_inner
    Arg must be set from Sql_cmd_load_table::execute_inner()
    since constructor does not see either the table or THD value
  */
  void set_io_cache_arg(void *arg) { cache.arg = arg; }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_load.cc
Function: Sql_cmd_load_table::read_xml_field
bool Sql_cmd_load_table::read_xml_field(THD *thd, COPY_INFO &info,
                                        Table_ref *table_list,
                                        READ_INFO &read_info,
                                        ulong skip_lines) {
  TABLE *table = table_list->table;
  const CHARSET_INFO *cs = read_info.read_charset;
  DBUG_TRACE;

  for (;;) {
    if (thd->killed) {
      thd->send_kill_message();
      return true;
    }

    // read row tag and save values into tag list
    if (read_info.read_xml()) break;

    List_iterator_fast<XML_TAG> xmlit(read_info.taglist);
    xmlit.rewind();
    XML_TAG *tag = nullptr;

#ifndef NDEBUG
    DBUG_PRINT("read_xml_field", ("skip_lines=%d", (int)skip_lines));
    while ((tag = xmlit++)) {
      DBUG_PRINT("read_xml_field", ("got tag:%i '%s' '%s'", tag->level,
                                    tag->field.c_ptr(), tag->value.c_ptr()));
    }
#endif

    restore_record(table, s->default_values);
    /*
      Check whether default values of the fields not specified in column list
      are correct or not.
    */
    if (validate_default_values_of_unset_fields(thd, table)) {
      read_info.error = true;
      break;
    }

    Autoinc_field_has_explicit_non_null_value_reset_guard after_each_row(table);

    auto it = m_opt_fields_or_vars.begin();
    Item *item = nullptr;
    for (; it != m_opt_fields_or_vars.end(); ++it) {
      item = *it;
      /* If this line is to be skipped we don't want to fill field or var */
      if (skip_lines) continue;

      // Skip hidden generated columns.
      if (is_hidden_generated_column(table, item)) continue;

      /* find field in tag list */
      xmlit.rewind();
      tag = xmlit++;

      while (tag && strcmp(tag->field.c_ptr(), item->item_name.ptr()) != 0)
        tag = xmlit++;

      item = item->real_item();

      if (!tag)  // found null
      {
        if (item->type() == Item::FIELD_ITEM) {
          Field *field = (static_cast<Item_field *>(item))->field;
          field->reset();
          field->set_null();
          if (field == table->next_number_field)
            table->autoinc_field_has_explicit_non_null_value = true;
          if (!field->is_nullable()) {
            if (field->type() == FIELD_TYPE_TIMESTAMP)
              // Specific of TIMESTAMP NOT NULL: set to CURRENT_TIMESTAMP.
              Item_func_now_local::store_in(field);
            else if (field != table->next_number_field)
              field->set_warning(Sql_condition::SL_WARNING,
                                 ER_WARN_NULL_TO_NOTNULL, 1);
          }
        } else {
          assert(nullptr != dynamic_cast<Item_user_var_as_out_param *>(item));
          ((Item_user_var_as_out_param *)item)->set_null_value(cs);
        }
        continue;
      }

      if (item->type() == Item::FIELD_ITEM) {
        Field *field = ((Item_field *)item)->field;
        field->set_notnull();
        if (field == table->next_number_field)
          table->autoinc_field_has_explicit_non_null_value = true;
        field->store(tag->value.ptr(), tag->value.length(), cs);
      } else {
        assert(nullptr != dynamic_cast<Item_user_var_as_out_param *>(item));
        ((Item_user_var_as_out_param *)item)
            ->set_value(tag->value.ptr(), tag->value.length(), cs);
      }
    }

    if (read_info.error) break;

    if (skip_lines) {
      skip_lines--;
      continue;
    }

    if (item != nullptr) {
      /* Have not read any field, thus input file is simply ended */
      if (it == m_opt_fields_or_vars.begin()) break;

      for (; it != m_opt_fields_or_vars.end(); item = *it++) {
        if (item->type() == Item::FIELD_ITEM) {
          /*
            QQ: We probably should not throw warning for each field.
            But how about intention to always have the same number
            of warnings in THD::num_truncated_fields (and get rid of
            num_truncated_fields in the end?)
          */
          thd->num_truncated_fields++;
          push_warning_printf(thd, Sql_condition::SL_WARNING,
                              ER_WARN_TOO_FEW_RECORDS,
                              ER_THD(thd, ER_WARN_TOO_FEW_RECORDS),
                              thd->get_stmt_da()->current_row_for_condition());
        } else {
          assert(nullptr != dynamic_cast<Item_user_var_as_out_param *>(item));
          ((Item_user_var_as_out_param *)item)->set_null_value(cs);
        }
      }
    }

    if (thd->killed || fill_record_n_invoke_before_triggers(
                           thd, &info, m_opt_set_fields, m_opt_set_exprs, table,
                           TRG_EVENT_INSERT, table->s->fields, true, nullptr))
      return true;

    switch (table_list->view_check_option(thd)) {
      case VIEW_CHECK_SKIP:
        goto continue_loop;
      case VIEW_CHECK_ERROR:
        return true;
    }

    if (invoke_table_check_constraints(thd, table)) {
      if (thd->is_error()) return true;
      // continue when IGNORE clause is used.
      goto continue_loop;
    }

    if (write_record(thd, table, &info, nullptr)) return true;

    /*
      We don't need to reset auto-increment field since we are restoring
      its default value at the beginning of each loop iteration.
    */
    thd->get_stmt_da()->inc_current_row_for_condition();
  continue_loop:;
  }
  return read_info.error || thd->is_error();
} /* load xml end */


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_load.cc
Function: Sql_cmd_load_table::read_fixed_length
    defaults are set by read_fixed_length() and read_sep_field(),
    not by COPY_INFO.
    * LOAD DATA INFILE fff INTO TABLE xxx (columns1) SET columns2=
    may need a default for columns other than columns1 and columns2.
  */
  const bool manage_defaults = !m_opt_fields_or_vars.empty();
  COPY_INFO info(COPY_INFO::INSERT_OPERATION, &m_opt_fields_or_vars,
                 &m_opt_set_fields, manage_defaults, handle_duplicates,
                 escape_char);

  if (info.add_function_default_columns(table, table->write_set)) return true;

  if (table->triggers) {
    if (table->triggers->mark_fields(TRG_EVENT_INSERT)) return true;
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_load.cc
Function: Sql_cmd_load_table::read_sep_field
bool Sql_cmd_load_table::read_sep_field(THD *thd, COPY_INFO &info,
                                        Table_ref *table_list,
                                        READ_INFO &read_info,
                                        const String &enclosed,
                                        ulong skip_lines) {
  TABLE *table = table_list->table;
  size_t enclosed_length;
  bool err;
  DBUG_TRACE;

  enclosed_length = enclosed.length();

  for (;;) {
    if (thd->killed) {
      thd->send_kill_message();
      return true;
    }

    restore_record(table, s->default_values);
    /*
      Check whether default values of the fields not specified in column list
      are correct or not.
    */
    if (validate_default_values_of_unset_fields(thd, table)) {
      read_info.error = true;
      break;
    }

    Autoinc_field_has_explicit_non_null_value_reset_guard after_each_row(table);

    auto it = m_opt_fields_or_vars.begin();
    for (; it != m_opt_fields_or_vars.end(); ++it) {
      Item *item = *it;
      uint length;
      uchar *pos;
      Item *real_item;

      // Skip hidden generated columns.
      if (is_hidden_generated_column(table, item)) continue;

      if (read_info.read_field()) break;

      /* If this line is to be skipped we don't want to fill field or var */
      if (skip_lines) continue;

      pos = read_info.row_start;
      length = (uint)(read_info.row_end - pos);

      real_item = item->real_item();

      Field_tmp_nullability_guard fld_tmp_nullability_guard(real_item);

      if ((!read_info.enclosed && (enclosed_length && length == 4 &&
                                   !memcmp(pos, STRING_WITH_LEN("NULL")))) ||
          (length == 1 && read_info.found_null)) {
        if (real_item->type() == Item::FIELD_ITEM) {
          Field *field = ((Item_field *)real_item)->field;
          if (field->reset())  // Set to 0
          {
            my_error(ER_WARN_NULL_TO_NOTNULL, MYF(0), field->field_name,
                     thd->get_stmt_da()->current_row_for_condition());
            return true;
          }
          if (!field->is_nullable() && field->type() == FIELD_TYPE_TIMESTAMP) {
            // Specific of TIMESTAMP NOT NULL: set to CURRENT_TIMESTAMP.
            Item_func_now_local::store_in(field);
          } else {
            /*
              Set field to NULL. Later we will clear temporary nullability flag
              and check NOT NULL constraint.
            */
            field->set_null();
          }
        } else if (item->type() == Item::STRING_ITEM) {
          assert(nullptr != dynamic_cast<Item_user_var_as_out_param *>(item));
          ((Item_user_var_as_out_param *)item)
              ->set_null_value(read_info.read_charset);
        }

        continue;
      }

      if (real_item->type() == Item::FIELD_ITEM) {
        Field *field = ((Item_field *)real_item)->field;
        field->set_notnull();
        read_info.row_end[0] = 0;  // Safe to change end marker
        if (field == table->next_number_field)
          table->autoinc_field_has_explicit_non_null_value = true;
        field->store((char *)pos, length, read_info.read_charset);
      } else if (item->type() == Item::STRING_ITEM) {
        assert(nullptr != dynamic_cast<Item_user_var_as_out_param *>(item));
        ((Item_user_var_as_out_param *)item)
            ->set_value((char *)pos, length, read_info.read_charset);
      }
    }

    if (thd->is_error()) read_info.error = true;

    if (read_info.error) break;
    if (skip_lines) {
      skip_lines--;
      continue;
    }
    if (it != m_opt_fields_or_vars.end()) {
      /* Have not read any field, thus input file is simply ended */
      if (it == m_opt_fields_or_vars.begin()) break;

      for (; it != m_opt_fields_or_vars.end(); ++it) {
        Item *item = *it;
        Item *real_item = item->real_item();
        if (real_item->type() == Item::FIELD_ITEM) {
          Field *field = ((Item_field *)real_item)->field;
          /*
            We set to 0. But if the field is DEFAULT NULL, the "null bit"
            turned on by restore_record() above remains so field will be NULL.
          */
          if (field->reset()) {
            my_error(ER_WARN_NULL_TO_NOTNULL, MYF(0), field->field_name,
                     thd->get_stmt_da()->current_row_for_condition());
            return true;
          }
          if (field->type() == FIELD_TYPE_TIMESTAMP && !field->is_nullable())
            // Specific of TIMESTAMP NOT NULL: set to CURRENT_TIMESTAMP.
            Item_func_now_local::store_in(field);
          /*
            QQ: We probably should not throw warning for each field.
            But how about intention to always have the same number
            of warnings in THD::num_truncated_fields (and get rid of
            num_truncated_fields in the end?)
          */
          thd->num_truncated_fields++;
          push_warning_printf(thd, Sql_condition::SL_WARNING,
                              ER_WARN_TOO_FEW_RECORDS,
                              ER_THD(thd, ER_WARN_TOO_FEW_RECORDS),
                              thd->get_stmt_da()->current_row_for_condition());
        } else if (item->type() == Item::STRING_ITEM) {
          assert(nullptr != dynamic_cast<Item_user_var_as_out_param *>(item));
          ((Item_user_var_as_out_param *)item)
              ->set_null_value(read_info.read_charset);
        }
      }
    }

    if (thd->killed || fill_record_n_invoke_before_triggers(
                           thd, &info, m_opt_set_fields, m_opt_set_exprs, table,
                           TRG_EVENT_INSERT, table->s->fields, true, nullptr))
      return true;

    if (!table->triggers) {
      /*
        If there is no trigger for the table then check the NOT NULL constraint
        for every table field.

        For the table that has BEFORE-INSERT trigger installed checking for
        NOT NULL constraint is done inside function
        fill_record_n_invoke_before_triggers() after all trigger instructions
        has been executed.
      */
      for (Item *item : m_opt_fields_or_vars) {
        Item *real_item = item->real_item();
        if (real_item->type() == Item::FIELD_ITEM)
          ((Item_field *)real_item)
              ->field->check_constraints(ER_WARN_NULL_TO_NOTNULL);
      }
    }

    if (thd->is_error()) return true;

    switch (table_list->view_check_option(thd)) {
      case VIEW_CHECK_SKIP:
        read_info.next_line();
        goto continue_loop;
      case VIEW_CHECK_ERROR:
        return true;
    }

    if (invoke_table_check_constraints(thd, table)) {
      if (thd->is_error()) return true;
      // continue when IGNORE clause is used.
      read_info.next_line();
      goto continue_loop;
    }

    err = write_record(thd, table, &info, nullptr);
    if (err) return true;
    /*
      We don't need to reset auto-increment field since we are restoring
      its default value at the beginning of each loop iteration.
    */
    if (read_info.next_line())  // Skip to next line
      break;
    if (read_info.line_truncated) {
      thd->num_truncated_fields++; /* Too long row */
      push_warning_printf(thd, Sql_condition::SL_WARNING,
                          ER_WARN_TOO_MANY_RECORDS,
                          ER_THD(thd, ER_WARN_TOO_MANY_RECORDS),
                          thd->get_stmt_da()->current_row_for_condition());
      if (thd->killed) return true;
    }
    thd->get_stmt_da()->inc_current_row_for_condition();
  continue_loop:;
  }
  return read_info.error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/event_parse_data.cc
Function: Event_parse_data::check_if_in_the_past
void Event_parse_data::check_if_in_the_past(THD *thd, my_time_t ltime_utc) {
  if (ltime_utc >= (my_time_t)thd->query_start_in_secs()) return;

  /*
    We'll come back later when we have the real on_completion value
  */
  if (on_completion == Event_parse_data::ON_COMPLETION_DEFAULT) return;

  if (on_completion == Event_parse_data::ON_COMPLETION_DROP) {
    switch (thd->lex->sql_command) {
      case SQLCOM_CREATE_EVENT:
        push_warning(thd, Sql_condition::SL_NOTE,
                     ER_EVENT_CANNOT_CREATE_IN_THE_PAST,
                     ER_THD(thd, ER_EVENT_CANNOT_CREATE_IN_THE_PAST));
        break;
      case SQLCOM_ALTER_EVENT:
        my_error(ER_EVENT_CANNOT_ALTER_IN_THE_PAST, MYF(0));
        break;
      default:
        assert(0);
    }

    do_not_create = true;
  } else if (status == Event_parse_data::ENABLED) {
    status = Event_parse_data::DISABLED;
    status_changed = true;
    push_warning(thd, Sql_condition::SL_NOTE, ER_EVENT_EXEC_TIME_IN_THE_PAST,
                 ER_THD(thd, ER_EVENT_EXEC_TIME_IN_THE_PAST));
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_geofunc.cc
Function: Item_func_as_wkt::val_str_ascii
String *Item_func_geohash::val_str_ascii(String *str) {
  assert(fixed == true);

  if (fill_and_check_fields()) {
    if (null_value) {
      return nullptr;
    } else {
      /*
        Since null_value == false, my_error() was raised inside
        fill_and_check_fields().
      */
      return error_str();
    }
  }

  // Allocate one extra byte, for trailing '\0'.
  if (str->alloc(geohash_max_output_length + 1)) return make_empty_result();
  str->length(0);

  double upper_latitude = max_latitude;
  double lower_latitude = min_latitude;
  double upper_longitude = max_longitude;
  double lower_longitude = min_longitude;
  bool even_bit = true;

  for (uint i = 0; i < geohash_max_output_length; i++) {
    /*
      We must encode in blocks of five bits, so we don't risk stopping
      in the middle of a character. If we stop in the middle of a character,
      some encoded geohash values will differ from geohash.org.
    */
    char current_char = 0;
    for (uint bit_number = 0; bit_number < 5; bit_number++) {
      if (even_bit) {
        // Encode one longitude bit.
        encode_bit(&upper_longitude, &lower_longitude, longitude, &current_char,
                   bit_number);
      } else {
        // Encode one latitude bit.
        encode_bit(&upper_latitude, &lower_latitude, latitude, &current_char,
                   bit_number);
      }
      even_bit = !even_bit;
    }
    q_append(char_to_base32(current_char), str);

    /*
      If encoded values of latitude and longitude matches the supplied
      arguments, there is no need to do more calculation.
    */
    if (latitude == (lower_latitude + upper_latitude) / 2.0 &&
        longitude == (lower_longitude + upper_longitude) / 2.0)
      break;
  }
  return str;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_geofunc.cc
Function: Item_func_as_wkb::val_str
String *Item_func_geometry_from_text::val_str(String *str) {
  assert(fixed == 1);
  Geometry_buffer buffer;
  String arg_val;
  String *wkt = args[0]->val_str_ascii(&arg_val);
  bool reverse = false;
  bool srid_default_ordering = true;
  bool is_geographic = false;
  bool lat_long = false;

  if ((null_value = (args[0]->null_value))) {
    assert(is_nullable());
    return nullptr;
  }

  if (!wkt) {
    /*
      We've already found out that args[0]->null_value is false.
      Therefore, wkt should never be null.
    */
    assert(false);
    my_error(ER_GIS_INVALID_DATA, MYF(0), func_name());
    return error_str();
  }

  Gis_read_stream trs(current_thd, wkt->charset(), wkt->ptr(), wkt->length());
  gis::srid_t srid = 0;

  if (arg_count >= 2) {
    if (validate_srid_arg(args[1], &srid, &null_value, func_name()))
      return error_str();
    if (null_value) {
      assert(is_nullable());
      return nullptr;
    }
  }

  const dd::Spatial_reference_system *srs = nullptr;
  std::unique_ptr<dd::cache::Dictionary_client::Auto_releaser> releaser(
      new dd::cache::Dictionary_client::Auto_releaser(
          current_thd->dd_client()));
  if (srid != 0) {
    Srs_fetcher fetcher(current_thd);
    if (fetcher.acquire(srid, &srs)) {
      return error_str();
    }

    if (srs == nullptr) {
      my_error(ER_SRS_NOT_FOUND, MYF(0), srid);
      return error_str();
    } else if (srs->is_geographic()) {
      is_geographic = true;
      lat_long = srs->is_lat_long();
    }
  }

  if (arg_count == 3) {
    String axis_ordering_tmp;
    String *axis_order = args[2]->val_str_ascii(&axis_ordering_tmp);
    null_value = (args[2]->null_value);
    if (null_value) {
      assert(is_nullable());
      return nullptr;
    }
    std::map<std::string, std::string> options;
    if (options_parser::parse_string(axis_order, &options, func_name())) {
      return error_str();
    }

    for (auto pair : options) {
      const std::string key = pair.first;
      const std::string value = pair.second;

      if (key == "axis-order") {
        if (value == "lat-long") {
          reverse = true;
          srid_default_ordering = false;
        } else if (value == "long-lat") {
          reverse = false;
          srid_default_ordering = false;
        } else if (value == "srid-defined") {
          // This is the default.
        } else {
          my_error(ER_INVALID_OPTION_VALUE, MYF(0), value.c_str(), key.c_str(),
                   func_name());
          return error_str();
        }
      } else {
        my_error(ER_INVALID_OPTION_KEY, MYF(0), key.c_str(), func_name());
        return error_str();
      }
    }
  }

  if (srid_default_ordering && is_geographic && lat_long) {
    reverse = true;
  }
  String temp(wkt->length());

  Geometry *g = Geometry::create_from_wkt(&buffer, &trs, &temp, true);
  if (g == nullptr) {
    my_error(ER_GIS_INVALID_DATA, MYF(0), func_name());
    return error_str();
  }
  if (!is_allowed_wkb_type(g->get_type())) {
    my_error(ER_UNEXPECTED_GEOMETRY_TYPE, MYF(0), "WKT",
             g->get_class_info()->m_name.str, func_name());
    return error_str();
  }

  if (reverse && is_geographic) {
    if (g->reverse_coordinates()) {
      my_error(ER_GIS_INVALID_DATA, MYF(0), func_name());
      return error_str();
    }
  }

  if (is_geographic) {
    bool latitude_out_of_range;
    bool longitude_out_of_range;
    double out_of_range_coord_value;
    if (g->validate_coordinate_range(
            srs->angular_unit(), &longitude_out_of_range,
            &latitude_out_of_range, &out_of_range_coord_value)) {
      if (longitude_out_of_range) {
        my_error(ER_LONGITUDE_OUT_OF_RANGE, MYF(0), out_of_range_coord_value,
                 func_name(), srs->from_radians(-M_PI),
                 srs->from_radians(M_PI));
        return error_str();
      }

      if (latitude_out_of_range) {
        my_error(ER_LATITUDE_OUT_OF_RANGE, MYF(0), out_of_range_coord_value,
                 func_name(), srs->from_radians(-M_PI_2),
                 srs->from_radians(M_PI_2));
        return error_str();
      }

      my_error(ER_GIS_INVALID_DATA, MYF(0),
               func_name()); /* purecov: inspected */
      return error_str();    /* purecov: inspected */
    }
  }

  str->set_charset(&my_charset_bin);
  if (str->reserve(SRID_SIZE + temp.length())) return error_str();
  str->length(0);
  q_append(srid, str);
  str->append(temp);

  return str;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_geofunc.cc
Function: Item_func_spatial_collection::val_str
String *Item_func_geometry_from_text::val_str(String *str) {
  assert(fixed == 1);
  Geometry_buffer buffer;
  String arg_val;
  String *wkt = args[0]->val_str_ascii(&arg_val);
  bool reverse = false;
  bool srid_default_ordering = true;
  bool is_geographic = false;
  bool lat_long = false;

  if ((null_value = (args[0]->null_value))) {
    assert(is_nullable());
    return nullptr;
  }

  if (!wkt) {
    /*
      We've already found out that args[0]->null_value is false.
      Therefore, wkt should never be null.
    */
    assert(false);
    my_error(ER_GIS_INVALID_DATA, MYF(0), func_name());
    return error_str();
  }

  Gis_read_stream trs(current_thd, wkt->charset(), wkt->ptr(), wkt->length());
  gis::srid_t srid = 0;

  if (arg_count >= 2) {
    if (validate_srid_arg(args[1], &srid, &null_value, func_name()))
      return error_str();
    if (null_value) {
      assert(is_nullable());
      return nullptr;
    }
  }

  const dd::Spatial_reference_system *srs = nullptr;
  std::unique_ptr<dd::cache::Dictionary_client::Auto_releaser> releaser(
      new dd::cache::Dictionary_client::Auto_releaser(
          current_thd->dd_client()));
  if (srid != 0) {
    Srs_fetcher fetcher(current_thd);
    if (fetcher.acquire(srid, &srs)) {
      return error_str();
    }

    if (srs == nullptr) {
      my_error(ER_SRS_NOT_FOUND, MYF(0), srid);
      return error_str();
    } else if (srs->is_geographic()) {
      is_geographic = true;
      lat_long = srs->is_lat_long();
    }
  }

  if (arg_count == 3) {
    String axis_ordering_tmp;
    String *axis_order = args[2]->val_str_ascii(&axis_ordering_tmp);
    null_value = (args[2]->null_value);
    if (null_value) {
      assert(is_nullable());
      return nullptr;
    }
    std::map<std::string, std::string> options;
    if (options_parser::parse_string(axis_order, &options, func_name())) {
      return error_str();
    }

    for (auto pair : options) {
      const std::string key = pair.first;
      const std::string value = pair.second;

      if (key == "axis-order") {
        if (value == "lat-long") {
          reverse = true;
          srid_default_ordering = false;
        } else if (value == "long-lat") {
          reverse = false;
          srid_default_ordering = false;
        } else if (value == "srid-defined") {
          // This is the default.
        } else {
          my_error(ER_INVALID_OPTION_VALUE, MYF(0), value.c_str(), key.c_str(),
                   func_name());
          return error_str();
        }
      } else {
        my_error(ER_INVALID_OPTION_KEY, MYF(0), key.c_str(), func_name());
        return error_str();
      }
    }
  }

  if (srid_default_ordering && is_geographic && lat_long) {
    reverse = true;
  }
  String temp(wkt->length());

  Geometry *g = Geometry::create_from_wkt(&buffer, &trs, &temp, true);
  if (g == nullptr) {
    my_error(ER_GIS_INVALID_DATA, MYF(0), func_name());
    return error_str();
  }
  if (!is_allowed_wkb_type(g->get_type())) {
    my_error(ER_UNEXPECTED_GEOMETRY_TYPE, MYF(0), "WKT",
             g->get_class_info()->m_name.str, func_name());
    return error_str();
  }

  if (reverse && is_geographic) {
    if (g->reverse_coordinates()) {
      my_error(ER_GIS_INVALID_DATA, MYF(0), func_name());
      return error_str();
    }
  }

  if (is_geographic) {
    bool latitude_out_of_range;
    bool longitude_out_of_range;
    double out_of_range_coord_value;
    if (g->validate_coordinate_range(
            srs->angular_unit(), &longitude_out_of_range,
            &latitude_out_of_range, &out_of_range_coord_value)) {
      if (longitude_out_of_range) {
        my_error(ER_LONGITUDE_OUT_OF_RANGE, MYF(0), out_of_range_coord_value,
                 func_name(), srs->from_radians(-M_PI),
                 srs->from_radians(M_PI));
        return error_str();
      }

      if (latitude_out_of_range) {
        my_error(ER_LATITUDE_OUT_OF_RANGE, MYF(0), out_of_range_coord_value,
                 func_name(), srs->from_radians(-M_PI_2),
                 srs->from_radians(M_PI_2));
        return error_str();
      }

      my_error(ER_GIS_INVALID_DATA, MYF(0),
               func_name()); /* purecov: inspected */
      return error_str();    /* purecov: inspected */
    }
  }

  str->set_charset(&my_charset_bin);
  if (str->reserve(SRID_SIZE + temp.length())) return error_str();
  str->length(0);
  q_append(srid, str);
  str->append(temp);

  return str;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_geofunc.cc
Function: Item_func_st_srid_observer::val_int
longlong Item_func_isempty::val_int() {
  assert(fixed == 1);
  String tmp;
  String *swkb = args[0]->val_str(&tmp);
  Geometry_buffer buffer;
  Geometry *g = nullptr;

  if ((null_value = (!swkb || args[0]->null_value))) return 0;
  if (!(g = Geometry::construct(&buffer, swkb))) {
    my_error(ER_GIS_INVALID_DATA, MYF(0), func_name());
    return error_int();
  }

  if (verify_srid_is_defined(g->get_srid())) return error_int();

  return (null_value || is_empty_geocollection(g)) ? 1 : 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::ordered_commit
int MYSQL_BIN_LOG::ordered_commit(THD *thd, bool all, bool skip_commit) {
  DBUG_TRACE;
  int flush_error = 0, sync_error = 0;
  my_off_t total_bytes = 0;
  bool do_rotate = false;

  CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP("before_assign_session_to_bgc_ticket");
  thd->rpl_thd_ctx.binlog_group_commit_ctx().assign_ticket();

  DBUG_EXECUTE_IF("syncpoint_before_wait_on_ticket_3",
                  binlog::Bgc_ticket_manager::instance().push_new_ticket(););
  DBUG_EXECUTE_IF("begin_new_bgc_ticket",
                  binlog::Bgc_ticket_manager::instance().push_new_ticket(););

  DBUG_EXECUTE_IF("crash_commit_before_log", DBUG_SUICIDE(););
  init_thd_variables(thd, all, skip_commit);
  DBUG_PRINT("enter", ("commit_pending: %s, commit_error: %d, thread_id: %u",
                       YESNO(thd->tx_commit_pending), thd->commit_error,
                       thd->thread_id()));

  DEBUG_SYNC(thd, "bgc_before_flush_stage");
  DBUG_EXECUTE_IF("ordered_commit_blocked", {
    const char act[] =
        "now signal signal.ordered_commit_waiting wait_for "
        "signal.ordered_commit_continue";
    assert(!debug_sync_set_action(current_thd, STRING_WITH_LEN(act)));
  });

  /*
    Stage #0: ensure slave threads commit order as they appear in the slave's
              relay log for transactions flushing to binary log.

    This will make thread wait until its turn to commit.
    Commit_order_manager maintains it own queue and its own order for the
    commit. So Stage#0 doesn't maintain separate StageID.
  */
  if (Commit_order_manager::wait_for_its_turn_before_flush_stage(thd) ||
      ending_trans(thd, all) ||
      Commit_order_manager::get_rollback_status(thd)) {
    if (Commit_order_manager::wait(thd)) {
      return thd->commit_error;
    }
  }

  /*
    Stage #1: flushing transactions to binary log

    While flushing, we allow new threads to enter and will process
    them in due time. Once the queue was empty, we cannot reap
    anything more since it is possible that a thread entered and
    appointed itself leader for the flush phase.
  */

  if (change_stage(thd, Commit_stage_manager::BINLOG_FLUSH_STAGE, thd, nullptr,
                   &LOCK_log)) {
    DBUG_PRINT("return", ("Thread ID: %u, commit_error: %d", thd->thread_id(),
                          thd->commit_error));
    return finish_commit(thd);
  }

  THD *wait_queue = nullptr, *final_queue = nullptr;
  mysql_mutex_t *leave_mutex_before_commit_stage = nullptr;
  my_off_t flush_end_pos = 0;
  bool update_binlog_end_pos_after_sync;
  if (unlikely(!is_open())) {
    final_queue = fetch_and_process_flush_stage_queue(true);
    leave_mutex_before_commit_stage = &LOCK_log;
    /*
      binary log is closed, flush stage and sync stage should be
      ignored. Binlog cache should be cleared, but instead of doing
      it here, do that work in 'finish_commit' function so that
      leader and followers thread caches will be cleared.
    */
    goto commit_stage;
  }
  DEBUG_SYNC(thd, "waiting_in_the_middle_of_flush_stage");
  flush_error =
      process_flush_stage_queue(&total_bytes, &do_rotate, &wait_queue);

  if (flush_error == 0 && total_bytes > 0)
    flush_error = flush_cache_to_file(&flush_end_pos);
  DBUG_EXECUTE_IF("crash_after_flush_binlog", DBUG_SUICIDE(););

  update_binlog_end_pos_after_sync = (get_sync_period() == 1);

  /*
    If the flush finished successfully, we can call the after_flush
    hook. Being invoked here, we have the guarantee that the hook is
    executed before the before/after_send_hooks on the dump thread
    preventing race conditions among these plug-ins.
  */
  if (flush_error == 0) {
    const char *file_name_ptr = log_file_name + dirname_length(log_file_name);
    assert(flush_end_pos != 0);
    if (RUN_HOOK(binlog_storage, after_flush,
                 (thd, file_name_ptr, flush_end_pos))) {
      LogErr(ERROR_LEVEL, ER_BINLOG_FAILED_TO_RUN_AFTER_FLUSH_HOOK);
      flush_error = ER_ERROR_ON_WRITE;
    }

    if (!update_binlog_end_pos_after_sync) update_binlog_end_pos();

    DBUG_EXECUTE_IF("crash_commit_after_log", DBUG_SUICIDE(););
  }

  if (flush_error) {
    /*
      Handle flush error (if any) after leader finishes it's flush stage.
    */
    handle_binlog_flush_or_sync_error(
        thd, false /* need_lock_log */,
        (thd->commit_error == THD::CE_FLUSH_GNO_EXHAUSTED_ERROR)
            ? ER_THD(thd, ER_GNO_EXHAUSTED)
            : nullptr);
  }

  DEBUG_SYNC(thd, "bgc_after_flush_stage_before_sync_stage");

  /*
    Stage #2: Syncing binary log file to disk
  */

  if (change_stage(thd, Commit_stage_manager::SYNC_STAGE, wait_queue, &LOCK_log,
                   &LOCK_sync)) {
    DBUG_PRINT("return", ("Thread ID: %u, commit_error: %d", thd->thread_id(),
                          thd->commit_error));
    return finish_commit(thd);
  }

  /*
    Shall introduce a delay only if it is going to do sync
    in this ongoing SYNC stage. The "+1" used below in the
    if condition is to count the ongoing sync stage.
    When sync_binlog=0 (where we never do sync in BGC group),
    it is considered as a special case and delay will be executed
    for every group just like how it is done when sync_binlog= 1.
  */
  if (!flush_error && (sync_counter + 1 >= get_sync_period()))
    Commit_stage_manager::get_instance().wait_count_or_timeout(
        opt_binlog_group_commit_sync_no_delay_count,
        opt_binlog_group_commit_sync_delay, Commit_stage_manager::SYNC_STAGE);

  final_queue = Commit_stage_manager::get_instance().fetch_queue_acquire_lock(
      Commit_stage_manager::SYNC_STAGE);

  if (flush_error == 0 && total_bytes > 0) {
    DEBUG_SYNC(thd, "before_sync_binlog_file");
    std::pair<bool, bool> result = sync_binlog_file(false);
    sync_error = result.first;
  }

  if (update_binlog_end_pos_after_sync && flush_error == 0 && sync_error == 0) {
    THD *tmp_thd = final_queue;
    const char *binlog_file = nullptr;
    my_off_t pos = 0;

    while (tmp_thd != nullptr) {
      if (tmp_thd->commit_error == THD::CE_NONE) {
        tmp_thd->get_trans_fixed_pos(&binlog_file, &pos);
      }
      tmp_thd = tmp_thd->next_to_commit;
    }

    if (binlog_file != nullptr && pos > 0) {
      update_binlog_end_pos(binlog_file, pos);
    }
  }

  DEBUG_SYNC(thd, "bgc_after_sync_stage_before_commit_stage");

  leave_mutex_before_commit_stage = &LOCK_sync;
  /*
    Stage #3: Commit all transactions in order.

    This stage is skipped if we do not need to order the commits and
    each thread have to execute the handlerton commit instead.

    However, since we are keeping the lock from the previous stage, we
    need to unlock it if we skip the stage.

    We must also step commit_clock before the ha_commit_low() is called
    either in ordered fashion (by the leader of this stage) or by the thread
    themselves.

    We are delaying the handling of sync error until
    all locks are released but we should not enter into
    commit stage if binlog_error_action is ABORT_SERVER.
  */
commit_stage:
  /* Clone needs binlog commit order. */
  if ((opt_binlog_order_commits || Clone_handler::need_commit_order()) &&
      (sync_error == 0 || binlog_error_action != ABORT_SERVER)) {
    if (change_stage(thd, Commit_stage_manager::COMMIT_STAGE, final_queue,
                     leave_mutex_before_commit_stage, &LOCK_commit)) {
      DBUG_PRINT("return", ("Thread ID: %u, commit_error: %d", thd->thread_id(),
                            thd->commit_error));
      return finish_commit(thd);
    }
    THD *commit_queue =
        Commit_stage_manager::get_instance().fetch_queue_acquire_lock(
            Commit_stage_manager::COMMIT_STAGE);
    DBUG_EXECUTE_IF("semi_sync_3-way_deadlock",
                    DEBUG_SYNC(thd, "before_process_commit_stage_queue"););

    if (flush_error == 0 && sync_error == 0)
      sync_error = call_after_sync_hook(commit_queue);

    /*
      process_commit_stage_queue will call update_on_commit or
      update_on_rollback for the GTID owned by each thd in the queue.

      This will be done this way to guarantee that GTIDs are added to
      gtid_executed in order, to avoid creating unnecessary temporary
      gaps and keep gtid_executed as a single interval at all times.

      If we allow each thread to call update_on_commit only when they
      are at finish_commit, the GTID order cannot be guaranteed and
      temporary gaps may appear in gtid_executed. When this happen,
      the server would have to add and remove intervals from the
      Gtid_set, and adding and removing intervals requires a mutex,
      which would reduce performance.
    */
    process_commit_stage_queue(thd, commit_queue);

    /**
     * After commit stage
     */
    if (change_stage(thd, Commit_stage_manager::AFTER_COMMIT_STAGE,
                     commit_queue, &LOCK_commit, &LOCK_after_commit)) {
      DBUG_PRINT("return", ("Thread ID: %u, commit_error: %d", thd->thread_id(),
                            thd->commit_error));
      return finish_commit(thd);
    }

    THD *after_commit_queue =
        Commit_stage_manager::get_instance().fetch_queue_acquire_lock(
            Commit_stage_manager::AFTER_COMMIT_STAGE);

    process_after_commit_stage_queue(thd, after_commit_queue);

    final_queue = after_commit_queue;
    mysql_mutex_unlock(&LOCK_after_commit);
  } else {
    if (leave_mutex_before_commit_stage)
      mysql_mutex_unlock(leave_mutex_before_commit_stage);
    if (flush_error == 0 && sync_error == 0)
      sync_error = call_after_sync_hook(final_queue);
  }

  /*
    Handle sync error after we release all locks in order to avoid deadlocks
  */
  if (sync_error)
    handle_binlog_flush_or_sync_error(thd, true /* need_lock_log */, nullptr);

  DEBUG_SYNC(thd, "before_signal_done");
  /* Commit done so signal all waiting threads */
  Commit_stage_manager::get_instance().signal_done(final_queue);
  DBUG_EXECUTE_IF("block_leader_after_delete", {
    const char action[] = "now SIGNAL leader_proceed";
    assert(!debug_sync_set_action(thd, STRING_WITH_LEN(action)));
  };);

  /*
    Finish the commit before executing a rotate, or run the risk of a
    deadlock. We don't need the return value here since it is in
    thd->commit_error, which is returned below.
  */
  (void)finish_commit(thd);
  DEBUG_SYNC(thd, "bgc_after_commit_stage_before_rotation");

  /*
    If we need to rotate, we do it without commit error.
    Otherwise the thd->commit_error will be possibly reset.
   */
  if (DBUG_EVALUATE_IF("force_rotate", 1, 0) ||
      (do_rotate && thd->commit_error == THD::CE_NONE &&
       !is_rotating_caused_by_incident)) {
    /*
      Do not force the rotate as several consecutive groups may
      request unnecessary rotations.

      NOTE: Run purge_logs wo/ holding LOCK_log because it does not
      need the mutex. Otherwise causes various deadlocks.
    */

    DEBUG_SYNC(thd, "ready_to_do_rotation");
    bool check_purge = false;
    mysql_mutex_lock(&LOCK_log);
    /*
      If rotate fails then depends on binlog_error_action variable
      appropriate action will be taken inside rotate call.
    */
    int error = rotate(false, &check_purge);
    mysql_mutex_unlock(&LOCK_log);

    if (error)
      thd->commit_error = THD::CE_COMMIT_ERROR;
    else if (check_purge)
      auto_purge();
  }
  /*
    flush or sync errors are handled above (using binlog_error_action).
    Hence treat only COMMIT_ERRORs as errors.
  */
  return thd->commit_error == THD::CE_COMMIT_ERROR;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::purge_logs_before_date
int MYSQL_BIN_LOG::purge_logs_before_date(time_t purge_time, bool auto_purge) {
  int error;
  int no_of_threads_locking_log = 0, no_of_log_files_purged = 0;
  bool log_is_active = false, log_is_in_use = false;
  char to_log[FN_REFLEN], copy_log_in_use[FN_REFLEN];
  LOG_INFO log_info;
  MY_STAT stat_area;
  THD *thd = current_thd;

  DBUG_TRACE;

  mysql_mutex_lock(&LOCK_index);
  to_log[0] = 0;

  if ((error = find_log_pos(&log_info, NullS, false /*need_lock_index=false*/)))
    goto err;

  while (!(log_is_active = is_active(log_info.log_file_name))) {
    if (!mysql_file_stat(m_key_file_log, log_info.log_file_name, &stat_area,
                         MYF(0))) {
      if (my_errno() == ENOENT) {
        /*
          It's not fatal if we can't stat a log file that does not exist.
        */
        set_my_errno(0);
      } else {
        /*
          Other than ENOENT are fatal
        */
        if (thd) {
          push_warning_printf(thd, Sql_condition::SL_WARNING,
                              ER_BINLOG_PURGE_FATAL_ERR,
                              "a problem with getting info on being purged %s; "
                              "consider examining correspondence "
                              "of your binlog index file "
                              "to the actual binlog files",
                              log_info.log_file_name);
        } else {
          LogErr(INFORMATION_LEVEL, ER_BINLOG_FAILED_TO_DELETE_LOG_FILE,
                 log_info.log_file_name);
        }
        error = LOG_INFO_FATAL;
        goto err;
      }
    }
    /* check if the binary log file is older than the purge_time
       if yes check if it is in use, if not in use then add
       it in the list of binary log files to be purged.
    */
    else if (stat_area.st_mtime < purge_time) {
      if ((no_of_threads_locking_log = log_in_use(log_info.log_file_name))) {
        if (!auto_purge) {
          log_is_in_use = true;
          strcpy(copy_log_in_use, log_info.log_file_name);
        }
        break;
      }
      strmake(to_log, log_info.log_file_name,
              sizeof(log_info.log_file_name) - 1);
      no_of_log_files_purged++;
    } else
      break;
    if (find_next_log(&log_info, false /*need_lock_index=false*/)) break;
  }

  if (log_is_active) {
    if (!auto_purge)
      push_warning_printf(
          thd, Sql_condition::SL_WARNING, ER_WARN_PURGE_LOG_IS_ACTIVE,
          ER_THD(thd, ER_WARN_PURGE_LOG_IS_ACTIVE), log_info.log_file_name);
  }

  if (log_is_in_use) {
    int no_of_log_files_to_purge = no_of_log_files_purged + 1;
    while (strcmp(log_file_name, log_info.log_file_name)) {
      if (mysql_file_stat(m_key_file_log, log_info.log_file_name, &stat_area,
                          MYF(0))) {
        if (stat_area.st_mtime < purge_time)
          no_of_log_files_to_purge++;
        else
          break;
      }
      if (find_next_log(&log_info, false /*need_lock_index=false*/)) {
        no_of_log_files_to_purge++;
        break;
      }
    }

    push_warning_printf(thd, Sql_condition::SL_WARNING,
                        ER_WARN_PURGE_LOG_IN_USE,
                        ER_THD(thd, ER_WARN_PURGE_LOG_IN_USE), copy_log_in_use,
                        no_of_threads_locking_log, no_of_log_files_purged,
                        no_of_log_files_to_purge);
  }

  error = (to_log[0] ? purge_logs(to_log, true, false /*need_lock_index=false*/,
                                  true /*need_update_threads=true*/,
                                  (ulonglong *)nullptr, auto_purge)
                     : 0);

err:
  mysql_mutex_unlock(&LOCK_index);
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::purge_logs
int MYSQL_BIN_LOG::purge_logs(const char *to_log, bool included,
                              bool need_lock_index, bool need_update_threads,
                              ulonglong *decrease_log_space, bool auto_purge) {
  int error = 0, no_of_log_files_to_purge = 0, no_of_log_files_purged = 0;
  int no_of_threads_locking_log = 0;
  bool exit_loop = false;
  LOG_INFO log_info;
  THD *thd = current_thd;
  DBUG_TRACE;
  DBUG_PRINT("info", ("to_log= %s", to_log));

  if (need_lock_index)
    mysql_mutex_lock(&LOCK_index);
  else
    mysql_mutex_assert_owner(&LOCK_index);
  if ((error =
           find_log_pos(&log_info, to_log, false /*need_lock_index=false*/))) {
    LogErr(ERROR_LEVEL, ER_BINLOG_PURGE_LOGS_CALLED_WITH_FILE_NOT_IN_INDEX,
           to_log);
    goto err;
  }

  DEBUG_SYNC(thd, "before_purge_logs");

  no_of_log_files_to_purge = log_info.entry_index;

  if ((error = open_purge_index_file(true))) {
    LogErr(ERROR_LEVEL, ER_BINLOG_PURGE_LOGS_CANT_SYNC_INDEX_FILE);
    goto err;
  }

  /*
    File name exists in index file; delete until we find this file
    or a file that is used.
  */
  if ((error = find_log_pos(&log_info, NullS, false /*need_lock_index=false*/)))
    goto err;

  while ((compare_log_name(to_log, log_info.log_file_name) ||
          (exit_loop = included))) {
    if (is_active(log_info.log_file_name)) {
      if (!auto_purge)
        push_warning_printf(
            thd, Sql_condition::SL_WARNING, ER_WARN_PURGE_LOG_IS_ACTIVE,
            ER_THD(thd, ER_WARN_PURGE_LOG_IS_ACTIVE), log_info.log_file_name);
      break;
    }

    if ((no_of_threads_locking_log = log_in_use(log_info.log_file_name))) {
      if (!auto_purge)
        push_warning_printf(thd, Sql_condition::SL_WARNING,
                            ER_WARN_PURGE_LOG_IN_USE,
                            ER_THD(thd, ER_WARN_PURGE_LOG_IN_USE),
                            log_info.log_file_name, no_of_threads_locking_log,
                            no_of_log_files_purged, no_of_log_files_to_purge);
      break;
    }
    no_of_log_files_purged++;

    if ((error = register_purge_index_entry(log_info.log_file_name))) {
      LogErr(ERROR_LEVEL, ER_BINLOG_PURGE_LOGS_CANT_COPY_TO_REGISTER_FILE,
             log_info.log_file_name);
      goto err;
    }

    if (find_next_log(&log_info, false /*need_lock_index=false*/) || exit_loop)
      break;
  }

  DBUG_EXECUTE_IF("crash_purge_before_update_index", DBUG_SUICIDE(););

  if ((error = sync_purge_index_file())) {
    LogErr(ERROR_LEVEL, ER_BINLOG_PURGE_LOGS_CANT_FLUSH_REGISTER_FILE);
    goto err;
  }

  /* We know how many files to delete. Update index file. */
  if ((error = remove_logs_from_index(&log_info, need_update_threads))) {
    LogErr(ERROR_LEVEL, ER_BINLOG_PURGE_LOGS_CANT_UPDATE_INDEX_FILE);
    goto err;
  }

  // Update gtid_state->lost_gtids
  if (!is_relay_log) {
    global_sid_lock->wrlock();
    error = init_gtid_sets(
        nullptr, const_cast<Gtid_set *>(gtid_state->get_lost_gtids()),
        opt_source_verify_checksum, false /*false=don't need lock*/,
        nullptr /*trx_parser*/, nullptr /*partial_trx*/);
    global_sid_lock->unlock();
    if (error) goto err;
  }

  DBUG_EXECUTE_IF("crash_purge_critical_after_update_index", DBUG_SUICIDE(););

err:

  int error_index = 0, close_error_index = 0;
  /* Read each entry from purge_index_file and delete the file. */
  if (!error && is_inited_purge_index_file() &&
      (error_index = purge_index_entry(thd, decrease_log_space,
                                       false /*need_lock_index=false*/)))
    LogErr(ERROR_LEVEL, ER_BINLOG_PURGE_LOGS_FAILED_TO_PURGE_LOG);

  close_error_index = close_purge_index_file();

  DBUG_EXECUTE_IF("crash_purge_non_critical_after_update_index",
                  DBUG_SUICIDE(););

  if (need_lock_index) mysql_mutex_unlock(&LOCK_index);

  /*
    Error codes from purge logs take precedence.
    Then error codes from purging the index entry.
    Finally, error codes from closing the purge index file.
  */
  error = error ? error : (error_index ? error_index : close_error_index);

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::purge_index_entry
      purge_index_entry(nullptr, nullptr, false) || close_purge_index_file() ||
      DBUG_EVALUATE_IF("fault_injection_recovering_index", 1, 0)) {
    LogErr(ERROR_LEVEL, ER_BINLOG_FAILED_TO_SYNC_INDEX_FILE);
    error = true;
    goto end;
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::new_file_impl
int MYSQL_BIN_LOG::new_file_impl(
    bool need_lock_log, Format_description_log_event *extra_description_event) {
  int error = 0;
  bool close_on_error = false;
  char new_name[FN_REFLEN], *new_name_ptr = nullptr, *old_name, *file_to_open;
  const size_t ERR_CLOSE_MSG_LEN = 1024;
  char close_on_error_msg[ERR_CLOSE_MSG_LEN];
  memset(close_on_error_msg, 0, sizeof close_on_error_msg);

  DBUG_TRACE;
  if (!is_open()) {
    DBUG_PRINT("info", ("log is closed"));
    return error;
  }

  if (need_lock_log)
    mysql_mutex_lock(&LOCK_log);
  else
    mysql_mutex_assert_owner(&LOCK_log);
  DBUG_EXECUTE_IF("semi_sync_3-way_deadlock",
                  DEBUG_SYNC(current_thd, "before_rotate_binlog"););
  mysql_mutex_lock(&LOCK_xids);
  /*
    We need to ensure that the number of prepared XIDs are 0.

    If m_atomic_prep_xids is not zero:
    - We wait for storage engine commit, hence decrease m_atomic_prep_xids
    - We keep the LOCK_log to block new transactions from being
      written to the binary log.
   */
  while (get_prep_xids() > 0) {
    mysql_cond_wait(&m_prep_xids_cond, &LOCK_xids);
  }
  mysql_mutex_unlock(&LOCK_xids);

  mysql_mutex_lock(&LOCK_index);

  mysql_mutex_assert_owner(&LOCK_log);
  mysql_mutex_assert_owner(&LOCK_index);

  if (DBUG_EVALUATE_IF("expire_logs_always", 0, 1) &&
      (error = ha_flush_logs(true))) {
    goto end;
  }

  if (!is_relay_log) {
    /* Save set of GTIDs of the last binlog into table on binlog rotation */
    if ((error = gtid_state->save_gtids_of_last_binlog_into_table())) {
      if (error == ER_RPL_GTID_TABLE_CANNOT_OPEN) {
        close_on_error =
            m_binlog_file->get_real_file_size() >=
                static_cast<my_off_t>(max_size) ||
            DBUG_EVALUATE_IF("simulate_max_binlog_size", true, false);

        if (!close_on_error) {
          LogErr(ERROR_LEVEL, ER_BINLOG_UNABLE_TO_ROTATE_GTID_TABLE_READONLY,
                 "Current binlog file was flushed to disk and will be kept in "
                 "use.");
        } else {
          snprintf(close_on_error_msg, sizeof close_on_error_msg,
                   ER_THD(current_thd, ER_RPL_GTID_TABLE_CANNOT_OPEN), "mysql",
                   "gtid_executed");

          if (binlog_error_action != ABORT_SERVER)
            LogErr(WARNING_LEVEL,
                   ER_BINLOG_UNABLE_TO_ROTATE_GTID_TABLE_READONLY,
                   "Binary logging going to be disabled.");
        }

        DBUG_EXECUTE_IF("gtid_executed_readonly",
                        { DBUG_SET("-d,gtid_executed_readonly"); });
        DBUG_EXECUTE_IF("simulate_max_binlog_size",
                        { DBUG_SET("-d,simulate_max_binlog_size"); });
      } else {
        close_on_error = true;
        snprintf(close_on_error_msg, sizeof close_on_error_msg, "%s",
                 ER_THD(current_thd, ER_OOM_SAVE_GTIDS));
      }
      goto end;
    }
  }

  /*
    If user hasn't specified an extension, generate a new log name
    We have to do this here and not in open as we want to store the
    new file name in the current binary log file.
  */
  new_name_ptr = new_name;
  if ((error = generate_new_name(new_name, name))) {
    // Use the old name if generation of new name fails.
    strcpy(new_name, name);
    close_on_error = true;
    snprintf(close_on_error_msg, sizeof close_on_error_msg,
             ER_THD(current_thd, ER_NO_UNIQUE_LOGFILE), name);
    if (strlen(close_on_error_msg)) {
      close_on_error_msg[strlen(close_on_error_msg) - 1] = '\0';
    }
    goto end;
  }

  /*
    Make sure that the log_file is initialized before writing
    Rotate_log_event into it.
  */
  if (m_binlog_file->is_open()) {
    /*
      We log the whole file name for log file as the user may decide
      to change base names at some point.
    */
    Rotate_log_event r(new_name + dirname_length(new_name), 0, LOG_EVENT_OFFSET,
                       is_relay_log ? Rotate_log_event::RELAY_LOG : 0);

    if (DBUG_EVALUATE_IF("fault_injection_new_file_rotate_event", (error = 1),
                         false) ||
        (error = write_event_to_binlog(&r))) {
      char errbuf[MYSYS_STRERROR_SIZE];
      DBUG_EXECUTE_IF("fault_injection_new_file_rotate_event", errno = 2;);
      close_on_error = true;
      snprintf(close_on_error_msg, sizeof close_on_error_msg,
               ER_THD(current_thd, ER_ERROR_ON_WRITE), name, errno,
               my_strerror(errbuf, sizeof(errbuf), errno));
      my_printf_error(ER_ERROR_ON_WRITE, ER_THD(current_thd, ER_ERROR_ON_WRITE),
                      MYF(ME_FATALERROR), name, errno,
                      my_strerror(errbuf, sizeof(errbuf), errno));
      goto end;
    }

    if ((error = m_binlog_file->flush())) {
      close_on_error = true;
      snprintf(close_on_error_msg, sizeof close_on_error_msg, "%s",
               "Either disk is full or file system is read only");
      goto end;
    }
  }

  DEBUG_SYNC(current_thd, "after_rotate_event_appended");

  old_name = name;
  name = nullptr;  // Don't free name
  close(LOG_CLOSE_TO_BE_OPENED | LOG_CLOSE_INDEX, false /*need_lock_log=false*/,
        false /*need_lock_index=false*/);

  if (checksum_alg_reset != binary_log::BINLOG_CHECKSUM_ALG_UNDEF) {
    assert(!is_relay_log);
    assert(binlog_checksum_options != checksum_alg_reset);
    binlog_checksum_options = checksum_alg_reset;
  }
  /*
    Note that at this point, atomic_log_state != LOG_CLOSED
    (important for is_open()).
  */
  DBUG_EXECUTE_IF("binlog_crash_between_close_and_open", { DBUG_SUICIDE(); });
  DEBUG_SYNC(current_thd, "binlog_rotate_between_close_and_open");
  /*
    new_file() is only used for rotation (in FLUSH LOGS or because size >
    max_binlog_size or max_relay_log_size).
    If this is a binary log, the Format_description_log_event at the beginning
    of the new file should have created=0 (to distinguish with the
    Format_description_log_event written at server startup, which should
    trigger temp tables deletion on slaves.
  */

  /* reopen index binlog file, BUG#34582 */
  file_to_open = index_file_name;
  error = open_index_file(index_file_name, nullptr,
                          false /*need_lock_index=false*/);
  if (!error) {
    /* reopen the binary log file. */
    file_to_open = new_name_ptr;
    error = open_binlog(old_name, new_name_ptr, max_size,
                        true /*null_created_arg=true*/,
                        false /*need_lock_index=false*/,
                        true /*need_sid_lock=true*/, extra_description_event);
  }

  /* handle reopening errors */
  if (error) {
    char errbuf[MYSYS_STRERROR_SIZE];
    my_printf_error(ER_CANT_OPEN_FILE, ER_THD(current_thd, ER_CANT_OPEN_FILE),
                    MYF(ME_FATALERROR), file_to_open, error,
                    my_strerror(errbuf, sizeof(errbuf), error));
    close_on_error = true;
    snprintf(close_on_error_msg, sizeof close_on_error_msg,
             ER_THD(current_thd, ER_CANT_OPEN_FILE), file_to_open, error,
             my_strerror(errbuf, sizeof(errbuf), error));
  }
  my_free(old_name);

end:

  if (error && close_on_error /* rotate, flush or reopen failed */) {
    /*
      Close whatever was left opened.

      We are keeping the behavior as it exists today, ie,
      we disable logging and move on (see: BUG#51014).

      TODO: as part of WL#1790 consider other approaches:
       - kill mysql (safety);
       - try multiple locations for opening a log file;
       - switch server to protected/readonly mode
       - ...
    */
    if (binlog_error_action == ABORT_SERVER) {
      char abort_msg[ERR_CLOSE_MSG_LEN + 48];
      memset(abort_msg, 0, sizeof abort_msg);
      snprintf(abort_msg, sizeof abort_msg,
               "%s, while rotating the binlog. "
               "Aborting the server",
               close_on_error_msg);
      exec_binlog_error_action_abort(abort_msg);
    } else
      LogErr(ERROR_LEVEL, ER_BINLOG_CANT_OPEN_FOR_LOGGING,
             new_name_ptr != nullptr ? new_name_ptr : "new file", errno);

    close(LOG_CLOSE_INDEX, false /*need_lock_log=false*/,
          false /*need_lock_index=false*/);
  }

  mysql_mutex_unlock(&LOCK_index);
  if (need_lock_log) mysql_mutex_unlock(&LOCK_log);

  DEBUG_SYNC(current_thd, "after_disable_binlog");
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::generate_new_name
int MYSQL_BIN_LOG::generate_new_name(char *new_name, const char *log_name,
                                     uint32 new_index_number) {
  fn_format(new_name, log_name, mysql_data_home, "", 4);
  if (!fn_ext(log_name)[0]) {
    if (find_uniq_filename(new_name, new_index_number)) {
      if (current_thd != nullptr)
        my_printf_error(ER_NO_UNIQUE_LOGFILE,
                        ER_THD(current_thd, ER_NO_UNIQUE_LOGFILE),
                        MYF(ME_FATALERROR), log_name);
      LogErr(ERROR_LEVEL, ER_FAILED_TO_GENERATE_UNIQUE_LOGFILE, log_name);
      return 1;
    }
  }
  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: check_binlog_cache_size
void check_binlog_cache_size(THD *thd) {
  if (binlog_cache_size > max_binlog_cache_size) {
    if (thd) {
      push_warning_printf(
          thd, Sql_condition::SL_WARNING, ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX,
          ER_THD(thd, ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX),
          (ulong)binlog_cache_size, (ulong)max_binlog_cache_size);
    } else {
      LogErr(WARNING_LEVEL, ER_BINLOG_CACHE_SIZE_TOO_LARGE, binlog_cache_size,
             (ulong)max_binlog_cache_size);
    }
    binlog_cache_size = static_cast<ulong>(max_binlog_cache_size);
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: check_binlog_stmt_cache_size
void check_binlog_stmt_cache_size(THD *thd) {
  if (binlog_stmt_cache_size > max_binlog_stmt_cache_size) {
    if (thd) {
      push_warning_printf(
          thd, Sql_condition::SL_WARNING,
          ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX,
          ER_THD(thd, ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX),
          (ulong)binlog_stmt_cache_size, (ulong)max_binlog_stmt_cache_size);
    } else {
      LogErr(WARNING_LEVEL, ER_BINLOG_STMT_CACHE_SIZE_TOO_LARGE,
             binlog_stmt_cache_size, (ulong)max_binlog_stmt_cache_size);
    }
    binlog_stmt_cache_size = static_cast<ulong>(max_binlog_stmt_cache_size);
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::report_missing_gtids
void MYSQL_BIN_LOG::report_missing_gtids(
    const Gtid_set *previous_gtid_set, const Gtid_set *slave_executed_gtid_set,
    std::string &errmsg) {
  DBUG_TRACE;
  THD *thd = current_thd;
  char *missing_gtids = nullptr;
  char *slave_executed_gtids = nullptr;
  Gtid_set gtid_missing(slave_executed_gtid_set->get_sid_map());
  gtid_missing.add_gtid_set(slave_executed_gtid_set);
  gtid_missing.remove_gtid_set(previous_gtid_set);
  gtid_missing.to_string(&missing_gtids);
  slave_executed_gtid_set->to_string(&slave_executed_gtids);

  String tmp_uuid;

  /* Protects thd->user_vars. */
  mysql_mutex_lock(&thd->LOCK_thd_data);
  const auto it = thd->user_vars.find("replica_uuid");
  if (it != thd->user_vars.end() && it->second->length() > 0) {
    tmp_uuid.copy(it->second->ptr(), it->second->length(), nullptr);
  }
  mysql_mutex_unlock(&thd->LOCK_thd_data);

  /*
     Log the information about the missing purged GTIDs to the error log.
  */
  std::ostringstream log_info;
  log_info << "If the binary log files have been deleted from disk,"
              " check the consistency of 'GTID_PURGED' variable."
              " The missing transactions are '"
           << missing_gtids << "'";
  LogErr(WARNING_LEVEL, ER_FOUND_MISSING_GTIDS, tmp_uuid.ptr(),
         log_info.str().c_str());
  /*
     Send the information about the slave executed GTIDs and missing
     purged GTIDs to slave if the message is less than MYSQL_ERRMSG_SIZE.
  */
  std::ostringstream gtid_info;
  gtid_info << "The GTID set sent by the replica is '" << slave_executed_gtids
            << "', and the missing transactions are '" << missing_gtids << "'";
  errmsg.assign(ER_THD(thd, ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS));

  /* Don't consider the "%s" in the format string. Subtract 2 from the
     total length */
  if ((errmsg.length() - 2 + gtid_info.str().length()) > MYSQL_ERRMSG_SIZE)
    gtid_info.str(
        "The GTID sets and the missing purged transactions are too"
        " long to print in this message. For more information,"
        " please see the source's error log or the manual for"
        " GTID_SUBTRACT");
  /* Buffer for formatting the message about the missing GTIDs. */
  char buff[MYSQL_ERRMSG_SIZE] = {0};
  snprintf(buff, MYSQL_ERRMSG_SIZE, errmsg.c_str(), gtid_info.str().c_str());
  errmsg.assign(buff);

  my_free(missing_gtids);
  my_free(slave_executed_gtids);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::reset_logs
bool MYSQL_BIN_LOG::reset_logs(THD *thd, bool delete_only) {
  LOG_INFO linfo;
  bool error = false;
  int err;
  const char *save_name = nullptr;
  Checkable_rwlock *sid_lock = nullptr;
  DBUG_TRACE;

  /*
    Flush logs for storage engines, so that the last transaction
    is persisted inside storage engines.
  */
  assert(!thd->is_log_reset());
  thd->set_log_reset();
  if (ha_flush_logs()) {
    thd->clear_log_reset();
    return true;
  }
  thd->clear_log_reset();

  ha_reset_logs(thd);

  /*
    We need to get both locks to be sure that no one is trying to
    write to the index log file.
  */
  mysql_mutex_lock(&LOCK_log);
  mysql_mutex_lock(&LOCK_index);

  if (is_relay_log)
    sid_lock = previous_gtid_set_relaylog->get_sid_map()->get_sid_lock();
  else
    sid_lock = global_sid_lock;
  sid_lock->wrlock();

  /* Save variables so that we can reopen the log */
  save_name = name;
  name = nullptr;  // Protect against free
  close(LOG_CLOSE_TO_BE_OPENED, false /*need_lock_log=false*/,
        false /*need_lock_index=false*/);

  /*
    First delete all old log files and then update the index file.
    As we first delete the log files and do not use sort of logging,
    a crash may lead to an inconsistent state where the index has
    references to non-existent files.

    We need to invert the steps and use the purge_index_file methods
    in order to make the operation safe.
  */

  if ((err = find_log_pos(&linfo, NullS, false /*need_lock_index=false*/)) !=
      0) {
    uint errcode = purge_log_get_error_code(err);
    LogErr(ERROR_LEVEL, ER_BINLOG_CANT_LOCATE_OLD_BINLOG_OR_RELAY_LOG_FILES);
    my_error(errcode, MYF(0));
    error = true;
    goto err;
  }

  for (;;) {
    if ((error = my_delete_allow_opened(linfo.log_file_name, MYF(0))) != 0) {
      if (my_errno() == ENOENT) {
        push_warning_printf(
            current_thd, Sql_condition::SL_WARNING, ER_LOG_PURGE_NO_FILE,
            ER_THD(current_thd, ER_LOG_PURGE_NO_FILE), linfo.log_file_name);
        LogErr(INFORMATION_LEVEL, ER_BINLOG_CANT_DELETE_FILE,
               linfo.log_file_name);
        set_my_errno(0);
        error = false;
      } else {
        push_warning_printf(current_thd, Sql_condition::SL_WARNING,
                            ER_BINLOG_PURGE_FATAL_ERR,
                            "a problem with deleting %s; "
                            "consider examining correspondence "
                            "of your binlog index file "
                            "to the actual binlog files",
                            linfo.log_file_name);
        LogErr(ERROR_LEVEL, ER_BINLOG_CANT_DELETE_FILE, linfo.log_file_name);
        my_error(ER_BINLOG_PURGE_FATAL_ERR, MYF(0));
        error = true;
        goto err;
      }
    }
    if (find_next_log(&linfo, false /*need_lock_index=false*/)) break;
  }

  /* Start logging with a new file */
  close(LOG_CLOSE_INDEX | LOG_CLOSE_TO_BE_OPENED, false /*need_lock_log=false*/,
        false /*need_lock_index=false*/);
  if ((error = my_delete_allow_opened(index_file_name,
                                      MYF(0))))  // Reset (open will update)
  {
    if (my_errno() == ENOENT) {
      push_warning_printf(
          current_thd, Sql_condition::SL_WARNING, ER_LOG_PURGE_NO_FILE,
          ER_THD(current_thd, ER_LOG_PURGE_NO_FILE), index_file_name);
      LogErr(INFORMATION_LEVEL, ER_BINLOG_CANT_DELETE_FILE, index_file_name);
      set_my_errno(0);
      error = false;
    } else {
      push_warning_printf(current_thd, Sql_condition::SL_WARNING,
                          ER_BINLOG_PURGE_FATAL_ERR,
                          "a problem with deleting %s; "
                          "consider examining correspondence "
                          "of your binlog index file "
                          "to the actual binlog files",
                          index_file_name);
      LogErr(ERROR_LEVEL, ER_BINLOG_CANT_DELETE_FILE, index_file_name);
      my_error(ER_BINLOG_PURGE_FATAL_ERR, MYF(0));
      error = true;
      goto err;
    }
  }
  DBUG_EXECUTE_IF("wait_for_kill_gtid_state_clear", {
    const char action[] = "now WAIT_FOR kill_gtid_state_clear";
    assert(!debug_sync_set_action(thd, STRING_WITH_LEN(action)));
  };);

  /*
    For relay logs we clear the gtid state associated per channel(i.e rli)
    in the purge_relay_logs()
  */
  if (!is_relay_log) {
    if (gtid_state->clear(thd)) {
      error = true;
    }
    /*
      Don't clear global_sid_map because gtid_state->clear() above didn't
      touched owned_gtids GTID set.
    */
    error = error || gtid_state->init();
  }

  if (!delete_only) {
    if (!open_index_file(index_file_name, nullptr,
                         false /*need_lock_index=false*/))
      error = open_binlog(save_name, nullptr, max_size, false,
                          false /*need_lock_index=false*/,
                          false /*need_sid_lock=false*/, nullptr,
                          thd->lex->next_binlog_file_nr) ||
              error;
  }
  /* String has been duplicated, free old file-name */
  if (name != nullptr) {
    my_free(const_cast<char *>(save_name));
    save_name = nullptr;
  }

err:
  if (name == nullptr)
    name = const_cast<char *>(save_name);  // restore old file-name
  sid_lock->unlock();
  mysql_mutex_unlock(&LOCK_index);
  mysql_mutex_unlock(&LOCK_log);
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::after_write_to_relay_log
bool MYSQL_BIN_LOG::after_write_to_relay_log(Master_info *mi) {
  DBUG_TRACE;
  DBUG_PRINT("info", ("max_size: %lu", max_size));

  // Check pre-conditions
  mysql_mutex_assert_owner(&LOCK_log);
  assert(is_relay_log);

  /*
    We allow the relay log rotation by relay log size
    only if the trx parser is not inside a transaction.
  */
  bool can_rotate = mi->transaction_parser.is_not_inside_transaction();

#ifndef NDEBUG
  if (m_binlog_file->get_real_file_size() >
          DBUG_EVALUATE_IF("rotate_replica_debug_group", 500, max_size) &&
      !can_rotate) {
    DBUG_PRINT("info", ("Postponing the rotation by size waiting for "
                        "the end of the current transaction."));
  }
#endif

  // Flush and sync
  bool error = flush_and_sync(false);
  if (error) {
    mi->report(ERROR_LEVEL, ER_REPLICA_RELAY_LOG_WRITE_FAILURE,
               ER_THD(current_thd, ER_REPLICA_RELAY_LOG_WRITE_FAILURE),
               "failed to flush event to relay log file");
    truncate_relaylog_file(mi, atomic_binlog_end_pos);
  } else {
    if (can_rotate) {
      mysql_mutex_lock(&mi->data_lock);
      /*
        If the last event of the transaction has been flushed, we can add
        the GTID (if it is not empty) to the logged set, or else it will
        not be available in the Previous GTIDs of the next relay log file
        if we are going to rotate the relay log.
      */
      const Gtid *last_gtid_queued = mi->get_queueing_trx_gtid();
      if (!last_gtid_queued->is_empty()) {
        mi->rli->get_sid_lock()->rdlock();
        DBUG_SIGNAL_WAIT_FOR(current_thd, "updating_received_transaction_set",
                             "reached_updating_received_transaction_set",
                             "continue_updating_received_transaction_set");
        mi->rli->add_logged_gtid(last_gtid_queued->sidno,
                                 last_gtid_queued->gno);
        mi->rli->get_sid_lock()->unlock();
      }

      if (mi->is_queueing_trx()) {
        mi->finished_queueing();

        Trx_monitoring_info processing;
        Trx_monitoring_info last;
        mi->get_gtid_monitoring_info()->copy_info_to(&processing, &last);

        // update the compression information
        binlog::global_context.monitoring_context()
            .transaction_compression()
            .update(binlog::monitoring::log_type::RELAY, last.compression_type,
                    last.gtid, last.end_time, last.compressed_bytes,
                    last.uncompressed_bytes,
                    mi->rli->get_gtid_set()->get_sid_map());
      }
      mysql_mutex_unlock(&mi->data_lock);

      /*
        If relay log is too big, rotate. But only if not in the middle of a
        transaction when GTIDs are enabled.

        Also rotate if a deferred flush request has been placed.

        We now try to mimic the following master binlog behavior: "A transaction
        is written in one chunk to the binary log, so it is never split between
        several binary logs. Therefore, if you have big transactions, you might
        see binary log files larger than max_binlog_size."
      */
      if (m_binlog_file->get_real_file_size() >
              DBUG_EVALUATE_IF("rotate_replica_debug_group", 500, max_size) ||
          mi->is_rotate_requested()) {
        error = new_file_without_locking(mi->get_mi_description_event());
        mi->clear_rotate_requests();
      }
    }
  }

  lock_binlog_end_pos();
  mi->rli->ign_master_log_name_end[0] = 0;
  update_binlog_end_pos(false /*need_lock*/);
  harvest_bytes_written(mi->rli, true /*need_log_space_lock=true*/);
  unlock_binlog_end_pos();

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::truncate_relaylog_file
bool MYSQL_BIN_LOG::truncate_relaylog_file(Master_info *mi,
                                           my_off_t truncate_pos) {
  DBUG_TRACE;
  assert(is_relay_log);
  mysql_mutex_assert_owner(&LOCK_log);
  Relay_log_info *rli = mi->rli;
  bool error = false;

  /*
    If the relay log was closed by an error (binlog_error_action=IGNORE_ERROR)
    this truncate function should produce no result as the relay log is already
    in really bad shape.
  */
  if (!is_open()) {
    return false;
  }

  my_off_t relaylog_file_size = m_binlog_file->position();

  if (truncate_pos > 0 && truncate_pos < relaylog_file_size) {
    if (m_binlog_file->truncate(truncate_pos)) {
      mi->report(ERROR_LEVEL, ER_REPLICA_RELAY_LOG_WRITE_FAILURE,
                 ER_THD(current_thd, ER_REPLICA_RELAY_LOG_WRITE_FAILURE),
                 "failed to truncate relay log file");
      error = true;
    } else {
      LogErr(INFORMATION_LEVEL, ER_REPLICA_RELAY_LOG_TRUNCATE_INFO,
             log_file_name, relaylog_file_size, truncate_pos);

      // Re-init the SQL thread IO_CACHE
      assert(strcmp(rli->get_event_relay_log_name(), log_file_name) ||
             rli->get_event_relay_log_pos() <= truncate_pos);
      rli->notify_relay_log_truncated();
    }
  }
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::write_event
int binlog_cache_data::write_event(Log_event *ev) {
  DBUG_TRACE;

  if (ev != nullptr) {
    DBUG_EXECUTE_IF("simulate_disk_full_at_flush_pending",
                    { DBUG_SET("+d,simulate_file_write_error"); });

    if (binary_event_serialize(ev, &m_cache)) {
      DBUG_EXECUTE_IF("simulate_disk_full_at_flush_pending", {
        DBUG_SET("-d,simulate_file_write_error");
        DBUG_SET("-d,simulate_disk_full_at_flush_pending");
        /*
           after +d,simulate_file_write_error the local cache
           is in unsane state. Since -d,simulate_file_write_error
           revokes the first simulation do_write_cache()
           can't be run without facing an assert.
           So it's blocked with the following 2nd simulation:
        */
        DBUG_SET("+d,simulate_do_write_cache_failure");
      });
      return 1;
    }
    if (ev->get_type_code() == binary_log::XID_EVENT ||
        ev->get_type_code() == binary_log::XA_PREPARE_LOG_EVENT)
      flags.with_xid = true;
    if (ev->is_using_immediate_logging()) flags.immediate = true;
    /* DDL gets marked as xid-requiring at its caching. */
    if (is_atomic_ddl_event(ev)) flags.with_xid = true;
    /* With respect to the event type being written */
    if (ev->is_sbr_logging_format()) flags.with_sbr = true;
    if (ev->is_rbr_logging_format()) flags.with_rbr = true;
    /* With respect to empty transactions */
    if (ev->starts_group()) flags.with_start = true;
    if (ev->ends_group()) flags.with_end = true;
    if (!ev->starts_group() && !ev->ends_group()) flags.with_content = true;
    m_event_counter++;
    DBUG_PRINT("debug",
               ("event_counter= %lu", static_cast<ulong>(m_event_counter)));
  }
  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::write_buffer
bool MYSQL_BIN_LOG::write_buffer(const char *buf, uint len, Master_info *mi) {
  DBUG_TRACE;

  // check preconditions
  assert(is_relay_log);
  mysql_mutex_assert_owner(&LOCK_log);

  // write data
  bool error = false;
  if (m_binlog_file->write(pointer_cast<const uchar *>(buf), len) == 0) {
    bytes_written += len;
    error = after_write_to_relay_log(mi);
  } else {
    mi->report(ERROR_LEVEL, ER_REPLICA_RELAY_LOG_WRITE_FAILURE,
               ER_THD(current_thd, ER_REPLICA_RELAY_LOG_WRITE_FAILURE),
               "failed to write event to the relay log file");
    truncate_relaylog_file(mi, atomic_binlog_end_pos);
    error = true;
  }

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: THD::issue_unsafe_warnings
void THD::issue_unsafe_warnings() {
  char buf[MYSQL_ERRMSG_SIZE * 2];
  DBUG_TRACE;
  /*
    Ensure that binlog_unsafe_warning_flags is big enough to hold all
    bits.  This is actually a constant expression.
  */
  assert(LEX::BINLOG_STMT_UNSAFE_COUNT <=
         sizeof(binlog_unsafe_warning_flags) * CHAR_BIT);

  uint32 unsafe_type_flags = binlog_unsafe_warning_flags;

  /*
    For each unsafe_type, check if the statement is unsafe in this way
    and issue a warning.
  */
  for (int unsafe_type = 0; unsafe_type < LEX::BINLOG_STMT_UNSAFE_COUNT;
       unsafe_type++) {
    if ((unsafe_type_flags & (1 << unsafe_type)) != 0) {
      push_warning_printf(
          this, Sql_condition::SL_NOTE, ER_BINLOG_UNSAFE_STATEMENT,
          ER_THD(this, ER_BINLOG_UNSAFE_STATEMENT),
          ER_THD_NONCONST(this, LEX::binlog_stmt_unsafe_errcode[unsafe_type]));
      if (log_error_verbosity > 1 && opt_log_unsafe_statements) {
        if (unsafe_type == LEX::BINLOG_STMT_UNSAFE_LIMIT)
          do_unsafe_limit_checkout(buf, unsafe_type, query().str);
        else  // cases other than LIMIT unsafety
          print_unsafe_warning_to_log(unsafe_type, buf, query().str);
      }
    }
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: MYSQL_BIN_LOG::report_missing_purged_gtids
void MYSQL_BIN_LOG::report_missing_purged_gtids(
    const Gtid_set *slave_executed_gtid_set, std::string &errmsg) {
  DBUG_TRACE;
  THD *thd = current_thd;
  Gtid_set gtid_missing(gtid_state->get_lost_gtids()->get_sid_map());
  gtid_missing.add_gtid_set(gtid_state->get_lost_gtids());
  gtid_missing.remove_gtid_set(slave_executed_gtid_set);

  String tmp_uuid;

  /* Protects thd->user_vars. */
  mysql_mutex_lock(&thd->LOCK_thd_data);
  const auto it = thd->user_vars.find("replica_uuid");
  if (it != thd->user_vars.end() && it->second->length() > 0) {
    tmp_uuid.copy(it->second->ptr(), it->second->length(), nullptr);
  }
  mysql_mutex_unlock(&thd->LOCK_thd_data);

  char *missing_gtids = nullptr;
  char *slave_executed_gtids = nullptr;
  gtid_missing.to_string(&missing_gtids);
  slave_executed_gtid_set->to_string(&slave_executed_gtids);

  /*
     Log the information about the missing purged GTIDs to the error log.
  */
  std::ostringstream log_info;
  log_info << "The missing transactions are '" << missing_gtids << "'";

  LogErr(WARNING_LEVEL, ER_FOUND_MISSING_GTIDS, tmp_uuid.ptr(),
         log_info.str().c_str());

  /*
     Send the information about the slave executed GTIDs and missing
     purged GTIDs to slave if the message is less than MYSQL_ERRMSG_SIZE.
  */
  std::ostringstream gtid_info;
  gtid_info << "The GTID set sent by the replica is '" << slave_executed_gtids
            << "', and the missing transactions are '" << missing_gtids << "'";
  errmsg.assign(ER_THD(thd, ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS));

  /* Don't consider the "%s" in the format string. Subtract 2 from the
     total length */
  int total_length = (errmsg.length() - 2 + gtid_info.str().length());

  DBUG_EXECUTE_IF("simulate_long_missing_gtids",
                  { total_length = MYSQL_ERRMSG_SIZE + 1; });

  if (total_length > MYSQL_ERRMSG_SIZE)
    gtid_info.str(
        "The GTID sets and the missing purged transactions are too"
        " long to print in this message. For more information,"
        " please see the source's error log or the manual for"
        " GTID_SUBTRACT");

  /* Buffer for formatting the message about the missing GTIDs. */
  char buff[MYSQL_ERRMSG_SIZE] = {0};
  snprintf(buff, MYSQL_ERRMSG_SIZE, errmsg.c_str(), gtid_info.str().c_str());
  errmsg.assign(buff);

  my_free(missing_gtids);
  my_free(slave_executed_gtids);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: THD::add_to_binlog_accessed_dbs
void THD::add_to_binlog_accessed_dbs(const char *db_param) {
  char *after_db;
  /*
    binlog_accessed_db_names list is to maintain the database
    names which are referenced in a given command.
    Prior to bug 17806014 fix, 'main_mem_root' memory root used
    to store this list. The 'main_mem_root' scope is till the end
    of the query. Hence it caused increasing memory consumption
    problem in big procedures like the ones mentioned below.
    Eg: CALL p1() where p1 is having 1,00,000 create and drop tables.
    'main_mem_root' is freed only at the end of the command CALL p1()'s
    execution. But binlog_accessed_db_names list scope is only till the
    individual statements specified the procedure(create/drop statements).
    Hence the memory allocated in 'main_mem_root' was left uncleared
    until the p1's completion, even though it is not required after
    completion of individual statements.

    Instead of using 'main_mem_root' whose scope is complete query execution,
    now the memroot is changed to use 'thd->mem_root' whose scope is until the
    individual statement in CALL p1(). 'thd->mem_root' is set to
    'execute_mem_root' in the context of procedure and it's scope is till the
    individual statement in CALL p1() and thd->memroot is equal to
    'main_mem_root' in the context of a normal 'top level query'.

    Eg: a) create table t1(i int); => If this function is called while
           processing this statement, thd->memroot is equal to &main_mem_root
           which will be freed immediately after executing this statement.
        b) CALL p1() -> p1 contains create table t1(i int); => If this function
           is called while processing create table statement which is inside
           a stored procedure, then thd->memroot is equal to 'execute_mem_root'
           which will be freed immediately after executing this statement.
    In both a and b case, thd->memroot will be freed immediately and will not
    increase memory consumption.

    A special case(stored functions/triggers):
    Consider the following example:
    create function f1(i int) returns int
    begin
      insert into db1.t1 values (1);
      insert into db2.t1 values (2);
    end;
    When we are processing SELECT f1(), the list should contain db1, db2 names.
    Since thd->mem_root contains 'execute_mem_root' in the context of
    stored function, the mem root will be freed after adding db1 in
    the list and when we are processing the second statement and when we try
    to add 'db2' in the db1's list, it will lead to crash as db1's memory
    is already freed. To handle this special case, if in_sub_stmt is set
    (which is true in case of stored functions/triggers), we use &main_mem_root,
    if not set we will use thd->memroot which changes it's value to
    'execute_mem_root' or '&main_mem_root' depends on the context.
   */
  MEM_ROOT *db_mem_root = in_sub_stmt ? &main_mem_root : mem_root;

  if (!binlog_accessed_db_names)
    binlog_accessed_db_names = new (db_mem_root) List<char>;

  if (binlog_accessed_db_names->elements > MAX_DBS_IN_EVENT_MTS) {
    push_warning_printf(
        this, Sql_condition::SL_WARNING, ER_MTA_UPDATED_DBS_GREATER_MAX,
        ER_THD(this, ER_MTA_UPDATED_DBS_GREATER_MAX), MAX_DBS_IN_EVENT_MTS);
    return;
  }

  after_db = strdup_root(db_mem_root, db_param);

  /*
     sorted insertion is implemented with first rearranging data
     (pointer to char*) of the links and final appending of the least
     ordered data to create a new link in the list.
  */
  if (binlog_accessed_db_names->elements != 0) {
    List_iterator<char> it(*get_binlog_accessed_db_names());

    while (it++) {
      char *swap = nullptr;
      char **ref_cur_db = it.ref();
      int cmp = strcmp(after_db, *ref_cur_db);

      assert(!swap || cmp < 0);

      if (cmp == 0) {
        after_db = nullptr; /* dup to ignore */
        break;
      } else if (swap || cmp > 0) {
        swap = *ref_cur_db;
        *ref_cur_db = after_db;
        after_db = swap;
      }
    }
  }
  if (after_db) binlog_accessed_db_names->push_back(after_db, db_mem_root);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: THD::decide_logging_format
int THD::decide_logging_format(Table_ref *tables) {
  DBUG_TRACE;
  DBUG_PRINT("info", ("query: %s", query().str));
  DBUG_PRINT("info", ("variables.binlog_format: %lu", variables.binlog_format));
  DBUG_PRINT("info", ("lex->get_stmt_unsafe_flags(): 0x%x",
                      lex->get_stmt_unsafe_flags()));

#if defined(ENABLED_DEBUG_SYNC)
  if (!is_attachable_ro_transaction_active())
    DEBUG_SYNC(this, "begin_decide_logging_format");
#endif

  reset_binlog_local_stmt_filter();

  /*
    We should not decide logging format if the binlog is closed or
    binlogging is off, or if the statement is filtered out from the
    binlog by filtering rules.
  */
  if (mysql_bin_log.is_open() && (variables.option_bits & OPTION_BIN_LOG) &&
      !(variables.binlog_format == BINLOG_FORMAT_STMT &&
        !binlog_filter->db_ok(m_db.str))) {
    /*
      Compute one bit field with the union of all the engine
      capabilities, and one with the intersection of all the engine
      capabilities.
    */
    handler::Table_flags flags_write_some_set = 0;
    handler::Table_flags flags_access_some_set = 0;
    handler::Table_flags flags_write_all_set =
        HA_BINLOG_ROW_CAPABLE | HA_BINLOG_STMT_CAPABLE;

    /*
       If different types of engines are about to be updated.
       For example: Innodb and Falcon; Innodb and MyIsam.
    */
    bool multi_write_engine = false;
    /*
       If different types of engines are about to be accessed
       and any of them is about to be updated. For example:
       Innodb and Falcon; Innodb and MyIsam.
    */
    bool multi_access_engine = false;
    /*
      Track if statement creates or drops a temporary table
      and log in ROW if it does.
*/
    bool is_create_drop_temp_table = false;
    /*
       Identifies if a table is changed.
    */
    bool is_write = false;
    /*
       A pointer to a previous table that was changed.
    */
    TABLE *prev_write_table = nullptr;
    /*
       A pointer to a previous table that was accessed.
    */
    TABLE *prev_access_table = nullptr;
    /*
      True if at least one table is transactional.
    */
    bool write_to_some_transactional_table = false;
    /*
      True if at least one table is non-transactional.
    */
    bool write_to_some_non_transactional_table = false;
    /*
       True if all non-transactional tables that has been updated
       are temporary.
    */
    bool write_all_non_transactional_are_tmp_tables = true;
    /**
      The number of tables used in the current statement,
      that should be replicated.
    */
    uint replicated_tables_count = 0;
    /**
      The number of tables written to in the current statement,
      that should not be replicated.
      A table should not be replicated when it is considered
      'local' to a MySQL instance.
      Currently, these tables are:
      - mysql.slow_log
      - mysql.general_log
      - mysql.slave_relay_log_info
      - mysql.slave_master_info
      - mysql.slave_worker_info
      - performance_schema.*
      - TODO: information_schema.*
      In practice, from this list, only performance_schema.* tables
      are written to by user queries.
    */
    uint non_replicated_tables_count = 0;
    /**
      Indicate whether we already reported a warning
      on modifying gtid_executed table.
    */
    int warned_gtid_executed_table = 0;
#ifndef NDEBUG
    {
      DBUG_PRINT("debug", ("prelocked_mode: %s",
                           get_locked_tables_mode_name(locked_tables_mode)));
    }
#endif

    if (variables.binlog_format != BINLOG_FORMAT_ROW && tables) {
      /*
        DML statements that modify a table with an auto_increment column based
        on rows selected from a table are unsafe as the order in which the rows
        are fetched from the select tables cannot be determined and may differ
        on master and slave.
       */
      if (has_write_table_with_auto_increment_and_query_block(tables))
        lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_WRITE_AUTOINC_SELECT);

      if (has_write_table_auto_increment_not_first_in_pk(tables))
        lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_AUTOINC_NOT_FIRST);

      /*
        A query that modifies autoinc column in sub-statement can make the
        master and slave inconsistent.
        We can solve these problems in mixed mode by switching to binlogging
        if at least one updated table is used by sub-statement
       */
      if (lex->requires_prelocking() &&
          has_write_table_with_auto_increment(lex->first_not_own_table()))
        lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_AUTOINC_COLUMNS);

      /*
        A query that modifies a table with a non-deterministic column default
        expression in a substatement, can make the master and the slave
        inconsistent. Switch to row logging in mixed mode, and raise a warning
        in statement mode.
      */
      if (lex->requires_prelocking() &&
          has_write_table_with_nondeterministic_default(
              lex->first_not_own_table()))
        lex->set_stmt_unsafe(
            LEX::BINLOG_STMT_UNSAFE_DEFAULT_EXPRESSION_IN_SUBSTATEMENT);

      /*
        A DML or DDL statement is unsafe if it reads a ACL table while
        modifying the table, because SE skips acquiring row locks.
        Therefore rows seen by DML or DDL may not have same effect on slave.

        We skip checking the same under lock tables mode, because we do
        not skip row locks on ACL table in this mode.
      */
      if (has_acl_table_read(this, tables)) {
        lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_ACL_TABLE_READ_IN_DML_DDL);
      }
    }

    /*
      Get the capabilities vector for all involved storage engines and
      mask out the flags for the binary log.
    */
    for (Table_ref *table = tables; table; table = table->next_global) {
      if (table->is_placeholder()) {
        /*
          Detect if this is a CREATE TEMPORARY or DROP of a
          temporary table. This will be used later in determining whether to
          log in ROW or STMT if MIXED replication is being used.
        */
        if (!is_create_drop_temp_table && !table->table &&
            ((lex->sql_command == SQLCOM_CREATE_TABLE &&
              (lex->create_info->options & HA_LEX_CREATE_TMP_TABLE)) ||
             ((lex->sql_command == SQLCOM_DROP_TABLE ||
               lex->sql_command == SQLCOM_TRUNCATE) &&
              find_temporary_table(this, table)))) {
          is_create_drop_temp_table = true;
        }
        continue;
      }
      handler::Table_flags const flags = table->table->file->ha_table_flags();

      DBUG_PRINT("info", ("table: %s; ha_table_flags: 0x%llx",
                          table->table_name, flags));

      if (table->table->no_replicate) {
        if (!warned_gtid_executed_table) {
          warned_gtid_executed_table =
              gtid_state->warn_or_err_on_modify_gtid_table(this, table);
          /*
            Do not allow users to modify the gtid_executed table
            explicitly by a XA transaction.
          */
          if (warned_gtid_executed_table == 2) return -1;
        }
        /*
          The statement uses a table that is not replicated.
          The following properties about the table:
          - persistent / transient
          - transactional / non transactional
          - temporary / permanent
          - read or write
          - multiple engines involved because of this table
          are not relevant, as this table is completely ignored.
          Because the statement uses a non replicated table,
          using STATEMENT format in the binlog is impossible.
          Either this statement will be discarded entirely,
          or it will be logged (possibly partially) in ROW format.
        */
        lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_SYSTEM_TABLE);

        if (table->lock_descriptor().type >= TL_WRITE_ALLOW_WRITE) {
          non_replicated_tables_count++;
          continue;
        }
      }

      replicated_tables_count++;

      bool trans = table->table->file->has_transactions();

      if (table->lock_descriptor().type >= TL_WRITE_ALLOW_WRITE) {
        write_to_some_transactional_table =
            write_to_some_transactional_table || trans;

        write_to_some_non_transactional_table =
            write_to_some_non_transactional_table || !trans;

        if (prev_write_table &&
            prev_write_table->file->ht != table->table->file->ht)
          multi_write_engine = true;

        if (table->table->s->tmp_table)
          lex->set_stmt_accessed_table(
              trans ? LEX::STMT_WRITES_TEMP_TRANS_TABLE
                    : LEX::STMT_WRITES_TEMP_NON_TRANS_TABLE);
        else
          lex->set_stmt_accessed_table(trans
                                           ? LEX::STMT_WRITES_TRANS_TABLE
                                           : LEX::STMT_WRITES_NON_TRANS_TABLE);

        /*
         Non-transactional updates are allowed when row binlog format is
         used and all non-transactional tables are temporary.
         Binlog format is checked on THD::is_dml_gtid_compatible() method.
        */
        if (!trans)
          write_all_non_transactional_are_tmp_tables =
              write_all_non_transactional_are_tmp_tables &&
              table->table->s->tmp_table;

        flags_write_all_set &= flags;
        flags_write_some_set |= flags;
        is_write = true;

        prev_write_table = table->table;

        /*
          It should be marked unsafe if a table which uses a fulltext parser
          plugin is modified. See also bug#48183.
        */
        if (!lex->is_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_FULLTEXT_PLUGIN)) {
          if (fulltext_unsafe_set(table->table->s))
            lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_FULLTEXT_PLUGIN);
        }
        /*
          INSERT...ON DUPLICATE KEY UPDATE on a table with more than one unique
          keys can be unsafe. Check for it if the flag is already not marked for
          the given statement.
        */
        if (!lex->is_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_INSERT_TWO_KEYS) &&
            lex->sql_command == SQLCOM_INSERT &&
            lex->duplicates == DUP_UPDATE) {
          uint keys = table->table->s->keys, i = 0, unique_keys = 0;
          for (KEY *keyinfo = table->table->s->key_info;
               i < keys && unique_keys <= 1; i++, keyinfo++) {
            if (keyinfo->flags & HA_NOSAME) unique_keys++;
          }
          if (unique_keys > 1)
            lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_INSERT_TWO_KEYS);
        }
      }
      if (lex->get_using_match()) {
        if (fulltext_unsafe_set(table->table->s))
          lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_FULLTEXT_PLUGIN);
      }

      flags_access_some_set |= flags;

      if (lex->sql_command != SQLCOM_CREATE_TABLE ||
          (lex->sql_command == SQLCOM_CREATE_TABLE &&
           ((lex->create_info->options & HA_LEX_CREATE_TMP_TABLE) ||
            (table->lock_descriptor().type < TL_WRITE_ALLOW_WRITE)))) {
        if (table->table->s->tmp_table)
          lex->set_stmt_accessed_table(
              trans ? LEX::STMT_READS_TEMP_TRANS_TABLE
                    : LEX::STMT_READS_TEMP_NON_TRANS_TABLE);
        else
          lex->set_stmt_accessed_table(trans ? LEX::STMT_READS_TRANS_TABLE
                                             : LEX::STMT_READS_NON_TRANS_TABLE);
      }

      if (prev_access_table &&
          prev_access_table->file->ht != table->table->file->ht)
        multi_access_engine = true;

      prev_access_table = table->table;
    }
    assert(!is_write || write_to_some_transactional_table ||
           write_to_some_non_transactional_table);
    /*
      write_all_non_transactional_are_tmp_tables may be true if any
      non-transactional table was not updated, so we fix its value here.
    */
    write_all_non_transactional_are_tmp_tables =
        write_all_non_transactional_are_tmp_tables &&
        write_to_some_non_transactional_table;

    DBUG_PRINT("info", ("flags_write_all_set: 0x%llx", flags_write_all_set));
    DBUG_PRINT("info", ("flags_write_some_set: 0x%llx", flags_write_some_set));
    DBUG_PRINT("info",
               ("flags_access_some_set: 0x%llx", flags_access_some_set));
    DBUG_PRINT("info", ("multi_write_engine: %d", multi_write_engine));
    DBUG_PRINT("info", ("multi_access_engine: %d", multi_access_engine));

    int error = 0;
    int unsafe_flags;

    /*
      With transactional data dictionary, CREATE TABLE runs as one statement
      in a multi-statement transaction internally. Revert this for the
      purposes of determining mixed statement safety.
    */
    const bool multi_stmt_trans = lex->sql_command != SQLCOM_CREATE_TABLE &&
                                  in_multi_stmt_transaction_mode();
    bool trans_table = trans_has_updated_trans_table(this);
    bool binlog_direct = variables.binlog_direct_non_trans_update;

    if (lex->is_mixed_stmt_unsafe(multi_stmt_trans, binlog_direct, trans_table,
                                  tx_isolation))
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_MIXED_STATEMENT);
    else if (multi_stmt_trans && trans_table && !binlog_direct &&
             lex->stmt_accessed_table(LEX::STMT_WRITES_NON_TRANS_TABLE))
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_NONTRANS_AFTER_TRANS);

    /*
      If more than one engine is involved in the statement and at
      least one is doing it's own logging (is *self-logging*), the
      statement cannot be logged atomically, so we generate an error
      rather than allowing the binlog to become corrupt.
    */
    if (multi_write_engine && (flags_write_some_set & HA_HAS_OWN_BINLOGGING))
      my_error((error = ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE),
               MYF(0));
    else if (multi_access_engine &&
             flags_access_some_set & HA_HAS_OWN_BINLOGGING)
      lex->set_stmt_unsafe(
          LEX::BINLOG_STMT_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE);

    /* XA is unsafe for statements */
    if (is_write &&
        !get_transaction()->xid_state()->has_state(XID_STATE::XA_NOTR))
      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_XA);

    DBUG_EXECUTE_IF("make_stmt_only_engines",
                    { flags_write_all_set = HA_BINLOG_STMT_CAPABLE; };);

    /* both statement-only and row-only engines involved */
    if ((flags_write_all_set &
         (HA_BINLOG_STMT_CAPABLE | HA_BINLOG_ROW_CAPABLE)) == 0) {
      /*
        1. Error: Binary logging impossible since both row-incapable
           engines and statement-incapable engines are involved
      */
      my_error((error = ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE), MYF(0));
    }
    /* statement-only engines involved */
    else if ((flags_write_all_set & HA_BINLOG_ROW_CAPABLE) == 0) {
      if (lex->is_stmt_row_injection()) {
        /*
          4. Error: Cannot execute row injection since table uses
             storage engine limited to statement-logging
        */
        my_error((error = ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE), MYF(0));
      } else if (variables.binlog_format == BINLOG_FORMAT_ROW &&
                 sqlcom_can_generate_row_events(this->lex->sql_command)) {
        /*
          2. Error: Cannot modify table that uses a storage engine
             limited to statement-logging when BINLOG_FORMAT = ROW
        */
        my_error((error = ER_BINLOG_ROW_MODE_AND_STMT_ENGINE), MYF(0));
      } else if (variables.binlog_format == BINLOG_FORMAT_MIXED &&
                 ((unsafe_flags = lex->get_stmt_unsafe_flags()) != 0)) {
        /*
          3. Error: Cannot execute statement: binlogging of unsafe
             statement is impossible when storage engine is limited to
             statement-logging and BINLOG_FORMAT = MIXED.
        */
        for (int unsafe_type = 0; unsafe_type < LEX::BINLOG_STMT_UNSAFE_COUNT;
             unsafe_type++)
          if (unsafe_flags & (1 << unsafe_type))
            my_error(
                (error = ER_BINLOG_UNSAFE_AND_STMT_ENGINE), MYF(0),
                ER_THD_NONCONST(current_thd,
                                LEX::binlog_stmt_unsafe_errcode[unsafe_type]));
      } else if (is_write &&
                 ((unsafe_flags = lex->get_stmt_unsafe_flags()) != 0)) {
        /*
          7. Warning: Unsafe statement logged as statement due to
             binlog_format = STATEMENT
        */
        binlog_unsafe_warning_flags |= unsafe_flags;
        DBUG_PRINT("info", ("Scheduling warning to be issued by "
                            "binlog_query: '%s'",
                            ER_THD(current_thd, ER_BINLOG_UNSAFE_STATEMENT)));
        DBUG_PRINT("info", ("binlog_unsafe_warning_flags: 0x%x",
                            binlog_unsafe_warning_flags));
      }
      /* log in statement format! */
    }
    /* no statement-only engines */
    else {
      /* binlog_format = STATEMENT */
      if (variables.binlog_format == BINLOG_FORMAT_STMT) {
        if (lex->is_stmt_row_injection()) {
          /*
            6. Error: Cannot execute row injection since
               BINLOG_FORMAT = STATEMENT
          */
          my_error((error = ER_BINLOG_ROW_INJECTION_AND_STMT_MODE), MYF(0));
        } else if ((flags_write_all_set & HA_BINLOG_STMT_CAPABLE) == 0 &&
                   sqlcom_can_generate_row_events(this->lex->sql_command)) {
          /*
            5. Error: Cannot modify table that uses a storage engine
               limited to row-logging when binlog_format = STATEMENT
          */
          my_error((error = ER_BINLOG_STMT_MODE_AND_ROW_ENGINE), MYF(0), "");
        } else if (is_write &&
                   (unsafe_flags = lex->get_stmt_unsafe_flags()) != 0) {
          /*
            7. Warning: Unsafe statement logged as statement due to
               binlog_format = STATEMENT
          */
          binlog_unsafe_warning_flags |= unsafe_flags;
          DBUG_PRINT("info", ("Scheduling warning to be issued by "
                              "binlog_query: '%s'",
                              ER_THD(current_thd, ER_BINLOG_UNSAFE_STATEMENT)));
          DBUG_PRINT("info", ("binlog_unsafe_warning_flags: 0x%x",
                              binlog_unsafe_warning_flags));
        }
        /* log in statement format! */
      }
      /* No statement-only engines and binlog_format != STATEMENT.
         I.e., nothing prevents us from row logging if needed. */
      else {
        if (lex->is_stmt_unsafe() || lex->is_stmt_row_injection() ||
            lex->is_stmt_unsafe_with_mixed_mode() ||
            (flags_write_all_set & HA_BINLOG_STMT_CAPABLE) == 0 ||
            lex->stmt_accessed_table(LEX::STMT_READS_TEMP_TRANS_TABLE) ||
            lex->stmt_accessed_table(LEX::STMT_READS_TEMP_NON_TRANS_TABLE) ||
            is_create_drop_temp_table) {
#ifndef NDEBUG
          int flags = lex->get_stmt_unsafe_flags();
          DBUG_PRINT("info", ("setting row format for unsafe statement"));
          for (int i = 0; i < Query_tables_list::BINLOG_STMT_UNSAFE_COUNT;
               i++) {
            if (flags & (1 << i))
              DBUG_PRINT(
                  "info",
                  ("unsafe reason: %s",
                   ER_THD_NONCONST(
                       current_thd,
                       Query_tables_list::binlog_stmt_unsafe_errcode[i])));
          }
          DBUG_PRINT("info",
                     ("is_row_injection=%d", lex->is_stmt_row_injection()));
          DBUG_PRINT("info", ("stmt_capable=%llu",
                              (flags_write_all_set & HA_BINLOG_STMT_CAPABLE)));
          DBUG_PRINT("info", ("lex->is_stmt_unsafe_with_mixed_mode = %d",
                              lex->is_stmt_unsafe_with_mixed_mode()));
#endif
          /* log in row format! */
          set_current_stmt_binlog_format_row_if_mixed();
        }
      }
    }

    if (non_replicated_tables_count > 0) {
      if ((replicated_tables_count == 0) || !is_write) {
        DBUG_PRINT("info",
                   ("decision: no logging, no replicated table affected"));
        set_binlog_local_stmt_filter();
      } else {
        if (!is_current_stmt_binlog_format_row()) {
          my_error((error = ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES), MYF(0));
        } else {
          clear_binlog_local_stmt_filter();
        }
      }
    } else {
      clear_binlog_local_stmt_filter();
    }

    if (!error &&
        !is_dml_gtid_compatible(write_to_some_transactional_table,
                                write_to_some_non_transactional_table,
                                write_all_non_transactional_are_tmp_tables))
      error = 1;

    if (error) {
      DBUG_PRINT("info", ("decision: no logging since an error was generated"));
      return -1;
    }

    if (is_write &&
        lex->sql_command != SQLCOM_END /* rows-event applying by slave */) {
      /*
        Master side of DML in the STMT format events parallelization.
        All involving table db:s are stored in a abc-ordered name list.
        In case the number of databases exceeds MAX_DBS_IN_EVENT_MTS maximum
        the list gathering breaks since it won't be sent to the slave.
      */
      for (Table_ref *table = tables; table; table = table->next_global) {
        if (table->is_placeholder()) continue;

        assert(table->table);

        if (table->table->s->is_referenced_by_foreign_key()) {
          /*
             FK-referenced dbs can't be gathered currently. The following
             event will be marked for sequential execution on slave.
          */
          binlog_accessed_db_names = nullptr;
          add_to_binlog_accessed_dbs("");
          break;
        }
        if (!is_current_stmt_binlog_format_row())
          add_to_binlog_accessed_dbs(table->db);
      }
    }
    DBUG_PRINT("info",
               ("decision: logging in %s format",
                is_current_stmt_binlog_format_row() ? "ROW" : "STATEMENT"));

    if (variables.binlog_format == BINLOG_FORMAT_ROW &&
        (lex->sql_command == SQLCOM_UPDATE ||
         lex->sql_command == SQLCOM_UPDATE_MULTI ||
         lex->sql_command == SQLCOM_DELETE ||
         lex->sql_command == SQLCOM_DELETE_MULTI)) {
      String table_names;
      /*
        Generate a warning for UPDATE/DELETE statements that modify a
        BLACKHOLE table, as row events are not logged in row format.
      */
      for (Table_ref *table = tables; table; table = table->next_global) {
        if (table->is_placeholder()) continue;
        if (table->table->file->ht->db_type == DB_TYPE_BLACKHOLE_DB &&
            table->lock_descriptor().type >= TL_WRITE_ALLOW_WRITE) {
          table_names.append(table->table_name);
          table_names.append(",");
        }
      }
      if (!table_names.is_empty()) {
        bool is_update = (lex->sql_command == SQLCOM_UPDATE ||
                          lex->sql_command == SQLCOM_UPDATE_MULTI);
        /*
          Replace the last ',' with '.' for table_names
        */
        table_names.replace(table_names.length() - 1, 1, ".", 1);
        push_warning_printf(
            this, Sql_condition::SL_WARNING, WARN_ON_BLOCKHOLE_IN_RBR,
            ER_THD(this, WARN_ON_BLOCKHOLE_IN_RBR),
            is_update ? "UPDATE" : "DELETE", table_names.c_ptr());
      }
    }
  } else {
    DBUG_PRINT(
        "info",
        ("decision: no logging since "
         "mysql_bin_log.is_open() = %d "
         "and (options & OPTION_BIN_LOG) = 0x%llx "
         "and binlog_format = %lu "
         "and binlog_filter->db_ok(db) = %d",
         mysql_bin_log.is_open(), (variables.option_bits & OPTION_BIN_LOG),
         variables.binlog_format, binlog_filter->db_ok(m_db.str)));

    for (Table_ref *table = tables; table; table = table->next_global) {
      if (!table->is_placeholder() && table->table->no_replicate &&
          gtid_state->warn_or_err_on_modify_gtid_table(this, table))
        break;
    }
  }

#if defined(ENABLED_DEBUG_SYNC)
  if (!is_attachable_ro_transaction_active())
    DEBUG_SYNC(this, "end_decide_logging_format");
#endif

  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: read_gtids_from_binlog
      As read_gtids_from_binlog() will not throw error on truncated
      relaylog files, we should do the same here in order to keep the
      current behavior.
    */
    if (relaylog_file_reader.get_error_type() ==
        Binlog_read_error::CANNOT_GET_FILE_PASSWORD)
      error = true;
    return error;
  }

  Log_event *ev = nullptr;
  bool seen_prev_gtids = false;
  ulong data_len = 0;

  while (!error && (ev = relaylog_file_reader.read_event_object()) != nullptr) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/binlog.cc
Function: handle_gtid_consistency_violation
    return handle_gtid_consistency_violation(
        this, ER_GTID_UNSAFE_CREATE_SELECT,
        ER_RPL_GTID_UNSAFE_STMT_CREATE_SELECT);
  }

  if ((is_create_temporary_table || is_drop_temporary_table) &&
      is_binlog_format_statement &&
      (is_in_transaction || is_in_sub_statement)) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Query_log_event::do_apply_event
  Query_log_event::do_apply_event()
*/
int Query_log_event::do_apply_event(Relay_log_info const *rli) {
  return do_apply_event(rli, query, q_len);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: User_var_log_event::do_apply_event
  Query_log_event::do_apply_event()
*/
int Query_log_event::do_apply_event(Relay_log_info const *rli) {
  return do_apply_event(rli, query, q_len);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Execute_load_query_log_event::do_apply_event
  Query_log_event::do_apply_event()
*/
int Query_log_event::do_apply_event(Relay_log_info const *rli) {
  return do_apply_event(rli, query, q_len);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Table_map_log_event::do_apply_event
  Query_log_event::do_apply_event()
*/
int Query_log_event::do_apply_event(Relay_log_info const *rli) {
  return do_apply_event(rli, query, q_len);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Rows_log_event::do_apply_event
  Query_log_event::do_apply_event()
*/
int Query_log_event::do_apply_event(Relay_log_info const *rli) {
  return do_apply_event(rli, query, q_len);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: Incident_log_event::do_apply_event
  Query_log_event::do_apply_event()
*/
int Query_log_event::do_apply_event(Relay_log_info const *rli) {
  return do_apply_event(rli, query, q_len);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/log_event.cc
Function: View_change_log_event::do_apply_event
  Query_log_event::do_apply_event()
*/
int Query_log_event::do_apply_event(Relay_log_info const *rli) {
  return do_apply_event(rli, query, q_len);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_record.cc
Function: unpack_row
bool unpack_row(Relay_log_info const *rli, TABLE *table,
                uint const source_column_count, uchar const *const row_data,
                MY_BITMAP const *column_image,
                uchar const **const row_image_end_p,
                uchar const *const event_end,
                enum_row_image_type row_image_type,
                bool event_has_value_options, bool only_seek) {
  DBUG_TRACE;
  assert(rli != nullptr);
  assert(table != nullptr);
  assert(row_data != nullptr);
  assert(column_image != nullptr);
  // This is guaranteed by the way column_image is initialized in the
  // Rows_log_event constructor.
  assert(column_image->n_bits == source_column_count);
  assert(row_image_end_p != nullptr);
  assert(event_end >= row_data);
  if (event_has_value_options)
    assert(row_image_type == enum_row_image_type::UPDATE_BI ||
           row_image_type == enum_row_image_type::UPDATE_AI);

  // Get table_def object and table used for type conversion
  table_def *tabledef = nullptr;
  TABLE *conv_table = nullptr;
  rli->get_table_data(table, &tabledef, &conv_table);
  assert(tabledef != nullptr);

  // check for mismatch between column counts in table_map_event and row_event
  if (tabledef->size() != source_column_count) {
    my_error(ER_REPLICA_CORRUPT_EVENT, MYF(0));
    return true;
  }

  uint image_column_count = bitmap_bits_set(column_image);
  bool source_has_gipk = tabledef->is_gipk_present_on_source_table();
  bool replica_has_gipk = table_has_generated_invisible_primary_key(table);

  DBUG_PRINT("info",
             ("table=%.*s "
              "source_column_count=%u image_column_count=%u "
              "tabledef=%p, conv_table=%p "
              "row_image_type=%d event_has_value_options=%d "
              "source_has_gipk=%d replica_has_gipk=%d",
              (int)table->s->table_name.length, table->s->table_name.str,
              source_column_count, image_column_count, tabledef, conv_table,
              (int)row_image_type, event_has_value_options, source_has_gipk,
              replica_has_gipk));

  std::unique_ptr<cs::util::ReplicatedColumnsView> fields =
      cs::util::ReplicatedColumnsViewFactory::
          get_columns_view_with_inbound_filters(rli->info_thd, table, tabledef);

  const uchar *pack_ptr = row_data;

  /*
    For UPDATE AI, partial bits are here.  For UPDATE BI, we
    sneak-peek into partial bits after reaching the end of the row.
  */
  Bit_reader partial_bits;
  ulonglong event_value_options = 0;
  if (event_has_value_options &&
      row_image_type == enum_row_image_type::UPDATE_AI) {
    pack_ptr =
        start_partial_bit_reader(pack_ptr, event_end - pack_ptr, tabledef,
                                 &partial_bits, &event_value_options);
    /*
      We *can* compute partial updates if event_value_options has
      PARTIAL_JSON, unless only_seek==true.
    */
    DBUG_PRINT("info", ("event_value_options=%llu only_seek=%d",
                        event_value_options, (int)only_seek));
    if ((event_value_options & PARTIAL_JSON_UPDATES) != 0 && !only_seek) {
      if (table->has_columns_marked_for_partial_update())
        /*
          partial_update_info has been initialized already (so this is
          not the first row of the statement having the PARTIAL_JSON
          bit set).  Clear the diff vector between rows.
        */
        table->clear_partial_update_diffs();
      else {
        /*
          partial_update_info has not been initialized (so this is the
          first row in the statement having the PARTIAL_JSON bit set).
          Initialize partial_update_info to allow the optimizer to
          collect partial diffs when applying any diff.  Each diff
          vector will be cleared between rows
          (clear_partial_update_diffs above).  The whole
          partial_update_info structure will be cleaned up at the end
          of the statement, when close_thread_tables calls
          cleanup_partial_update.
        */
#ifndef NDEBUG
        int marked_columns = 0;
#endif
        for (auto it = fields->begin();
             it != fields->end() && it.translated_pos() != source_column_count;
             ++it) {
          size_t col_i = it.translated_pos();
          if (tabledef->type(col_i) == MYSQL_TYPE_JSON &&
              bitmap_is_set(column_image, col_i)) {
#ifndef NDEBUG
            marked_columns++;
#endif
            if (table->mark_column_for_partial_update(*it))
              // my_error was already called
              return true; /* purecov: inspected */
          }
        }
#ifndef NDEBUG
        DBUG_EXECUTE_IF("rpl_row_jsondiff_binarydiff", {
          if (marked_columns == 1) {
            const char act[] =
                "now SIGNAL signal.rpl_row_jsondiff_binarydiff_marked_columns";
            assert(opt_debug_sync_timeout > 0);
            assert(!debug_sync_set_action(current_thd, STRING_WITH_LEN(act)));
          }
        };);
#endif
        table->setup_partial_update();
      }
    }
  }

  // NULL bits
  Bit_reader null_bits(pack_ptr);
  pack_ptr = translate_beginning_of_raw_data(
      pack_ptr, column_image, image_column_count, null_bits, tabledef,
      source_has_gipk, replica_has_gipk);
  size_t last_source_pos = 0;
  // Iterate over columns that exist both in source and replica
  for (auto it = fields->begin();
       it != fields->end() && it.translated_pos() != source_column_count;
       ++it) {
    Field *field_ptr = *it;
    size_t col_i = last_source_pos = it.translated_pos();

    /*
      If there is a conversion table, we pick up the field pointer to
      the conversion table.  If the conversion table or the field
      pointer is NULL, no conversions are necessary.
     */
    Field *conv_field =
        conv_table ? conv_table->field[it.absolute_pos()] : nullptr;
    Field *const f = conv_field ? conv_field : field_ptr;
    DBUG_PRINT("debug", ("Conversion %srequired for field '%s' (#%lu)",
                         conv_field ? "" : "not ", field_ptr->field_name,
                         static_cast<long unsigned int>(it.absolute_pos())));
    assert(f != nullptr);

    DBUG_PRINT("debug",
               ("field name: %s; field position: %p", f->field_name, pack_ptr));

    bool is_partial_json = false;
    if ((event_value_options & PARTIAL_JSON_UPDATES) != 0 &&
        tabledef->type(col_i) == MYSQL_TYPE_JSON) {
      is_partial_json = partial_bits.get();
      DBUG_PRINT("info", ("Read %d from partial_bits", is_partial_json));
    }

    /*
      No need to bother about columns that does not exist: they have
      gotten default values when being emptied above.
     */
    if (bitmap_is_set(column_image, col_i)) {
      /* Field...::unpack() cannot return 0 */
      assert(pack_ptr != nullptr);

      if (null_bits.get()) {
        if (f->is_nullable()) {
          DBUG_PRINT("debug", ("Was NULL"));
          /**
            Calling reset just in case one is unpacking on top a
            record with data.

            This could probably go into set_null() but doing so,
            (i) triggers assertion in other parts of the code at
            the moment; (ii) it would make us reset the field,
            always when setting null, which right now doesn't seem
            needed anywhere else except here.

            TODO: maybe in the future we should consider moving
                  the reset to make it part of set_null. But then
                  the assertions triggered need to be
                  addressed/revisited.
           */
          f->reset();
          f->set_null();
        } else {
          f->set_default();
          push_warning_printf(
              current_thd, Sql_condition::SL_WARNING, ER_BAD_NULL_ERROR,
              ER_THD(current_thd, ER_BAD_NULL_ERROR), f->field_name);
        }
      } else {
        f->set_notnull();

        /*
          We only unpack the field if it was non-null.
          Use the master's size information if available else call
          normal unpack operation.
        */
        uint const metadata = tabledef->field_metadata(col_i);
#ifndef NDEBUG
        uchar const *const old_pack_ptr = pack_ptr;
#endif
        /// @todo calc_field_size may read out of bounds /Sven
        uint32 len = tabledef->calc_field_size(col_i, pack_ptr);
        uint32 event_len = event_end - pack_ptr;
        DBUG_PRINT("info", ("calc_field_size ret=%d event_len=%d", (int)len,
                            (int)event_len));
        if (len > event_len) {
          my_error(ER_REPLICA_CORRUPT_EVENT, MYF(0));
          return true;
        }
        if (only_seek)
          pack_ptr += len;
        else if (unpack_field(&pack_ptr, f, metadata, row_image_type,
                              is_partial_json))
          return true;
        DBUG_PRINT("debug", ("Unpacked; metadata: 0x%x;"
                             " pack_ptr: %p; pack_ptr': %p; bytes: %d",
                             metadata, old_pack_ptr, pack_ptr,
                             (int)(pack_ptr - old_pack_ptr)));

        /*
          The raw size of the field, as calculated in calc_field_size,
          should match the one reported by Field_*::unpack unless it is
          a old decimal data type which is unsupported datatype in
          RBR mode.
         */
        assert(tabledef->type(col_i) == MYSQL_TYPE_DECIMAL ||
               tabledef->calc_field_size(col_i, old_pack_ptr) ==
                   (uint32)(pack_ptr - old_pack_ptr));
      }

      /*
        If conv_field is set, then we are doing a conversion. In this
        case, we have unpacked the master data to the conversion
        table, so we need to copy the value stored in the conversion
        table into the final table and do the conversion at the same time.
      */
      if (conv_field) {
        Copy_field copy;
#ifndef NDEBUG
        char source_buf[MAX_FIELD_WIDTH];
        char value_buf[MAX_FIELD_WIDTH];
        String source_type(source_buf, sizeof(source_buf), system_charset_info);
        String value_string(value_buf, sizeof(value_buf), system_charset_info);
        conv_field->sql_type(source_type);
        conv_field->val_str(&value_string);
        DBUG_PRINT("debug", ("Copying field '%s' of type '%s' with value '%s'",
                             field_ptr->field_name, source_type.c_ptr_safe(),
                             value_string.c_ptr_safe()));
#endif
        copy.set(field_ptr, f);
        copy.invoke_do_copy();
#ifndef NDEBUG
        char target_buf[MAX_FIELD_WIDTH];
        String target_type(target_buf, sizeof(target_buf), system_charset_info);
        field_ptr->sql_type(target_type);
        field_ptr->val_str(&value_string);
        DBUG_PRINT("debug", ("Value of field '%s' of type '%s' is now '%s'",
                             field_ptr->field_name, target_type.c_ptr_safe(),
                             value_string.c_ptr_safe()));
#endif
      }
    }
#ifndef NDEBUG
    else {
      DBUG_PRINT("debug", ("Non-existent: skipped"));
    }
#endif
  }

  // move past source's extra fields
  for (size_t col_i = last_source_pos + 1; col_i < source_column_count;
       ++col_i) {
    if ((event_value_options & PARTIAL_JSON_UPDATES) != 0 &&
        tabledef->type(col_i) == MYSQL_TYPE_JSON)
      partial_bits.get();
    if (bitmap_is_set(column_image, col_i)) {
      if (!null_bits.get()) {
        uint32 len = tabledef->calc_field_size(col_i, pack_ptr);
        uint32 event_len = event_end - pack_ptr;
        DBUG_PRINT("info", ("Skipping field"));
        DBUG_DUMP("info", pack_ptr, len);
        if (len > event_len) {
          my_error(ER_REPLICA_CORRUPT_EVENT, MYF(0));
          return true;
        }
        pack_ptr += len;
      }
    }
  }

  // We have read all the null bits.
  assert(null_bits.tell() == image_column_count);

  DBUG_DUMP("info", row_data, pack_ptr - row_data);

  *row_image_end_p = pack_ptr;

  // Read partial_bits, if this is UPDATE_BI of a PARTIAL_UPDATE_ROWS_LOG_EVENT
  if (event_has_value_options &&
      row_image_type == enum_row_image_type::UPDATE_BI) {
    DBUG_PRINT("info", ("reading partial_bits"));
    pack_ptr =
        start_partial_bit_reader(pack_ptr, event_end - pack_ptr, tabledef,
                                 &partial_bits, &event_value_options);
    if ((event_value_options & PARTIAL_JSON_UPDATES) != 0) {
      for (auto it = fields->begin();
           it != fields->end() && it.translated_pos() != source_column_count;
           ++it) {
        size_t col_i = it.translated_pos();
        if (tabledef->type(col_i) == MYSQL_TYPE_JSON) {
          if (partial_bits.get()) {
            DBUG_PRINT("info",
                       ("forcing column %s in the read_set", it->field_name));
            bitmap_set_bit(table->read_set, it.absolute_pos());
          }
#ifndef NO_DBUG
          else
            DBUG_PRINT("info", ("not forcing column %s in the read_set",
                                it->field_name));
#endif
        }
      }
    }
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_record.cc
Function: prepare_record
int prepare_record(TABLE *const table, const MY_BITMAP *cols,
                   const bool check) {
  DBUG_TRACE;

  restore_record(table, s->default_values);

  if (!check) return 0;

  /*
    For fields the extra fields on the slave, we check if they have a default.
    The check follows the same rules as the INSERT query without specifying an
    explicit value for a field not having the explicit default
    (@c check_that_all_fields_are_given_values()).
  */

  DBUG_PRINT_BITSET("debug", "cols: %s", cols);
  /**
    Save a reference to the original write set bitmaps.
    We will need this to restore the bitmaps at the end.
  */
  MY_BITMAP *old_write_set = table->write_set;
  /**
    Just to be sure that tmp_set is currently not in use as
    the write_set already.
  */
  assert(table->write_set != &table->tmp_set);
  /* set the temporary write_set */
  table->column_bitmaps_set_no_signal(table->read_set, &table->tmp_set);
  /**
    Set table->write_set bits for all the columns as they
    will be checked in set_default() function.
  */
  bitmap_set_all(table->write_set);

  for (Field **field_ptr = table->field; *field_ptr; ++field_ptr) {
    uint field_index = (uint)(field_ptr - table->field);
    if (field_index >= cols->n_bits || !bitmap_is_set(cols, field_index)) {
      Field *const f = *field_ptr;
      if (f->is_flag_set(NO_DEFAULT_VALUE_FLAG) &&
          (f->real_type() != MYSQL_TYPE_ENUM)) {
        f->set_default();
        push_warning_printf(
            current_thd, Sql_condition::SL_WARNING, ER_NO_DEFAULT_FOR_FIELD,
            ER_THD(current_thd, ER_NO_DEFAULT_FOR_FIELD), f->field_name);
      } else if (f->has_insert_default_datetime_value_expression() ||
                 f->has_insert_default_general_value_expression()) {
        f->set_default();
      }
    }
  }

  /* set the write_set back to original*/
  table->column_bitmaps_set_no_signal(table->read_set, old_write_set);

  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_table_access.cc
Function: System_table_access::close_table
bool System_table_access::close_table(THD *thd, TABLE *table,
                                      Open_tables_backup *backup, bool error,
                                      bool need_commit) {
  Query_tables_list query_tables_list_backup;
  bool res = false;

  DBUG_TRACE;

  if (table) {
    if (error)
      res = ha_rollback_trans(thd, false);
    else {
      /*
        To make the commit not to block with global read lock set
        "ignore_global_read_lock" flag to true.
       */
      res = ha_commit_trans(thd, false, true);
    }
    if (need_commit) {
      if (error)
        res = ha_rollback_trans(thd, true) || res;
      else {
        /*
          To make the commit not to block with global read lock set
          "ignore_global_read_lock" flag to true.
         */
        res = ha_commit_trans(thd, true, true) || res;
      }
    }
    /*
      In order not to break execution of current statement we have to
      backup/reset/restore Query_tables_list part of LEX, which is
      accessed and updated in the process of closing tables.
    */
    thd->lex->reset_n_backup_query_tables_list(&query_tables_list_backup);
    close_thread_tables(thd);
    thd->lex->restore_backup_query_tables_list(&query_tables_list_backup);
    thd->restore_backup_open_tables_state(backup);
  }

  DBUG_EXECUTE_IF("simulate_flush_commit_error", {
    my_printf_error(ER_ERROR_DURING_FLUSH_LOGS,
                    ER_THD(thd, ER_ERROR_DURING_FLUSH_LOGS), MYF(ME_FATALERROR),
                    true);
    LogErr(ERROR_LEVEL, ER_ERROR_DURING_FLUSH_LOG_COMMIT_PHASE, true);
    return true;
  });

  return res;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_utility.cc
Function: table_def::compatible_with
bool table_def::compatible_with(THD *thd, Relay_log_info *rli, TABLE *table,
                                TABLE **conv_table_var) {
  /*
    Prohibit replication into dictionary internal tables. We know this is
    not DDL (which will be replicated as statements, and rejected by the
    corresponding check for SQL statements), thus 'false' in the call below.
    Also sserting that this is not a DD system thread.
  */
  assert(!thd->is_dd_system_thread());
  const dd::Dictionary *dictionary = dd::get_dictionary();
  if (dictionary && !dictionary->is_dd_table_access_allowed(
                        false, false, table->s->db.str, table->s->db.length,
                        table->s->table_name.str)) {
    DBUG_PRINT("debug", ("Access to dictionary table %s.%s is prohibited",
                         table->s->db.str, table->s->table_name.str));
    rli->report(
        ERROR_LEVEL, ER_SERVER_NO_SYSTEM_TABLE_ACCESS,
        ER_THD(thd, ER_SERVER_NO_SYSTEM_TABLE_ACCESS),
        ER_THD_NONCONST(thd, dictionary->table_type_error_code(
                                 table->s->db.str, table->s->table_name.str)),
        table->s->db.str, table->s->table_name.str);
    return false;
  }

  if (compute_source_table_gipk_info(*thd, table)) {
    rli->report(ERROR_LEVEL, ER_REPLICATION_INCOMPATIBLE_TABLE_WITH_GIPK,
                ER_THD(thd, ER_REPLICATION_INCOMPATIBLE_TABLE_WITH_GIPK),
                static_cast<int>(size()),
                decimal_numeric_version_to_string(
                    thd->variables.immediate_server_version)
                    .c_str(),
                table->s->db.str, table->s->table_name.str, table->s->fields);
    thd->is_slave_error = true;
    return false;
  }

  bool replica_has_gipk = table_has_generated_invisible_primary_key(table);
  std::unique_ptr<cs::util::ReplicatedColumnsView> fields =
      cs::util::ReplicatedColumnsViewFactory::
          get_columns_view_with_inbound_filters(rli->info_thd, table, this);

  /*
    We only count columns which exist both in the table and in the event. The
    computation depends on the following possible differences in table columns
    and event columns:
     1. If the table has generated columns, there are extra columns at the right
        end of the table, which are excluded in the event from 8.0.18 and up.
     2. It is possible for the replica-side table to have an extra GIPK, when
        the source has no GIPK.
     3. It is possible for the source-side table to have an extra GIPK, when the
        replica has no GIPK.

     4. For the remaining columns, not counting generated columns or differences
        in GIPK columns, it is allowed that either the source or the replica has
        less columns at the right of the table.

    To account for cases 1 and 2, we use fields->filtered_size(), which
    retrieves the number of columns on the replica, not counting generated
    columns or extra GIPK columns. To account for case 3, we use
    filtered_size(replica_has_gipk), which retrieves the number of columns in
    the event, not counting any extra GIPK column in the event. To account for
    case 4, we compute the minimum of these two numbers.
  */

  uint const cols_to_check =
      min<ulong>(fields->filtered_size(), filtered_size(replica_has_gipk));
  TABLE *tmp_table = nullptr;

  for (auto it = fields->begin(); it.filtered_pos() < cols_to_check; ++it) {
    Field *const field = *it;
    size_t col = it.translated_pos();
    size_t absolute_col_pos = it.absolute_pos();
    int order;
    if (can_convert_field_to(field, type(col), field_metadata(col),
                             is_array(col), rli, m_flags, &order)) {
      DBUG_PRINT("debug", ("Checking column %lu -"
                           " field '%s' can be converted - order: %d",
                           static_cast<long unsigned int>(col),
                           field->field_name, order));
      assert(order >= -1 && order <= 1);

      /*
        If order is not 0, a conversion is required, so we need to set
        up the conversion table.
       */
      if (order != 0 && tmp_table == nullptr) {
        /*
          This will create the full table with all fields. This is
          necessary to ge the correct field lengths for the record.
        */
        tmp_table = create_conversion_table(thd, rli, table, replica_has_gipk);
        if (tmp_table == nullptr) return false;
        /*
          Clear all fields up to, but not including, this column.
        */
        for (unsigned int i = 0; i < absolute_col_pos; ++i)
          tmp_table->field[i] = nullptr;
      }

      if (order == 0 && tmp_table != nullptr)
        tmp_table->field[absolute_col_pos] = nullptr;
    } else {
      DBUG_PRINT("debug",
                 ("Checking column %lu -"
                  " field '%s' can not be converted",
                  static_cast<long unsigned int>(col), field->field_name));
      assert(col < size() && col < table->s->fields);
      assert(table->s->db.str && table->s->table_name.str);
      const char *db_name = table->s->db.str;
      const char *tbl_name = table->s->table_name.str;
      char source_buf[MAX_FIELD_WIDTH];
      char target_buf[MAX_FIELD_WIDTH];
      String field_sql_type;
      enum loglevel report_level = INFORMATION_LEVEL;
      String source_type(source_buf, sizeof(source_buf), &my_charset_latin1);
      String target_type(target_buf, sizeof(target_buf), &my_charset_latin1);
      show_sql_type(type(col), is_array(col), field_metadata(col),
                    &source_type);
      field->sql_type(target_type);
      if (!ignored_error_code(ER_SERVER_REPLICA_CONVERSION_FAILED)) {
        report_level = ERROR_LEVEL;
        thd->is_slave_error = true;
      } else if (log_error_verbosity >= 2)
        report_level = WARNING_LEVEL;

      if (field->has_charset() && (field->type() == MYSQL_TYPE_VARCHAR ||
                                   field->type() == MYSQL_TYPE_STRING)) {
        field_sql_type.append((field->type() == MYSQL_TYPE_VARCHAR) ? "varchar"
                                                                    : "char");
        const CHARSET_INFO *cs = field->charset();
        size_t length = cs->cset->snprintf(
            cs, target_type.ptr(), target_type.alloced_length(),
            "%s(%u(bytes) %s)", field_sql_type.c_ptr_safe(),
            field->field_length, field->charset()->csname);
        target_type.length(length);
      } else
        field->sql_type(target_type);

      if (report_level != INFORMATION_LEVEL)
        rli->report(report_level, ER_SERVER_REPLICA_CONVERSION_FAILED,
                    ER_THD(thd, ER_SERVER_REPLICA_CONVERSION_FAILED),
                    static_cast<int>(col), db_name, tbl_name,
                    source_type.c_ptr_safe(), target_type.c_ptr_safe());
      return false;
    }
  }

#ifndef NDEBUG
  if (tmp_table) {
    for (unsigned int col = 0; col < tmp_table->s->fields; ++col)
      if (tmp_table->field[col]) {
        char source_buf[MAX_FIELD_WIDTH];
        char target_buf[MAX_FIELD_WIDTH];
        String source_type(source_buf, sizeof(source_buf), &my_charset_latin1);
        String target_type(target_buf, sizeof(target_buf), &my_charset_latin1);
        tmp_table->field[col]->sql_type(source_type);
        table->field[col]->sql_type(target_type);
        DBUG_PRINT("debug",
                   ("Field %s - conversion required."
                    " Source type: '%s', Target type: '%s'",
                    tmp_table->field[col]->field_name, source_type.c_ptr_safe(),
                    target_type.c_ptr_safe()));
      }
  }
#endif

  *conv_table_var = tmp_table;
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_utility.cc
Function: table_def::create_conversion_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_utility.cc
Function: table_def::create_conversion_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_binlog_sender.cc
Function: Binlog_sender::check_start_file
int Binlog_sender::check_start_file() {
  char index_entry_name[FN_REFLEN];
  char *name_ptr = nullptr;
  std::string errmsg;

  if (m_start_file[0] != '\0') {
    mysql_bin_log.make_log_name(index_entry_name, m_start_file);
    name_ptr = index_entry_name;
  } else if (m_using_gtid_protocol) {
    /*
      In normal scenarios, it is not possible that Slave will
      contain more gtids than Master with resepctive to Master's
      UUID. But it could be possible case if Master's binary log
      is truncated(due to raid failure) or Master's binary log is
      deleted but GTID_PURGED was not set properly. That scenario
      needs to be validated, i.e., it should *always* be the case that
      Slave's gtid executed set (+retrieved set) is a subset of
      Master's gtid executed set with respective to Master's UUID.
      If it happens, dump thread will be stopped during the handshake
      with Slave (thus the Slave's I/O thread will be stopped with the
      error. Otherwise, it can lead to data inconsistency between Master
      and Slave.
    */
    Sid_map *slave_sid_map = m_exclude_gtid->get_sid_map();
    assert(slave_sid_map);
    global_sid_lock->wrlock();
    const rpl_sid &server_sid = gtid_state->get_server_sid();
    rpl_sidno subset_sidno = slave_sid_map->sid_to_sidno(server_sid);
    Gtid_set gtid_executed_and_owned(
        gtid_state->get_executed_gtids()->get_sid_map());

    // gtids = executed_gtids & owned_gtids
    if (gtid_executed_and_owned.add_gtid_set(
            gtid_state->get_executed_gtids()) != RETURN_STATUS_OK) {
      assert(0);
    }
    gtid_state->get_owned_gtids()->get_gtids(gtid_executed_and_owned);

    if (!m_exclude_gtid->is_subset_for_sid(&gtid_executed_and_owned,
                                           gtid_state->get_server_sidno(),
                                           subset_sidno)) {
      global_sid_lock->unlock();
      set_fatal_error(ER_THD(m_thd, ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE));
      return 1;
    }
    /*
      Setting GTID_PURGED (when GTID_EXECUTED set is empty i.e., when
      previous_gtids are also empty) will make binlog rotate. That
      leaves first binary log with empty previous_gtids and second
      binary log's previous_gtids with the value of gtid_purged.
      In find_first_log_not_in_gtid_set() while we search for a binary
      log whose previous_gtid_set is subset of slave_gtid_executed,
      in this particular case, server will always find the first binary
      log with empty previous_gtids which is subset of any given
      slave_gtid_executed. Thus Master thinks that it found the first
      binary log which is actually not correct and unable to catch
      this error situation. Hence adding below extra if condition
      to check the situation. Slave should know about Master's purged GTIDs.
      If Slave's GTID executed + retrieved set does not contain Master's
      complete purged GTID list, that means Slave is requesting(expecting)
      GTIDs which were purged by Master. We should let Slave know about the
      situation. i.e., throw error if slave's GTID executed set is not
      a superset of Master's purged GTID set.
      The other case, where user deleted binary logs manually
      (without using 'PURGE BINARY LOGS' command) but gtid_purged
      is not set by the user, the following if condition cannot catch it.
      But that is not a problem because in find_first_log_not_in_gtid_set()
      while checking for subset previous_gtids binary log, the logic
      will not find one and an error ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS
      is thrown from there.
    */
    if (!gtid_state->get_lost_gtids()->is_subset(m_exclude_gtid)) {
      mysql_bin_log.report_missing_purged_gtids(m_exclude_gtid, errmsg);
      global_sid_lock->unlock();
      set_fatal_error(errmsg.c_str());
      return 1;
    }
    global_sid_lock->unlock();
    Gtid first_gtid = {0, 0};
    if (mysql_bin_log.find_first_log_not_in_gtid_set(
            index_entry_name, m_exclude_gtid, &first_gtid, errmsg)) {
      set_fatal_error(errmsg.c_str());
      return 1;
    }
    name_ptr = index_entry_name;
    /*
      find_first_log_not_in_gtid_set() guarantees the file it found has
      Previous_gtids_log_event as all following binlogs. So the variable is
      set to false which tells not to check the event again when starting to
      dump binglogs.
    */
    m_check_previous_gtid_event = false;
    /*
      If we are skipping at least the first transaction of the binlog,
      we must clear the "created" field of the FD event (set it to 0)
      to avoid cleaning up temp tables on slave.
    */
    m_gtid_clear_fd_created_flag =
        (first_gtid.sidno >= 1 && first_gtid.gno >= 1 &&
         m_exclude_gtid->contains_gtid(first_gtid));
  }

  /*
    Index entry name is saved into m_linfo. If name_ptr is NULL,
    then starts from the first file in index file.
  */

  if (mysql_bin_log.find_log_pos(&m_linfo, name_ptr, true)) {
    set_fatal_error(
        "Could not find first log file name in binary log "
        "index file");
    return 1;
  }

  if (m_start_pos < BIN_LOG_HEADER_SIZE) {
    set_fatal_error(
        "Client requested source to start replication "
        "from position < 4");
    return 1;
  }

  Binlog_read_error binlog_read_error;
  Binlog_ifile binlog_ifile(&binlog_read_error);
  if (binlog_ifile.open(m_linfo.log_file_name)) {
    set_fatal_error(binlog_read_error.get_str());
    return 1;
  }

  if (m_start_pos > binlog_ifile.length()) {
    set_fatal_error(
        "Client requested source to start replication from "
        "position > file size");
    return 1;
  }
  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_binlog_sender.cc
Function: Binlog_sender::check_event_type
bool Binlog_sender::check_event_type(Log_event_type type, const char *log_file,
                                     my_off_t log_pos) {
  if (type == binary_log::ANONYMOUS_GTID_LOG_EVENT) {
    /*
      Normally, there will not be any anonymous events when
      auto_position is enabled, since both the master and the slave
      refuse to connect if the master is not using GTID_MODE=ON.
      However, if the master changes GTID_MODE after the connection
      was initialized, or if the slave requests to replicate
      transactions that appear before the last anonymous event, then
      this can happen. Then we generate this error to prevent sending
      anonymous transactions to the slave.
    */
    if (m_using_gtid_protocol) {
      DBUG_EXECUTE_IF("skip_sender_anon_autoposition_error",
                      { return false; };);
      char buf[MYSQL_ERRMSG_SIZE];
      snprintf(buf, MYSQL_ERRMSG_SIZE,
               ER_THD(m_thd, ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION),
               log_file, log_pos);
      set_fatal_error(buf);
      return true;
    }
    /*
      Normally, there will not be any anonymous events when master has
      GTID_MODE=ON, since anonymous events are not generated when
      GTID_MODE=ON.  However, this can happen if the master changes
      GTID_MODE to ON when the slave has not yet replicated all
      anonymous transactions.
    */
    else if (global_gtid_mode.get() == Gtid_mode::ON) {
      char buf[MYSQL_ERRMSG_SIZE];
      snprintf(buf, MYSQL_ERRMSG_SIZE,
               ER_THD(m_thd, ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON),
               log_file, log_pos);
      set_fatal_error(buf);
      return true;
    }
  } else if (type == binary_log::GTID_LOG_EVENT) {
    /*
      Normally, there will not be any GTID events when master has
      GTID_MODE=OFF, since GTID events are not generated when
      GTID_MODE=OFF.  However, this can happen if the master changes
      GTID_MODE to OFF when the slave has not yet replicated all GTID
      transactions.
    */
    if (global_gtid_mode.get() == Gtid_mode::OFF) {
      char buf[MYSQL_ERRMSG_SIZE];
      snprintf(buf, MYSQL_ERRMSG_SIZE,
               ER_THD(m_thd, ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF),
               log_file, log_pos);
      set_fatal_error(buf);
      return true;
    }
  }
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_mysql_connect.cc
Function: Mysql_connection::Mysql_connection not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_mysql_connect.cc
Function: Mysql_connection::Mysql_connection not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: start_slave_threads
  start_slave_threads()

  NOTES
    SLAVE_FORCE_ALL is not implemented here on purpose since it does not make
    sense to do that for starting a slave--we always care if it actually
    started the threads that were not previously running
*/

bool start_slave_threads(bool need_lock_slave, bool wait_for_start,
                         Master_info *mi, int thread_mask) {
  mysql_mutex_t *lock_io{nullptr}, *lock_sql{nullptr}, *lock_cond_io{nullptr},
      *lock_cond_sql{nullptr};
  mysql_cond_t *cond_io{nullptr}, *cond_sql{nullptr};
  bool is_error{false};
  DBUG_TRACE;
  DBUG_EXECUTE_IF("uninitialized_source-info_structure", mi->inited = false;);

  if (!mi->inited || !mi->rli->inited) {
    int error = (!mi->inited ? ER_REPLICA_CM_INIT_REPOSITORY
                             : ER_REPLICA_AM_INIT_REPOSITORY);
    Rpl_info *info = (!mi->inited ? mi : static_cast<Rpl_info *>(mi->rli));
    const char *prefix = current_thd ? ER_THD_NONCONST(current_thd, error)
                                     : ER_DEFAULT_NONCONST(error);
    info->report(ERROR_LEVEL,
                 (!mi->inited ? ER_SERVER_REPLICA_CM_INIT_REPOSITORY
                              : ER_SERVER_REPLICA_AM_INIT_REPOSITORY),
                 prefix, nullptr);
    my_error(error, MYF(0));
    return true;
  }

  if (check_replica_configuration_errors(mi, thread_mask)) return true;

  /**
    SQL AFTER MTS GAPS has no effect when GTID_MODE=ON and SOURCE_AUTO_POS=1
    as no gaps information was collected.
  **/
  if (global_gtid_mode.get() == Gtid_mode::ON && mi->is_auto_position() &&
      mi->rli->until_condition == Relay_log_info::UNTIL_SQL_AFTER_MTS_GAPS) {
    if (current_thd) {
      push_warning_printf(
          current_thd, Sql_condition::SL_WARNING,
          ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED,
          ER_THD(current_thd, ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED),
          mi->get_channel());
    }
  }

  if (need_lock_slave) {
    lock_io = &mi->run_lock;
    lock_sql = &mi->rli->run_lock;
  }
  if (wait_for_start) {
    cond_io = &mi->start_cond;
    cond_sql = &mi->rli->start_cond;
    lock_cond_io = &mi->run_lock;
    lock_cond_sql = &mi->rli->run_lock;
  }

  if (thread_mask & SLAVE_IO)
    is_error = start_slave_thread(key_thread_replica_io, handle_slave_io,
                                  lock_io, lock_cond_io, cond_io,
                                  &mi->slave_running, &mi->slave_run_id, mi);

  if (!is_error && (thread_mask & (SLAVE_IO | SLAVE_MONITOR)) &&
      mi->is_source_connection_auto_failover() &&
      !Source_IO_monitor::get_instance()->is_monitoring_process_running()) {
    is_error = Source_IO_monitor::get_instance()->launch_monitoring_process(
        key_thread_replica_monitor_io);

    if (is_error)
      terminate_slave_threads(mi, thread_mask & (SLAVE_IO | SLAVE_MONITOR),
                              rpl_stop_replica_timeout, need_lock_slave);
  }

  if (!is_error && (thread_mask & SLAVE_SQL)) {
    /*
      MTS-recovery gaps gathering is placed onto common execution path
      for either START-SLAVE and --skip-start-replica= 0
    */
    if (mi->rli->recovery_parallel_workers != 0) {
      if (mts_recovery_groups(mi->rli)) {
        is_error = true;
        my_error(ER_MTA_RECOVERY_FAILURE, MYF(0));
      }
    }
    if (!is_error)
      is_error = start_slave_thread(
          key_thread_replica_sql, handle_slave_sql, lock_sql, lock_cond_sql,
          cond_sql, &mi->rli->slave_running, &mi->rli->slave_run_id, mi);
    if (is_error)
      terminate_slave_threads(mi, thread_mask & (SLAVE_IO | SLAVE_MONITOR),
                              rpl_stop_replica_timeout, need_lock_slave);
  }
  return is_error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_io not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_sql not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_sql not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_sql not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_sql not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_sql not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_sql not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_sql not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_sql not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_sql not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_sql not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: sql_slave_killed
  a parameter of sql_slave_killed() to defer the killed status
*/
#define SLAVE_WAIT_GROUP_DONE 60
bool use_slave_mask = false;
MY_BITMAP slave_error_mask;
char slave_skip_error_names[SHOW_VAR_FUNC_BUFF_SIZE];

char *replica_load_tmpdir = nullptr;
bool replicate_same_server_id;
ulonglong relay_log_space_limit = 0;

const char *relay_log_index = nullptr;
const char *relay_log_basename = nullptr;

/*
  MTS load-ballancing parameter.
  Max length of one MTS Worker queue. The value also determines the size
  of Relay_log_info::gaq (see @c slave_start_workers()).
  It can be set to any value in [1, ULONG_MAX - 1] range.
*/
const ulong mts_slave_worker_queue_len_max = 16384;

/*
  Statistics go to the error log every # of seconds when
  --log_error_verbosity > 2
*/
const long mts_online_stat_period = 60 * 2;

/*
  MTS load-ballancing parameter.
  Time unit in microsecs to sleep by MTS Coordinator to avoid extra thread
  signalling in the case of Worker queues are close to be filled up.
*/
const ulong mts_coordinator_basic_nap = 5;

/*
  MTS load-ballancing parameter.
  Percent of Worker queue size at which Worker is considered to become
  hungry.

  C enqueues --+                   . underrun level
               V                   "
   +----------+-+------------------+--------------+
   | empty    |.|::::::::::::::::::|xxxxxxxxxxxxxx| ---> Worker dequeues
   +----------+-+------------------+--------------+

   Like in the above diagram enqueuing to the x-d area would indicate
   actual underrruning by Worker.
*/
const ulong mts_worker_underrun_level = 10;

/*
  When slave thread exits, we need to remember the temporary tables so we
  can re-use them on slave start.

  TODO: move the vars below under Master_info
*/

int disconnect_slave_event_count = 0, abort_slave_event_count = 0;

static thread_local Master_info *RPL_MASTER_INFO = nullptr;

/**
  Encapsulates the messages and thread stages used for a specific call
  to try_to_reconnect.  Different Reconnect_messages objects may be
  used by the caller of try_to_reconnect in order to make the errors
  and stages include text that describes the reason for the reconnect.
*/
struct Reconnect_messages {
  /// Stage used while waiting to reconnect
  PSI_stage_info &stage_waiting_to_reconnect;
  /// Error reported in case the thread is killed while waiting
  std::string error_killed_while_waiting;
  /// Stage used while reconnecting
  PSI_stage_info &stage_reconnecting;
  /// Description of the condition that caused the thread to reconnect
  std::string triggering_error;
  /**
    The string representation of the enum_server_command that had been
    sent to the source before condition that caused the thread to
    reconnect happened.
  */
  std::string triggering_command;
};


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: handle_slave_worker
static void *handle_slave_worker(void *arg) {
  THD *thd; /* needs to be first for thread_stack */
  bool thd_added = false;
  int error = 0;
  Slave_worker *w = (Slave_worker *)arg;
  Relay_log_info *rli = w->c_rli;
  ulong purge_cnt = 0;
  ulonglong purge_size = 0;
  struct slave_job_item _item, *job_item = &_item;
  Global_THD_manager *thd_manager = Global_THD_manager::get_instance();
#ifdef HAVE_PSI_THREAD_INTERFACE
  struct PSI_thread *psi;
#endif

  my_thread_init();
  DBUG_TRACE;

  thd = new THD;
  if (!thd) {
    LogErr(ERROR_LEVEL, ER_RPL_REPLICA_CANT_INITIALIZE_REPLICA_WORKER,
           rli->get_for_channel_str());
    goto err;
  }
  mysql_mutex_lock(&w->info_thd_lock);
  w->info_thd = thd;
  mysql_mutex_unlock(&w->info_thd_lock);
  thd->thread_stack = (char *)&thd;

#ifdef HAVE_PSI_THREAD_INTERFACE
  // save the instrumentation for worker thread in w->info_thd
  psi = PSI_THREAD_CALL(get_thread)();
  thd_set_psi(w->info_thd, psi);
#endif
  mysql_thread_set_psi_THD(thd);

  if (init_replica_thread(thd, SLAVE_THD_WORKER)) {
    // todo make SQL thread killed
    LogErr(ERROR_LEVEL, ER_RPL_REPLICA_CANT_INITIALIZE_REPLICA_WORKER,
           rli->get_for_channel_str());
    goto err;
  }
  thd->rli_slave = w;
  thd->init_query_mem_roots();

  if (channel_map.is_group_replication_channel_name(rli->get_channel())) {
    if (channel_map.is_group_replication_channel_name(rli->get_channel(),
                                                      true)) {
      thd->rpl_thd_ctx.set_rpl_channel_type(GR_APPLIER_CHANNEL);
    } else {
      thd->rpl_thd_ctx.set_rpl_channel_type(GR_RECOVERY_CHANNEL);
    }
  } else {
    thd->rpl_thd_ctx.set_rpl_channel_type(RPL_STANDARD_CHANNEL);
  }

  w->set_filter(rli->rpl_filter);

  if ((w->deferred_events_collecting = w->rpl_filter->is_on()))
    w->deferred_events = new Deferred_log_events();
  assert(thd->rli_slave->info_thd == thd);

  /* Set applier thread InnoDB priority */
  set_thd_tx_priority(thd, rli->get_thd_tx_priority());
  /* Set write set related options */
  set_thd_write_set_options(thd, rli->get_ignore_write_set_memory_limit(),
                            rli->get_allow_drop_write_set());

  thd->variables.require_row_format = rli->is_row_format_required();

  if (Relay_log_info::PK_CHECK_STREAM !=
      rli->get_require_table_primary_key_check())
    thd->variables.sql_require_primary_key =
        (rli->get_require_table_primary_key_check() ==
         Relay_log_info::PK_CHECK_ON);
  w->set_require_table_primary_key_check(
      rli->get_require_table_primary_key_check());

  thd->variables.sql_generate_invisible_primary_key = false;
  if (thd->rpl_thd_ctx.get_rpl_channel_type() != GR_APPLIER_CHANNEL &&
      thd->rpl_thd_ctx.get_rpl_channel_type() != GR_RECOVERY_CHANNEL &&
      Relay_log_info::PK_CHECK_GENERATE ==
          rli->get_require_table_primary_key_check()) {
    thd->variables.sql_generate_invisible_primary_key = true;
  }

  thd_manager->add_thd(thd);
  thd_added = true;

  if (w->update_is_transactional()) {
    rli->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
                ER_THD(thd, ER_REPLICA_FATAL_ERROR),
                "Error checking if the worker repository is transactional.");
    goto err;
  }

  if (rli->get_commit_order_manager() != nullptr)
    rli->get_commit_order_manager()->init_worker_context(
        *w);  // Initialize worker context within Commit_order_manager

  mysql_mutex_lock(&w->jobs_lock);
  w->running_status = Slave_worker::RUNNING;
  mysql_cond_signal(&w->jobs_cond);

  mysql_mutex_unlock(&w->jobs_lock);

  assert(thd->is_slave_error == 0);

  w->stats_exec_time = w->stats_read_time = 0;
  set_timespec_nsec(&w->ts_exec[0], 0);
  set_timespec_nsec(&w->ts_exec[1], 0);
  set_timespec_nsec(&w->stats_begin, 0);

  // No need to report anything, all error handling will be performed in the
  // slave SQL thread.
  if (!rli->check_privilege_checks_user())
    rli->initialize_security_context(w->info_thd);  // Worker security context
                                                    // initialization with
                                                    // `PRIVILEGE_CHECKS_USER`

  while (!error) {
    error = slave_worker_exec_job_group(w, rli);
  }

  /*
     Cleanup after an error requires clear_error() go first.
     Otherwise assert(!all) in binlog_rollback()
  */
  thd->clear_error();
  w->cleanup_context(thd, error);

  mysql_mutex_lock(&w->jobs_lock);

  while (w->jobs.de_queue(job_item)) {
    purge_cnt++;
    purge_size += job_item->data->common_header->data_written;
    assert(job_item->data);
    delete job_item->data;
  }

  assert(w->jobs.get_length() == 0);

  mysql_mutex_unlock(&w->jobs_lock);

  mysql_mutex_lock(&rli->pending_jobs_lock);
  rli->pending_jobs -= purge_cnt;
  rli->mts_pending_jobs_size -= purge_size;
  assert(rli->mts_pending_jobs_size < rli->mts_pending_jobs_size_max);

  mysql_mutex_unlock(&rli->pending_jobs_lock);

  /*
     In MTS case cleanup_after_session() has be called explicitly.
     TODO: to make worker thd be deleted before Slave_worker instance.
  */
  if (thd->rli_slave) {
    w->cleanup_after_session();
    thd->rli_slave = nullptr;
  }
  mysql_mutex_lock(&w->jobs_lock);

  struct timespec stats_end;
  set_timespec_nsec(&stats_end, 0);
  DBUG_PRINT("info",
             ("Worker %lu statistics: "
              "events processed = %lu "
              "online time = %llu "
              "events exec time = %llu "
              "events read time = %llu "
              "hungry waits = %lu "
              "priv queue overfills = %llu ",
              w->id, w->events_done, diff_timespec(&stats_end, &w->stats_begin),
              w->stats_exec_time, w->stats_read_time, w->wq_empty_waits,
              w->jobs.waited_overfill));

  w->running_status = Slave_worker::NOT_RUNNING;
  mysql_cond_signal(&w->jobs_cond);  // famous last goodbye

  mysql_mutex_unlock(&w->jobs_lock);

err:

  if (thd) {
    /*
       The slave code is very bad. Notice that it is missing
       several clean up calls here. I've just added what was
       necessary to avoid valgrind errors.

       /Alfranio
    */
    thd->get_protocol_classic()->end_net();

    /*
      to avoid close_temporary_tables() closing temp tables as those
      are Coordinator's burden.
    */
    thd->system_thread = NON_SYSTEM_THREAD;
    thd->release_resources();

    THD_CHECK_SENTRY(thd);
    if (thd_added) thd_manager->remove_thd(thd);
    mysql_thread_set_psi_THD(nullptr);
    delete thd;
  }

  my_thread_end();
#if OPENSSL_VERSION_NUMBER < 0x10100000L
  ERR_remove_thread_state(0);
#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
  my_thread_exit(nullptr);
  return nullptr;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: io_thread_init_commands
int io_thread_init_commands(MYSQL *mysql, Master_info *mi) {
  char query[256];
  int ret = 0;
  DBUG_EXECUTE_IF("fake_5_5_version_replica", return ret;);

  mi->reset_network_error();

  sprintf(query, "SET @slave_uuid = '%s', @replica_uuid = '%s'", server_uuid,
          server_uuid);
  if (mysql_real_query(mysql, query, static_cast<ulong>(strlen(query))) &&
      !check_io_slave_killed(mi->info_thd, mi, nullptr))
    goto err;

  mysql_free_result(mysql_store_result(mysql));
  return ret;

err:
  if (mysql_errno(mysql) && is_network_error(mysql_errno(mysql))) {
    mi->report(WARNING_LEVEL, mysql_errno(mysql),
               "The initialization command '%s' failed with the following"
               " error: '%s'.",
               query, mysql_error(mysql));
    mi->set_network_error();
    ret = 2;
  } else {
    char errmsg[512];
    const char *errmsg_fmt =
        "The replica I/O thread stops because a fatal error is encountered "
        "when it tries to send query to source(query: %s).";

    sprintf(errmsg, errmsg_fmt, query);
    mi->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
               ER_THD(current_thd, ER_REPLICA_FATAL_ERROR), errmsg);
    ret = 1;
  }
  mysql_free_result(mysql_store_result(mysql));
  return ret;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: queue_event
    queue_event(), as after_write_to_relay_log() will already flush it.
  */
  if (do_flush_relay_log) err |= mi->rli->flush_current_log();

  if (!skip_repo_persistence) err |= mi->flush_info(force);

  if (need_lock) {
    mysql_mutex_unlock(data_lock);
    mysql_mutex_unlock(log_lock);
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: heartbeat_queue_event
int heartbeat_queue_event(bool is_valid, Master_info *&mi,
                          std::string binlog_name, uint64_t position,
                          unsigned long &inc_pos, bool &do_flush_mi) {
  if (!is_valid) {
    char errbuf[1024];
    char llbuf[22];
    sprintf(errbuf,
            "inconsistent heartbeat event content; the event's data: "
            "log_file_name %-.512s log_pos %s",
            binlog_name.c_str(), llstr(position, llbuf));
    mi->report(ERROR_LEVEL, ER_REPLICA_HEARTBEAT_FAILURE,
               ER_THD(current_thd, ER_REPLICA_HEARTBEAT_FAILURE), errbuf);
    return 1;
  }
  mysql_mutex_lock(&mi->data_lock);
  mi->received_heartbeats++;
  mi->last_heartbeat = my_getsystime() / 10;
  std::string mi_log_filename{
      mi->get_master_log_name() != nullptr ? mi->get_master_log_name() : ""};

  /*
    compare local and event's versions of log_file, log_pos.

    Heartbeat is sent only after an event corresponding to the coordinates
    the heartbeat carries.
    Slave can not have a difference in coordinates except in the
    special case when mi->get_master_log_name(), mi->get_master_log_pos()
    have never been updated by Rotate event i.e when slave does not have
    any history with the master (and thereafter mi->get_master_log_pos() is
    NULL).

    TODO: handling `when' for SHOW REPLICA STATUS' snds behind
  */
  if (mi_log_filename.compare(binlog_name) != 0) {
    std::ostringstream oss;
    oss << "Replication heartbeat event contained the filename '" << binlog_name
        << "' which is different from '" << mi_log_filename
        << "' that was specified in earlier Rotate events.";
    mi->report(ERROR_LEVEL, ER_REPLICA_HEARTBEAT_FAILURE,
               ER_THD(current_thd, ER_REPLICA_HEARTBEAT_FAILURE),
               oss.str().c_str());
    return 1;
  } else if (mi->get_master_log_pos() > position) {
    std::ostringstream oss;
    oss << "Replication heartbeat event contained the position " << position
        << " which is smaller than the position " << mi->get_master_log_pos()
        << " that was computed from earlier events received in the stream. "
        << "The filename is '" << mi_log_filename << "'.";
    mi->report(ERROR_LEVEL, ER_REPLICA_HEARTBEAT_FAILURE,
               ER_THD(current_thd, ER_REPLICA_HEARTBEAT_FAILURE),
               oss.str().c_str());
    return 1;
  }
  /*
    During GTID protocol, if the master skips transactions,
    a heartbeat event is sent to the slave at the end of last
    skipped transaction to update coordinates.

    I/O thread receives the heartbeat event and updates mi
    only if the received heartbeat position is greater than
    mi->get_master_log_pos(). This event is written to the
    relay log as an ignored Rotate event. SQL thread reads
    the rotate event only to update the coordinates corresponding
    to the last skipped transaction. Note that,
    we update only the positions and not the file names, as a ROTATE
    EVENT from the master prior to this will update the file name.
  */
  if (mi->is_auto_position() && mi->get_master_log_pos() < position &&
      !mi_log_filename.empty()) {
    DBUG_EXECUTE_IF("reached_heart_beat_queue_event",
                    { rpl_replica_debug_point(DBUG_RPL_S_HEARTBEAT_EV); };);
    mi->set_master_log_pos(position);

    /*
       Put this heartbeat event in the relay log as a Rotate Event.
    */
    inc_pos = 0;
    mysql_mutex_unlock(&mi->data_lock);
    if (write_rotate_to_master_pos_into_relay_log(mi->info_thd, mi, false
                                                  /* force_flush_mi_info */))
      return 0;
    do_flush_mi = false; /* write_rotate_... above flushed master info */
  } else
    mysql_mutex_unlock(&mi->data_lock);

  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: connect_to_master
int connect_to_master(THD *thd, MYSQL *mysql, Master_info *mi, bool reconnect,
                      bool suppress_warnings, const std::string &host,
                      const uint port, bool is_io_thread) {
  int last_errno = -2;  // impossible error
  ulong err_count = 0;
  char llbuff[22];
  char password[MAX_PASSWORD_LENGTH + 1];
  size_t password_size = sizeof(password);
  DBUG_TRACE;
  set_replica_max_allowed_packet(thd, mysql);
#ifndef NDEBUG
  mi->events_until_exit = disconnect_slave_event_count;
#endif
  ulong client_flag = CLIENT_REMEMBER_OPTIONS;

  /* Always reset public key to remove cached copy */
  mysql_reset_server_public_key();

  mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, (char *)&replica_net_timeout);
  mysql_options(mysql, MYSQL_OPT_READ_TIMEOUT, (char *)&replica_net_timeout);

  if (mi->bind_addr[0]) {
    DBUG_PRINT("info", ("bind_addr: %s", mi->bind_addr));
    mysql_options(mysql, MYSQL_OPT_BIND, mi->bind_addr);
  }

  /* By default the channel is not configured to use SSL */
  enum mysql_ssl_mode ssl_mode = SSL_MODE_DISABLED;
  if (mi->ssl) {
    /* The channel is configured to use SSL */
    mysql_options(mysql, MYSQL_OPT_SSL_KEY,
                  mi->ssl_key[0] ? mi->ssl_key : nullptr);
    mysql_options(mysql, MYSQL_OPT_SSL_CERT,
                  mi->ssl_cert[0] ? mi->ssl_cert : nullptr);
    mysql_options(mysql, MYSQL_OPT_SSL_CA,
                  mi->ssl_ca[0] ? mi->ssl_ca : nullptr);
    mysql_options(mysql, MYSQL_OPT_SSL_CAPATH,
                  mi->ssl_capath[0] ? mi->ssl_capath : nullptr);
    mysql_options(mysql, MYSQL_OPT_SSL_CIPHER,
                  mi->ssl_cipher[0] ? mi->ssl_cipher : nullptr);
    mysql_options(mysql, MYSQL_OPT_SSL_CRL,
                  mi->ssl_crl[0] ? mi->ssl_crl : nullptr);
    mysql_options(mysql, MYSQL_OPT_TLS_VERSION,
                  mi->tls_version[0] ? mi->tls_version : nullptr);
    mysql_options(mysql, MYSQL_OPT_TLS_CIPHERSUITES,
                  mi->tls_ciphersuites.first
                      ? nullptr
                      : mi->tls_ciphersuites.second.c_str());
    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH,
                  mi->ssl_crlpath[0] ? mi->ssl_crlpath : nullptr);
    if (mi->ssl_verify_server_cert)
      ssl_mode = SSL_MODE_VERIFY_IDENTITY;
    else if (mi->ssl_ca[0] || mi->ssl_capath[0])
      ssl_mode = SSL_MODE_VERIFY_CA;
    else
      ssl_mode = SSL_MODE_REQUIRED;
  }
  mysql_options(mysql, MYSQL_OPT_SSL_MODE, &ssl_mode);

  mysql_options(mysql, MYSQL_OPT_COMPRESSION_ALGORITHMS,
                opt_replica_compressed_protocol ? COMPRESSION_ALGORITHM_ZLIB
                                                : mi->compression_algorithm);
  mysql_options(mysql, MYSQL_OPT_ZSTD_COMPRESSION_LEVEL,
                &mi->zstd_compression_level);
  /*
    If server's default charset is not supported (like utf16, utf32) as client
    charset, then set client charset to 'latin1' (default client charset).
  */
  if (is_supported_parser_charset(default_charset_info))
    mysql_options(mysql, MYSQL_SET_CHARSET_NAME, default_charset_info->csname);
  else {
    LogErr(INFORMATION_LEVEL, ER_RPL_REPLICA_CANT_USE_CHARSET,
           default_charset_info->csname, default_client_charset_info->csname);
    mysql_options(mysql, MYSQL_SET_CHARSET_NAME,
                  default_client_charset_info->csname);
  }

  if (mi->is_start_plugin_auth_configured()) {
    DBUG_PRINT("info", ("Slaving is using MYSQL_DEFAULT_AUTH %s",
                        mi->get_start_plugin_auth()));
    mysql_options(mysql, MYSQL_DEFAULT_AUTH, mi->get_start_plugin_auth());
  }

  if (mi->is_start_plugin_dir_configured()) {
    DBUG_PRINT("info", ("Slaving is using MYSQL_PLUGIN_DIR %s",
                        mi->get_start_plugin_dir()));
    mysql_options(mysql, MYSQL_PLUGIN_DIR, mi->get_start_plugin_dir());
  }
  /* Set MYSQL_PLUGIN_DIR in case master asks for an external authentication
     plugin */
  else if (opt_plugin_dir_ptr && *opt_plugin_dir_ptr)
    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir_ptr);

  if (mi->public_key_path[0]) {
    /* Set public key path */
    DBUG_PRINT("info", ("Set source's public key path"));
    mysql_options(mysql, MYSQL_SERVER_PUBLIC_KEY, mi->public_key_path);
  }

  /* Get public key from master */
  DBUG_PRINT("info", ("Set preference to get public key from source"));
  mysql_options(mysql, MYSQL_OPT_GET_SERVER_PUBLIC_KEY, &mi->get_public_key);

  if (is_io_thread && !mi->is_start_user_configured())
    LogErr(WARNING_LEVEL, ER_RPL_REPLICA_INSECURE_CHANGE_SOURCE);

  if (mi->get_password(password, &password_size)) {
    mi->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
               ER_THD(thd, ER_REPLICA_FATAL_ERROR),
               "Unable to configure password when attempting to "
               "connect to the source server. Connection attempt "
               "terminated.");
    return 1;
  }

  const char *user = mi->get_user();
  if (user == nullptr || user[0] == 0) {
    mi->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
               ER_THD(thd, ER_REPLICA_FATAL_ERROR),
               "Invalid (empty) username when attempting to "
               "connect to the source server. Connection attempt "
               "terminated.");
    return 1;
  }

  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, "program_name", "mysqld");
  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, "_client_role",
                 "binary_log_listener");
  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,
                 "_client_replication_channel_name", mi->get_channel());

  const char *tmp_host = host.empty() ? mi->host : host.c_str();
  uint tmp_port = (port == 0) ? mi->port : port;

  bool replica_was_killed{false};
  bool connected{false};

  while (!connected) {
    replica_was_killed = is_io_thread ? io_slave_killed(thd, mi)
                                      : monitor_io_replica_killed(thd, mi);
    if (replica_was_killed) {
      LogErr(INFORMATION_LEVEL, ER_RPL_REPLICA_IO_THREAD_KILLED,
             mi->get_for_channel_str());
      break;
    }

    if (reconnect) {
      connected = !mysql_reconnect(mysql);
    } else {
      // Set this each time mysql_real_connect() is called to make a connection
      mysql_extension_set_server_extn(mysql, &mi->server_extn);

      connected = mysql_real_connect(mysql, tmp_host, user, password, nullptr,
                                     tmp_port, nullptr, client_flag);
    }
    if (connected) break;

    /*
       SHOW REPLICA STATUS will display the number of retries which
       would be real retry counts instead of mi->retry_count for
       each connection attempt by 'Last_IO_Error' entry.
    */
    last_errno = mysql_errno(mysql);
    suppress_warnings = false;
    if (is_io_thread) {
      mi->report(ERROR_LEVEL, last_errno,
                 "Error %s to source '%s@%s:%d'."
                 " This was attempt %lu/%lu, with a delay of %d seconds between"
                 " attempts. Message: %s",
                 (reconnect ? "reconnecting" : "connecting"), mi->get_user(),
                 tmp_host, tmp_port, err_count + 1, mi->retry_count,
                 mi->connect_retry, mysql_error(mysql));
    }

    /*
      By default we try forever. The reason is that failure will trigger
      master election, so if the user did not set mi->retry_count we
      do not want to have election triggered on the first failure to
      connect
    */
    if (++err_count == mi->retry_count) {
      if (is_network_error(last_errno) && is_io_thread) mi->set_network_error();
      replica_was_killed = true;
      break;
    }
    slave_sleep(thd, mi->connect_retry,
                is_io_thread ? io_slave_killed : monitor_io_replica_killed, mi);
  }

  if (!replica_was_killed) {
    if (is_io_thread) {
      mi->clear_error();  // clear possible left over reconnect error
      mi->reset_network_error();
    }

    if (reconnect) {
      if (!suppress_warnings)
        LogErr(SYSTEM_LEVEL,
               ER_RPL_REPLICA_CONNECTED_TO_SOURCE_REPLICATION_RESUMED,
               mi->get_for_channel_str(), mi->get_user(), tmp_host, tmp_port,
               mi->get_io_rpl_log_name(),
               llstr(mi->get_master_log_pos(), llbuff));
    } else {
      query_logger.general_log_print(thd, COM_CONNECT_OUT, "%s@%s:%d",
                                     mi->get_user(), tmp_host, tmp_port);
    }

    thd->set_active_vio(mysql->net.vio);
  }
  mysql->reconnect = true;
  DBUG_PRINT("exit", ("replica_was_killed: %d", replica_was_killed));
  return replica_was_killed;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: reset_slave
int reset_slave(THD *thd) {
  DBUG_TRACE;

  channel_map.assert_some_wrlock();

  Master_info *mi = nullptr;
  int result = 0;
  mi_map::iterator it, gr_channel_map_it;
  if (thd->lex->reset_slave_info.all) {
    /* First do reset_slave for default channel */
    mi = channel_map.get_default_channel_mi();
    if (mi && reset_slave(thd, mi, thd->lex->reset_slave_info.all)) return 1;
    /* Do while iteration for rest of the channels */
    it = channel_map.begin();
    while (it != channel_map.end()) {
      if (!it->first.compare(channel_map.get_default_channel())) {
        it++;
        continue;
      }
      mi = it->second;
      assert(mi);
      if ((result = reset_slave(thd, mi, thd->lex->reset_slave_info.all)))
        break;
      it = channel_map.begin();
    }
    /* RESET group replication specific channels */
    gr_channel_map_it = channel_map.begin(GROUP_REPLICATION_CHANNEL);
    while (gr_channel_map_it != channel_map.end(GROUP_REPLICATION_CHANNEL)) {
      mi = gr_channel_map_it->second;
      assert(mi);
      /*
        We cannot RESET a group replication channel while the group
        replication is running.
      */
      if (is_group_replication_running()) {
        my_error(ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED, MYF(0),
                 "RESET REPLICA ALL FOR CHANNEL", mi->get_channel());
        return 1;
      }
      if ((result = reset_slave(thd, mi, thd->lex->reset_slave_info.all)))
        break;
      gr_channel_map_it = channel_map.begin(GROUP_REPLICATION_CHANNEL);
    }
  } else {
    it = channel_map.begin();
    while (it != channel_map.end()) {
      mi = it->second;
      assert(mi);
      if ((result = reset_slave(thd, mi, thd->lex->reset_slave_info.all)))
        break;
      it++;
    }
    /*
      RESET group replication specific channels.

      We cannot RESET a group replication channel while the group
      replication is running.
    */
    gr_channel_map_it = channel_map.begin(GROUP_REPLICATION_CHANNEL);
    while (gr_channel_map_it != channel_map.end(GROUP_REPLICATION_CHANNEL)) {
      mi = gr_channel_map_it->second;
      assert(mi);
      if (is_group_replication_running()) {
        my_error(ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED, MYF(0),
                 "RESET REPLICA FOR CHANNEL", mi->get_channel());
        return 1;
      }
      if ((result = reset_slave(thd, mi, thd->lex->reset_slave_info.all)))
        break;
      gr_channel_map_it++;
    }
  }
  return result;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: start_slave
bool start_slave(THD *thd) {
  DBUG_TRACE;
  Master_info *mi;
  bool channel_configured, error = false;

  if (channel_map.get_num_instances() == 1) {
    mi = channel_map.get_default_channel_mi();
    assert(mi);
    if (start_slave(thd, &thd->lex->slave_connection, &thd->lex->mi,
                    thd->lex->slave_thd_opt, mi, true))
      return true;
  } else {
    /*
      Users cannot start more than one channel's applier thread
      if sql_replica_skip_counter > 0. It throws an error to the session.
    */
    mysql_mutex_lock(&LOCK_sql_replica_skip_counter);
    /* sql_replica_skip_counter > 0 && !(START SLAVE IO_THREAD) */
    if (sql_replica_skip_counter > 0 && !(thd->lex->slave_thd_opt & SLAVE_IO)) {
      my_error(ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER, MYF(0));
      mysql_mutex_unlock(&LOCK_sql_replica_skip_counter);
      return true;
    }
    mysql_mutex_unlock(&LOCK_sql_replica_skip_counter);

    for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();
         it++) {
      mi = it->second;

      channel_configured =
          mi &&                      // Master_info exists
          (mi->inited || mi->reset)  // It is inited or was reset
          && mi->host[0];            // host is set

      if (channel_configured) {
        if (start_slave(thd, &thd->lex->slave_connection, &thd->lex->mi,
                        thd->lex->slave_thd_opt, mi, true)) {
          LogErr(ERROR_LEVEL, ER_RPL_REPLICA_CANT_START_REPLICA_FOR_CHANNEL,
                 mi->get_channel());
          error = true;
        }
      }
    }
  }
  if (!error) {
    /* no error */
    my_ok(thd);
  }
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: stop_slave
int stop_slave(THD *thd) {
  DBUG_TRACE;
  bool push_temp_table_warning = true;
  Master_info *mi = nullptr;
  int error = 0;

  if (channel_map.get_num_instances() == 1) {
    mi = channel_map.get_default_channel_mi();

    assert(!strcmp(mi->get_channel(), channel_map.get_default_channel()));

    error = stop_slave(thd, mi, true, false /*for_one_channel*/,
                       &push_temp_table_warning);
  } else {
    for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();
         it++) {
      mi = it->second;

      if (Master_info::is_configured(mi)) {
        if (stop_slave(thd, mi, true, false /*for_one_channel*/,
                       &push_temp_table_warning)) {
          LogErr(ERROR_LEVEL, ER_RPL_REPLICA_CANT_STOP_REPLICA_FOR_CHANNEL,
                 mi->get_channel());
          error = 1;
        }
      }
    }
  }

  if (!error) {
    /* no error */
    my_ok(thd);
  }

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: get_master_version_and_clock
static int get_master_version_and_clock(MYSQL *mysql, Master_info *mi) {
  char err_buff[MAX_SLAVE_ERRMSG];
  const char *errmsg = nullptr;
  int err_code = 0;
  int version_number = 0;
  version_number = atoi(mysql->server_version);

  MYSQL_RES *master_res = nullptr;
  MYSQL_ROW master_row;
  DBUG_TRACE;

  DBUG_EXECUTE_IF("unrecognized_source_version", { version_number = 1; };);

  mi->reset_network_error();

  if (!my_isdigit(&my_charset_bin, *mysql->server_version) ||
      version_number < 5) {
    errmsg = "Source reported unrecognized MySQL version";
    err_code = ER_REPLICA_FATAL_ERROR;
    sprintf(err_buff, ER_THD_NONCONST(current_thd, err_code), errmsg);
    goto err;
  }

  mysql_mutex_lock(mi->rli->relay_log.get_log_lock());
  mysql_mutex_lock(&mi->data_lock);
  mi->set_mi_description_event(new Format_description_log_event());
  /* as we are here, we tried to allocate the event */
  if (mi->get_mi_description_event() == nullptr) {
    mysql_mutex_unlock(&mi->data_lock);
    mysql_mutex_unlock(mi->rli->relay_log.get_log_lock());
    errmsg = "default Format_description_log_event";
    err_code = ER_REPLICA_CREATE_EVENT_FAILURE;
    sprintf(err_buff, ER_THD_NONCONST(current_thd, err_code), errmsg);
    goto err;
  }

  /*
    FD_q's (A) is set initially from RL's (A): FD_q.(A) := RL.(A).
    It's necessary to adjust FD_q.(A) at this point because in the following
    course FD_q is going to be dumped to RL.
    Generally FD_q is derived from a received FD_m (roughly FD_q := FD_m)
    in queue_event and the master's (A) is installed.
    At one step with the assignment the Relay-Log's checksum alg is set to
    a new value: RL.(A) := FD_q.(A). If the slave service is stopped
    the last time assigned RL.(A) will be passed over to the restarting
    service (to the current execution point).
    RL.A is a "codec" to verify checksum in queue_event() almost all the time
    the first fake Rotate event.
    Starting from this point IO thread will executes the following checksum
    warmup sequence  of actions:

    FD_q.A := RL.A,
    A_m^0 := master.@@global.binlog_checksum,
    {queue_event(R_f): verifies(R_f, A_m^0)},
    {queue_event(FD_m): verifies(FD_m, FD_m.A), dump(FD_q), rotate(RL),
                        FD_q := FD_m, RL.A := FD_q.A)}

    See legends definition on MYSQL_BIN_LOG::relay_log_checksum_alg
    docs lines (binlog.h).
    In above A_m^0 - the value of master's
    @@binlog_checksum determined in the upcoming handshake (stored in
    mi->checksum_alg_before_fd).


    After the warm-up sequence IO gets to "normal" checksum verification mode
    to use RL.A in

    {queue_event(E_m): verifies(E_m, RL.A)}

    until it has received a new FD_m.
  */
  mi->get_mi_description_event()->common_footer->checksum_alg =
      mi->rli->relay_log.relay_log_checksum_alg;

  assert(mi->get_mi_description_event()->common_footer->checksum_alg !=
         binary_log::BINLOG_CHECKSUM_ALG_UNDEF);
  assert(mi->rli->relay_log.relay_log_checksum_alg !=
         binary_log::BINLOG_CHECKSUM_ALG_UNDEF);

  mysql_mutex_unlock(&mi->data_lock);
  mysql_mutex_unlock(mi->rli->relay_log.get_log_lock());

  /*
    Compare the master and slave's clock. Do not die if master's clock is
    unavailable (very old master not supporting UNIX_TIMESTAMP()?).
  */

  DBUG_EXECUTE_IF("dbug.before_get_UNIX_TIMESTAMP", {
    rpl_replica_debug_point(DBUG_RPL_S_BEFORE_UNIX_TIMESTAMP);
  };);

  master_res = nullptr;
  if (!mysql_real_query(mysql, STRING_WITH_LEN("SELECT UNIX_TIMESTAMP()")) &&
      (master_res = mysql_store_result(mysql)) &&
      (master_row = mysql_fetch_row(master_res))) {
    mysql_mutex_lock(&mi->data_lock);
    mi->clock_diff_with_master =
        (long)(time((time_t *)nullptr) - strtoul(master_row[0], nullptr, 10));
    DBUG_EXECUTE_IF("dbug.mta.force_clock_diff_eq_0",
                    mi->clock_diff_with_master = 0;);
    mysql_mutex_unlock(&mi->data_lock);
  } else if (check_io_slave_killed(mi->info_thd, mi, nullptr))
    goto slave_killed_err;
  else if (is_network_error(mysql_errno(mysql))) {
    mi->report(WARNING_LEVEL, mysql_errno(mysql),
               "Get source clock failed with error: %s", mysql_error(mysql));
    goto network_err;
  } else {
    mysql_mutex_lock(&mi->data_lock);
    mi->clock_diff_with_master = 0; /* The "most sensible" value */
    mysql_mutex_unlock(&mi->data_lock);
    LogErr(WARNING_LEVEL, ER_RPL_REPLICA_SECONDS_BEHIND_SOURCE_DUBIOUS,
           mysql_error(mysql), mysql_errno(mysql));
  }
  if (master_res) {
    mysql_free_result(master_res);
    master_res = nullptr;
  }

  /*
    Check that the master's server id and ours are different. Because if they
    are equal (which can result from a simple copy of master's datadir to slave,
    thus copying some my.cnf), replication will work but all events will be
    skipped.
    Do not die if SELECT @@SERVER_ID fails on master (very old master?).
    Note: we could have put a @@SERVER_ID in the previous SELECT
    UNIX_TIMESTAMP() instead, but this would not have worked on 3.23 masters.
  */
  DBUG_EXECUTE_IF("dbug.before_get_SERVER_ID",
                  { rpl_replica_debug_point(DBUG_RPL_S_BEFORE_SERVER_ID); };);
  master_res = nullptr;
  master_row = nullptr;
  DBUG_EXECUTE_IF("get_source_server_id.ER_NET_READ_INTERRUPTED", {
    DBUG_SET("+d,inject_ER_NET_READ_INTERRUPTED");
    DBUG_SET(
        "-d,get_source_server_id."
        "ER_NET_READ_INTERRUPTED");
  });
  if (!mysql_real_query(mysql, STRING_WITH_LEN("SELECT @@GLOBAL.SERVER_ID")) &&
      (master_res = mysql_store_result(mysql)) &&
      (master_row = mysql_fetch_row(master_res))) {
    if ((::server_id ==
         (mi->master_id = strtoul(master_row[0], nullptr, 10))) &&
        !mi->rli->replicate_same_server_id) {
      errmsg =
          "The replica I/O thread stops because source and replica have equal "
          "MySQL server ids; these ids must be different for replication to "
          "work (or the --replicate-same-server-id option must be used on "
          "replica but this does not always make sense; please check the "
          "manual before using it).";
      err_code = ER_REPLICA_FATAL_ERROR;
      sprintf(err_buff, ER_THD(current_thd, ER_REPLICA_FATAL_ERROR), errmsg);
      goto err;
    }
  } else if (mysql_errno(mysql) != ER_UNKNOWN_SYSTEM_VARIABLE) {
    if (check_io_slave_killed(mi->info_thd, mi, nullptr))
      goto slave_killed_err;
    else if (is_network_error(mysql_errno(mysql))) {
      mi->report(WARNING_LEVEL, mysql_errno(mysql),
                 "Get source SERVER_ID failed with error: %s",
                 mysql_error(mysql));
      goto network_err;
    }
    /* Fatal error */
    errmsg =
        "The replica I/O thread stops because a fatal error is encountered "
        "when it try to get the value of SERVER_ID variable from source.";
    err_code = mysql_errno(mysql);
    sprintf(err_buff, "%s Error: %s", errmsg, mysql_error(mysql));
    goto err;
  } else {
    mi->report(WARNING_LEVEL, ER_SERVER_UNKNOWN_SYSTEM_VARIABLE,
               "Unknown system variable 'SERVER_ID' on source, maybe it "
               "is a *VERY OLD SOURCE*.");
  }
  if (master_res) {
    mysql_free_result(master_res);
    master_res = nullptr;
  }
  if (mi->master_id == 0 && mi->ignore_server_ids->dynamic_ids.size() > 0) {
    errmsg =
        "Replica configured with server id filtering could not detect the "
        "source "
        "server id.";
    err_code = ER_REPLICA_FATAL_ERROR;
    sprintf(err_buff, ER_THD(current_thd, ER_REPLICA_FATAL_ERROR), errmsg);
    goto err;
  }

  if (mi->heartbeat_period != 0.0) {
    char llbuf[22];
    const char query_format[] =
        "SET @master_heartbeat_period = %s, @source_heartbeat_period = %s";
    char query[sizeof(query_format) - 2 * 2 + 2 * sizeof(llbuf) + 1];
    /*
       the period is an ulonglong of nano-secs.
    */
    llstr((ulonglong)(mi->heartbeat_period * 1000000000UL), llbuf);
    sprintf(query, query_format, llbuf, llbuf);

    if (mysql_real_query(mysql, query, static_cast<ulong>(strlen(query)))) {
      if (check_io_slave_killed(mi->info_thd, mi, nullptr))
        goto slave_killed_err;

      if (is_network_error(mysql_errno(mysql))) {
        mi->report(
            WARNING_LEVEL, mysql_errno(mysql),
            "SET @source_heartbeat_period to source failed with error: %s",
            mysql_error(mysql));
        mysql_free_result(mysql_store_result(mysql));
        goto network_err;
      } else {
        /* Fatal error */
        errmsg =
            "The replica I/O thread stops because a fatal error is encountered "
            " when it tries to SET @source_heartbeat_period on source.";
        err_code = ER_REPLICA_FATAL_ERROR;
        sprintf(err_buff, "%s Error: %s", errmsg, mysql_error(mysql));
        mysql_free_result(mysql_store_result(mysql));
        goto err;
      }
    }
    mysql_free_result(mysql_store_result(mysql));
  }

  /*
    Querying if master is capable to checksum and notifying it about own
    CRC-awareness. The master's side instant value of @@global.binlog_checksum
    is stored in the dump thread's uservar area as well as cached locally
    to become known in consensus by master and slave.
  */
  if (DBUG_EVALUATE_IF("simulate_replica_unaware_checksum", 0, 1)) {
    int rc;
    // Set both variables, so that it works equally on both old and new
    // source server.
    const char query[] =
        "SET @master_binlog_checksum = @@global.binlog_checksum, "
        "@source_binlog_checksum = @@global.binlog_checksum";
    master_res = nullptr;
    // initially undefined
    mi->checksum_alg_before_fd = binary_log::BINLOG_CHECKSUM_ALG_UNDEF;
    /*
      @c checksum_alg_before_fd is queried from master in this block.
      If master is old checksum-unaware the value stays undefined.
      Once the first FD will be received its alg descriptor will replace
      the being queried one.
    */
    rc = mysql_real_query(mysql, query, static_cast<ulong>(strlen(query)));
    if (rc != 0) {
      mi->checksum_alg_before_fd = binary_log::BINLOG_CHECKSUM_ALG_OFF;
      if (check_io_slave_killed(mi->info_thd, mi, nullptr))
        goto slave_killed_err;

      if (mysql_errno(mysql) == ER_UNKNOWN_SYSTEM_VARIABLE) {
        // this is tolerable as OM -> NS is supported
        mi->report(WARNING_LEVEL, mysql_errno(mysql),
                   "Notifying source by %s failed with "
                   "error: %s",
                   query, mysql_error(mysql));
      } else {
        if (is_network_error(mysql_errno(mysql))) {
          mi->report(WARNING_LEVEL, mysql_errno(mysql),
                     "Notifying source by %s failed with "
                     "error: %s",
                     query, mysql_error(mysql));
          mysql_free_result(mysql_store_result(mysql));
          goto network_err;
        } else {
          errmsg =
              "The replica I/O thread stops because a fatal error is "
              "encountered "
              "when it tried to SET @source_binlog_checksum on source.";
          err_code = ER_REPLICA_FATAL_ERROR;
          sprintf(err_buff, "%s Error: %s", errmsg, mysql_error(mysql));
          mysql_free_result(mysql_store_result(mysql));
          goto err;
        }
      }
    } else {
      mysql_free_result(mysql_store_result(mysql));
      // Read back the user variable that we just set, to verify that
      // the source recognized the checksum algorithm.
      if (!mysql_real_query(
              mysql, STRING_WITH_LEN("SELECT @source_binlog_checksum")) &&
          (master_res = mysql_store_result(mysql)) &&
          (master_row = mysql_fetch_row(master_res)) &&
          (master_row[0] != nullptr)) {
        mi->checksum_alg_before_fd = static_cast<enum_binlog_checksum_alg>(
            find_type(master_row[0], &binlog_checksum_typelib, 1) - 1);

        DBUG_EXECUTE_IF("undefined_algorithm_on_replica",
                        mi->checksum_alg_before_fd =
                            binary_log::BINLOG_CHECKSUM_ALG_UNDEF;);
        if (mi->checksum_alg_before_fd ==
            binary_log::BINLOG_CHECKSUM_ALG_UNDEF) {
          errmsg =
              "The replica I/O thread was stopped because a fatal error is "
              "encountered "
              "The checksum algorithm used by source is unknown to replica.";
          err_code = ER_REPLICA_FATAL_ERROR;
          sprintf(err_buff, "%s Error: %s", errmsg, mysql_error(mysql));
          mysql_free_result(mysql_store_result(mysql));
          goto err;
        }

        // valid outcome is either of
        assert(mi->checksum_alg_before_fd ==
                   binary_log::BINLOG_CHECKSUM_ALG_OFF ||
               mi->checksum_alg_before_fd ==
                   binary_log::BINLOG_CHECKSUM_ALG_CRC32);
      } else if (check_io_slave_killed(mi->info_thd, mi, nullptr))
        goto slave_killed_err;
      else if (is_network_error(mysql_errno(mysql))) {
        mi->report(WARNING_LEVEL, mysql_errno(mysql),
                   "Get source BINLOG_CHECKSUM failed with error: %s",
                   mysql_error(mysql));
        goto network_err;
      } else {
        errmsg =
            "The replica I/O thread stops because a fatal error is encountered "
            "when it tried to SELECT @source_binlog_checksum.";
        err_code = ER_REPLICA_FATAL_ERROR;
        sprintf(err_buff, "%s Error: %s", errmsg, mysql_error(mysql));
        mysql_free_result(mysql_store_result(mysql));
        goto err;
      }
    }
    if (master_res) {
      mysql_free_result(master_res);
      master_res = nullptr;
    }
  } else
    mi->checksum_alg_before_fd = binary_log::BINLOG_CHECKSUM_ALG_OFF;

  if (DBUG_EVALUATE_IF("bug32442749_simulate_null_checksum", 1, 0)) {
    const char query[] = "SET @source_binlog_checksum= NULL";
    int rc = mysql_real_query(mysql, query, static_cast<ulong>(strlen(query)));
    if (rc != 0) {
      errmsg =
          "The replica I/O thread stops because a fatal error is encountered "
          "when it tried to SET @source_binlog_checksum.";
      err_code = ER_REPLICA_FATAL_ERROR;
      sprintf(err_buff, "%s Error: %s", errmsg, mysql_error(mysql));
      mysql_free_result(mysql_store_result(mysql));
      goto err;
    }
    mysql_free_result(mysql_store_result(mysql));
  }

  if (DBUG_EVALUATE_IF("simulate_replica_unaware_gtid", 0, 1)) {
    auto master_gtid_mode = Gtid_mode::OFF;
    auto slave_gtid_mode = global_gtid_mode.get();
    switch (io_thread_init_command(mi, "SELECT @@GLOBAL.GTID_MODE",
                                   ER_UNKNOWN_SYSTEM_VARIABLE, &master_res,
                                   &master_row)) {
      case COMMAND_STATUS_ERROR:
        return 2;
      case COMMAND_STATUS_ALLOWED_ERROR:
        // master is old and does not have @@GLOBAL.GTID_MODE
        master_gtid_mode = Gtid_mode::OFF;
        break;
      case COMMAND_STATUS_OK: {
        const char *master_gtid_mode_string = master_row[0];
        DBUG_EXECUTE_IF("simulate_source_has_gtid_mode_on_something",
                        { master_gtid_mode_string = "on_something"; });
        DBUG_EXECUTE_IF("simulate_source_has_gtid_mode_off_something",
                        { master_gtid_mode_string = "off_something"; });
        DBUG_EXECUTE_IF("simulate_source_has_unknown_gtid_mode",
                        { master_gtid_mode_string = "Krakel Spektakel"; });
        bool error;
        std::tie(error, master_gtid_mode) =
            Gtid_mode::from_string(master_gtid_mode_string);
        if (error) {
          mi->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
                     "The replica IO thread stops because the source has "
                     "an unknown @@GLOBAL.GTID_MODE '%s'.",
                     master_gtid_mode_string);
          mysql_free_result(master_res);
          return 1;
        }
        mysql_free_result(master_res);
        break;
      }
    }
    if ((slave_gtid_mode == Gtid_mode::OFF &&
         master_gtid_mode >= Gtid_mode::ON_PERMISSIVE) ||
        (slave_gtid_mode == Gtid_mode::ON &&
         master_gtid_mode <= Gtid_mode::OFF_PERMISSIVE &&
         mi->rli->m_assign_gtids_to_anonymous_transactions_info.get_type() ==
             Assign_gtids_to_anonymous_transactions_info::enum_type::
                 AGAT_OFF)) {
      mi->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
                 "The replication receiver thread cannot start because "
                 "the source has GTID_MODE = %.192s and this server has "
                 "GTID_MODE = %.192s.",
                 Gtid_mode::to_string(master_gtid_mode),
                 Gtid_mode::to_string(slave_gtid_mode));
      return 1;
    }
    if (mi->is_auto_position() && master_gtid_mode != Gtid_mode::ON) {
      mi->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
                 "The replication receiver thread cannot start in "
                 "AUTO_POSITION mode: the source has GTID_MODE = %.192s "
                 "instead of ON.",
                 Gtid_mode::to_string(master_gtid_mode));
      return 1;
    }
  }

err:
  if (errmsg) {
    if (master_res) mysql_free_result(master_res);
    assert(err_code != 0);
    mi->report(ERROR_LEVEL, err_code, "%s", err_buff);
    return 1;
  }

  return 0;

network_err:
  if (master_res) mysql_free_result(master_res);
  mi->set_network_error();
  return 2;

slave_killed_err:
  if (master_res) mysql_free_result(master_res);
  return 2;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: get_master_uuid
static int get_master_uuid(MYSQL *mysql, Master_info *mi) {
  const char *errmsg;
  MYSQL_RES *master_res = nullptr;
  MYSQL_ROW master_row = nullptr;
  int ret = 0;
  char query_buf[] = "SELECT @@GLOBAL.SERVER_UUID";

  mi->reset_network_error();

  DBUG_EXECUTE_IF("dbug.return_null_SOURCE_UUID", {
    mi->master_uuid[0] = 0;
    return 0;
  };);

  DBUG_EXECUTE_IF("dbug.before_get_SOURCE_UUID",
                  { rpl_replica_debug_point(DBUG_RPL_S_BEFORE_MASTER_UUID); };);

  DBUG_EXECUTE_IF("dbug.simulate_busy_io",
                  { rpl_replica_debug_point(DBUG_RPL_S_SIMULATE_BUSY_IO); };);
#ifndef NDEBUG
  DBUG_EXECUTE_IF("dbug.simulate_no_such_var_server_uuid", {
    query_buf[strlen(query_buf) - 1] = '_';  // corrupt the last char
  });
#endif
  if (!mysql_real_query(mysql, STRING_WITH_LEN(query_buf)) &&
      (master_res = mysql_store_result(mysql)) &&
      (master_row = mysql_fetch_row(master_res))) {
    if (!strcmp(::server_uuid, master_row[0]) &&
        !mi->rli->replicate_same_server_id) {
      errmsg =
          "The replica I/O thread stops because source and replica have equal "
          "MySQL server UUIDs; these UUIDs must be different for "
          "replication to work.";
      mi->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
                 ER_THD(current_thd, ER_REPLICA_FATAL_ERROR), errmsg);
      // Fatal error
      ret = 1;
    } else {
      if (mi->master_uuid[0] != 0) {
        if (strcmp(mi->master_uuid, master_row[0])) {
          bool is_host_port_unchanged{false};
          char new_source_uuid[UUID_LENGTH + 1];
          strncpy(new_source_uuid, master_row[0], UUID_LENGTH);
          new_source_uuid[UUID_LENGTH] = 0;
          if (!mi->m_uuid_from_host.empty() && mi->m_uuid_from_port != 0) {
            if (mi->m_uuid_from_host.compare(mi->host) == 0 &&
                mi->m_uuid_from_port == mi->port) {
              is_host_port_unchanged = true;
            }
          }
          if (is_host_port_unchanged) {
            LogErr(WARNING_LEVEL,
                   ER_RPL_REPLICA_SOURCE_UUID_HAS_CHANGED_HOST_PORT_UNCHANGED,
                   mi->host, mi->port, mi->master_uuid, new_source_uuid);
          } else {
            LogErr(INFORMATION_LEVEL,
                   ER_RPL_REPLICA_SOURCE_UUID_HOST_PORT_HAS_CHANGED,
                   mi->m_uuid_from_host.c_str(), mi->m_uuid_from_port,
                   mi->master_uuid, mi->host, mi->port, new_source_uuid);
          }
        } else {
          if (!mi->m_uuid_from_host.empty() && mi->m_uuid_from_port != 0 &&
              mi->m_uuid_from_host.compare(mi->host) != 0 &&
              mi->m_uuid_from_port != mi->port) {
            LogErr(WARNING_LEVEL, ER_RPL_REPLICA_SOURCE_UUID_HAS_NOT_CHANGED,
                   mi->m_uuid_from_host.c_str(), mi->m_uuid_from_port, mi->host,
                   mi->port, mi->master_uuid);
          }
        }
      }
      strncpy(mi->master_uuid, master_row[0], UUID_LENGTH);
      mi->master_uuid[UUID_LENGTH] = 0;
      mi->m_uuid_from_host.assign(mi->host);
      mi->m_uuid_from_port = mi->port;
    }
  } else if (mysql_errno(mysql) != ER_UNKNOWN_SYSTEM_VARIABLE) {
    if (is_network_error(mysql_errno(mysql))) {
      mi->report(WARNING_LEVEL, mysql_errno(mysql),
                 "Get source SERVER_UUID failed with error: %s",
                 mysql_error(mysql));
      mi->set_network_error();
      ret = 2;
    } else {
      /* Fatal error */
      errmsg =
          "The replica I/O thread stops because a fatal error is encountered "
          "when it tries to get the value of SERVER_UUID variable from source.";
      mi->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
                 ER_THD(current_thd, ER_REPLICA_FATAL_ERROR), errmsg);
      ret = 1;
    }
  } else {
    mi->master_uuid[0] = 0;
    mi->report(
        WARNING_LEVEL, ER_UNKNOWN_SYSTEM_VARIABLE,
        "Unknown system variable 'SERVER_UUID' on source. "
        "A probable cause is that the variable is not supported on the "
        "source (version: %s), even though it is on the replica (version: %s)",
        mysql->server_version, server_version);
  }

  if (master_res) mysql_free_result(master_res);
  return ret;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: try_to_reconnect not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: try_to_reconnect not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: register_slave_on_master not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: register_slave_on_master not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: exec_relay_log_event
        while executing exec_relay_log_event().
      */
      rli->report(ERROR_LEVEL, thd->get_stmt_da()->mysql_errno(), "%s", errmsg);
    } else if (last_errno != thd->get_stmt_da()->mysql_errno()) {


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: write_rotate_to_master_pos_into_relay_log not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: write_rotate_to_master_pos_into_relay_log not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: write_rotate_to_master_pos_into_relay_log not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: write_rotate_to_master_pos_into_relay_log not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: validate_change_replication_source_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: validate_change_replication_source_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: log_invalid_position_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: log_invalid_position_warning not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: issue_deprecation_warnings_for_channel
static void issue_deprecation_warnings_for_channel(THD *thd) {
  LEX_MASTER_INFO *lex_mi = &thd->lex->mi;

  /*
    Deprecation of GTID_MODE + IGNORE_SERVER_IDS

    Generate deprecation warning when user executes CHANGE
    MASTER TO IGNORE_SERVER_IDS if GTID_MODE=ON.
  */
  if (lex_mi->repl_ignore_server_ids.size() > 0 &&
      global_gtid_mode.get() == Gtid_mode::ON) {
    push_warning_printf(thd, Sql_condition::SL_WARNING,
                        ER_WARN_DEPRECATED_SYNTAX,
                        ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT),
                        "CHANGE MASTER TO ... IGNORE_SERVER_IDS='...' "
                        "(when @@GLOBAL.GTID_MODE = ON)");
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: change_applier_receiver_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: change_applier_receiver_options not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_replica.cc
Function: change_receive_options
   change_receive_options()

   - used in change_master().
   - Execute threads should be stopped before this function is called.

  @param lex_mi structure that holds all change master options given on the
                change master command.

  @param mi     Pointer to Master_info object belonging to the replica channel
                that will be configured

  @return       false if the execute options were successfully set and true,
                otherwise.
*/
static bool change_execute_options(LEX_MASTER_INFO *lex_mi, Master_info *mi) {
  DBUG_TRACE;

  if (lex_mi->privilege_checks_username != nullptr ||
      lex_mi->privilege_checks_none) {
    Relay_log_info::enum_priv_checks_status error{
        mi->rli->set_privilege_checks_user(
            lex_mi->privilege_checks_username,
            lex_mi->privilege_checks_none ? nullptr
                                          : lex_mi->privilege_checks_hostname)};
    if (!!error) {
      mi->rli->report_privilege_check_error(
          ERROR_LEVEL, error, true /* to client*/, mi->rli->get_channel(),
          lex_mi->privilege_checks_username, lex_mi->privilege_checks_hostname);
      return true;
    }
  }

  if (lex_mi->require_row_format != LEX_MASTER_INFO::LEX_MI_UNCHANGED) {
    mi->rli->set_require_row_format(lex_mi->require_row_format ==
                                    LEX_MASTER_INFO::LEX_MI_ENABLE);
  }

  if (lex_mi->require_table_primary_key_check !=
      LEX_MASTER_INFO::LEX_MI_PK_CHECK_UNCHANGED) {
    switch (lex_mi->require_table_primary_key_check) {
      case (LEX_MASTER_INFO::LEX_MI_PK_CHECK_STREAM):
        mi->rli->set_require_table_primary_key_check(
            Relay_log_info::PK_CHECK_STREAM);
        break;
      case (LEX_MASTER_INFO::LEX_MI_PK_CHECK_ON):
        mi->rli->set_require_table_primary_key_check(
            Relay_log_info::PK_CHECK_ON);
        break;
      case (LEX_MASTER_INFO::LEX_MI_PK_CHECK_OFF):
        mi->rli->set_require_table_primary_key_check(
            Relay_log_info::PK_CHECK_OFF);
        break;
      case (LEX_MASTER_INFO::LEX_MI_PK_CHECK_GENERATE):
        if (channel_map.is_group_replication_channel_name(lex_mi->channel)) {
          my_error(ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR, MYF(0));
          return true;
        }
        mi->rli->set_require_table_primary_key_check(
            Relay_log_info::PK_CHECK_GENERATE);
        break;

      default:     /* purecov: tested */
        assert(0); /* purecov: tested */
        break;
    }
  }

  if (lex_mi->relay_log_name) {
    char relay_log_name[FN_REFLEN];
    mi->rli->relay_log.make_log_name(relay_log_name, lex_mi->relay_log_name);
    mi->rli->set_group_relay_log_name(relay_log_name);
    mi->rli->is_group_master_log_pos_invalid = true;
  }

  if (lex_mi->relay_log_pos) {
    mi->rli->set_group_relay_log_pos(lex_mi->relay_log_pos);
    mi->rli->is_group_master_log_pos_invalid = true;
  }

  if (lex_mi->sql_delay != -1) mi->rli->set_sql_delay(lex_mi->sql_delay);

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_async_conn_failover_add_managed_udf.cc
Function: Rpl_async_conn_failover_add_managed::add_managed not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_async_conn_failover_add_managed_udf.cc
Function: Rpl_async_conn_failover_add_managed::add_managed not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_async_conn_failover_add_source_udf.cc
Function: Rpl_async_conn_failover_add_source::add_source not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_async_conn_failover_add_source_udf.cc
Function: Rpl_async_conn_failover_add_source::add_source not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_async_conn_failover_delete_source_udf.cc
Function: Rpl_async_conn_failover_delete_source::delete_source not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_async_conn_failover_delete_source_udf.cc
Function: Rpl_async_conn_failover_delete_source::delete_source not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/csv/ha_tina.cc
Function: tina_is_supported_system_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/csv/ha_tina.cc
Function: tina_is_supported_system_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/myisam/ha_myisam.cc
Function: ha_myisam::create
int ha_myisam::create(const char *name, TABLE *table_arg,
                      HA_CREATE_INFO *ha_create_info, dd::Table *) {
  int error;
  uint create_flags = 0, records, i;
  char buff[FN_REFLEN];
  MI_KEYDEF *keydef;
  MI_COLUMNDEF *recinfo;
  MI_CREATE_INFO create_info;
  TABLE_SHARE *share = table_arg->s;
  uint options = share->db_options_in_use;
  DBUG_TRACE;

  for (i = 0; i < share->keys; i++) {
    if (table_arg->key_info[i].flags & HA_USES_PARSER) {
      create_flags |= HA_CREATE_RELIES_ON_SQL_LAYER;
      break;
    }
  }
  if ((error = table2myisam(table_arg, &keydef, &recinfo, &records)))
    return error; /* purecov: inspected */
  memset(&create_info, 0, sizeof(create_info));
  create_info.max_rows = share->max_rows;
  create_info.reloc_rows = share->min_rows;
  create_info.with_auto_increment = share->next_number_key_offset == 0;
  create_info.auto_increment = (ha_create_info->auto_increment_value
                                    ? ha_create_info->auto_increment_value - 1
                                    : (ulonglong)0);
  create_info.data_file_length =
      ((ulonglong)share->max_rows * share->avg_row_length);
  create_info.language = share->table_charset->number;

#ifndef _WIN32
  if (my_enable_symlinks) {
    create_info.data_file_name = ha_create_info->data_file_name;
    create_info.index_file_name = ha_create_info->index_file_name;
  } else
#endif /* !_WIN32 */
  {
    if (ha_create_info->data_file_name)
      push_warning_printf(
          table_arg->in_use, Sql_condition::SL_WARNING, WARN_OPTION_IGNORED,
          ER_THD(table_arg->in_use, WARN_OPTION_IGNORED), "DATA DIRECTORY");
    if (ha_create_info->index_file_name)
      push_warning_printf(
          table_arg->in_use, Sql_condition::SL_WARNING, WARN_OPTION_IGNORED,
          ER_THD(table_arg->in_use, WARN_OPTION_IGNORED), "INDEX DIRECTORY");
  }

  if (ha_create_info->options & HA_LEX_CREATE_TMP_TABLE)
    create_flags |= HA_CREATE_TMP_TABLE;
  if (ha_create_info->options & HA_CREATE_KEEP_FILES)
    create_flags |= HA_CREATE_KEEP_FILES;
  if (options & HA_OPTION_PACK_RECORD) create_flags |= HA_PACK_RECORD;
  if (options & HA_OPTION_CHECKSUM) create_flags |= HA_CREATE_CHECKSUM;
  if (options & HA_OPTION_DELAY_KEY_WRITE)
    create_flags |= HA_CREATE_DELAY_KEY_WRITE;

  /* TODO: Check that the following fn_format is really needed */
  error = mi_create(
      fn_format(buff, name, "", "", MY_UNPACK_FILENAME | MY_APPEND_EXT),
      share->keys, keydef, records, recinfo, 0, (MI_UNIQUEDEF *)nullptr,
      &create_info, create_flags);
  my_free(recinfo);
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/myisam/ha_myisam.cc
Function: ha_myisam::repair
int ha_myisam::repair(THD *thd, HA_CHECK_OPT *check_opt) {
  int error;
  MI_CHECK param;
  ha_rows start_records;

  if (!file) return HA_ADMIN_INTERNAL_ERROR;

  myisamchk_init(&param);
  param.thd = thd;
  param.op_name = "repair";
  param.testflag =
      ((check_opt->flags & ~(T_EXTEND)) | T_SILENT | T_FORCE_CREATE |
       T_CALC_CHECKSUM | (check_opt->flags & T_EXTEND ? T_REP : T_REP_BY_SORT));
  param.sort_buffer_length = THDVAR(thd, sort_buffer_size);
  start_records = file->state->records;
  while ((error = repair(thd, param, false)) && param.retry_repair) {
    param.retry_repair = false;
    if (test_all_bits(param.testflag,
                      (uint)(T_RETRY_WITHOUT_QUICK | T_QUICK))) {
      param.testflag &= ~T_RETRY_WITHOUT_QUICK;
      LogErr(INFORMATION_LEVEL, ER_RETRYING_REPAIR_WITHOUT_QUICK,
             table->s->path.str);
      continue;
    }
    param.testflag &= ~T_QUICK;
    if ((param.testflag & T_REP_BY_SORT)) {
      param.testflag = (param.testflag & ~T_REP_BY_SORT) | T_REP;
      LogErr(INFORMATION_LEVEL, ER_RETRYING_REPAIR_WITH_KEYCACHE,
             table->s->path.str);
      continue;
    }
    break;
  }
  if (!error && start_records != file->state->records &&
      !(check_opt->flags & T_VERY_SILENT)) {
    char llbuff[22], llbuff2[22];
    LogErr(INFORMATION_LEVEL, ER_FOUND_ROWS_WHILE_REPAIRING,
           llstr(file->state->records, llbuff), llstr(start_records, llbuff2),
           table->s->path.str);
  }
  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/myisam/ha_myisam.cc
Function: myisam_is_supported_system_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/myisam/ha_myisam.cc
Function: myisam_is_supported_system_table not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_binlog_client::read_replication_info
bool Ndb_binlog_client::read_replication_info(
    Ndb *ndb, const char *db, const char *table_name, uint server_id,
    uint32 *binlog_flags, const st_conflict_fn_def **conflict_fn,
    st_conflict_fn_arg *args, uint *num_args) {
  DBUG_TRACE;

  /* Override for ndb_apply_status when logging */
  if (opt_ndb_log_apply_status) {
    if (Ndb_apply_status_table::is_apply_status_table(db, table_name)) {
      // Ensure to get all columns from ndb_apply_status updates and that events
      // are always logged as WRITES.
      ndb_log_info(
          "ndb-log-apply-status forcing 'mysql.ndb_apply_status' to FULL "
          "USE_WRITE");
      *binlog_flags = NBT_FULL;
      *conflict_fn = nullptr;
      *num_args = 0;
      return false;
    }
  }

  Ndb_rep_tab_reader rep_tab_reader;

  int const rc = rep_tab_reader.lookup(ndb, db, table_name, server_id);

  if (rc == 0) {
    // lookup() may return a warning although it succeeds
    const char *msg = rep_tab_reader.get_warning_message();
    if (msg != nullptr) {
      push_warning_printf(m_thd, Sql_condition::SL_WARNING,
                          ER_NDB_REPLICATION_SCHEMA_ERROR,
                          ER_THD(m_thd, ER_NDB_REPLICATION_SCHEMA_ERROR), msg);
      ndb_log_warning("Binlog: %s", msg);
    }
  } else {
    /* When rep_tab_reader.lookup() returns with non-zero error code,
    it must give a warning message describing why it failed*/
    const char *msg = rep_tab_reader.get_warning_message();
    assert(msg);
    my_error(ER_NDB_REPLICATION_SCHEMA_ERROR, MYF(0), msg);
    ndb_log_warning("Binlog: %s", msg);
    return true;
  }

  *binlog_flags = rep_tab_reader.get_binlog_flags();
  const char *conflict_fn_spec = rep_tab_reader.get_conflict_fn_spec();

  if (conflict_fn_spec != nullptr) {
    char msgbuf[FN_REFLEN];
    if (parse_conflict_fn_spec(conflict_fn_spec, conflict_fn, args, num_args,
                               msgbuf, sizeof(msgbuf)) != 0) {
      my_error(ER_CONFLICT_FN_PARSE_ERROR, MYF(0), msgbuf);

      /*
        Log as well, useful for contexts where the thd's stack of
        warnings are ignored
      */
      ndb_log_warning("Replica: Table %s.%s : Parse error on conflict fn : %s",
                      db, table_name, msgbuf);

      return true;
    }
  } else {
    /* No conflict function specified */
    conflict_fn = nullptr;
    num_args = nullptr;
  }

  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_binlog_client::apply_replication_info
int Ndb_binlog_client::apply_replication_info(
    Ndb *ndb, NDB_SHARE *share, const NdbDictionary::Table *ndbtab,
    const st_conflict_fn_def *conflict_fn, const st_conflict_fn_arg *args,
    uint num_args, uint32 binlog_flags) {
  DBUG_TRACE;

  DBUG_PRINT("info", ("Setting binlog flags to %u", binlog_flags));
  share->set_binlog_flags((enum Ndb_binlog_type)binlog_flags);

  // Configure the NDB_SHARE to subscribe to changes for constrained
  // columns when calculating transaction dependencies and table has unique
  // indexes or fk(s). It's necessary to do this check early using the NDB
  // table since the shadow_table inside NDB_SHARE aren't updated until the new
  // NdbEventOperation is created during inplace alter table.
  bool need_constraints = false;
  if (opt_ndb_log_trans_dependency &&
      !ndb_table_have_unique_or_fk(ndb->getDictionary(), ndbtab,
                                   need_constraints)) {
    log_ndb_error(ndb->getDictionary()->getNdbError());
    log_warning(ER_GET_ERRMSG, "Failed to check for table constraints");
    return -1;
  }
  share->set_subscribe_constrained(need_constraints);

  if (conflict_fn != nullptr) {
    char tmp_buf[FN_REFLEN];
    if (setup_conflict_fn(ndb, &share->m_cfn_share, share->db,
                          share->table_name, share->get_binlog_use_update(),
                          ndbtab, tmp_buf, sizeof(tmp_buf), conflict_fn, args,
                          num_args) == 0) {
      ndb_log_verbose(1, "Replica: %s", tmp_buf);
    } else {
      /*
        Dump setup failure message to error log
        for cases where thd warning stack is
        ignored
      */
      ndb_log_warning("Replica: Table %s.%s : %s", share->db, share->table_name,
                      tmp_buf);

      push_warning_printf(m_thd, Sql_condition::SL_WARNING,
                          ER_CONFLICT_FN_PARSE_ERROR,
                          ER_THD(m_thd, ER_CONFLICT_FN_PARSE_ERROR), tmp_buf);

      return -1;
    }
  } else {
    /* No conflict function specified */
    slave_reset_conflict_fn(share->m_cfn_share);
  }

  return 0;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbcluster_binlog.cc
Function: Ndb_binlog_client::drop_events_for_table
void Ndb_binlog_client::drop_events_for_table(THD *thd, Ndb *ndb,
                                              const char *db,
                                              const char *table_name) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("db: %s, tabname: %s", db, table_name));

  if (DBUG_EVALUATE_IF("ndb_skip_drop_event", true, false)) {
    ndb_log_verbose(1, "Binlog: skipping drop event on '%s.%s'", db,
                    table_name);
    return;
  }

  for (uint i = 0; i < 2; i++) {
    std::string event_name = event_name_for_table(db, table_name, i);

    NdbDictionary::Dictionary *dict = ndb->getDictionary();
    if (dict->dropEvent(event_name.c_str()) == 0) {
      // Event dropped successfully
      continue;
    }

    if (dict->getNdbError().code == 4710 || dict->getNdbError().code == 1419) {
      // Failed to drop event but return code says it was
      // because the event didn't exist, ignore
      continue;
    }

    /* Failed to drop event, push warning and write to log */
    push_warning_printf(thd, Sql_condition::SL_WARNING, ER_GET_ERRMSG,
                        ER_THD(thd, ER_GET_ERRMSG), dict->getNdbError().code,
                        dict->getNdbError().message, "NDB");

    ndb_log_error(
        "Binlog: Unable to drop event for '%s.%s' from NDB, "
        "event_name: '%s' error: '%d - %s'",
        db, table_name, event_name.c_str(), dict->getNdbError().code,
        dict->getNdbError().message);
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/server_component/persistent_dynamic_loader.cc
Function: mysql_persistent_dynamic_loader_imp::init
bool mysql_persistent_dynamic_loader_imp::init(void *thdp) {
  try {
    THD *thd = reinterpret_cast<THD *>(thdp);

    if (mysql_persistent_dynamic_loader_imp::initialized()) {
      return true;
    }

    static PSI_mutex_key key_component_id_by_urn_mutex;
    static PSI_mutex_info all_dyloader_mutexes[] = {
        {&key_component_id_by_urn_mutex, "key_component_id_by_urn_mutex", 0, 0,
         PSI_DOCUMENT_ME}};

    int count = (int)array_elements(all_dyloader_mutexes);
    mysql_mutex_register("p_dyn_loader", all_dyloader_mutexes, count);

    mysql_mutex_init(key_component_id_by_urn_mutex, &component_id_by_urn_mutex,
                     MY_MUTEX_INIT_SLOW);

    TABLE *component_table;
    int res;

    mysql_persistent_dynamic_loader_imp::s_group_id = 0;

    /* Open component table and scan read all records. */
    if (open_component_table(thd, TL_READ, &component_table, SELECT_ACL)) {
      push_warning(thd, Sql_condition::SL_WARNING, ER_COMPONENT_TABLE_INCORRECT,
                   ER_THD(thd, ER_COMPONENT_TABLE_INCORRECT));
      mysql_persistent_dynamic_loader_imp::is_initialized = true;
      return false;
    }

    auto guard =
        create_scope_guard([&thd]() { commit_and_close_mysql_tables(thd); });

    unique_ptr_destroy_only<RowIterator> iterator = init_table_iterator(
        thd, component_table, /*ignore_not_found_rows=*/false,
        /*count_examined_rows=*/false);
    if (iterator == nullptr) {
      push_warning(thd, Sql_condition::SL_WARNING, ER_COMPONENT_TABLE_INCORRECT,
                   ER_THD(thd, ER_COMPONENT_TABLE_INCORRECT));
      return false;
    }

    if (component_table->s->fields < CT_FIELD_COUNT) {
      push_warning(thd, Sql_condition::SL_WARNING, ER_COMPONENT_TABLE_INCORRECT,
                   ER_THD(thd, ER_COMPONENT_TABLE_INCORRECT));
      return false;
    }

    /* All read records will be aggregated in groups by group ID. */
    std::map<uint64, std::vector<std::string>> component_groups;

    for (;;) {
      res = iterator->Read();
      if (res != 0) {
        break;
      }

      uint64 component_id =
          component_table->field[CT_FIELD_COMPONENT_ID]->val_int();
      uint64 component_group_id =
          component_table->field[CT_FIELD_GROUP_ID]->val_int();
      String component_urn_str;
      component_table->field[CT_FIELD_COMPONENT_URN]->val_str(
          &component_urn_str);

      std::string component_urn(component_urn_str.ptr(),
                                component_urn_str.length());

      mysql_persistent_dynamic_loader_imp::s_group_id =
          std::max(mysql_persistent_dynamic_loader_imp::s_group_id.load(),
                   component_group_id);

      component_groups[component_group_id].push_back(component_urn);
      {
        MUTEX_LOCK(lock, &component_id_by_urn_mutex);
        mysql_persistent_dynamic_loader_imp::component_id_by_urn.emplace(
            component_urn, component_id);
      }
    }

    iterator.reset();

    /* res is guaranteed to be != 0, -1 means end of records encountered, which
      is interpreted as a success. */
    assert(res != 0);
    if (res != -1) {
      return true;
    }

    for (auto it = component_groups.begin(); it != component_groups.end();
         ++it) {
      std::vector<const char *> urns;
      for (auto group_it = it->second.begin(); group_it != it->second.end();
           ++group_it) {
        urns.push_back(group_it->c_str());
      }
      /* We continue process despite of any errors. */
      dynamic_loader_srv->load(urns.data(), (int)urns.size());
    }

    mysql_persistent_dynamic_loader_imp::is_initialized = true;

    return false;
  } catch (...) {
    mysql_components_handle_std_exception(__func__);
  }

  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/server_component/persistent_dynamic_loader.cc
Function: mysql_persistent_dynamic_loader_imp::unload not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/server_component/persistent_dynamic_loader.cc
Function: mysql_persistent_dynamic_loader_imp::unload not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_partition.cc
Function: fix_fields_part_func
    fix_fields_part_func()
    thd                  The thread object
    func_expr            The item tree reference of the partition function
    table                The table object
    part_info            Reference to partitioning data structure
    is_sub_part          Is the table subpartitioned as well
    is_create_table_ind  Indicator of whether openfrm was called as part of
                         CREATE or ALTER TABLE

  RETURN VALUE
    true                 An error occurred, something was wrong with the
                         partition function.
    false                Ok, a partition field array was created

  DESCRIPTION
    This function is used to build an array of partition fields for the
    partitioning function and subpartitioning function. The partitioning
    function is an item tree that must reference at least one field in the
    table. This is checked first in the parser that the function doesn't
    contain non-cacheable parts (like a random function) and by checking
    here that the function isn't a constant function.

    Calculate the number of fields in the partition function.
    Use it allocate memory for array of Field pointers.
    Initialise array of field pointers. Use information set when
    calling fix_fields and reset it immediately after.
    The get_fields_in_item_tree activates setting of bit in flags
    on the field object.

    The function must be called with thd->mem_root set to the memory
    allocator associated with the TABLE object. Thus, any memory allocated
    during resolving and other actions have the same lifetime as the TABLE.

    Notice that memory allocations made during evaluation calls is NOT
    supported, thus any item class that performs memory allocations during
    evaluation calls must be disallowed as partition functions.
    SEE Bug #21658
*/

static bool fix_fields_part_func(THD *thd, Item *func_expr, TABLE *table,
                                 bool is_sub_part, bool is_create_table_ind) {
  partition_info *part_info = table->part_info;
  bool result = true;
  int error;
  LEX *old_lex = thd->lex;
  LEX lex;
  Query_expression unit(CTX_NONE);
  Query_block select(thd->mem_root, nullptr, nullptr);
  lex.new_static_query(&unit, &select);

  DBUG_TRACE;

  if (init_lex_with_single_table(thd, table, &lex)) goto end;

  {
    Item_ident::Change_context ctx(&lex.query_block->context);
    func_expr->walk(&Item::change_context_processor, enum_walk::POSTFIX,
                    (uchar *)&ctx);
  }
  thd->where = "partition function";

  if (unlikely(func_expr->fix_fields(thd, &func_expr))) {
    DBUG_PRINT("info", ("Field in partition function not part of table"));
    clear_field_flag(table);
    goto end;
  }
  if (unlikely(func_expr->const_item())) {
    my_error(ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR, MYF(0));
    clear_field_flag(table);
    goto end;
  }

  /*
    We don't allow creating partitions with expressions with non matching
    arguments as a (sub)partitioning function,
    but we want to allow such expressions when opening existing tables for
    easier maintenance. This exception should be deprecated at some point
    in future so that we always throw an error.
  */
  if (func_expr->walk(&Item::check_valid_arguments_processor,
                      enum_walk::POSTFIX, nullptr)) {
    if (is_create_table_ind) {
      my_error(ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR, MYF(0));
      goto end;
    } else
      push_warning(thd, Sql_condition::SL_WARNING,
                   ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR,
                   ER_THD(thd, ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR));
  }

  if ((!is_sub_part) && (error = check_signed_flag(part_info))) goto end;
  result = set_up_field_array(table, is_sub_part);
end:
  end_lex_with_single_table(thd, table, old_lex);
#if !defined(NDEBUG)
  Item_ident::Change_context nul_ctx(nullptr);
  func_expr->walk(&Item::change_context_processor, enum_walk::POSTFIX,
                  (uchar *)&nul_ctx);
#endif
  return result;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_install_plugin not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_install_plugin not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_plugin.cc
Function: mysql_uninstall_plugin
static bool mysql_uninstall_plugin(THD *thd, LEX_CSTRING name) {
  TABLE *table;
  st_plugin_int *plugin;
  bool error = true;
  int rc = 0;
  bool remove_IS_metadata_from_dd = false;
  dd::Schema_MDL_locker mdl_handler(thd);
  dd::String_type orig_plugin_name;

  DBUG_TRACE;

  Table_ref tables("mysql", 5, "plugin", 6, "plugin", TL_WRITE);

  if (!opt_noacl &&
      check_table_access(thd, DELETE_ACL, &tables, false, 1, false)) {
    assert(thd->is_error());
    return true;
  }

  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||
      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))
    return true;

  Disable_autocommit_guard autocommit_guard(thd);
  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
  /* need to open before acquiring LOCK_plugin or it will deadlock */
  if (!(table =
            open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT))) {
    assert(thd->is_error());
    return true;
  }

  /*
    System table mysql.plugin is supported by only InnoDB engine. Changing
    table's engine is not allowed. But to support logical upgrade creating
    system table is allowed in MyISAM engine. UNINSTALL PLUGIN operation is
    *not* allowed in this case.
  */
  if ((table->file->ht->is_supported_system_table != nullptr) &&
      !table->file->ht->is_supported_system_table(tables.db, tables.table_name,
                                                  true)) {
    my_error(ER_UNSUPPORTED_ENGINE, MYF(0),
             ha_resolve_storage_engine_name(table->file->ht), tables.db,
             tables.table_name);
    return end_transaction(thd, error);
  }

  // UNINSTALL PLUGIN operation is *not* allowed if table structure is changed.
  System_table_intact table_intact(thd);
  if (table_intact.check(thd, table, &mysql_plugin_table_def))
    return end_transaction(thd, error);

  mysql_mutex_lock(&LOCK_plugin_install);
  if (!table->key_info) {
    my_error(ER_MISSING_KEY, MYF(0), table->s->db.str,
             table->s->table_name.str);
    goto err;
  }

  /*
    Pre-acquire audit plugins for events that may potentially occur
    during [UN]INSTALL PLUGIN.

    When audit event is triggered, audit subsystem acquires interested
    plugins by walking through plugin list. Evidently plugin list
    iterator protects plugin list by acquiring LOCK_plugin, see
    plugin_foreach_with_mask().

    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin
    rather for a long time.

    When audit event is triggered during [UN]INSTALL PLUGIN, plugin
    list iterator acquires the same lock (within the same thread)
    second time.

    This hack should be removed when LOCK_plugin is fixed so it
    protects only what it supposed to protect.
  */
  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS,
                              MYSQL_AUDIT_GENERAL_ALL);

  mysql_mutex_lock(&LOCK_plugin);
  if (!(plugin = plugin_find_internal(name, MYSQL_ANY_PLUGIN)) ||
      plugin->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_DYING)) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), "PLUGIN", name.str);
    goto err;
  }
  if (!plugin->plugin_dl) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_PLUGIN_DELETE_BUILTIN, MYF(0));
    goto err;
  }
  if (plugin->load_option == PLUGIN_FORCE_PLUS_PERMANENT) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_PLUGIN_IS_PERMANENT, MYF(0), name.str);
    goto err;
  }
  /*
    Error message for ER_PLUGIN_IS_PERMANENT is not suitable for
    plugins marked as not dynamically uninstallable, so we have a
    separate one instead of changing the old one.
   */
  if (plugin->plugin->flags & PLUGIN_OPT_NO_UNINSTALL) {
    mysql_mutex_unlock(&LOCK_plugin);
    my_error(ER_PLUGIN_NO_UNINSTALL, MYF(0), plugin->plugin->name);
    goto err;
  }

  if ((plugin->plugin->check_uninstall) && (plugin->state == PLUGIN_IS_READY)) {
    int check;
    /*
      Prevent other threads to uninstall concurrently this plugin.
    */
    plugin->state = PLUGIN_IS_DYING;
    mysql_mutex_unlock(&LOCK_plugin);

    DEBUG_SYNC(current_thd, "in_plugin_check_uninstall");

    /*
      Check uninstall may perform complex operations,
      including acquiring MDL locks, which in turn may need LOCK_plugin.
    */
    DBUG_PRINT("info", ("check uninstall plugin: '%s'", plugin->name.str));
    check = plugin->plugin->check_uninstall(plugin);

    mysql_mutex_lock(&LOCK_plugin);
    assert(plugin->state == PLUGIN_IS_DYING);

    if (check) {
      DBUG_PRINT("warning",
                 ("Plugin '%s' blocked uninstall.", plugin->name.str));
      plugin->state = PLUGIN_IS_READY;
      mysql_mutex_unlock(&LOCK_plugin);
      my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name.str,
               "Plugin is still in use.");
      goto err;
    }
  }

  plugin->state = PLUGIN_IS_DELETED;
  if (plugin->ref_count)
    push_warning(thd, Sql_condition::SL_WARNING, WARN_PLUGIN_BUSY,
                 ER_THD(thd, WARN_PLUGIN_BUSY));
  else
    reap_needed = true;

  // Check if we need to remove I_S plugin metadata from DD.
  remove_IS_metadata_from_dd =
      (plugin->plugin->type == MYSQL_INFORMATION_SCHEMA_PLUGIN &&
       plugin->load_option != PLUGIN_OFF);

  orig_plugin_name = dd::String_type(plugin->name.str, plugin->name.length);
  reap_plugins();
  mysql_mutex_unlock(&LOCK_plugin);

  uchar user_key[MAX_KEY_LENGTH];
  table->use_all_columns();
  table->field[0]->store(name.str, name.length, system_charset_info);
  key_copy(user_key, table->record[0], table->key_info,
           table->key_info->key_length);

  if ((rc = table->file->ha_index_read_idx_map(
           table->record[0], 0, user_key, HA_WHOLE_KEY, HA_READ_KEY_EXACT)) ==
      0) {
    /*
      We do not replicate the UNINSTALL PLUGIN statement. Disable binlogging
      of the delete from the plugin table, so that it is not replicated in
      row based mode.
    */
    assert(!thd->is_error());
    Disable_binlog_guard binlog_guard(thd);
    rc = table->file->ha_delete_row(table->record[0]);
    if (rc) {
      assert(thd->is_error());
    } else
      error = false;
  } else if (rc != HA_ERR_KEY_NOT_FOUND && rc != HA_ERR_END_OF_FILE) {
    assert(thd->is_error());
  } else
    error = false;

  if (error) {
    const char msg[] = "got '%s' deleting from mysql.plugin";
    char buf[MYSQL_ERRMSG_SIZE + sizeof(msg) - 2];
    char errbuf[MYSQL_ERRMSG_SIZE];
    my_strerror(errbuf, sizeof(errbuf), error);
    snprintf(buf, sizeof(buf), msg, errbuf);
    report_error(REPORT_TO_USER, ER_PLUGIN_UNINSTALL_ERROR, name.str, buf);
  }

  if (!error && !thd->transaction_rollback_request &&
      remove_IS_metadata_from_dd) {
    error = dd::info_schema::remove_I_S_view_metadata(
        thd,
        dd::String_type(orig_plugin_name.c_str(), orig_plugin_name.length()));
    assert(!error || thd->is_error());

    if (!error) {
      Uncommitted_tables_guard uncommitted_tables(thd);
      error = update_referencing_views_metadata(
          thd, INFORMATION_SCHEMA_NAME.str, orig_plugin_name.c_str(), false,
          &uncommitted_tables);
    }

    if (error) {
      report_error(REPORT_TO_USER, ER_PLUGIN_UNINSTALL_ERROR, name.str,
                   "error updating metadata");
    }
  }

err:
  mysql_mutex_unlock(&LOCK_plugin_install);
  return end_transaction(thd, error || thd->transaction_rollback_request);
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_tablespace.cc
Function: set_table_encryption_type not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_tablespace.cc
Function: set_table_encryption_type not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/debug_sync.cc
Function: debug_sync_execute
static void debug_sync_execute(THD *thd, st_debug_sync_action *action) {
#ifndef NDEBUG
  const char *dsp_name = action->sync_point.c_ptr();
  const char *sig_emit = action->signal.c_ptr();
  const char *sig_wait = action->wait_for.c_ptr();
#endif
  DBUG_TRACE;
  assert(thd);
  assert(action);
  DBUG_PRINT("debug_sync",
             ("sync_point: '%s'  activation_count: %lu  hit_limit: %lu  "
              "execute: %lu  timeout: %lu  signal: '%s'  wait_for: '%s'",
              dsp_name, action->activation_count, action->hit_limit,
              action->execute, action->timeout, sig_emit, sig_wait));

  assert(action->activation_count);
  action->activation_count--;

  if (action->execute) {
    const char *old_proc_info = nullptr;

    action->execute--;

    /*
      If we will be going to wait, set proc_info for the PROCESSLIST table.
      Do this before emitting the signal, so other threads can see it
      if they awake before we enter_cond() below.
    */
    if (action->wait_for.length()) {
      st_debug_sync_control *ds_control = thd->debug_sync_control;
      strxnmov(ds_control->ds_proc_info, sizeof(ds_control->ds_proc_info) - 1,
               "debug sync point: ", action->sync_point.c_ptr(), NullS);
      old_proc_info = thd->proc_info();
      debug_sync_thd_proc_info(thd, ds_control->ds_proc_info);
    }

    /*
      Take mutex to ensure that only one thread access
      debug_sync_global.ds_signal_set at a time.  Need to take mutex for
      read access too, to create a memory barrier in order to avoid that
      threads just reads an old cached version of the signal.
    */
    mysql_mutex_lock(&debug_sync_global.ds_mutex);

    if (action->signal.length()) {
      std::string signal = action->signal.ptr();
      myu::Split(
          signal.begin(), signal.end(), myu::IsComma,
          [](std::string::const_iterator f, std::string::const_iterator l) {
            auto tr = myu::FindTrimmedRange(f, l, myu::IsSpace);
            if (tr.first != tr.second) {
              std::string s{tr.first, tr.second};
              add_signal_event(&s);
            }
          });

      /* Wake threads waiting in a sync point. */
      mysql_cond_broadcast(&debug_sync_global.ds_cond);
      DBUG_PRINT("debug_sync_exec",
                 ("signal '%s'  at: '%s'", sig_emit, dsp_name));
    } /* end if (action->signal.length()) */

    if (action->wait_for.length()) {
      mysql_mutex_t *old_mutex;
      mysql_cond_t *old_cond = nullptr;
      int error = 0;
      struct timespec abstime;
      std::string wait_for = action->wait_for.ptr();

      /*
        We don't use enter_cond()/exit_cond(). They do not save old
        mutex and cond. This would prohibit the use of DEBUG_SYNC
        between other places of enter_cond() and exit_cond().

        Note that we cannot lock LOCK_current_cond here. See comment
        in THD::enter_cond().
      */
      old_mutex = thd->current_mutex;
      old_cond = thd->current_cond;
      thd->current_mutex = &debug_sync_global.ds_mutex;
      thd->current_cond = &debug_sync_global.ds_cond;

      set_timespec(&abstime, action->timeout);
      DBUG_EXECUTE("debug_sync_exec", {
        DBUG_PRINT("debug_sync_exec",
                   ("wait for '%s'  at: '%s'", sig_wait, dsp_name));
      });
      /*
        Wait until global signal string matches the wait_for string.
        Interrupt when thread or query is killed or facility disabled.
        The facility can become disabled when some thread cannot get
        the required dynamic memory allocated.
      */
      while (!is_signalled(&wait_for) && !thd->killed &&
             opt_debug_sync_timeout) {
        error = mysql_cond_timedwait(&debug_sync_global.ds_cond,
                                     &debug_sync_global.ds_mutex, &abstime);

        DBUG_EXECUTE("debug_sync", {
          /* Functions as DBUG_PRINT args can change keyword and line nr. */
          DBUG_PRINT("debug_sync",
                     ("awoke from %s error: %d", sig_wait, error));
        });

        if (is_timeout(error)) {
          // We should not make the statement fail, even if in strict mode.
          push_warning(thd, Sql_condition::SL_WARNING, ER_DEBUG_SYNC_TIMEOUT,
                       ER_THD(thd, ER_DEBUG_SYNC_TIMEOUT));
          DBUG_EXECUTE_IF("debug_sync_abort_on_timeout", DBUG_ABORT(););
          break;
        }
        error = 0;
      }
      if (action->clear_event) clear_signal_event(&wait_for);

      DBUG_EXECUTE(
          "debug_sync_exec",
          if (thd->killed) DBUG_PRINT("debug_sync_exec",
                                      ("killed %d from '%s'  at: '%s'",
                                       thd->killed.load(), sig_wait, dsp_name));
          else DBUG_PRINT("debug_sync_exec",
                          ("%s from '%s'  at: '%s'",
                           error ? "timeout" : "resume", sig_wait, dsp_name)););

      /*
        We don't use enter_cond()/exit_cond(). They do not save old
        mutex and cond. This would prohibit the use of DEBUG_SYNC
        between other places of enter_cond() and exit_cond(). The
        protected mutex must always unlocked _before_ mysys_var->mutex
        is locked. (See comment in THD::exit_cond().)
      */
      mysql_mutex_unlock(&debug_sync_global.ds_mutex);
      if (old_mutex) {
        mysql_mutex_lock(&thd->LOCK_current_cond);
        thd->current_mutex = old_mutex;
        thd->current_cond = old_cond;
        mysql_mutex_unlock(&thd->LOCK_current_cond);
        debug_sync_thd_proc_info(thd, old_proc_info);
      } else
        debug_sync_thd_proc_info(thd, old_proc_info);
    } else {
      /* In case we don't wait, we just release the mutex. */
      mysql_mutex_unlock(&debug_sync_global.ds_mutex);
    } /* end if (action->wait_for.length()) */

  } /* end if (action->execute) */

  /* hit_limit is zero for infinite. Don't decrement unconditionally. */
  if (action->hit_limit) {
    if (!--action->hit_limit) {
      thd->killed = THD::KILL_QUERY;
      my_error(ER_DEBUG_SYNC_HIT_LIMIT, MYF(0));
    }
    DBUG_PRINT("debug_sync_exec",
               ("hit_limit: %lu  at: '%s'", action->hit_limit, dsp_name));
  }
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/item_xmlfunc.cc
Function: parse_xml
   invoking parse_xml(). So, we should never see any NULL SQL input
   and never return NULL from the overridden member functions in
   item_xmlfunc.cc.

   @see Item_xml_str_func::parse_xpath()
   @see Item_func_xml_update::val_str()

   @param nodeset   the nodeset to be modified
  */
  virtual void val_nodeset(XPathFilter *nodeset) const = 0;
  enum Type type() const override { return XPATH_NODESET; }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/resourcegroups/resource_group_sql_cmd.cc
Function: check_and_apply_resource_grp
        check_and_apply_resource_grp(thd, m_thread_id_list->at(0),
                                     resource_group, true))
      return true;
    else
      for (const auto &thread_id : *m_thread_id_list)
        (void)check_and_apply_resource_grp(thd, thread_id, resource_group,
                                           false);
  }

  my_ok(thd);
  return false;
}

bool resourcegroups::Sql_cmd_set_resource_group::prepare(THD *thd) {
  DBUG_TRACE;

  if (Sql_cmd::prepare(thd)) return true;

  bool rc = check_resource_group_set_privilege(thd->security_context());

  return rc;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: check_routine_already_exists not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp.cc
Function: check_routine_already_exists not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/ndb/plugin/ha_ndbinfo.cc
Function: err2mysql
static int err2mysql(int error) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("error: %d", error));
  assert(error != 0);
  switch (error) {
    case NdbInfo::ERR_ClusterFailure:
      return HA_ERR_NO_CONNECTION;
      break;
    case NdbInfo::ERR_OutOfMemory:
      return HA_ERR_OUT_OF_MEM;
      break;
    default:
      break;
  }
  {
    char errbuf[MYSQL_ERRMSG_SIZE];
    push_warning_printf(current_thd, Sql_condition::SL_WARNING, ER_GET_ERRNO,
                        ER_THD(current_thd, ER_GET_ERRNO), error,
                        my_strerror(errbuf, MYSQL_ERRMSG_SIZE, error));
  }
  return HA_ERR_INTERNAL_ERROR;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: warn_index_not_applicable not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/range_optimizer/range_analysis.cc
Function: warn_index_not_applicable not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/dict/dict0dd.cc
Function: format_validate not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/storage/innobase/dict/dict0dd.cc
Function: format_validate not found.

-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sp_head.cc
Function: sp_head::merge_table_list
bool sp_head::merge_table_list(THD *thd, Table_ref *table,
                               LEX *lex_for_tmp_check) {
  if (lex_for_tmp_check->sql_command == SQLCOM_DROP_TABLE &&
      lex_for_tmp_check->drop_temporary)
    return true;

  for (auto &key_and_value : m_sptabs) {
    key_and_value.second->query_lock_count = 0;
  }

  for (; table; table = table->next_global)
    if (!table->is_internal() && !table->schema_table) {
      /* Fail if this is an inaccessible DD table. */
      const dd::Dictionary *dictionary = dd::get_dictionary();
      if (dictionary &&
          !dictionary->is_dd_table_access_allowed(
              thd->is_dd_system_thread(),
              table->mdl_request.is_ddl_or_lock_tables_lock_request(),
              table->db, table->db_length, table->table_name)) {
        my_error(ER_NO_SYSTEM_TABLE_ACCESS, MYF(0),
                 ER_THD_NONCONST(thd, dictionary->table_type_error_code(
                                          table->db, table->table_name)),
                 table->db, table->table_name);
        return true;
      }

      /*
        Structure of key for the multi-set is "db\0table\0alias\0".
        Since "alias" part can have arbitrary length we use String
        object to construct the key. By default String will use
        buffer allocated on stack with NAME_LEN bytes reserved for
        alias, since in most cases it is going to be smaller than
        NAME_LEN bytes.
      */
      char tname_buff[(NAME_LEN + 1) * 3];
      String tname(tname_buff, sizeof(tname_buff), &my_charset_bin);
      size_t temp_table_key_length;

      tname.length(0);
      tname.append(table->db, table->db_length);
      tname.append('\0');
      tname.append(table->table_name, table->table_name_length);
      tname.append('\0');
      temp_table_key_length = tname.length();
      tname.append(table->alias);
      tname.append('\0');

      /*
        We ignore alias when we check if table was already marked as temporary
        (and therefore should not be prelocked). Otherwise we will erroneously
        treat table with same name but with different alias as non-temporary.
      */

      SP_TABLE *tab;

      if ((tab = find_or_nullptr(m_sptabs,
                                 std::string(tname.ptr(), tname.length()))) ||
          ((tab = find_or_nullptr(
                m_sptabs, std::string(tname.ptr(), temp_table_key_length))) &&
           tab->temp)) {
        if (tab->lock_type < table->lock_descriptor().type)
          tab->lock_type =
              table->lock_descriptor()
                  .type;  // Use the table with the highest lock type
        tab->query_lock_count++;
        if (tab->query_lock_count > tab->lock_count) tab->lock_count++;
        tab->trg_event_map |= table->trg_event_map;
      } else {
        if (!(tab = (SP_TABLE *)thd->mem_calloc(sizeof(SP_TABLE))))
          return false;
        if (lex_for_tmp_check->sql_command == SQLCOM_CREATE_TABLE &&
            lex_for_tmp_check->query_tables == table &&
            lex_for_tmp_check->create_info->options & HA_LEX_CREATE_TMP_TABLE) {
          tab->temp = true;
          tab->qname.length = temp_table_key_length;
        } else
          tab->qname.length = tname.length();
        tab->qname.str = (char *)thd->memdup(tname.ptr(), tab->qname.length);
        if (!tab->qname.str) return false;
        tab->table_name_length = table->table_name_length;
        tab->db_length = table->db_length;
        tab->lock_type = table->lock_descriptor().type;
        tab->lock_count = tab->query_lock_count = 1;
        tab->trg_event_map = table->trg_event_map;
        if (!m_sptabs.emplace(to_string(tab->qname), tab).second) return false;
      }
    }
  return true;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_system_table_check.h
Function: System_table_intact::report_error
  void report_error(uint code, const char *fmt, ...) override
      MY_ATTRIBUTE((format(printf, 3, 4))) {
    va_list args;
    va_start(args, fmt);

    if (code == 0)
      LogEvent()
          .prio(WARNING_LEVEL)
          .errcode(ER_SERVER_TABLE_CHECK_FAILED)
          .subsys(LOG_SUBSYSTEM_TAG)
          .source_file(MY_BASENAME)
          .messagev(fmt, args);
    else if (code == ER_CANNOT_LOAD_FROM_TABLE_V2) {
      char *db_name, *table_name;
      db_name = va_arg(args, char *);
      table_name = va_arg(args, char *);
      my_error(code, MYF(0), db_name, table_name);
      LogErr(m_log_level, ER_SERVER_CANNOT_LOAD_FROM_TABLE_V2, db_name,
             table_name);
    } else {
      my_printv_error(code, ER_THD_NONCONST(m_thd, code), MYF(0), args);
      va_end(args);

      if (code == ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2)
        code = ER_SERVER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2;
      else if (code == ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2)
        code = ER_SERVER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2;
      else
        code = ER_SERVER_ACL_TABLE_ERROR;

      va_start(args, fmt);
      LogEvent()
          .prio(m_log_level)
          .errcode(code)
          .subsys(LOG_SUBSYSTEM_TAG)
          .source_file(MY_BASENAME)
          .messagev(fmt, args);
    }

    va_end(args);
  }


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/sql_signal.cc
Function: Sql_cmd_common_signal::assign_defaults
void Sql_cmd_common_signal::assign_defaults(
    THD *thd [[maybe_unused]], Sql_condition *cond, bool set_level_code,
    Sql_condition::enum_severity_level level, int sqlcode) {
  if (set_level_code) {
    cond->m_severity_level = level;
    cond->m_mysql_errno = sqlcode;
  }
  if (!cond->message_text())
    cond->set_message_text(ER_THD_NONCONST(thd, sqlcode));
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/rpl_rli_pdb.cc
Function: Slave_worker::retry_transaction
bool Slave_worker::retry_transaction(uint start_relay_number,
                                     my_off_t start_relay_pos,
                                     uint end_relay_number,
                                     my_off_t end_relay_pos) {
  THD *thd = info_thd;
  bool silent = false;

  DBUG_TRACE;

  /* Flag to check for cleanup */
  bool cleaned_up{false};

  /* Resets the worker context for next transaction retry, if any */
  auto clean_retry_context = [&cleaned_up, &thd, this]() -> void {
    if (!cleaned_up) {
      cleanup_context(thd, true);
      reset_commit_order_deadlock();
      cleaned_up = true;
    }
  };

  /* Object of sentry class to perform cleanup */
  raii::Sentry<> retry_context_guard{clean_retry_context};

  if (slave_trans_retries == 0) return true;

  do {
    /* Simulate a lock deadlock error */
    uint error = 0;
    bool ret;
    cleaned_up = false;

    std::tie(ret, silent, error) = check_and_report_end_of_retries(thd);
    DBUG_EXECUTE_IF("error_on_rows_query_event_apply", { ret = false; };);
    if (ret) return true;

    DBUG_EXECUTE_IF("error_on_rows_query_event_apply", {
      if (c_rli->retried_trans == 2) {
        DBUG_SET("-d,error_on_rows_query_event_apply");
        std::string act{"now SIGNAL end_retries_on_rows_query_event_apply"};
        assert(!debug_sync_set_action(thd, act.data(), act.length()));
      }
      silent = true;
    };);

    if (!silent) {
      trans_retries++;
      if (current_thd->rli_slave->is_processing_trx()) {
        // if the error code is zero, we get the top of the error stack
        uint transient_error =
            (error == 0) ? thd->get_stmt_da()->mysql_errno() : error;
        current_thd->rli_slave->retried_processing(
            transient_error, ER_THD_NONCONST(thd, transient_error),
            trans_retries);
#ifndef NDEBUG
        if (trans_retries == 2 || trans_retries == 6)
          DBUG_EXECUTE_IF("rpl_ps_tables_worker_retry", {
            char const act[] =
                "now SIGNAL signal.rpl_ps_tables_worker_retry_pause "
                "WAIT_FOR signal.rpl_ps_tables_worker_retry_continue";
            assert(opt_debug_sync_timeout > 0);
            // we can't add the usual assert here because thd->is_error()
            // is true (and that's OK)
            debug_sync_set_action(thd, STRING_WITH_LEN(act));
          });
#endif
      }
    }

    mysql_mutex_lock(&c_rli->data_lock);
    c_rli->retried_trans++;
    mysql_mutex_unlock(&c_rli->data_lock);

    clean_retry_context();
    worker_sleep(min<ulong>(trans_retries, MAX_SLAVE_RETRY_PAUSE));

  } while (read_and_apply_events(start_relay_number, start_relay_pos,
                                 end_relay_number, end_relay_pos));
  return false;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::create_native_table
bool create_native_table(THD *thd, const Plugin_table *pt) {
  if (dd::get_dictionary()->is_dd_table_name(pt->get_schema_name(),
                                             pt->get_name())) {
    my_error(ER_NO_SYSTEM_TABLE_ACCESS, MYF(0),
             ER_THD_NONCONST(thd, dd::get_dictionary()->table_type_error_code(
                                      pt->get_schema_name(), pt->get_name())),
             pt->get_schema_name(), pt->get_name());

    return true;
  }

  // Acquire MDL on new native table that we would create.
  bool error = false;
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, pt->get_schema_name(),
                   pt->get_name(), MDL_EXCLUSIVE, MDL_TRANSACTION);
  dd::Schema_MDL_locker mdl_locker(thd);
  if (mdl_locker.ensure_locked(pt->get_schema_name()) ||
      thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  /*
    1. Mark that we are executing a special DDL during
    plugin initialization. This will enable DDL to not be
    committed or binlogged. The called of this API would commit
    the transaction.

    2. Remove metadata of native table if already exists. This could
    happen if server was crashed and restarted.

    3. Create native table.

    4. Undo 1.
  */
  dd::cache::Dictionary_client *client = thd->dd_client();
  const dd::Table *table_def = nullptr;
  if (client->acquire(pt->get_schema_name(), pt->get_name(), &table_def))
    return true;

  thd->mark_plugin_fake_ddl(true);
  ulong master_access = thd->security_context()->master_access();
  thd->security_context()->set_master_access(~(ulong)0);
  {
    Disable_binlog_guard guard(thd);

    // Drop the table and related dynamic statistics too.
    if (table_def) {
      error =
          client->drop(table_def) || client->remove_table_dynamic_statistics(
                                         pt->get_schema_name(), pt->get_name());
    }

    if (!error) error = dd::execute_query(thd, pt->get_ddl());
  }

  thd->security_context()->set_master_access(master_access);
  thd->mark_plugin_fake_ddl(false);

  return error;
}


-------------------------------------------------------------------------------------------
File: /root/LLVM/mysql-8.0.36/sql/dd/impl/dictionary_impl.cc
Function: dd::drop_native_table
bool drop_native_table(THD *thd, const char *schema_name,
                       const char *table_name) {
  if (dd::get_dictionary()->is_dd_table_name(schema_name, table_name)) {
    my_error(ER_NO_SYSTEM_TABLE_ACCESS, MYF(0),
             ER_THD_NONCONST(thd, dd::get_dictionary()->table_type_error_code(
                                      schema_name, table_name)),
             schema_name, table_name);

    return true;
  }

  // Acquire MDL on schema and table.
  MDL_request mdl_request;
  MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE, schema_name, table_name,
                   MDL_EXCLUSIVE, MDL_TRANSACTION);
  dd::Schema_MDL_locker mdl_locker(thd);
  if (mdl_locker.ensure_locked(schema_name) ||
      thd->mdl_context.acquire_lock(&mdl_request,
                                    thd->variables.lock_wait_timeout))
    return true;

  dd::cache::Dictionary_client *client = thd->dd_client();
  const dd::Table *table_def = nullptr;
  if (client->acquire(schema_name, table_name, &table_def)) {
    // Error is reported by the dictionary subsystem.
    return true;
  }

  // Not error is reported if table is not present.
  if (!table_def) return false;

  // Drop the table and related dynamic statistics too.
  return client->drop(table_def) ||
         client->remove_table_dynamic_statistics(schema_name, table_name);
}


